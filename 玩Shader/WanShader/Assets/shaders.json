{"userName":"bluebean","date":"2020-01-09T02:25:12.900Z","numShaders":36,"shaders":[{"Ver":null,"ImageRenderpass":{"Code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","inputs":[],"outputs":[],"code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Annotated Ray Tracing","id":"9b37e05ade204245a09c06921a913d6e","date":null,"viewed":0,"name":"Annotated Ray Tracing","description":"See https://www.tinycranes.com/blog/2015/05/annotated-realtime-raytracing/","likes":0,"published":null,"tags":["raytracing"," spheres"]},"ver":null,"info":{"Name":"Annotated Ray Tracing","id":"9b37e05ade204245a09c06921a913d6e","date":null,"viewed":0,"name":"Annotated Ray Tracing","description":"See https://www.tinycranes.com/blog/2015/05/annotated-realtime-raytracing/","likes":0,"published":null,"tags":["raytracing"," spheres"]},"renderpass":[{"Code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","inputs":[],"outputs":[],"code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Bump Mapping","id":"3l3GWS","date":"1577616030","viewed":34,"name":"Bump Mapping","description":"\u51F9\u51F8\u8D34\u56FE","likes":2,"published":"Public","tags":["noise","bump"]},"ver":"0.1","info":{"Name":"Bump Mapping","id":"3l3GWS","date":"1577616030","viewed":34,"name":"Bump Mapping","description":"\u51F9\u51F8\u8D34\u56FE","likes":2,"published":"Public","tags":["noise","bump"]},"renderpass":[{"Code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Catmull-Rom Spline Demo","id":"3tt3zS","date":"1576731439","viewed":48,"name":"Catmull-Rom Spline Demo","description":"Catmull-Rom\u6837\u6761\u7EBF\u63D2\u503C\u793A\u4F8B","likes":1,"published":"Public","tags":["spline","catmullrom","interpolating"]},"ver":"0.1","info":{"Name":"Catmull-Rom Spline Demo","id":"3tt3zS","date":"1576731439","viewed":48,"name":"Catmull-Rom Spline Demo","description":"Catmull-Rom\u6837\u6761\u7EBF\u63D2\u503C\u793A\u4F8B","likes":1,"published":"Public","tags":["spline","catmullrom","interpolating"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Example of 3D Noise","id":"Wtc3W7","date":"0","viewed":0,"name":"Example of 3D Noise","description":"3d\u566A\u58F0\u793A\u4F8B","likes":0,"published":"Private","tags":["3d","noise"]},"ver":"0.1","info":{"Name":"Example of 3D Noise","id":"Wtc3W7","date":"0","viewed":0,"name":"Example of 3D Noise","description":"3d\u566A\u58F0\u793A\u4F8B","likes":0,"published":"Private","tags":["3d","noise"]},"renderpass":[{"Code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Examples Of 2D Noise","id":"llKyDc","date":"1576221630","viewed":61,"name":"Examples Of 2D Noise","description":"2d\u566A\u58F0\u793A\u4F8B","likes":6,"published":"Public","tags":["2d","noise"]},"ver":"0.1","info":{"Name":"Examples Of 2D Noise","id":"llKyDc","date":"1576221630","viewed":61,"name":"Examples Of 2D Noise","description":"2d\u566A\u58F0\u793A\u4F8B","likes":6,"published":"Public","tags":["2d","noise"]},"renderpass":[{"Code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Eye-2D","id":"3dyXDt","date":"0","viewed":0,"name":"Eye-2D","description":"Eye-2D","likes":0,"published":"Private","tags":["2dmodel"]},"ver":"0.1","info":{"Name":"Eye-2D","id":"3dyXDt","date":"0","viewed":0,"name":"Eye-2D","description":"Eye-2D","likes":0,"published":"Private","tags":["2dmodel"]},"renderpass":[{"Code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"fbm test1","id":"wsyXDV","date":"0","viewed":0,"name":"fbm test1","description":"math fbm noise","likes":0,"published":"Private","tags":["mathfbmnoise"]},"ver":"0.1","info":{"Name":"fbm test1","id":"wsyXDV","date":"0","viewed":0,"name":"fbm test1","description":"math fbm noise","likes":0,"published":"Private","tags":["mathfbmnoise"]},"renderpass":[{"Code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Greate Material Demo","id":"ttX3Rs","date":"0","viewed":0,"name":"Greate Material Demo","description":"Greate Material Demo","likes":0,"published":"Private","tags":["material"]},"ver":"0.1","info":{"Name":"Greate Material Demo","id":"ttX3Rs","date":"0","viewed":0,"name":"Greate Material Demo","description":"Greate Material Demo","likes":0,"published":"Private","tags":["material"]},"renderpass":[{"Code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","inputs":[],"outputs":[],"code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Jupiter","id":"f42bd54a7b094bdfa426589faab377d5","date":null,"viewed":0,"name":"Jupiter","description":"Jupiter UV effect WIP\r\nTry increasing iteration, and enabling fullscreen to see less aliasing artifact. \r\n\r\nBased on --> https://www.shadertoy.com/view/ltc3Rj\r\nBlog post --> http://viclw17.github.io/2018/06/12/GLSL-Practice-With-Shadertoy/\r\nhttps://www.shadertoy.com/view/MdyfWw","likes":0,"published":null,"tags":["2d"," uv"]},"ver":null,"info":{"Name":"Jupiter","id":"f42bd54a7b094bdfa426589faab377d5","date":null,"viewed":0,"name":"Jupiter","description":"Jupiter UV effect WIP\r\nTry increasing iteration, and enabling fullscreen to see less aliasing artifact. \r\n\r\nBased on --> https://www.shadertoy.com/view/ltc3Rj\r\nBlog post --> http://viclw17.github.io/2018/06/12/GLSL-Practice-With-Shadertoy/\r\nhttps://www.shadertoy.com/view/MdyfWw","likes":0,"published":null,"tags":["2d"," uv"]},"renderpass":[{"Code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","inputs":[],"outputs":[],"code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Mandelbrot Set Render","id":"wtlSW8","date":"1562830347","viewed":89,"name":"Mandelbrot Set Render","description":"mandelbrot set Render2\nreferences:\nhttps://www.shadertoy.com/view/lsX3W4\n","likes":1,"published":"Public","tags":["fractal"]},"ver":"0.1","info":{"Name":"Mandelbrot Set Render","id":"wtlSW8","date":"1562830347","viewed":89,"name":"Mandelbrot Set Render","description":"mandelbrot set Render2\nreferences:\nhttps://www.shadertoy.com/view/lsX3W4\n","likes":1,"published":"Public","tags":["fractal"]},"renderpass":[{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Marble Material","id":"Wtc3DM","date":"1576576570","viewed":47,"name":"Marble Material","description":"\u7A0B\u5E8F\u6027\u7684\u5927\u7406\u77F3\u6750\u8D28\uFF0C\u770B\u8D77\u6765\u66F4\u50CF\u62FC\u5408\u677F","likes":2,"published":"Public","tags":["marble","fractalnoise"]},"ver":"0.1","info":{"Name":"Marble Material","id":"Wtc3DM","date":"1576576570","viewed":47,"name":"Marble Material","description":"\u7A0B\u5E8F\u6027\u7684\u5927\u7406\u77F3\u6750\u8D28\uFF0C\u770B\u8D77\u6765\u66F4\u50CF\u62FC\u5408\u677F","likes":2,"published":"Public","tags":["marble","fractalnoise"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Moon craters","id":"3dd2b8aeda434ee7ac8f0e4cccb86100","date":null,"viewed":0,"name":"Moon craters","description":"Trying to mimic a moon surface with craters ","likes":0,"published":null,"tags":["3d"," moon"," craters"]},"ver":null,"info":{"Name":"Moon craters","id":"3dd2b8aeda434ee7ac8f0e4cccb86100","date":null,"viewed":0,"name":"Moon craters","description":"Trying to mimic a moon surface with craters ","likes":0,"published":null,"tags":["3d"," moon"," craters"]},"renderpass":[{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Noise-Based Procedural Flame","id":"Wtc3RB","date":"0","viewed":0,"name":"Noise-Based Procedural Flame","description":"\u8FC7\u7A0B\u6027\u706B\u7130","likes":0,"published":"Private","tags":["procedural","noise","flame"]},"ver":"0.1","info":{"Name":"Noise-Based Procedural Flame","id":"Wtc3RB","date":"0","viewed":0,"name":"Noise-Based Procedural Flame","description":"\u8FC7\u7A0B\u6027\u706B\u7130","likes":0,"published":"Private","tags":["procedural","noise","flame"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Path to the colorful infinity","id":"b7c3b842a33a42eeb6a3da114dc57cfc","date":null,"viewed":0,"name":"Path to the colorful infinity","description":"Moving forward through layers of my \"sponge \"shader (https://www.shadertoy.com/view/MsjfDK)\r\nhttps://www.shadertoy.com/view/WtjyzR","likes":0,"published":null,"tags":["2d"," fractal"," colors"," space"," abstract"," recursive"," generative"," pseudo3d"," inversion"," layers"," symmetries"," travel"," spacefolding"]},"ver":null,"info":{"Name":"Path to the colorful infinity","id":"b7c3b842a33a42eeb6a3da114dc57cfc","date":null,"viewed":0,"name":"Path to the colorful infinity","description":"Moving forward through layers of my \"sponge \"shader (https://www.shadertoy.com/view/MsjfDK)\r\nhttps://www.shadertoy.com/view/WtjyzR","likes":0,"published":null,"tags":["2d"," fractal"," colors"," space"," abstract"," recursive"," generative"," pseudo3d"," inversion"," layers"," symmetries"," travel"," spacefolding"]},"renderpass":[{"Code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Procedural Brick Texture 2D","id":"wlcGRM","date":"1576151122","viewed":55,"name":"Procedural Brick Texture 2D","description":"2D\u53CD\u952F\u9F7F\u7816\u5757\u8D34\u56FE","likes":4,"published":"Public","tags":["2d","brick","antialiase"]},"ver":"0.1","info":{"Name":"Procedural Brick Texture 2D","id":"wlcGRM","date":"1576151122","viewed":55,"name":"Procedural Brick Texture 2D","description":"2D\u53CD\u952F\u9F7F\u7816\u5757\u8D34\u56FE","likes":4,"published":"Public","tags":["2d","brick","antialiase"]},"renderpass":[{"Code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Procedural Five-Point Star","id":"3ttGDr","date":"1576051881","viewed":39,"name":"Procedural Five-Point Star","description":"\u4E94\u89D2\u661F","likes":1,"published":"Public","tags":["procedural","2d","fivepointstar"]},"ver":"0.1","info":{"Name":"Procedural Five-Point Star","id":"3ttGDr","date":"1576051881","viewed":39,"name":"Procedural Five-Point Star","description":"\u4E94\u89D2\u661F","likes":1,"published":"Public","tags":["procedural","2d","fivepointstar"]},"renderpass":[{"Code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Raymarch in Raymarch","id":"wllXWH","date":"0","viewed":0,"name":"Raymarch in Raymarch","description":"Raymarch tutorial","likes":0,"published":"Private","tags":["raymarch"]},"ver":"0.1","info":{"Name":"Raymarch in Raymarch","id":"wllXWH","date":"0","viewed":0,"name":"Raymarch in Raymarch","description":"Raymarch tutorial","likes":0,"published":"Private","tags":["raymarch"]},"renderpass":[{"Code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"RayMarch-Primitives","id":"WllGRX","date":"0","viewed":0,"name":"RayMarch-Primitives","description":"RayMarch-Primitives","likes":0,"published":"Private","tags":["primitives"]},"ver":"0.1","info":{"Name":"RayMarch-Primitives","id":"WllGRX","date":"0","viewed":0,"name":"RayMarch-Primitives","description":"RayMarch-Primitives","likes":0,"published":"Private","tags":["primitives"]},"renderpass":[{"Code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Seascape ","id":"a9cdcf805dd04ac08fa41c537e6f2872","date":null,"viewed":0,"name":"Seascape ","description":"fully-procedural sea surface computing. without textures.\r\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape\r\nhttps://www.shadertoy.com/view/Ms2SD1","likes":0,"published":null,"tags":["procedural"," noise"," waves"," sea"," water"," subsurface"]},"ver":null,"info":{"Name":"Seascape ","id":"a9cdcf805dd04ac08fa41c537e6f2872","date":null,"viewed":0,"name":"Seascape ","description":"fully-procedural sea surface computing. without textures.\r\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape\r\nhttps://www.shadertoy.com/view/Ms2SD1","likes":0,"published":null,"tags":["procedural"," noise"," waves"," sea"," water"," subsurface"]},"renderpass":[{"Code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Sphere UV","id":"wl33W2","date":"1577591248","viewed":40,"name":"Sphere UV","description":"\u7403\u4F53UV\u5750\u6807","likes":5,"published":"Public","tags":["math","uv","sphere"]},"ver":"0.1","info":{"Name":"Sphere UV","id":"wl33W2","date":"1577591248","viewed":40,"name":"Sphere UV","description":"\u7403\u4F53UV\u5750\u6807","likes":5,"published":"Public","tags":["math","uv","sphere"]},"renderpass":[{"Code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","inputs":[],"outputs":[],"code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Stone Circle ","id":"55b24a179a814cff844d96116c51ee7a","date":null,"viewed":0,"name":"Stone Circle ","description":"Inspired by a story generated using an artificial intelligence.","likes":0,"published":null,"tags":["raymarching"," modeling"," distancemap"," stonecircle"]},"ver":null,"info":{"Name":"Stone Circle ","id":"55b24a179a814cff844d96116c51ee7a","date":null,"viewed":0,"name":"Stone Circle ","description":"Inspired by a story generated using an artificial intelligence.","likes":0,"published":null,"tags":["raymarching"," modeling"," distancemap"," stonecircle"]},"renderpass":[{"Code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","inputs":[],"outputs":[],"code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Worley Cellular Noise 2D","id":"tt3GRj","date":"1577105511","viewed":35,"name":"Worley Cellular Noise 2D","description":"Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["2d","noise","worley","cellular"]},"ver":"0.1","info":{"Name":"Worley Cellular Noise 2D","id":"tt3GRj","date":"1577105511","viewed":35,"name":"Worley Cellular Noise 2D","description":"Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["2d","noise","worley","cellular"]},"renderpass":[{"Code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Worley Cellular Noise 3D","id":"3ldGRl","date":"1577259203","viewed":50,"name":"Worley Cellular Noise 3D","description":"3d Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["3d","noise","worley","cellular"]},"ver":"0.1","info":{"Name":"Worley Cellular Noise 3D","id":"3ldGRl","date":"1577259203","viewed":50,"name":"Worley Cellular Noise 3D","description":"3d Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["3d","noise","worley","cellular"]},"renderpass":[{"Code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]}]}