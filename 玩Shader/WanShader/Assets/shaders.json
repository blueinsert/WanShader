{"userName":"bluebean","date":"2020-01-09T02:25:12.900Z","numShaders":36,"shaders":[{"Ver":null,"ImageRenderpass":{"Code":"float pi=acos(-1.);\r\n\r\nfloat sat(float t) { return clamp(t, 0.,1.); }\r\n\r\n//DAVE HOSKINS' HASH FUNCTIONS\r\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\r\n//https://www.shadertoy.com/view/4djSRW\r\nfloat rnd(float p)\r\n{\r\n    p = fract(p * 0.1031);\r\n    p *= p + 33.33;\r\n    return fract(2.*p*p);\r\n}\r\n\r\nvec3 rnd23(vec2 p)\r\n{\r\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\nfloat rnd31(vec3 p3)\r\n{\r\n\tp3  = fract(p3 * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec3 rnd33(vec3 p3)\r\n{\r\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\n\r\n// Lower that value if it's too slow\r\n#define SAMPLE_COUNT 30.\r\n\r\n#define res iResolution\r\n\r\n//////////////////////\r\n// PATHTRACING PASS //\r\n//////////////////////\r\n\r\n// we use globals for most parameters, it save space\r\n// s is starting position, r is ray direction\r\n// n is normal at intersection point and d is distance to the intersection\r\nvec3 s,r,n=vec3(0);\r\nfloat d=10000.;\r\nvec3 boxid=vec3(0);\r\n\r\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\r\n\r\n// Compute octahedron distance from center, os is the size of each of the 4 'axis'\r\nfloat octaedge(vec3 p, vec4 os) {\r\n    \r\n    vec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\r\n    vec4 popo = p.xxyy*vv.xyww + p.yyzz*vv.zzxy;\r\n    popo=abs(popo)-os;\r\n          \r\n    float d = max(max(popo.x,popo.y),max(popo.z,popo.w));\r\n\r\n    return d;\r\n}\r\n\r\nvec4 osize1 = vec4(10);\r\nvec4 osize2 = vec4(2);\r\nvec3 boxrepeat = vec3(1,8,8);\r\nvec3 centerrepeat = vec3(.4,2,2);\r\nfloat boxanim = 0.;\r\nfloat centeranim = 0.;\r\nfloat boxtime = 0.;\r\nfloat insidedist(vec3 p) {\r\n\treturn max(octaedge(p, osize1), -octaedge(p, osize2));\r\n}\r\n\r\n// analytical box intersection\r\nvoid box(vec3 basepos, int side) {\r\n\t\r\n    // are we on the outside octahedron or the center one\r\n\tbool iscenter = octaedge(basepos,osize2)<.1;\r\n\tvec3 rep = iscenter ? centerrepeat : boxrepeat;\r\n\t\r\n    // main repetition is based on the x axis\r\n\tvec3 id2 = floor(basepos.x/rep.x)+vec3(1.7,3,7);\r\n\t\r\n    // then we can have integer multiplier subdivision without breaking the illusion\r\n\trep = (rep/(floor(rnd33(id2)*vec3(6))+1.));\r\n\t\r\n\tvec3 pos=vec3(0);\t\r\n    \r\n    // offset on yz axis, box animation\r\n\tvec2 ooo = fract(rnd(floor(basepos.x/rep.x)+.7)*vec2(1,3.7))*8.*7.;\r\n    ooo*=boxtime*vec2(1,1.3)*(iscenter?centeranim:boxanim)*rep.yz*0.03;\r\n    basepos.yz += ooo;\r\n\tpos.yz += ooo;\r\n  \r\n    // here we are applying the box repetition\r\n\tboxid = (floor(basepos/rep)+0.5)*rep;\r\n\r\n\tvec3 size = rep*0.4;\r\n  \r\n\tvec3 vr = r;\r\n\tpos=s+pos-boxid;\r\n  \r\n\tvec3 box=max((size-pos)/vr,(-size-pos)/vr);\r\n\tfloat bd = min(min(box.x,box.y),box.z);\r\n\tif(bd>0. && bd>d*float(side)) {\r\n\t\tvec3 cur = step(abs(pos+vr*d),size);\r\n\t\tif(side>0 ? (min(cur.x,min(cur.y,cur.z))>0.) : insidedist(s+r*bd)>0.) {\r\n\t\t\td=bd;\r\n\t\t\tn=-step(box-bd,vec3(0))*sign(pos+vr*d);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n// analytical octrahedron intersection, with customisable size for each of the 4 'axis'\r\nvoid frontocta(vec4 size, int side) {\r\n    \r\n  \tvec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\r\n    vec4 invd = 1. / (r.xxyy*vv.xyww + r.yyzz*vv.zzxy);\r\n  \tvec4 popo = -s.xxyy*vv.xyww - s.yyzz*vv.zzxy;\r\n    \r\n    vec4 t0 = (popo - size) * invd;\r\n    vec4 t1 = (popo + size) * invd;\r\n    vec4 mi = min(t0, t1);\r\n    vec4 ma = max(t0, t1);\r\n\r\n    float front = min(min(ma.x,ma.y),min(ma.z,ma.w));\r\n    float back = max(max(mi.x,mi.y),max(mi.z,mi.w));\r\n    if(back>front) return;\r\n\r\n    if(side==0) {\r\n        back=front;\r\n    }\r\n\r\n    if(back<d && back > 0.) {\r\n        d = back;\r\n        vec4 vo = sign(t0-t1) * (side==0 ? step(-back,-ma) : step(back,mi));\r\n\r\n        n = vo.xxz - vo.yzw;\r\n        n.y += vo.y-vo.w;\r\n        n*=-sign(float(side)-.5)*vec3(0.817,0.5777,0.817); // = vec3(1,0.5 * 1.4142,1)/1.224 = 1.224 = cos(45) * tan(60)\r\n    }\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 frag = fragCoord.xy;\r\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\r\n\t\t\r\n\tvec3 col = vec3(0);\r\n\t\t\r\n\tfloat time =iTime-.9;\r\n\tboxtime = time;\r\n\r\n    // Main way to control the intro (camera, DOF focus, shape)\r\n    // Each vec3 is a section of the intro\r\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\r\n    // second value is the focus distance for the DOF, negative value makes the DOF bigger\r\n    // third value is the shape seed, integer value is the background shape, fractionnal part is the center shape\r\n\tvec3 mot[16] = vec3[16]( \r\n\t\t\t\t\t\t vec3(12,2,14.19)\r\n\t\t\t\t\t\t,vec3(-4.7,11,29)\r\n\t\t\t\t\t\t,vec3(7,10,7.2)\r\n\t\t\t\t\t\t,vec3(11,-5,5.63)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(16.45,5,17.4)\r\n\t\t\t\t\t\t,vec3(-12,5,12.2)\r\n\t\t\t\t\t\t,vec3(2,5,12.2)\r\n\t\t\t\t\t\t,vec3(0.4,9,10)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(17.8,7,11.1)\r\n\t\t\t\t\t\t,vec3(-7.6,-20,15)\r\n\t\t\t\t\t\t,vec3(-13,-30,2.2)\r\n\t\t\t\t\t\t,vec3(7,40,3)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(17,20,6)\r\n\t\t\t\t\t\t,vec3(-5.4,50,15.4)\r\n\t\t\t\t\t\t,vec3(16,30,13)\r\n\t\t\t\t\t\t,vec3(12,10,7)\r\n\t\t\t\t\t\t);\r\n\r\n\r\n\tfloat light = 0.;\r\n\tint section = int(min(16.,time/8.));\r\n\tfloat rest = mod(time,8.);\r\n\r\n\tvec3 mval = mot[section];\r\n\tif(section>5 && section<9) mval.z+=floor(rest)*2.2;\r\n\r\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0));\r\n\t\t\r\n\t//////// SIZES ////////\r\n\tif(section==0) osize2 = vec4(6);\r\n\t\r\n    // extruding the shapes\r\n\tfloat push2 = max(0.,time-48.)*1.5;\r\n\tif(section>7) push2 = 10000.;\r\n\tfloat push = 2.+max(0.,time-40.)*.5+push2;\r\n\tfloat decol=max(0.,time-70.);\r\n\tif(section>14) {\r\n\t\tdecol=0.;\r\n\t\tpush=0.;\r\n\t\tpush2=0.;\r\n\t}\r\n\r\n\tif(section>4)osize2 = vec4(2,push,push,2);\r\n\tif(section>6)osize1 = vec4(10,10.+push2,10.+push2,10);\r\n\t\r\n\t//////// REPEATS ////////\r\n\tboxrepeat = rnd23(vec2(floor(mval.z),0))*50.;\r\n\tcenterrepeat = pow(rnd23(vec2(0,fract(mval.z)*31.5+28.)),vec3(2))*10.+.2;\r\n\r\n\tif(section==3) osize1=vec4(20);\r\n\t\t\r\n\t//////// NIGHT ////////\r\n\tfloat skydist = 1.;\r\n\tfloat bright=0.;\r\n\tif(section>8 && section<15) {\r\n\t\tboxanim = .3;\r\n\t\tboxrepeat *= 2.;\r\n\t\tcenterrepeat *= 10.;\r\n\t\tif(section>11) {\r\n            // transition to night section, with light appearing\r\n\t\t\tlight = sat((time/8.-12.));\r\n\t\t\tskydist = section>12?200.:20.*light;\r\n\t\t\tosize1 = vec4(20,push2,push2,20);\r\n\t\t\tboxanim=0.;\r\n\t\t\tif(section==14) {\r\n                // center brightening and vanishing\r\n\t\t\t\tcenterrepeat.xy*=1.1;\r\n\t\t\t\tbright=pow(sat(time/8.-14.07),2.);\r\n\t\t\t\tosize2.xw = vec2(2.-sqrt(bright+.01-uv.y*.02+uv.x*.001)*2.3,17.*bright+2.);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcenteranim = section>2?(section>7?0.3:0.3):0.;\r\n\r\n\t//////// CAMERA ANIMATION ////////\r\n    // array value is a seed to an offset on lissajous curves, with various speed factor\r\n\tfloat avance = pcam.x*200. + (rest+(fract(mval.x+.5)-.5)*8.) * (pcam.y-0.2);\r\n\tif(mval.x<0.) avance += floor(rest/4.)*3.;\r\n\t\r\n\tfloat focusdist = abs(mval.y);\r\n\tfloat dofamount = mval.y>0. ? .05 : .15;\r\n    // extrapush is used to put the camera outside the room without colliding, so we can zoom more\r\n\tfloat extrapush = max(fract(pcam.z*17.23)-.5,0.)*15.;\r\n\tfloat fov = pcam.z*1.5+.5 + extrapush/2.;\r\n\tvec3 bs=vec3(0,-1.5 + sin(avance*.2)*1.,0);\r\n\tvec3 t = vec3(0,-1.5 + sin(avance*.3)*3.,0);\r\n\r\n    // lissajous curve to makes interesting camera motion\r\n\tbs.x += 5.*sin(avance*.4 + 0.7);\r\n\tbs.z += 5.*sin(avance*.9);\r\n\r\n    // camera target is following the same curve in front of the camera but with a random factor to focus more on the center\r\n\tfloat dt=max(0.,fract(pcam.z*24.81)-.2)*6.;\r\n\tt.x += dt*sin(avance*.4 + 0.7 + 1.);\r\n\tt.z += dt*sin(avance*.9 + 1.);\r\n\t\r\n\t//////// SKYDIVING ////////\r\n\tvec3 govec = vec3(-1,1.41,-1);\r\n\tvec3 poff = govec*decol*min(2.,decol)*2.5;\r\n\tt -= poff + govec*10.*(step(2.,decol)-bright);\r\n\tbs -= poff;\r\n    \r\n\t//////// CAMERA COMPUTE ////////\r\n\tvec3 cz=normalize(t-bs);\r\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\r\n\tvec3 cy=cross(cz,cx);\r\n\r\n\t// Main path tracing loop, do many samples to reduce the noise\r\n    float ZERO=min(0.,iTime); // this is a trick to force the GPU to keep the loop\r\n    // instead of trying to compile a giant shader by duplicating what's inside\r\n\tfor(float i=ZERO; i<SAMPLE_COUNT; ++i) {\r\n    \t\t\r\n\t\ts=bs;\t\r\n\t\tvec2 h = rnd23(frag-13.6-i*184.7).xy;\r\n\t\t// DOF\r\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\r\n\t\ts-=voff;\r\n\t\tr=normalize(uv.x*cx+uv.y*cy+fov*cz + voff*fov/(focusdist+extrapush));\r\n\r\n\t\ts += (r-cz) * extrapush;\r\n\t\t\r\n        // number of bounces is 3\r\n\t\tfor(float j=0.; j<3.; ++j) {\r\n\t\t\t////////// TRACE //////////\r\n\t\t\td=100000.;\r\n  \r\n            // find instersection with geometry\r\n            \r\n            // first test if we started inside a repeating box\r\n\t\t\tbox(s,-1);\r\n  \r\n            // then intersect with the background octahedron\r\n\t\t\tfrontocta(osize1, 0);\r\n  \r\n            // save that intersection for latter\r\n\t\t\tfloat d2=d;\r\n\t\t\tvec3 s2=s;\r\n\t\t\tvec3 n2=n;\r\n\r\n            // intersect with the center shape\r\n\t\t\tfrontocta(osize2, 1);\r\n  \r\n            // now use that position to carve the repeating box\r\n\t\t\tbox(s+r*d,1);\r\n\r\n            // if intersection position is outside the center octahedron, it means that we went trough the shape\r\n            // so we back to the background intersection\r\n\t\t\tif(octaedge(s+r*d,osize2)>0.01) {\r\n\t\t\t\td=d2;\r\n\t\t\t\tn=n2;\r\n                // last possible repeating box intersection on the background octahedron\r\n\t\t\t\tbox(s+r*d,1);\r\n\t\t\t}\r\n    \r\n            // and finally the ground plane intersection\r\n\t\t\tfloat curplane=(1.1-s.y)/r.y;\r\n\t\t\tif(curplane>0. && curplane<d) {\r\n\t\t\t\td=curplane;\r\n\t\t\t\tn=sign(s.y)*vec3(0,1,0);\r\n\t\t\t}\r\n    \t\t\t\r\n\t\t\tif(d>10000.) break;\r\n\t\t\t\r\n\t\t\t// go to the intersection point\r\n\t\t\ts = s + r * d;\r\n\t\t\r\n            // test if we are outside the 'sky distance'\r\n\t\t\tfloat edge1 = octaedge(s,osize1);\t\t\t\t\t\t\r\n\t\t\tif(edge1>skydist) {\r\n                // if so, we just push the sky color and early out\r\n\t\t\t\tcol += mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n            // if we are in the light section\r\n\t\t\tif(light>0.) {\r\n\t\t\t\tfloat middle = step(7.,edge1);\r\n\r\n                // center burning\r\n\t\t\t\tcol += bright * step(1.,-edge1) * vec3(.5,.7,1)*3.;\r\n\t\t\t\t\r\n                // side lights in two colors\r\n\t\t\t\tcol += middle * vec3(0.4,0.5,0.8) * 1.2 * step(0.7,rnd(dot(boxid,vec3(1,4,7))+floor(time)*0.1));\r\n\t\t\t\tcol += middle * vec3(0.2,0.5,0.9) * 1.2 * step(0.1,fract(.2+boxid.z*0.01 + floor(time)*13.2)*3.-1.5);\t\t\t\r\n\t\t\t}\r\n\r\n            // slight increase in perf, get out before computing rebound direction in the last rebound\r\n\t\t\tif(j==2.) break;\r\n\r\n            // roughness computing, depending on if we are on the center shape or not\r\n\t\t\tvec3 grid = step(fract(s*4.-.1),vec3(.8));\r\n\t\t\tfloat rough = octaedge(s,osize2)<.1 ? .5 : mix(1.,0.45*rnd31(floor(s*4.-.1)*27.33),min(grid.x,min(grid.y,grid.z)));\r\n            // slight offset so we get out of the surface before rebound\r\n\t\t\ts-=r*0.01;\r\n            // random rebound direction according to roughness parameter\r\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375.)+fract(time))-.5)*rough);\r\n\t\t}\r\n\t}\r\n\tcol *= .6/SAMPLE_COUNT;\r\n\t\r\n\tfragColor = vec4(col, 1);\r\n}","inputs":[],"outputs":[],"code":"float pi=acos(-1.);\r\n\r\nfloat sat(float t) { return clamp(t, 0.,1.); }\r\n\r\n//DAVE HOSKINS' HASH FUNCTIONS\r\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\r\n//https://www.shadertoy.com/view/4djSRW\r\nfloat rnd(float p)\r\n{\r\n    p = fract(p * 0.1031);\r\n    p *= p + 33.33;\r\n    return fract(2.*p*p);\r\n}\r\n\r\nvec3 rnd23(vec2 p)\r\n{\r\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\nfloat rnd31(vec3 p3)\r\n{\r\n\tp3  = fract(p3 * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec3 rnd33(vec3 p3)\r\n{\r\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\n\r\n// Lower that value if it's too slow\r\n#define SAMPLE_COUNT 30.\r\n\r\n#define res iResolution\r\n\r\n//////////////////////\r\n// PATHTRACING PASS //\r\n//////////////////////\r\n\r\n// we use globals for most parameters, it save space\r\n// s is starting position, r is ray direction\r\n// n is normal at intersection point and d is distance to the intersection\r\nvec3 s,r,n=vec3(0);\r\nfloat d=10000.;\r\nvec3 boxid=vec3(0);\r\n\r\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\r\n\r\n// Compute octahedron distance from center, os is the size of each of the 4 'axis'\r\nfloat octaedge(vec3 p, vec4 os) {\r\n    \r\n    vec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\r\n    vec4 popo = p.xxyy*vv.xyww + p.yyzz*vv.zzxy;\r\n    popo=abs(popo)-os;\r\n          \r\n    float d = max(max(popo.x,popo.y),max(popo.z,popo.w));\r\n\r\n    return d;\r\n}\r\n\r\nvec4 osize1 = vec4(10);\r\nvec4 osize2 = vec4(2);\r\nvec3 boxrepeat = vec3(1,8,8);\r\nvec3 centerrepeat = vec3(.4,2,2);\r\nfloat boxanim = 0.;\r\nfloat centeranim = 0.;\r\nfloat boxtime = 0.;\r\nfloat insidedist(vec3 p) {\r\n\treturn max(octaedge(p, osize1), -octaedge(p, osize2));\r\n}\r\n\r\n// analytical box intersection\r\nvoid box(vec3 basepos, int side) {\r\n\t\r\n    // are we on the outside octahedron or the center one\r\n\tbool iscenter = octaedge(basepos,osize2)<.1;\r\n\tvec3 rep = iscenter ? centerrepeat : boxrepeat;\r\n\t\r\n    // main repetition is based on the x axis\r\n\tvec3 id2 = floor(basepos.x/rep.x)+vec3(1.7,3,7);\r\n\t\r\n    // then we can have integer multiplier subdivision without breaking the illusion\r\n\trep = (rep/(floor(rnd33(id2)*vec3(6))+1.));\r\n\t\r\n\tvec3 pos=vec3(0);\t\r\n    \r\n    // offset on yz axis, box animation\r\n\tvec2 ooo = fract(rnd(floor(basepos.x/rep.x)+.7)*vec2(1,3.7))*8.*7.;\r\n    ooo*=boxtime*vec2(1,1.3)*(iscenter?centeranim:boxanim)*rep.yz*0.03;\r\n    basepos.yz += ooo;\r\n\tpos.yz += ooo;\r\n  \r\n    // here we are applying the box repetition\r\n\tboxid = (floor(basepos/rep)+0.5)*rep;\r\n\r\n\tvec3 size = rep*0.4;\r\n  \r\n\tvec3 vr = r;\r\n\tpos=s+pos-boxid;\r\n  \r\n\tvec3 box=max((size-pos)/vr,(-size-pos)/vr);\r\n\tfloat bd = min(min(box.x,box.y),box.z);\r\n\tif(bd>0. && bd>d*float(side)) {\r\n\t\tvec3 cur = step(abs(pos+vr*d),size);\r\n\t\tif(side>0 ? (min(cur.x,min(cur.y,cur.z))>0.) : insidedist(s+r*bd)>0.) {\r\n\t\t\td=bd;\r\n\t\t\tn=-step(box-bd,vec3(0))*sign(pos+vr*d);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n// analytical octrahedron intersection, with customisable size for each of the 4 'axis'\r\nvoid frontocta(vec4 size, int side) {\r\n    \r\n  \tvec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\r\n    vec4 invd = 1. / (r.xxyy*vv.xyww + r.yyzz*vv.zzxy);\r\n  \tvec4 popo = -s.xxyy*vv.xyww - s.yyzz*vv.zzxy;\r\n    \r\n    vec4 t0 = (popo - size) * invd;\r\n    vec4 t1 = (popo + size) * invd;\r\n    vec4 mi = min(t0, t1);\r\n    vec4 ma = max(t0, t1);\r\n\r\n    float front = min(min(ma.x,ma.y),min(ma.z,ma.w));\r\n    float back = max(max(mi.x,mi.y),max(mi.z,mi.w));\r\n    if(back>front) return;\r\n\r\n    if(side==0) {\r\n        back=front;\r\n    }\r\n\r\n    if(back<d && back > 0.) {\r\n        d = back;\r\n        vec4 vo = sign(t0-t1) * (side==0 ? step(-back,-ma) : step(back,mi));\r\n\r\n        n = vo.xxz - vo.yzw;\r\n        n.y += vo.y-vo.w;\r\n        n*=-sign(float(side)-.5)*vec3(0.817,0.5777,0.817); // = vec3(1,0.5 * 1.4142,1)/1.224 = 1.224 = cos(45) * tan(60)\r\n    }\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 frag = fragCoord.xy;\r\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\r\n\t\t\r\n\tvec3 col = vec3(0);\r\n\t\t\r\n\tfloat time =iTime-.9;\r\n\tboxtime = time;\r\n\r\n    // Main way to control the intro (camera, DOF focus, shape)\r\n    // Each vec3 is a section of the intro\r\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\r\n    // second value is the focus distance for the DOF, negative value makes the DOF bigger\r\n    // third value is the shape seed, integer value is the background shape, fractionnal part is the center shape\r\n\tvec3 mot[16] = vec3[16]( \r\n\t\t\t\t\t\t vec3(12,2,14.19)\r\n\t\t\t\t\t\t,vec3(-4.7,11,29)\r\n\t\t\t\t\t\t,vec3(7,10,7.2)\r\n\t\t\t\t\t\t,vec3(11,-5,5.63)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(16.45,5,17.4)\r\n\t\t\t\t\t\t,vec3(-12,5,12.2)\r\n\t\t\t\t\t\t,vec3(2,5,12.2)\r\n\t\t\t\t\t\t,vec3(0.4,9,10)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(17.8,7,11.1)\r\n\t\t\t\t\t\t,vec3(-7.6,-20,15)\r\n\t\t\t\t\t\t,vec3(-13,-30,2.2)\r\n\t\t\t\t\t\t,vec3(7,40,3)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(17,20,6)\r\n\t\t\t\t\t\t,vec3(-5.4,50,15.4)\r\n\t\t\t\t\t\t,vec3(16,30,13)\r\n\t\t\t\t\t\t,vec3(12,10,7)\r\n\t\t\t\t\t\t);\r\n\r\n\r\n\tfloat light = 0.;\r\n\tint section = int(min(16.,time/8.));\r\n\tfloat rest = mod(time,8.);\r\n\r\n\tvec3 mval = mot[section];\r\n\tif(section>5 && section<9) mval.z+=floor(rest)*2.2;\r\n\r\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0));\r\n\t\t\r\n\t//////// SIZES ////////\r\n\tif(section==0) osize2 = vec4(6);\r\n\t\r\n    // extruding the shapes\r\n\tfloat push2 = max(0.,time-48.)*1.5;\r\n\tif(section>7) push2 = 10000.;\r\n\tfloat push = 2.+max(0.,time-40.)*.5+push2;\r\n\tfloat decol=max(0.,time-70.);\r\n\tif(section>14) {\r\n\t\tdecol=0.;\r\n\t\tpush=0.;\r\n\t\tpush2=0.;\r\n\t}\r\n\r\n\tif(section>4)osize2 = vec4(2,push,push,2);\r\n\tif(section>6)osize1 = vec4(10,10.+push2,10.+push2,10);\r\n\t\r\n\t//////// REPEATS ////////\r\n\tboxrepeat = rnd23(vec2(floor(mval.z),0))*50.;\r\n\tcenterrepeat = pow(rnd23(vec2(0,fract(mval.z)*31.5+28.)),vec3(2))*10.+.2;\r\n\r\n\tif(section==3) osize1=vec4(20);\r\n\t\t\r\n\t//////// NIGHT ////////\r\n\tfloat skydist = 1.;\r\n\tfloat bright=0.;\r\n\tif(section>8 && section<15) {\r\n\t\tboxanim = .3;\r\n\t\tboxrepeat *= 2.;\r\n\t\tcenterrepeat *= 10.;\r\n\t\tif(section>11) {\r\n            // transition to night section, with light appearing\r\n\t\t\tlight = sat((time/8.-12.));\r\n\t\t\tskydist = section>12?200.:20.*light;\r\n\t\t\tosize1 = vec4(20,push2,push2,20);\r\n\t\t\tboxanim=0.;\r\n\t\t\tif(section==14) {\r\n                // center brightening and vanishing\r\n\t\t\t\tcenterrepeat.xy*=1.1;\r\n\t\t\t\tbright=pow(sat(time/8.-14.07),2.);\r\n\t\t\t\tosize2.xw = vec2(2.-sqrt(bright+.01-uv.y*.02+uv.x*.001)*2.3,17.*bright+2.);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcenteranim = section>2?(section>7?0.3:0.3):0.;\r\n\r\n\t//////// CAMERA ANIMATION ////////\r\n    // array value is a seed to an offset on lissajous curves, with various speed factor\r\n\tfloat avance = pcam.x*200. + (rest+(fract(mval.x+.5)-.5)*8.) * (pcam.y-0.2);\r\n\tif(mval.x<0.) avance += floor(rest/4.)*3.;\r\n\t\r\n\tfloat focusdist = abs(mval.y);\r\n\tfloat dofamount = mval.y>0. ? .05 : .15;\r\n    // extrapush is used to put the camera outside the room without colliding, so we can zoom more\r\n\tfloat extrapush = max(fract(pcam.z*17.23)-.5,0.)*15.;\r\n\tfloat fov = pcam.z*1.5+.5 + extrapush/2.;\r\n\tvec3 bs=vec3(0,-1.5 + sin(avance*.2)*1.,0);\r\n\tvec3 t = vec3(0,-1.5 + sin(avance*.3)*3.,0);\r\n\r\n    // lissajous curve to makes interesting camera motion\r\n\tbs.x += 5.*sin(avance*.4 + 0.7);\r\n\tbs.z += 5.*sin(avance*.9);\r\n\r\n    // camera target is following the same curve in front of the camera but with a random factor to focus more on the center\r\n\tfloat dt=max(0.,fract(pcam.z*24.81)-.2)*6.;\r\n\tt.x += dt*sin(avance*.4 + 0.7 + 1.);\r\n\tt.z += dt*sin(avance*.9 + 1.);\r\n\t\r\n\t//////// SKYDIVING ////////\r\n\tvec3 govec = vec3(-1,1.41,-1);\r\n\tvec3 poff = govec*decol*min(2.,decol)*2.5;\r\n\tt -= poff + govec*10.*(step(2.,decol)-bright);\r\n\tbs -= poff;\r\n    \r\n\t//////// CAMERA COMPUTE ////////\r\n\tvec3 cz=normalize(t-bs);\r\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\r\n\tvec3 cy=cross(cz,cx);\r\n\r\n\t// Main path tracing loop, do many samples to reduce the noise\r\n    float ZERO=min(0.,iTime); // this is a trick to force the GPU to keep the loop\r\n    // instead of trying to compile a giant shader by duplicating what's inside\r\n\tfor(float i=ZERO; i<SAMPLE_COUNT; ++i) {\r\n    \t\t\r\n\t\ts=bs;\t\r\n\t\tvec2 h = rnd23(frag-13.6-i*184.7).xy;\r\n\t\t// DOF\r\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\r\n\t\ts-=voff;\r\n\t\tr=normalize(uv.x*cx+uv.y*cy+fov*cz + voff*fov/(focusdist+extrapush));\r\n\r\n\t\ts += (r-cz) * extrapush;\r\n\t\t\r\n        // number of bounces is 3\r\n\t\tfor(float j=0.; j<3.; ++j) {\r\n\t\t\t////////// TRACE //////////\r\n\t\t\td=100000.;\r\n  \r\n            // find instersection with geometry\r\n            \r\n            // first test if we started inside a repeating box\r\n\t\t\tbox(s,-1);\r\n  \r\n            // then intersect with the background octahedron\r\n\t\t\tfrontocta(osize1, 0);\r\n  \r\n            // save that intersection for latter\r\n\t\t\tfloat d2=d;\r\n\t\t\tvec3 s2=s;\r\n\t\t\tvec3 n2=n;\r\n\r\n            // intersect with the center shape\r\n\t\t\tfrontocta(osize2, 1);\r\n  \r\n            // now use that position to carve the repeating box\r\n\t\t\tbox(s+r*d,1);\r\n\r\n            // if intersection position is outside the center octahedron, it means that we went trough the shape\r\n            // so we back to the background intersection\r\n\t\t\tif(octaedge(s+r*d,osize2)>0.01) {\r\n\t\t\t\td=d2;\r\n\t\t\t\tn=n2;\r\n                // last possible repeating box intersection on the background octahedron\r\n\t\t\t\tbox(s+r*d,1);\r\n\t\t\t}\r\n    \r\n            // and finally the ground plane intersection\r\n\t\t\tfloat curplane=(1.1-s.y)/r.y;\r\n\t\t\tif(curplane>0. && curplane<d) {\r\n\t\t\t\td=curplane;\r\n\t\t\t\tn=sign(s.y)*vec3(0,1,0);\r\n\t\t\t}\r\n    \t\t\t\r\n\t\t\tif(d>10000.) break;\r\n\t\t\t\r\n\t\t\t// go to the intersection point\r\n\t\t\ts = s + r * d;\r\n\t\t\r\n            // test if we are outside the 'sky distance'\r\n\t\t\tfloat edge1 = octaedge(s,osize1);\t\t\t\t\t\t\r\n\t\t\tif(edge1>skydist) {\r\n                // if so, we just push the sky color and early out\r\n\t\t\t\tcol += mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n            // if we are in the light section\r\n\t\t\tif(light>0.) {\r\n\t\t\t\tfloat middle = step(7.,edge1);\r\n\r\n                // center burning\r\n\t\t\t\tcol += bright * step(1.,-edge1) * vec3(.5,.7,1)*3.;\r\n\t\t\t\t\r\n                // side lights in two colors\r\n\t\t\t\tcol += middle * vec3(0.4,0.5,0.8) * 1.2 * step(0.7,rnd(dot(boxid,vec3(1,4,7))+floor(time)*0.1));\r\n\t\t\t\tcol += middle * vec3(0.2,0.5,0.9) * 1.2 * step(0.1,fract(.2+boxid.z*0.01 + floor(time)*13.2)*3.-1.5);\t\t\t\r\n\t\t\t}\r\n\r\n            // slight increase in perf, get out before computing rebound direction in the last rebound\r\n\t\t\tif(j==2.) break;\r\n\r\n            // roughness computing, depending on if we are on the center shape or not\r\n\t\t\tvec3 grid = step(fract(s*4.-.1),vec3(.8));\r\n\t\t\tfloat rough = octaedge(s,osize2)<.1 ? .5 : mix(1.,0.45*rnd31(floor(s*4.-.1)*27.33),min(grid.x,min(grid.y,grid.z)));\r\n            // slight offset so we get out of the surface before rebound\r\n\t\t\ts-=r*0.01;\r\n            // random rebound direction according to roughness parameter\r\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375.)+fract(time))-.5)*rough);\r\n\t\t}\r\n\t}\r\n\tcol *= .6/SAMPLE_COUNT;\r\n\t\r\n\tfragColor = vec4(col, 1);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"[4k] The vanishing of Ashlar","id":"7b97b94022bf45e3babd9a084478fdee","date":null,"viewed":0,"name":"[4k] The vanishing of Ashlar","description":"The vanishing of Ashlar by NuSan, PC 4k intro made for Outline Online 2020\nhttps://www.shadertoy.com/view/3sBBRK","likes":0,"published":null,"tags":[" intro"," 4k"," outline"]},"ver":null,"info":{"Name":"[4k] The vanishing of Ashlar","id":"7b97b94022bf45e3babd9a084478fdee","date":null,"viewed":0,"name":"[4k] The vanishing of Ashlar","description":"The vanishing of Ashlar by NuSan, PC 4k intro made for Outline Online 2020\nhttps://www.shadertoy.com/view/3sBBRK","likes":0,"published":null,"tags":[" intro"," 4k"," outline"]},"renderpass":[{"Code":"float pi=acos(-1.);\r\n\r\nfloat sat(float t) { return clamp(t, 0.,1.); }\r\n\r\n//DAVE HOSKINS' HASH FUNCTIONS\r\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\r\n//https://www.shadertoy.com/view/4djSRW\r\nfloat rnd(float p)\r\n{\r\n    p = fract(p * 0.1031);\r\n    p *= p + 33.33;\r\n    return fract(2.*p*p);\r\n}\r\n\r\nvec3 rnd23(vec2 p)\r\n{\r\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\nfloat rnd31(vec3 p3)\r\n{\r\n\tp3  = fract(p3 * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec3 rnd33(vec3 p3)\r\n{\r\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\n\r\n// Lower that value if it's too slow\r\n#define SAMPLE_COUNT 30.\r\n\r\n#define res iResolution\r\n\r\n//////////////////////\r\n// PATHTRACING PASS //\r\n//////////////////////\r\n\r\n// we use globals for most parameters, it save space\r\n// s is starting position, r is ray direction\r\n// n is normal at intersection point and d is distance to the intersection\r\nvec3 s,r,n=vec3(0);\r\nfloat d=10000.;\r\nvec3 boxid=vec3(0);\r\n\r\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\r\n\r\n// Compute octahedron distance from center, os is the size of each of the 4 'axis'\r\nfloat octaedge(vec3 p, vec4 os) {\r\n    \r\n    vec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\r\n    vec4 popo = p.xxyy*vv.xyww + p.yyzz*vv.zzxy;\r\n    popo=abs(popo)-os;\r\n          \r\n    float d = max(max(popo.x,popo.y),max(popo.z,popo.w));\r\n\r\n    return d;\r\n}\r\n\r\nvec4 osize1 = vec4(10);\r\nvec4 osize2 = vec4(2);\r\nvec3 boxrepeat = vec3(1,8,8);\r\nvec3 centerrepeat = vec3(.4,2,2);\r\nfloat boxanim = 0.;\r\nfloat centeranim = 0.;\r\nfloat boxtime = 0.;\r\nfloat insidedist(vec3 p) {\r\n\treturn max(octaedge(p, osize1), -octaedge(p, osize2));\r\n}\r\n\r\n// analytical box intersection\r\nvoid box(vec3 basepos, int side) {\r\n\t\r\n    // are we on the outside octahedron or the center one\r\n\tbool iscenter = octaedge(basepos,osize2)<.1;\r\n\tvec3 rep = iscenter ? centerrepeat : boxrepeat;\r\n\t\r\n    // main repetition is based on the x axis\r\n\tvec3 id2 = floor(basepos.x/rep.x)+vec3(1.7,3,7);\r\n\t\r\n    // then we can have integer multiplier subdivision without breaking the illusion\r\n\trep = (rep/(floor(rnd33(id2)*vec3(6))+1.));\r\n\t\r\n\tvec3 pos=vec3(0);\t\r\n    \r\n    // offset on yz axis, box animation\r\n\tvec2 ooo = fract(rnd(floor(basepos.x/rep.x)+.7)*vec2(1,3.7))*8.*7.;\r\n    ooo*=boxtime*vec2(1,1.3)*(iscenter?centeranim:boxanim)*rep.yz*0.03;\r\n    basepos.yz += ooo;\r\n\tpos.yz += ooo;\r\n  \r\n    // here we are applying the box repetition\r\n\tboxid = (floor(basepos/rep)+0.5)*rep;\r\n\r\n\tvec3 size = rep*0.4;\r\n  \r\n\tvec3 vr = r;\r\n\tpos=s+pos-boxid;\r\n  \r\n\tvec3 box=max((size-pos)/vr,(-size-pos)/vr);\r\n\tfloat bd = min(min(box.x,box.y),box.z);\r\n\tif(bd>0. && bd>d*float(side)) {\r\n\t\tvec3 cur = step(abs(pos+vr*d),size);\r\n\t\tif(side>0 ? (min(cur.x,min(cur.y,cur.z))>0.) : insidedist(s+r*bd)>0.) {\r\n\t\t\td=bd;\r\n\t\t\tn=-step(box-bd,vec3(0))*sign(pos+vr*d);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n// analytical octrahedron intersection, with customisable size for each of the 4 'axis'\r\nvoid frontocta(vec4 size, int side) {\r\n    \r\n  \tvec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\r\n    vec4 invd = 1. / (r.xxyy*vv.xyww + r.yyzz*vv.zzxy);\r\n  \tvec4 popo = -s.xxyy*vv.xyww - s.yyzz*vv.zzxy;\r\n    \r\n    vec4 t0 = (popo - size) * invd;\r\n    vec4 t1 = (popo + size) * invd;\r\n    vec4 mi = min(t0, t1);\r\n    vec4 ma = max(t0, t1);\r\n\r\n    float front = min(min(ma.x,ma.y),min(ma.z,ma.w));\r\n    float back = max(max(mi.x,mi.y),max(mi.z,mi.w));\r\n    if(back>front) return;\r\n\r\n    if(side==0) {\r\n        back=front;\r\n    }\r\n\r\n    if(back<d && back > 0.) {\r\n        d = back;\r\n        vec4 vo = sign(t0-t1) * (side==0 ? step(-back,-ma) : step(back,mi));\r\n\r\n        n = vo.xxz - vo.yzw;\r\n        n.y += vo.y-vo.w;\r\n        n*=-sign(float(side)-.5)*vec3(0.817,0.5777,0.817); // = vec3(1,0.5 * 1.4142,1)/1.224 = 1.224 = cos(45) * tan(60)\r\n    }\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 frag = fragCoord.xy;\r\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\r\n\t\t\r\n\tvec3 col = vec3(0);\r\n\t\t\r\n\tfloat time =iTime-.9;\r\n\tboxtime = time;\r\n\r\n    // Main way to control the intro (camera, DOF focus, shape)\r\n    // Each vec3 is a section of the intro\r\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\r\n    // second value is the focus distance for the DOF, negative value makes the DOF bigger\r\n    // third value is the shape seed, integer value is the background shape, fractionnal part is the center shape\r\n\tvec3 mot[16] = vec3[16]( \r\n\t\t\t\t\t\t vec3(12,2,14.19)\r\n\t\t\t\t\t\t,vec3(-4.7,11,29)\r\n\t\t\t\t\t\t,vec3(7,10,7.2)\r\n\t\t\t\t\t\t,vec3(11,-5,5.63)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(16.45,5,17.4)\r\n\t\t\t\t\t\t,vec3(-12,5,12.2)\r\n\t\t\t\t\t\t,vec3(2,5,12.2)\r\n\t\t\t\t\t\t,vec3(0.4,9,10)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(17.8,7,11.1)\r\n\t\t\t\t\t\t,vec3(-7.6,-20,15)\r\n\t\t\t\t\t\t,vec3(-13,-30,2.2)\r\n\t\t\t\t\t\t,vec3(7,40,3)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(17,20,6)\r\n\t\t\t\t\t\t,vec3(-5.4,50,15.4)\r\n\t\t\t\t\t\t,vec3(16,30,13)\r\n\t\t\t\t\t\t,vec3(12,10,7)\r\n\t\t\t\t\t\t);\r\n\r\n\r\n\tfloat light = 0.;\r\n\tint section = int(min(16.,time/8.));\r\n\tfloat rest = mod(time,8.);\r\n\r\n\tvec3 mval = mot[section];\r\n\tif(section>5 && section<9) mval.z+=floor(rest)*2.2;\r\n\r\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0));\r\n\t\t\r\n\t//////// SIZES ////////\r\n\tif(section==0) osize2 = vec4(6);\r\n\t\r\n    // extruding the shapes\r\n\tfloat push2 = max(0.,time-48.)*1.5;\r\n\tif(section>7) push2 = 10000.;\r\n\tfloat push = 2.+max(0.,time-40.)*.5+push2;\r\n\tfloat decol=max(0.,time-70.);\r\n\tif(section>14) {\r\n\t\tdecol=0.;\r\n\t\tpush=0.;\r\n\t\tpush2=0.;\r\n\t}\r\n\r\n\tif(section>4)osize2 = vec4(2,push,push,2);\r\n\tif(section>6)osize1 = vec4(10,10.+push2,10.+push2,10);\r\n\t\r\n\t//////// REPEATS ////////\r\n\tboxrepeat = rnd23(vec2(floor(mval.z),0))*50.;\r\n\tcenterrepeat = pow(rnd23(vec2(0,fract(mval.z)*31.5+28.)),vec3(2))*10.+.2;\r\n\r\n\tif(section==3) osize1=vec4(20);\r\n\t\t\r\n\t//////// NIGHT ////////\r\n\tfloat skydist = 1.;\r\n\tfloat bright=0.;\r\n\tif(section>8 && section<15) {\r\n\t\tboxanim = .3;\r\n\t\tboxrepeat *= 2.;\r\n\t\tcenterrepeat *= 10.;\r\n\t\tif(section>11) {\r\n            // transition to night section, with light appearing\r\n\t\t\tlight = sat((time/8.-12.));\r\n\t\t\tskydist = section>12?200.:20.*light;\r\n\t\t\tosize1 = vec4(20,push2,push2,20);\r\n\t\t\tboxanim=0.;\r\n\t\t\tif(section==14) {\r\n                // center brightening and vanishing\r\n\t\t\t\tcenterrepeat.xy*=1.1;\r\n\t\t\t\tbright=pow(sat(time/8.-14.07),2.);\r\n\t\t\t\tosize2.xw = vec2(2.-sqrt(bright+.01-uv.y*.02+uv.x*.001)*2.3,17.*bright+2.);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcenteranim = section>2?(section>7?0.3:0.3):0.;\r\n\r\n\t//////// CAMERA ANIMATION ////////\r\n    // array value is a seed to an offset on lissajous curves, with various speed factor\r\n\tfloat avance = pcam.x*200. + (rest+(fract(mval.x+.5)-.5)*8.) * (pcam.y-0.2);\r\n\tif(mval.x<0.) avance += floor(rest/4.)*3.;\r\n\t\r\n\tfloat focusdist = abs(mval.y);\r\n\tfloat dofamount = mval.y>0. ? .05 : .15;\r\n    // extrapush is used to put the camera outside the room without colliding, so we can zoom more\r\n\tfloat extrapush = max(fract(pcam.z*17.23)-.5,0.)*15.;\r\n\tfloat fov = pcam.z*1.5+.5 + extrapush/2.;\r\n\tvec3 bs=vec3(0,-1.5 + sin(avance*.2)*1.,0);\r\n\tvec3 t = vec3(0,-1.5 + sin(avance*.3)*3.,0);\r\n\r\n    // lissajous curve to makes interesting camera motion\r\n\tbs.x += 5.*sin(avance*.4 + 0.7);\r\n\tbs.z += 5.*sin(avance*.9);\r\n\r\n    // camera target is following the same curve in front of the camera but with a random factor to focus more on the center\r\n\tfloat dt=max(0.,fract(pcam.z*24.81)-.2)*6.;\r\n\tt.x += dt*sin(avance*.4 + 0.7 + 1.);\r\n\tt.z += dt*sin(avance*.9 + 1.);\r\n\t\r\n\t//////// SKYDIVING ////////\r\n\tvec3 govec = vec3(-1,1.41,-1);\r\n\tvec3 poff = govec*decol*min(2.,decol)*2.5;\r\n\tt -= poff + govec*10.*(step(2.,decol)-bright);\r\n\tbs -= poff;\r\n    \r\n\t//////// CAMERA COMPUTE ////////\r\n\tvec3 cz=normalize(t-bs);\r\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\r\n\tvec3 cy=cross(cz,cx);\r\n\r\n\t// Main path tracing loop, do many samples to reduce the noise\r\n    float ZERO=min(0.,iTime); // this is a trick to force the GPU to keep the loop\r\n    // instead of trying to compile a giant shader by duplicating what's inside\r\n\tfor(float i=ZERO; i<SAMPLE_COUNT; ++i) {\r\n    \t\t\r\n\t\ts=bs;\t\r\n\t\tvec2 h = rnd23(frag-13.6-i*184.7).xy;\r\n\t\t// DOF\r\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\r\n\t\ts-=voff;\r\n\t\tr=normalize(uv.x*cx+uv.y*cy+fov*cz + voff*fov/(focusdist+extrapush));\r\n\r\n\t\ts += (r-cz) * extrapush;\r\n\t\t\r\n        // number of bounces is 3\r\n\t\tfor(float j=0.; j<3.; ++j) {\r\n\t\t\t////////// TRACE //////////\r\n\t\t\td=100000.;\r\n  \r\n            // find instersection with geometry\r\n            \r\n            // first test if we started inside a repeating box\r\n\t\t\tbox(s,-1);\r\n  \r\n            // then intersect with the background octahedron\r\n\t\t\tfrontocta(osize1, 0);\r\n  \r\n            // save that intersection for latter\r\n\t\t\tfloat d2=d;\r\n\t\t\tvec3 s2=s;\r\n\t\t\tvec3 n2=n;\r\n\r\n            // intersect with the center shape\r\n\t\t\tfrontocta(osize2, 1);\r\n  \r\n            // now use that position to carve the repeating box\r\n\t\t\tbox(s+r*d,1);\r\n\r\n            // if intersection position is outside the center octahedron, it means that we went trough the shape\r\n            // so we back to the background intersection\r\n\t\t\tif(octaedge(s+r*d,osize2)>0.01) {\r\n\t\t\t\td=d2;\r\n\t\t\t\tn=n2;\r\n                // last possible repeating box intersection on the background octahedron\r\n\t\t\t\tbox(s+r*d,1);\r\n\t\t\t}\r\n    \r\n            // and finally the ground plane intersection\r\n\t\t\tfloat curplane=(1.1-s.y)/r.y;\r\n\t\t\tif(curplane>0. && curplane<d) {\r\n\t\t\t\td=curplane;\r\n\t\t\t\tn=sign(s.y)*vec3(0,1,0);\r\n\t\t\t}\r\n    \t\t\t\r\n\t\t\tif(d>10000.) break;\r\n\t\t\t\r\n\t\t\t// go to the intersection point\r\n\t\t\ts = s + r * d;\r\n\t\t\r\n            // test if we are outside the 'sky distance'\r\n\t\t\tfloat edge1 = octaedge(s,osize1);\t\t\t\t\t\t\r\n\t\t\tif(edge1>skydist) {\r\n                // if so, we just push the sky color and early out\r\n\t\t\t\tcol += mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n            // if we are in the light section\r\n\t\t\tif(light>0.) {\r\n\t\t\t\tfloat middle = step(7.,edge1);\r\n\r\n                // center burning\r\n\t\t\t\tcol += bright * step(1.,-edge1) * vec3(.5,.7,1)*3.;\r\n\t\t\t\t\r\n                // side lights in two colors\r\n\t\t\t\tcol += middle * vec3(0.4,0.5,0.8) * 1.2 * step(0.7,rnd(dot(boxid,vec3(1,4,7))+floor(time)*0.1));\r\n\t\t\t\tcol += middle * vec3(0.2,0.5,0.9) * 1.2 * step(0.1,fract(.2+boxid.z*0.01 + floor(time)*13.2)*3.-1.5);\t\t\t\r\n\t\t\t}\r\n\r\n            // slight increase in perf, get out before computing rebound direction in the last rebound\r\n\t\t\tif(j==2.) break;\r\n\r\n            // roughness computing, depending on if we are on the center shape or not\r\n\t\t\tvec3 grid = step(fract(s*4.-.1),vec3(.8));\r\n\t\t\tfloat rough = octaedge(s,osize2)<.1 ? .5 : mix(1.,0.45*rnd31(floor(s*4.-.1)*27.33),min(grid.x,min(grid.y,grid.z)));\r\n            // slight offset so we get out of the surface before rebound\r\n\t\t\ts-=r*0.01;\r\n            // random rebound direction according to roughness parameter\r\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375.)+fract(time))-.5)*rough);\r\n\t\t}\r\n\t}\r\n\tcol *= .6/SAMPLE_COUNT;\r\n\t\r\n\tfragColor = vec4(col, 1);\r\n}","inputs":[],"outputs":[],"code":"float pi=acos(-1.);\r\n\r\nfloat sat(float t) { return clamp(t, 0.,1.); }\r\n\r\n//DAVE HOSKINS' HASH FUNCTIONS\r\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\r\n//https://www.shadertoy.com/view/4djSRW\r\nfloat rnd(float p)\r\n{\r\n    p = fract(p * 0.1031);\r\n    p *= p + 33.33;\r\n    return fract(2.*p*p);\r\n}\r\n\r\nvec3 rnd23(vec2 p)\r\n{\r\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\nfloat rnd31(vec3 p3)\r\n{\r\n\tp3  = fract(p3 * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\nvec3 rnd33(vec3 p3)\r\n{\r\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\n\r\n// Lower that value if it's too slow\r\n#define SAMPLE_COUNT 30.\r\n\r\n#define res iResolution\r\n\r\n//////////////////////\r\n// PATHTRACING PASS //\r\n//////////////////////\r\n\r\n// we use globals for most parameters, it save space\r\n// s is starting position, r is ray direction\r\n// n is normal at intersection point and d is distance to the intersection\r\nvec3 s,r,n=vec3(0);\r\nfloat d=10000.;\r\nvec3 boxid=vec3(0);\r\n\r\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\r\n\r\n// Compute octahedron distance from center, os is the size of each of the 4 'axis'\r\nfloat octaedge(vec3 p, vec4 os) {\r\n    \r\n    vec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\r\n    vec4 popo = p.xxyy*vv.xyww + p.yyzz*vv.zzxy;\r\n    popo=abs(popo)-os;\r\n          \r\n    float d = max(max(popo.x,popo.y),max(popo.z,popo.w));\r\n\r\n    return d;\r\n}\r\n\r\nvec4 osize1 = vec4(10);\r\nvec4 osize2 = vec4(2);\r\nvec3 boxrepeat = vec3(1,8,8);\r\nvec3 centerrepeat = vec3(.4,2,2);\r\nfloat boxanim = 0.;\r\nfloat centeranim = 0.;\r\nfloat boxtime = 0.;\r\nfloat insidedist(vec3 p) {\r\n\treturn max(octaedge(p, osize1), -octaedge(p, osize2));\r\n}\r\n\r\n// analytical box intersection\r\nvoid box(vec3 basepos, int side) {\r\n\t\r\n    // are we on the outside octahedron or the center one\r\n\tbool iscenter = octaedge(basepos,osize2)<.1;\r\n\tvec3 rep = iscenter ? centerrepeat : boxrepeat;\r\n\t\r\n    // main repetition is based on the x axis\r\n\tvec3 id2 = floor(basepos.x/rep.x)+vec3(1.7,3,7);\r\n\t\r\n    // then we can have integer multiplier subdivision without breaking the illusion\r\n\trep = (rep/(floor(rnd33(id2)*vec3(6))+1.));\r\n\t\r\n\tvec3 pos=vec3(0);\t\r\n    \r\n    // offset on yz axis, box animation\r\n\tvec2 ooo = fract(rnd(floor(basepos.x/rep.x)+.7)*vec2(1,3.7))*8.*7.;\r\n    ooo*=boxtime*vec2(1,1.3)*(iscenter?centeranim:boxanim)*rep.yz*0.03;\r\n    basepos.yz += ooo;\r\n\tpos.yz += ooo;\r\n  \r\n    // here we are applying the box repetition\r\n\tboxid = (floor(basepos/rep)+0.5)*rep;\r\n\r\n\tvec3 size = rep*0.4;\r\n  \r\n\tvec3 vr = r;\r\n\tpos=s+pos-boxid;\r\n  \r\n\tvec3 box=max((size-pos)/vr,(-size-pos)/vr);\r\n\tfloat bd = min(min(box.x,box.y),box.z);\r\n\tif(bd>0. && bd>d*float(side)) {\r\n\t\tvec3 cur = step(abs(pos+vr*d),size);\r\n\t\tif(side>0 ? (min(cur.x,min(cur.y,cur.z))>0.) : insidedist(s+r*bd)>0.) {\r\n\t\t\td=bd;\r\n\t\t\tn=-step(box-bd,vec3(0))*sign(pos+vr*d);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n// analytical octrahedron intersection, with customisable size for each of the 4 'axis'\r\nvoid frontocta(vec4 size, int side) {\r\n    \r\n  \tvec4 vv=vec4(1.4142,-1.4142,1,-1); // 1.4142 = cos(45)/cos(60)\r\n    vec4 invd = 1. / (r.xxyy*vv.xyww + r.yyzz*vv.zzxy);\r\n  \tvec4 popo = -s.xxyy*vv.xyww - s.yyzz*vv.zzxy;\r\n    \r\n    vec4 t0 = (popo - size) * invd;\r\n    vec4 t1 = (popo + size) * invd;\r\n    vec4 mi = min(t0, t1);\r\n    vec4 ma = max(t0, t1);\r\n\r\n    float front = min(min(ma.x,ma.y),min(ma.z,ma.w));\r\n    float back = max(max(mi.x,mi.y),max(mi.z,mi.w));\r\n    if(back>front) return;\r\n\r\n    if(side==0) {\r\n        back=front;\r\n    }\r\n\r\n    if(back<d && back > 0.) {\r\n        d = back;\r\n        vec4 vo = sign(t0-t1) * (side==0 ? step(-back,-ma) : step(back,mi));\r\n\r\n        n = vo.xxz - vo.yzw;\r\n        n.y += vo.y-vo.w;\r\n        n*=-sign(float(side)-.5)*vec3(0.817,0.5777,0.817); // = vec3(1,0.5 * 1.4142,1)/1.224 = 1.224 = cos(45) * tan(60)\r\n    }\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 frag = fragCoord.xy;\r\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\r\n\t\t\r\n\tvec3 col = vec3(0);\r\n\t\t\r\n\tfloat time =iTime-.9;\r\n\tboxtime = time;\r\n\r\n    // Main way to control the intro (camera, DOF focus, shape)\r\n    // Each vec3 is a section of the intro\r\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\r\n    // second value is the focus distance for the DOF, negative value makes the DOF bigger\r\n    // third value is the shape seed, integer value is the background shape, fractionnal part is the center shape\r\n\tvec3 mot[16] = vec3[16]( \r\n\t\t\t\t\t\t vec3(12,2,14.19)\r\n\t\t\t\t\t\t,vec3(-4.7,11,29)\r\n\t\t\t\t\t\t,vec3(7,10,7.2)\r\n\t\t\t\t\t\t,vec3(11,-5,5.63)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(16.45,5,17.4)\r\n\t\t\t\t\t\t,vec3(-12,5,12.2)\r\n\t\t\t\t\t\t,vec3(2,5,12.2)\r\n\t\t\t\t\t\t,vec3(0.4,9,10)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(17.8,7,11.1)\r\n\t\t\t\t\t\t,vec3(-7.6,-20,15)\r\n\t\t\t\t\t\t,vec3(-13,-30,2.2)\r\n\t\t\t\t\t\t,vec3(7,40,3)\r\n\t\t\t\t\t\t// --------------\r\n\t\t\t\t\t\t,vec3(17,20,6)\r\n\t\t\t\t\t\t,vec3(-5.4,50,15.4)\r\n\t\t\t\t\t\t,vec3(16,30,13)\r\n\t\t\t\t\t\t,vec3(12,10,7)\r\n\t\t\t\t\t\t);\r\n\r\n\r\n\tfloat light = 0.;\r\n\tint section = int(min(16.,time/8.));\r\n\tfloat rest = mod(time,8.);\r\n\r\n\tvec3 mval = mot[section];\r\n\tif(section>5 && section<9) mval.z+=floor(rest)*2.2;\r\n\r\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0));\r\n\t\t\r\n\t//////// SIZES ////////\r\n\tif(section==0) osize2 = vec4(6);\r\n\t\r\n    // extruding the shapes\r\n\tfloat push2 = max(0.,time-48.)*1.5;\r\n\tif(section>7) push2 = 10000.;\r\n\tfloat push = 2.+max(0.,time-40.)*.5+push2;\r\n\tfloat decol=max(0.,time-70.);\r\n\tif(section>14) {\r\n\t\tdecol=0.;\r\n\t\tpush=0.;\r\n\t\tpush2=0.;\r\n\t}\r\n\r\n\tif(section>4)osize2 = vec4(2,push,push,2);\r\n\tif(section>6)osize1 = vec4(10,10.+push2,10.+push2,10);\r\n\t\r\n\t//////// REPEATS ////////\r\n\tboxrepeat = rnd23(vec2(floor(mval.z),0))*50.;\r\n\tcenterrepeat = pow(rnd23(vec2(0,fract(mval.z)*31.5+28.)),vec3(2))*10.+.2;\r\n\r\n\tif(section==3) osize1=vec4(20);\r\n\t\t\r\n\t//////// NIGHT ////////\r\n\tfloat skydist = 1.;\r\n\tfloat bright=0.;\r\n\tif(section>8 && section<15) {\r\n\t\tboxanim = .3;\r\n\t\tboxrepeat *= 2.;\r\n\t\tcenterrepeat *= 10.;\r\n\t\tif(section>11) {\r\n            // transition to night section, with light appearing\r\n\t\t\tlight = sat((time/8.-12.));\r\n\t\t\tskydist = section>12?200.:20.*light;\r\n\t\t\tosize1 = vec4(20,push2,push2,20);\r\n\t\t\tboxanim=0.;\r\n\t\t\tif(section==14) {\r\n                // center brightening and vanishing\r\n\t\t\t\tcenterrepeat.xy*=1.1;\r\n\t\t\t\tbright=pow(sat(time/8.-14.07),2.);\r\n\t\t\t\tosize2.xw = vec2(2.-sqrt(bright+.01-uv.y*.02+uv.x*.001)*2.3,17.*bright+2.);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcenteranim = section>2?(section>7?0.3:0.3):0.;\r\n\r\n\t//////// CAMERA ANIMATION ////////\r\n    // array value is a seed to an offset on lissajous curves, with various speed factor\r\n\tfloat avance = pcam.x*200. + (rest+(fract(mval.x+.5)-.5)*8.) * (pcam.y-0.2);\r\n\tif(mval.x<0.) avance += floor(rest/4.)*3.;\r\n\t\r\n\tfloat focusdist = abs(mval.y);\r\n\tfloat dofamount = mval.y>0. ? .05 : .15;\r\n    // extrapush is used to put the camera outside the room without colliding, so we can zoom more\r\n\tfloat extrapush = max(fract(pcam.z*17.23)-.5,0.)*15.;\r\n\tfloat fov = pcam.z*1.5+.5 + extrapush/2.;\r\n\tvec3 bs=vec3(0,-1.5 + sin(avance*.2)*1.,0);\r\n\tvec3 t = vec3(0,-1.5 + sin(avance*.3)*3.,0);\r\n\r\n    // lissajous curve to makes interesting camera motion\r\n\tbs.x += 5.*sin(avance*.4 + 0.7);\r\n\tbs.z += 5.*sin(avance*.9);\r\n\r\n    // camera target is following the same curve in front of the camera but with a random factor to focus more on the center\r\n\tfloat dt=max(0.,fract(pcam.z*24.81)-.2)*6.;\r\n\tt.x += dt*sin(avance*.4 + 0.7 + 1.);\r\n\tt.z += dt*sin(avance*.9 + 1.);\r\n\t\r\n\t//////// SKYDIVING ////////\r\n\tvec3 govec = vec3(-1,1.41,-1);\r\n\tvec3 poff = govec*decol*min(2.,decol)*2.5;\r\n\tt -= poff + govec*10.*(step(2.,decol)-bright);\r\n\tbs -= poff;\r\n    \r\n\t//////// CAMERA COMPUTE ////////\r\n\tvec3 cz=normalize(t-bs);\r\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\r\n\tvec3 cy=cross(cz,cx);\r\n\r\n\t// Main path tracing loop, do many samples to reduce the noise\r\n    float ZERO=min(0.,iTime); // this is a trick to force the GPU to keep the loop\r\n    // instead of trying to compile a giant shader by duplicating what's inside\r\n\tfor(float i=ZERO; i<SAMPLE_COUNT; ++i) {\r\n    \t\t\r\n\t\ts=bs;\t\r\n\t\tvec2 h = rnd23(frag-13.6-i*184.7).xy;\r\n\t\t// DOF\r\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\r\n\t\ts-=voff;\r\n\t\tr=normalize(uv.x*cx+uv.y*cy+fov*cz + voff*fov/(focusdist+extrapush));\r\n\r\n\t\ts += (r-cz) * extrapush;\r\n\t\t\r\n        // number of bounces is 3\r\n\t\tfor(float j=0.; j<3.; ++j) {\r\n\t\t\t////////// TRACE //////////\r\n\t\t\td=100000.;\r\n  \r\n            // find instersection with geometry\r\n            \r\n            // first test if we started inside a repeating box\r\n\t\t\tbox(s,-1);\r\n  \r\n            // then intersect with the background octahedron\r\n\t\t\tfrontocta(osize1, 0);\r\n  \r\n            // save that intersection for latter\r\n\t\t\tfloat d2=d;\r\n\t\t\tvec3 s2=s;\r\n\t\t\tvec3 n2=n;\r\n\r\n            // intersect with the center shape\r\n\t\t\tfrontocta(osize2, 1);\r\n  \r\n            // now use that position to carve the repeating box\r\n\t\t\tbox(s+r*d,1);\r\n\r\n            // if intersection position is outside the center octahedron, it means that we went trough the shape\r\n            // so we back to the background intersection\r\n\t\t\tif(octaedge(s+r*d,osize2)>0.01) {\r\n\t\t\t\td=d2;\r\n\t\t\t\tn=n2;\r\n                // last possible repeating box intersection on the background octahedron\r\n\t\t\t\tbox(s+r*d,1);\r\n\t\t\t}\r\n    \r\n            // and finally the ground plane intersection\r\n\t\t\tfloat curplane=(1.1-s.y)/r.y;\r\n\t\t\tif(curplane>0. && curplane<d) {\r\n\t\t\t\td=curplane;\r\n\t\t\t\tn=sign(s.y)*vec3(0,1,0);\r\n\t\t\t}\r\n    \t\t\t\r\n\t\t\tif(d>10000.) break;\r\n\t\t\t\r\n\t\t\t// go to the intersection point\r\n\t\t\ts = s + r * d;\r\n\t\t\r\n            // test if we are outside the 'sky distance'\r\n\t\t\tfloat edge1 = octaedge(s,osize1);\t\t\t\t\t\t\r\n\t\t\tif(edge1>skydist) {\r\n                // if so, we just push the sky color and early out\r\n\t\t\t\tcol += mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n            // if we are in the light section\r\n\t\t\tif(light>0.) {\r\n\t\t\t\tfloat middle = step(7.,edge1);\r\n\r\n                // center burning\r\n\t\t\t\tcol += bright * step(1.,-edge1) * vec3(.5,.7,1)*3.;\r\n\t\t\t\t\r\n                // side lights in two colors\r\n\t\t\t\tcol += middle * vec3(0.4,0.5,0.8) * 1.2 * step(0.7,rnd(dot(boxid,vec3(1,4,7))+floor(time)*0.1));\r\n\t\t\t\tcol += middle * vec3(0.2,0.5,0.9) * 1.2 * step(0.1,fract(.2+boxid.z*0.01 + floor(time)*13.2)*3.-1.5);\t\t\t\r\n\t\t\t}\r\n\r\n            // slight increase in perf, get out before computing rebound direction in the last rebound\r\n\t\t\tif(j==2.) break;\r\n\r\n            // roughness computing, depending on if we are on the center shape or not\r\n\t\t\tvec3 grid = step(fract(s*4.-.1),vec3(.8));\r\n\t\t\tfloat rough = octaedge(s,osize2)<.1 ? .5 : mix(1.,0.45*rnd31(floor(s*4.-.1)*27.33),min(grid.x,min(grid.y,grid.z)));\r\n            // slight offset so we get out of the surface before rebound\r\n\t\t\ts-=r*0.01;\r\n            // random rebound direction according to roughness parameter\r\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375.)+fract(time))-.5)*rough);\r\n\t\t}\r\n\t}\r\n\tcol *= .6/SAMPLE_COUNT;\r\n\t\r\n\tfragColor = vec4(col, 1);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n----- Night Mist ------\r\n-- by NuSan & Valden --\r\n    \r\n3rd place at Revision 2019 - PC 4k intro\r\n\r\nhttp://www.pouet.net/prod.php?which=81046\r\nhttps://youtu.be/m7IFUjf_8gg\r\n\r\nNuSan: Concept, visual, code\r\nValden: Music\r\n\r\nOriginal tools: Leviathan 2.0 by Armak, 4klang by Alcatraz, Shader Minifier by LLB\r\n*/\r\n\r\n#define time iTime\r\n#define bpm (time*1.5)\r\n#define section (bpm/16.)\r\nint section2 = 0;\r\nfloat pi = acos(float(-1));\r\n\r\nfloat box(vec3 p,vec3 s) {p=abs(p)-s;return max(p.x,max(p.y,p.z));}\r\nfloat cyl(vec3 p,float s, float h) {return max(length(p.xz)-s,abs(p.y)-h);}\r\nfloat smin(float a,float b,float h) {float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;}\r\n\r\n#define rep(a,s) (fract((a)/s+.5)-.5)*s\r\n#define repa(a,s) abs(fract((a)/s+.5)-.5)*s\r\n#define repc(a,s) (smoothstep(0,1,abs(frac//(a)/s+.5)-.5)*2)*s*0.5)\r\n#define c0(a) clamp(a,0.,1.)\r\n\r\nmat2 rot(float a) {\tfloat ca=cos(a),sa=sin(a); return mat2(ca,sa,-sa,ca);}\r\n\r\nfloat noi2(vec2 p) {\r\n  vec2 ip=floor(p);\r\n  p=smoothstep(0.0,1.0,fract(p));\r\n  vec4 v=fract(sin(dot(ip,vec2(7,137))+vec4(0,7,137,144))*8986.352);\r\n  vec2 v2=mix(v.xz,v.yw,p.x);\r\n  return mix(v2.x,v2.y,p.y);\r\n}\r\n\r\nint scene=0;\r\nfloat mont=0.;\r\nfloat decal=0.;\r\nfloat anim=0.;\r\n\r\n// shift the world on x/y axis according to z axis value\r\nvec3 tunnel(vec3 p) {\r\n  vec3 o=vec3(0);\r\n  if(scene==1) {\r\n  \to.x+=sin(p.z*0.05)*6.;\r\n  \to.x+=sin(p.z*0.15)*3.;\r\n  \to.y+=sin(p.z*0.07)*7.;\r\n  }\r\n  return o;\r\n}\r\n\r\n// morph the world into plane, cylinder or sphere\r\nvec3 morph(vec3 p) {\r\n\r\n\tp+=tunnel(p);\r\n\tvec3 rop=p; // plane\r\n\t\r\n\t// cylinder\r\n\tif(scene==1) rop=vec3(atan(p.y,p.x)*5., length(p.xy)-10., p.z*0.5);\r\n\r\n\tif(scene==3) {\r\n\t\t// sphere\r\n\t\trop = vec3(abs(atan(p.z,p.x))*10.-5., (10.-length(p)), abs(atan(length(p.xz),p.y))*10.-16.);\r\n\t}\r\n\t\r\n\treturn rop;\r\n}\r\n\r\n// kaleidoscopic folding for the city\r\nvec3 kalei(vec3 p, inout vec2 ad) {\r\n\t\r\n\tfloat s=10.+fract(section*4.)*anim;\r\n\tfor(int i=0;i<5;++i) {\r\n\t\tp.xz *= rot(float(i)+12.7);\r\n\t\tfloat freq=100.0;\r\n\t\tad.x+=sign(p.x)*sign(p.z)*(float(i)*0.72+.2);\r\n\t\tad.y=min(ad.y,min(abs(p.x),abs(p.z)));\r\n\t\tp.xz = repa(p.xz,freq);\r\n\t\tp.xz -=s;\r\n\t\ts*=0.5;\r\n\t}\t\r\n\t// change scene\r\n\tp.x += decal;\r\n\treturn p;\r\n}\r\n\r\nfloat at=0.;\r\nfloat mat=0.;\r\nvec3 localp;\r\n// give signed distance field at position p\r\nfloat map2(vec3 p) {\r\n\tp=morph(p); // morph the world into plane, cylinder or sphere\r\n\r\n\tvec3 bp=p;\r\n\tvec2 uv=p.xz;\r\n\r\n\tvec2 off=sin(p.xz*vec2(0.2,0.35)*10.+sin(p.y*10.));\r\n\t\r\n\tvec2 ad=vec2(0);\r\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\r\n\t\r\n\tfloat d=box(p, vec3(0.4));\r\n\t\r\n\tat+=1./(d+0.1);\r\n\r\n\tfloat city=min( min( box(p-vec3(0,0,0.5), vec3(0.55)) , box(p-vec3(0.5,0,-0.3), vec3(0.2,2,0.2))) , cyl(p-vec3(1.0,0,0),0.3,3.) );\r\n\r\n\td=min(d,city);\r\n\tlocalp=p;\r\n\r\n\tvec3 rp=p;\r\n\trp.xz=rep(rp.xz,0.5);\r\n\trp.xz+=off*0.05;\r\n\t// fields\r\n\tfloat blob=box(p-vec3(3,0,0), vec3(1.6));\r\n\td=min(d,min(max(smin(cyl(rp,0.1,9.),-5.-p.y,-5.),blob), max(abs(blob-0.2)-0.05,-.7-p.y)));\r\n\t\r\n\tvec3 ap=abs(abs(p+vec3(-2,1.2,0))-vec3(4,0.6,1.2));\r\n\td=min(d,max(box(ap,vec3(.7)), box(0.7-max(ap,ap.yzx),vec3(0.2)))); // grid\r\n\t\t\t\r\n\t\t\t\r\n\t// terrain/mountain\r\n\td=smin(min(d,(noi2(uv*0.1)*5.+noi2(uv*0.2)*3. + pow(abs(noi2(uv)*0.2+noi2(uv*2.)*0.1+noi2(uv*4.)*0.05-0.5),5.)*10.-4.-bp.y+mont)*.9), -bp.y, 0.2); // Combine terrain\r\n\t\t\t\r\n\tmat=abs(d-city)<0.01?1.:0.;\r\n\r\n\td=max(d,0.00001); // anti glitch? avoid some nan/inf values\r\n\t\r\n\treturn d;\r\n}\r\n\r\nfloat rnd1(float t) {\r\n  return fract(sin(t*478.556)*8522.412);\r\n}\r\n\r\nfloat rnd2(vec2 t) {\r\n  return fract(dot(sin(t*741.145 + t.yx*422.988), vec2(7789.532)));\r\n}\r\n\r\n// give volumetric amount at position p\r\nfloat atspeed=1.;\r\nfloat gridsize=5.;\r\nvec3 atmo(vec3 p) {\r\n\tvec3 bp=p;\r\n\tp=morph(p); // morph the world into plane, cylinder or sphere\r\n\tvec2 ad=vec2(0,10);\r\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\r\n\t\r\n\tvec3 col=vec3(0);\r\n\r\n\tvec3 back=vec3(0.5,0.2,1.0);\r\n\tback.xy*=rot(ad.x);\r\n\tback=abs(back);\r\n\tfloat fade=c0((p.y+8.)*0.03);\r\n\tfloat ff=rnd2(floor(p.xz*gridsize));\r\n\tfloat pulse=0.7;//fract(bpm*0.25);\r\n\tcol += ff*back*5.0*smoothstep(0.1,0.2,ad.y)*pow(smoothstep(0.9*pulse,1.0*pulse,sin(rnd1(ad.x)*1.7*pi+bpm*pi*atspeed) ),10.)*fade*fade;\r\n\t\r\n\treturn col;\r\n}\r\n\r\nvec3 sky(vec3 r) {\r\n\treturn mix(vec3(0.2,0.5,1.0), vec3(2.0,1.1,0.6), smoothstep(0.2,1.,-r.z));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\r\n    uv -= 0.5;\r\n    uv /= vec2(iResolution.y / iResolution.x, 1);\r\n    \r\n    section2 = int(section);\r\n    \r\n\tfloat fov=.4;\r\n\tfloat shad = 1.;\r\n\t\r\n    // change scenes according time\r\n\tif(section2>3 && section<4.) anim=30.;\r\n\tmont=(section2>1 && section2<10)?100.:0.;\r\n\tif(section2>5 && section<8.) { decal=4.-floor((section-5.)*4.)*.5; fov=rnd1(floor(bpm))+.2;}\r\n\tif(section2>3&&section2<8) scene=1;\r\n\tif(section2>9) {scene=3;atspeed=2.;}\r\n\r\n\tfloat fx=c0((2.-abs(section-4.1))*4.)+c0((1.-abs(section-10.))*4.); // night\r\n\t\r\n\tvec3 s = vec3(0,-2,-10); // distance cam\r\n\tvec3 light = normalize(-vec3(1,2.5,3)); // light height\r\n\t\t\r\n\tvec3 t = vec3(0.3,0.5,0);\r\n\r\n    // camera setting by scenes\r\n\tfloat div=1.;\r\n\tfloat camoff= section2>9 ? 0. : (rnd1(floor(section*div)));\r\n\r\n\tfloat mav=time*0.5+camoff*50.;\r\n\tfloat piv=.2;\r\n\tfloat az=0.7;\r\n\tif(scene==0) {\r\n\t\ts.y=camoff*(section2>6?12.5:14.);\r\n\t}\r\n\tif(scene==1) {\r\n\t\ts.z=6.;\r\n\t\taz=2.3*sin(section*5.);\r\n\t\tmav=10.;\r\n\t}\r\n\tif(scene==3) {\r\n\t\taz=0.2;\r\n\t\ts.z=20.;\r\n\t\tt=vec3(0,0,10);\r\n\t\tmav=min((section-11.55)*6.,(section-12.15)*3.);\r\n\t\tmav*=c0(-mav);\r\n\t\tpiv*=c0(-mav);\r\n\t\tmav+=3.5;\r\n\t}\r\n\tfloat muvol=.2;\r\n\tif(section2>8&&section2<10) {muvol=.6;s.z=-30.;anim=30.;az=1.3;atspeed=2.;gridsize=1.;}\r\n\r\n\tfloat rand = rnd2(uv);\r\n\tfloat dither=0.9+0.1*rand;\r\n\t\r\n\ts.yz*=rot(az);\r\n\ts.xz *= rot(mav);\r\n\r\n\tif(scene==0) {\r\n\t\ts.z-=max(20.-time,0.)*3.;\r\n\t}\r\n\t\r\n\tfloat avance=0.;\r\n\tfloat tar=10.;\r\n\tif(scene==1) {\r\n\t\tavance=fract(section)*80.-40.; // traveling\r\n\t\ttar*=float(1-section2%2*2)*10.;//+(section>7.25?1:0)*7;\r\n\t}\r\n\ts.z -= avance;\r\n\tt.z -= avance+tar; // cam dir\r\n\ts -= tunnel(s);\r\n\tt -= tunnel(t);\r\n\t\r\n\tvec3 cz = normalize(t-s);\r\n\tvec3 cx = normalize(cross(cz, vec3(sin(time)*piv,1,0)));\r\n\tvec3 cy = cross(cz, cx);\r\n\r\n\tvec3 r = normalize(cx*uv.x + cy*uv.y + cz*fov);\r\n\t\r\n\t// main raymarching loop\r\n\tvec3 p = s;\r\n\tfloat dd=0.;\r\n\tfor(int i=0; i<100; ++i) {\r\n\t\tfloat d = map2(p)*0.7*dither;\r\n\t\tif(d<0.001) {break;}\r\n\t\tif(dd>100.) {dd=100.;break;}\t\t\r\n\t\tp+=r*d;\r\n\t\tdd+=d;\r\n\t}\r\n\r\n\tfloat curmat=mat;\r\n\tvec3 lop=localp;\r\n\r\n\tvec2 off=vec2(0.01,0);\r\n\tvec3 n = normalize(vec3(map2(p+off.xyy)-map2(p-off.xyy),map2(p+off.yxy)-map2(p-off.yxy),map2(p+off.yyx)-map2(p-off.yyx))-.001);\r\n\t\t\r\n\tif(scene==1){\r\n\t\tlight=normalize(vec3(-p.x,-p.y,10.*sin(time)));\r\n\t}\r\n\r\n\tfloat ao=(c0(map2(p+n*0.2)/0.2)*.5+.5) * c0(map2(p+n*0.05)/0.05);\r\n\t\r\n\tfloat deg = 1.-c0(dd/100.);\r\n\tfloat fog = c0(deg*deg);\r\n\r\n    // shadow raymarching (cheap)\r\n\tvec3 sp = p + n * 0.5 - r * 0.2;\r\n\tfor(int i=0; i<10; ++i) {\r\n\t\tfloat d=map2(sp);\r\n\t\tshad=min(shad,d);\r\n\t\tsp+=d*light*0.6*dither;\r\n\t}\r\n\t\t\t\t\r\n\tshad=c0((shad-.02)*3.);\r\n\tvec2 gg=abs(fract(lop.xy*5.)-0.5);\r\n\tfloat windows=curmat*smoothstep(0.35,0.3,max(gg.x,gg.y))*step(abs(n.y),.9)*(1.-fx);\r\n\t\t\r\n\tfloat spec=max(0.,dot(n,normalize(light-r)));\r\n\r\n\tfloat fre=pow(1.-abs(dot(n,r)),5.);\r\n\tvec3 col = (max(0., dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)\r\n        +sky(r)*pow(spec,5.)+curmat*10.*pow(spec,50.))\r\n     * (1.-windows)+(1.-windows*.4)*(fre * ao*2.+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2))\r\n        *mix(vec3(1),vec3(0.2,0.2,0.7),fx)+sky(reflect(r,n))*windows*spec*fre *10.\r\n        +atmo(p)*6.*fog*fx+sky(r) * exp((1.-fog)*3.)*0.2*pow(1.-fx,10.)+vec3(0.2,0.5,1.0)\r\n        * pow(at*0.002,2.)*5.*pow(fx,0.3);\r\n\r\n\t/*\r\n\t// maximized version\r\n\t// diffuse and spec\r\n\tcol += max(0, dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)+sky(r)*pow(spec,5)+curmat*10*pow(spec,50)) * (1-windows);\r\n\t\r\n\t// fresnel\r\n\tfloat fre=pow(1-abs(dot(n,r)),5);\r\n\tcol += (fre * ao*2+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2);\r\n\t\r\n\t// night color mood\r\n\tcol*=mix(vec3(1),vec3(0.2,0.2,0.7),fx);\r\n\r\n\t// sky reflection inside the windows\r\n\tcol += sky(reflect(r,n))*windows*spec*fre *10;\r\n\t\r\n\t// emissive from the ground during night\r\n\tcol += atmo(p)*6*fog*fx;\r\n\t\r\n\t// sky fog and atmosphere\r\n\tcol += sky(r) * exp((1-fog)*3)*0.2*pow(1-fx,10);\r\n\tcol += vec3(0.2,0.5,1.0) * pow(at*0.002,2)*5*pow(fx,0.3);\r\n\t*/\r\n\t\r\n    // \"volumetric\" for night scenes\r\n\tvec3 rp=r*muvol;\r\n\tvec3 vp=s+rp*rand;\r\n\tfor(int i=0; i<100; ++i) {\r\n\t\tif(length(vp-s)>dd) break;\r\n\t\tcol+=atmo(vp)*fx;\r\n\t\tvp+=rp;\r\n\t}\r\n\t\r\n\tvec2 vig=abs(uv)-vec2(0.5,0.2);\t\r\n\tcol = c0(pow(1.-exp(-col*pow(0.5-length(max(vec2(0),vig)),0.5)*2.5),vec3(1.8)))*c0(time/5.)*c0((12.25-section)*10.);\r\n\t/*\r\n\t// maximised version\r\n\t// filmic lol\r\n\tcol = 1-exp(-col*2.5);\r\n\tcol = c0(pow(col,vec3(2.1)));\r\n\t\r\n\t// fade in/out\r\n\tcol *= c0(time/5);\r\n\tcol *= c0((11.3-section)*10);\r\n\t*/\r\n\t\r\n\tfragColor = vec4(col, 1);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n----- Night Mist ------\r\n-- by NuSan & Valden --\r\n    \r\n3rd place at Revision 2019 - PC 4k intro\r\n\r\nhttp://www.pouet.net/prod.php?which=81046\r\nhttps://youtu.be/m7IFUjf_8gg\r\n\r\nNuSan: Concept, visual, code\r\nValden: Music\r\n\r\nOriginal tools: Leviathan 2.0 by Armak, 4klang by Alcatraz, Shader Minifier by LLB\r\n*/\r\n\r\n#define time iTime\r\n#define bpm (time*1.5)\r\n#define section (bpm/16.)\r\nint section2 = 0;\r\nfloat pi = acos(float(-1));\r\n\r\nfloat box(vec3 p,vec3 s) {p=abs(p)-s;return max(p.x,max(p.y,p.z));}\r\nfloat cyl(vec3 p,float s, float h) {return max(length(p.xz)-s,abs(p.y)-h);}\r\nfloat smin(float a,float b,float h) {float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;}\r\n\r\n#define rep(a,s) (fract((a)/s+.5)-.5)*s\r\n#define repa(a,s) abs(fract((a)/s+.5)-.5)*s\r\n#define repc(a,s) (smoothstep(0,1,abs(frac//(a)/s+.5)-.5)*2)*s*0.5)\r\n#define c0(a) clamp(a,0.,1.)\r\n\r\nmat2 rot(float a) {\tfloat ca=cos(a),sa=sin(a); return mat2(ca,sa,-sa,ca);}\r\n\r\nfloat noi2(vec2 p) {\r\n  vec2 ip=floor(p);\r\n  p=smoothstep(0.0,1.0,fract(p));\r\n  vec4 v=fract(sin(dot(ip,vec2(7,137))+vec4(0,7,137,144))*8986.352);\r\n  vec2 v2=mix(v.xz,v.yw,p.x);\r\n  return mix(v2.x,v2.y,p.y);\r\n}\r\n\r\nint scene=0;\r\nfloat mont=0.;\r\nfloat decal=0.;\r\nfloat anim=0.;\r\n\r\n// shift the world on x/y axis according to z axis value\r\nvec3 tunnel(vec3 p) {\r\n  vec3 o=vec3(0);\r\n  if(scene==1) {\r\n  \to.x+=sin(p.z*0.05)*6.;\r\n  \to.x+=sin(p.z*0.15)*3.;\r\n  \to.y+=sin(p.z*0.07)*7.;\r\n  }\r\n  return o;\r\n}\r\n\r\n// morph the world into plane, cylinder or sphere\r\nvec3 morph(vec3 p) {\r\n\r\n\tp+=tunnel(p);\r\n\tvec3 rop=p; // plane\r\n\t\r\n\t// cylinder\r\n\tif(scene==1) rop=vec3(atan(p.y,p.x)*5., length(p.xy)-10., p.z*0.5);\r\n\r\n\tif(scene==3) {\r\n\t\t// sphere\r\n\t\trop = vec3(abs(atan(p.z,p.x))*10.-5., (10.-length(p)), abs(atan(length(p.xz),p.y))*10.-16.);\r\n\t}\r\n\t\r\n\treturn rop;\r\n}\r\n\r\n// kaleidoscopic folding for the city\r\nvec3 kalei(vec3 p, inout vec2 ad) {\r\n\t\r\n\tfloat s=10.+fract(section*4.)*anim;\r\n\tfor(int i=0;i<5;++i) {\r\n\t\tp.xz *= rot(float(i)+12.7);\r\n\t\tfloat freq=100.0;\r\n\t\tad.x+=sign(p.x)*sign(p.z)*(float(i)*0.72+.2);\r\n\t\tad.y=min(ad.y,min(abs(p.x),abs(p.z)));\r\n\t\tp.xz = repa(p.xz,freq);\r\n\t\tp.xz -=s;\r\n\t\ts*=0.5;\r\n\t}\t\r\n\t// change scene\r\n\tp.x += decal;\r\n\treturn p;\r\n}\r\n\r\nfloat at=0.;\r\nfloat mat=0.;\r\nvec3 localp;\r\n// give signed distance field at position p\r\nfloat map2(vec3 p) {\r\n\tp=morph(p); // morph the world into plane, cylinder or sphere\r\n\r\n\tvec3 bp=p;\r\n\tvec2 uv=p.xz;\r\n\r\n\tvec2 off=sin(p.xz*vec2(0.2,0.35)*10.+sin(p.y*10.));\r\n\t\r\n\tvec2 ad=vec2(0);\r\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\r\n\t\r\n\tfloat d=box(p, vec3(0.4));\r\n\t\r\n\tat+=1./(d+0.1);\r\n\r\n\tfloat city=min( min( box(p-vec3(0,0,0.5), vec3(0.55)) , box(p-vec3(0.5,0,-0.3), vec3(0.2,2,0.2))) , cyl(p-vec3(1.0,0,0),0.3,3.) );\r\n\r\n\td=min(d,city);\r\n\tlocalp=p;\r\n\r\n\tvec3 rp=p;\r\n\trp.xz=rep(rp.xz,0.5);\r\n\trp.xz+=off*0.05;\r\n\t// fields\r\n\tfloat blob=box(p-vec3(3,0,0), vec3(1.6));\r\n\td=min(d,min(max(smin(cyl(rp,0.1,9.),-5.-p.y,-5.),blob), max(abs(blob-0.2)-0.05,-.7-p.y)));\r\n\t\r\n\tvec3 ap=abs(abs(p+vec3(-2,1.2,0))-vec3(4,0.6,1.2));\r\n\td=min(d,max(box(ap,vec3(.7)), box(0.7-max(ap,ap.yzx),vec3(0.2)))); // grid\r\n\t\t\t\r\n\t\t\t\r\n\t// terrain/mountain\r\n\td=smin(min(d,(noi2(uv*0.1)*5.+noi2(uv*0.2)*3. + pow(abs(noi2(uv)*0.2+noi2(uv*2.)*0.1+noi2(uv*4.)*0.05-0.5),5.)*10.-4.-bp.y+mont)*.9), -bp.y, 0.2); // Combine terrain\r\n\t\t\t\r\n\tmat=abs(d-city)<0.01?1.:0.;\r\n\r\n\td=max(d,0.00001); // anti glitch? avoid some nan/inf values\r\n\t\r\n\treturn d;\r\n}\r\n\r\nfloat rnd1(float t) {\r\n  return fract(sin(t*478.556)*8522.412);\r\n}\r\n\r\nfloat rnd2(vec2 t) {\r\n  return fract(dot(sin(t*741.145 + t.yx*422.988), vec2(7789.532)));\r\n}\r\n\r\n// give volumetric amount at position p\r\nfloat atspeed=1.;\r\nfloat gridsize=5.;\r\nvec3 atmo(vec3 p) {\r\n\tvec3 bp=p;\r\n\tp=morph(p); // morph the world into plane, cylinder or sphere\r\n\tvec2 ad=vec2(0,10);\r\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\r\n\t\r\n\tvec3 col=vec3(0);\r\n\r\n\tvec3 back=vec3(0.5,0.2,1.0);\r\n\tback.xy*=rot(ad.x);\r\n\tback=abs(back);\r\n\tfloat fade=c0((p.y+8.)*0.03);\r\n\tfloat ff=rnd2(floor(p.xz*gridsize));\r\n\tfloat pulse=0.7;//fract(bpm*0.25);\r\n\tcol += ff*back*5.0*smoothstep(0.1,0.2,ad.y)*pow(smoothstep(0.9*pulse,1.0*pulse,sin(rnd1(ad.x)*1.7*pi+bpm*pi*atspeed) ),10.)*fade*fade;\r\n\t\r\n\treturn col;\r\n}\r\n\r\nvec3 sky(vec3 r) {\r\n\treturn mix(vec3(0.2,0.5,1.0), vec3(2.0,1.1,0.6), smoothstep(0.2,1.,-r.z));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\r\n    uv -= 0.5;\r\n    uv /= vec2(iResolution.y / iResolution.x, 1);\r\n    \r\n    section2 = int(section);\r\n    \r\n\tfloat fov=.4;\r\n\tfloat shad = 1.;\r\n\t\r\n    // change scenes according time\r\n\tif(section2>3 && section<4.) anim=30.;\r\n\tmont=(section2>1 && section2<10)?100.:0.;\r\n\tif(section2>5 && section<8.) { decal=4.-floor((section-5.)*4.)*.5; fov=rnd1(floor(bpm))+.2;}\r\n\tif(section2>3&&section2<8) scene=1;\r\n\tif(section2>9) {scene=3;atspeed=2.;}\r\n\r\n\tfloat fx=c0((2.-abs(section-4.1))*4.)+c0((1.-abs(section-10.))*4.); // night\r\n\t\r\n\tvec3 s = vec3(0,-2,-10); // distance cam\r\n\tvec3 light = normalize(-vec3(1,2.5,3)); // light height\r\n\t\t\r\n\tvec3 t = vec3(0.3,0.5,0);\r\n\r\n    // camera setting by scenes\r\n\tfloat div=1.;\r\n\tfloat camoff= section2>9 ? 0. : (rnd1(floor(section*div)));\r\n\r\n\tfloat mav=time*0.5+camoff*50.;\r\n\tfloat piv=.2;\r\n\tfloat az=0.7;\r\n\tif(scene==0) {\r\n\t\ts.y=camoff*(section2>6?12.5:14.);\r\n\t}\r\n\tif(scene==1) {\r\n\t\ts.z=6.;\r\n\t\taz=2.3*sin(section*5.);\r\n\t\tmav=10.;\r\n\t}\r\n\tif(scene==3) {\r\n\t\taz=0.2;\r\n\t\ts.z=20.;\r\n\t\tt=vec3(0,0,10);\r\n\t\tmav=min((section-11.55)*6.,(section-12.15)*3.);\r\n\t\tmav*=c0(-mav);\r\n\t\tpiv*=c0(-mav);\r\n\t\tmav+=3.5;\r\n\t}\r\n\tfloat muvol=.2;\r\n\tif(section2>8&&section2<10) {muvol=.6;s.z=-30.;anim=30.;az=1.3;atspeed=2.;gridsize=1.;}\r\n\r\n\tfloat rand = rnd2(uv);\r\n\tfloat dither=0.9+0.1*rand;\r\n\t\r\n\ts.yz*=rot(az);\r\n\ts.xz *= rot(mav);\r\n\r\n\tif(scene==0) {\r\n\t\ts.z-=max(20.-time,0.)*3.;\r\n\t}\r\n\t\r\n\tfloat avance=0.;\r\n\tfloat tar=10.;\r\n\tif(scene==1) {\r\n\t\tavance=fract(section)*80.-40.; // traveling\r\n\t\ttar*=float(1-section2%2*2)*10.;//+(section>7.25?1:0)*7;\r\n\t}\r\n\ts.z -= avance;\r\n\tt.z -= avance+tar; // cam dir\r\n\ts -= tunnel(s);\r\n\tt -= tunnel(t);\r\n\t\r\n\tvec3 cz = normalize(t-s);\r\n\tvec3 cx = normalize(cross(cz, vec3(sin(time)*piv,1,0)));\r\n\tvec3 cy = cross(cz, cx);\r\n\r\n\tvec3 r = normalize(cx*uv.x + cy*uv.y + cz*fov);\r\n\t\r\n\t// main raymarching loop\r\n\tvec3 p = s;\r\n\tfloat dd=0.;\r\n\tfor(int i=0; i<100; ++i) {\r\n\t\tfloat d = map2(p)*0.7*dither;\r\n\t\tif(d<0.001) {break;}\r\n\t\tif(dd>100.) {dd=100.;break;}\t\t\r\n\t\tp+=r*d;\r\n\t\tdd+=d;\r\n\t}\r\n\r\n\tfloat curmat=mat;\r\n\tvec3 lop=localp;\r\n\r\n\tvec2 off=vec2(0.01,0);\r\n\tvec3 n = normalize(vec3(map2(p+off.xyy)-map2(p-off.xyy),map2(p+off.yxy)-map2(p-off.yxy),map2(p+off.yyx)-map2(p-off.yyx))-.001);\r\n\t\t\r\n\tif(scene==1){\r\n\t\tlight=normalize(vec3(-p.x,-p.y,10.*sin(time)));\r\n\t}\r\n\r\n\tfloat ao=(c0(map2(p+n*0.2)/0.2)*.5+.5) * c0(map2(p+n*0.05)/0.05);\r\n\t\r\n\tfloat deg = 1.-c0(dd/100.);\r\n\tfloat fog = c0(deg*deg);\r\n\r\n    // shadow raymarching (cheap)\r\n\tvec3 sp = p + n * 0.5 - r * 0.2;\r\n\tfor(int i=0; i<10; ++i) {\r\n\t\tfloat d=map2(sp);\r\n\t\tshad=min(shad,d);\r\n\t\tsp+=d*light*0.6*dither;\r\n\t}\r\n\t\t\t\t\r\n\tshad=c0((shad-.02)*3.);\r\n\tvec2 gg=abs(fract(lop.xy*5.)-0.5);\r\n\tfloat windows=curmat*smoothstep(0.35,0.3,max(gg.x,gg.y))*step(abs(n.y),.9)*(1.-fx);\r\n\t\t\r\n\tfloat spec=max(0.,dot(n,normalize(light-r)));\r\n\r\n\tfloat fre=pow(1.-abs(dot(n,r)),5.);\r\n\tvec3 col = (max(0., dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)\r\n        +sky(r)*pow(spec,5.)+curmat*10.*pow(spec,50.))\r\n     * (1.-windows)+(1.-windows*.4)*(fre * ao*2.+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2))\r\n        *mix(vec3(1),vec3(0.2,0.2,0.7),fx)+sky(reflect(r,n))*windows*spec*fre *10.\r\n        +atmo(p)*6.*fog*fx+sky(r) * exp((1.-fog)*3.)*0.2*pow(1.-fx,10.)+vec3(0.2,0.5,1.0)\r\n        * pow(at*0.002,2.)*5.*pow(fx,0.3);\r\n\r\n\t/*\r\n\t// maximized version\r\n\t// diffuse and spec\r\n\tcol += max(0, dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)+sky(r)*pow(spec,5)+curmat*10*pow(spec,50)) * (1-windows);\r\n\t\r\n\t// fresnel\r\n\tfloat fre=pow(1-abs(dot(n,r)),5);\r\n\tcol += (fre * ao*2+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2);\r\n\t\r\n\t// night color mood\r\n\tcol*=mix(vec3(1),vec3(0.2,0.2,0.7),fx);\r\n\r\n\t// sky reflection inside the windows\r\n\tcol += sky(reflect(r,n))*windows*spec*fre *10;\r\n\t\r\n\t// emissive from the ground during night\r\n\tcol += atmo(p)*6*fog*fx;\r\n\t\r\n\t// sky fog and atmosphere\r\n\tcol += sky(r) * exp((1-fog)*3)*0.2*pow(1-fx,10);\r\n\tcol += vec3(0.2,0.5,1.0) * pow(at*0.002,2)*5*pow(fx,0.3);\r\n\t*/\r\n\t\r\n    // \"volumetric\" for night scenes\r\n\tvec3 rp=r*muvol;\r\n\tvec3 vp=s+rp*rand;\r\n\tfor(int i=0; i<100; ++i) {\r\n\t\tif(length(vp-s)>dd) break;\r\n\t\tcol+=atmo(vp)*fx;\r\n\t\tvp+=rp;\r\n\t}\r\n\t\r\n\tvec2 vig=abs(uv)-vec2(0.5,0.2);\t\r\n\tcol = c0(pow(1.-exp(-col*pow(0.5-length(max(vec2(0),vig)),0.5)*2.5),vec3(1.8)))*c0(time/5.)*c0((12.25-section)*10.);\r\n\t/*\r\n\t// maximised version\r\n\t// filmic lol\r\n\tcol = 1-exp(-col*2.5);\r\n\tcol = c0(pow(col,vec3(2.1)));\r\n\t\r\n\t// fade in/out\r\n\tcol *= c0(time/5);\r\n\tcol *= c0((11.3-section)*10);\r\n\t*/\r\n\t\r\n\tfragColor = vec4(col, 1);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"[4kb] Night Mist - Revision 2019","id":"b42f3e257a3e4b9da5452cccf75303d6","date":null,"viewed":0,"name":"[4kb] Night Mist - Revision 2019","description":"Night Mist - by NuSan & Valden\n\n3rd place at Revision 2019 - PC 4k intro\n\nhttp://www.pouet.net/prod.php?which=81046\nhttps://youtu.be/m7IFUjf_8gg\n\nNuSan: Concept, visual, code\nValden: Music\nhttps://www.shadertoy.com/view/tlX3zB","likes":0,"published":null,"tags":["raymarching"," intro"," demoscene"," volumetric"," demo"," 4kb"]},"ver":null,"info":{"Name":"[4kb] Night Mist - Revision 2019","id":"b42f3e257a3e4b9da5452cccf75303d6","date":null,"viewed":0,"name":"[4kb] Night Mist - Revision 2019","description":"Night Mist - by NuSan & Valden\n\n3rd place at Revision 2019 - PC 4k intro\n\nhttp://www.pouet.net/prod.php?which=81046\nhttps://youtu.be/m7IFUjf_8gg\n\nNuSan: Concept, visual, code\nValden: Music\nhttps://www.shadertoy.com/view/tlX3zB","likes":0,"published":null,"tags":["raymarching"," intro"," demoscene"," volumetric"," demo"," 4kb"]},"renderpass":[{"Code":"/*\r\n----- Night Mist ------\r\n-- by NuSan & Valden --\r\n    \r\n3rd place at Revision 2019 - PC 4k intro\r\n\r\nhttp://www.pouet.net/prod.php?which=81046\r\nhttps://youtu.be/m7IFUjf_8gg\r\n\r\nNuSan: Concept, visual, code\r\nValden: Music\r\n\r\nOriginal tools: Leviathan 2.0 by Armak, 4klang by Alcatraz, Shader Minifier by LLB\r\n*/\r\n\r\n#define time iTime\r\n#define bpm (time*1.5)\r\n#define section (bpm/16.)\r\nint section2 = 0;\r\nfloat pi = acos(float(-1));\r\n\r\nfloat box(vec3 p,vec3 s) {p=abs(p)-s;return max(p.x,max(p.y,p.z));}\r\nfloat cyl(vec3 p,float s, float h) {return max(length(p.xz)-s,abs(p.y)-h);}\r\nfloat smin(float a,float b,float h) {float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;}\r\n\r\n#define rep(a,s) (fract((a)/s+.5)-.5)*s\r\n#define repa(a,s) abs(fract((a)/s+.5)-.5)*s\r\n#define repc(a,s) (smoothstep(0,1,abs(frac//(a)/s+.5)-.5)*2)*s*0.5)\r\n#define c0(a) clamp(a,0.,1.)\r\n\r\nmat2 rot(float a) {\tfloat ca=cos(a),sa=sin(a); return mat2(ca,sa,-sa,ca);}\r\n\r\nfloat noi2(vec2 p) {\r\n  vec2 ip=floor(p);\r\n  p=smoothstep(0.0,1.0,fract(p));\r\n  vec4 v=fract(sin(dot(ip,vec2(7,137))+vec4(0,7,137,144))*8986.352);\r\n  vec2 v2=mix(v.xz,v.yw,p.x);\r\n  return mix(v2.x,v2.y,p.y);\r\n}\r\n\r\nint scene=0;\r\nfloat mont=0.;\r\nfloat decal=0.;\r\nfloat anim=0.;\r\n\r\n// shift the world on x/y axis according to z axis value\r\nvec3 tunnel(vec3 p) {\r\n  vec3 o=vec3(0);\r\n  if(scene==1) {\r\n  \to.x+=sin(p.z*0.05)*6.;\r\n  \to.x+=sin(p.z*0.15)*3.;\r\n  \to.y+=sin(p.z*0.07)*7.;\r\n  }\r\n  return o;\r\n}\r\n\r\n// morph the world into plane, cylinder or sphere\r\nvec3 morph(vec3 p) {\r\n\r\n\tp+=tunnel(p);\r\n\tvec3 rop=p; // plane\r\n\t\r\n\t// cylinder\r\n\tif(scene==1) rop=vec3(atan(p.y,p.x)*5., length(p.xy)-10., p.z*0.5);\r\n\r\n\tif(scene==3) {\r\n\t\t// sphere\r\n\t\trop = vec3(abs(atan(p.z,p.x))*10.-5., (10.-length(p)), abs(atan(length(p.xz),p.y))*10.-16.);\r\n\t}\r\n\t\r\n\treturn rop;\r\n}\r\n\r\n// kaleidoscopic folding for the city\r\nvec3 kalei(vec3 p, inout vec2 ad) {\r\n\t\r\n\tfloat s=10.+fract(section*4.)*anim;\r\n\tfor(int i=0;i<5;++i) {\r\n\t\tp.xz *= rot(float(i)+12.7);\r\n\t\tfloat freq=100.0;\r\n\t\tad.x+=sign(p.x)*sign(p.z)*(float(i)*0.72+.2);\r\n\t\tad.y=min(ad.y,min(abs(p.x),abs(p.z)));\r\n\t\tp.xz = repa(p.xz,freq);\r\n\t\tp.xz -=s;\r\n\t\ts*=0.5;\r\n\t}\t\r\n\t// change scene\r\n\tp.x += decal;\r\n\treturn p;\r\n}\r\n\r\nfloat at=0.;\r\nfloat mat=0.;\r\nvec3 localp;\r\n// give signed distance field at position p\r\nfloat map2(vec3 p) {\r\n\tp=morph(p); // morph the world into plane, cylinder or sphere\r\n\r\n\tvec3 bp=p;\r\n\tvec2 uv=p.xz;\r\n\r\n\tvec2 off=sin(p.xz*vec2(0.2,0.35)*10.+sin(p.y*10.));\r\n\t\r\n\tvec2 ad=vec2(0);\r\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\r\n\t\r\n\tfloat d=box(p, vec3(0.4));\r\n\t\r\n\tat+=1./(d+0.1);\r\n\r\n\tfloat city=min( min( box(p-vec3(0,0,0.5), vec3(0.55)) , box(p-vec3(0.5,0,-0.3), vec3(0.2,2,0.2))) , cyl(p-vec3(1.0,0,0),0.3,3.) );\r\n\r\n\td=min(d,city);\r\n\tlocalp=p;\r\n\r\n\tvec3 rp=p;\r\n\trp.xz=rep(rp.xz,0.5);\r\n\trp.xz+=off*0.05;\r\n\t// fields\r\n\tfloat blob=box(p-vec3(3,0,0), vec3(1.6));\r\n\td=min(d,min(max(smin(cyl(rp,0.1,9.),-5.-p.y,-5.),blob), max(abs(blob-0.2)-0.05,-.7-p.y)));\r\n\t\r\n\tvec3 ap=abs(abs(p+vec3(-2,1.2,0))-vec3(4,0.6,1.2));\r\n\td=min(d,max(box(ap,vec3(.7)), box(0.7-max(ap,ap.yzx),vec3(0.2)))); // grid\r\n\t\t\t\r\n\t\t\t\r\n\t// terrain/mountain\r\n\td=smin(min(d,(noi2(uv*0.1)*5.+noi2(uv*0.2)*3. + pow(abs(noi2(uv)*0.2+noi2(uv*2.)*0.1+noi2(uv*4.)*0.05-0.5),5.)*10.-4.-bp.y+mont)*.9), -bp.y, 0.2); // Combine terrain\r\n\t\t\t\r\n\tmat=abs(d-city)<0.01?1.:0.;\r\n\r\n\td=max(d,0.00001); // anti glitch? avoid some nan/inf values\r\n\t\r\n\treturn d;\r\n}\r\n\r\nfloat rnd1(float t) {\r\n  return fract(sin(t*478.556)*8522.412);\r\n}\r\n\r\nfloat rnd2(vec2 t) {\r\n  return fract(dot(sin(t*741.145 + t.yx*422.988), vec2(7789.532)));\r\n}\r\n\r\n// give volumetric amount at position p\r\nfloat atspeed=1.;\r\nfloat gridsize=5.;\r\nvec3 atmo(vec3 p) {\r\n\tvec3 bp=p;\r\n\tp=morph(p); // morph the world into plane, cylinder or sphere\r\n\tvec2 ad=vec2(0,10);\r\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\r\n\t\r\n\tvec3 col=vec3(0);\r\n\r\n\tvec3 back=vec3(0.5,0.2,1.0);\r\n\tback.xy*=rot(ad.x);\r\n\tback=abs(back);\r\n\tfloat fade=c0((p.y+8.)*0.03);\r\n\tfloat ff=rnd2(floor(p.xz*gridsize));\r\n\tfloat pulse=0.7;//fract(bpm*0.25);\r\n\tcol += ff*back*5.0*smoothstep(0.1,0.2,ad.y)*pow(smoothstep(0.9*pulse,1.0*pulse,sin(rnd1(ad.x)*1.7*pi+bpm*pi*atspeed) ),10.)*fade*fade;\r\n\t\r\n\treturn col;\r\n}\r\n\r\nvec3 sky(vec3 r) {\r\n\treturn mix(vec3(0.2,0.5,1.0), vec3(2.0,1.1,0.6), smoothstep(0.2,1.,-r.z));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\r\n    uv -= 0.5;\r\n    uv /= vec2(iResolution.y / iResolution.x, 1);\r\n    \r\n    section2 = int(section);\r\n    \r\n\tfloat fov=.4;\r\n\tfloat shad = 1.;\r\n\t\r\n    // change scenes according time\r\n\tif(section2>3 && section<4.) anim=30.;\r\n\tmont=(section2>1 && section2<10)?100.:0.;\r\n\tif(section2>5 && section<8.) { decal=4.-floor((section-5.)*4.)*.5; fov=rnd1(floor(bpm))+.2;}\r\n\tif(section2>3&&section2<8) scene=1;\r\n\tif(section2>9) {scene=3;atspeed=2.;}\r\n\r\n\tfloat fx=c0((2.-abs(section-4.1))*4.)+c0((1.-abs(section-10.))*4.); // night\r\n\t\r\n\tvec3 s = vec3(0,-2,-10); // distance cam\r\n\tvec3 light = normalize(-vec3(1,2.5,3)); // light height\r\n\t\t\r\n\tvec3 t = vec3(0.3,0.5,0);\r\n\r\n    // camera setting by scenes\r\n\tfloat div=1.;\r\n\tfloat camoff= section2>9 ? 0. : (rnd1(floor(section*div)));\r\n\r\n\tfloat mav=time*0.5+camoff*50.;\r\n\tfloat piv=.2;\r\n\tfloat az=0.7;\r\n\tif(scene==0) {\r\n\t\ts.y=camoff*(section2>6?12.5:14.);\r\n\t}\r\n\tif(scene==1) {\r\n\t\ts.z=6.;\r\n\t\taz=2.3*sin(section*5.);\r\n\t\tmav=10.;\r\n\t}\r\n\tif(scene==3) {\r\n\t\taz=0.2;\r\n\t\ts.z=20.;\r\n\t\tt=vec3(0,0,10);\r\n\t\tmav=min((section-11.55)*6.,(section-12.15)*3.);\r\n\t\tmav*=c0(-mav);\r\n\t\tpiv*=c0(-mav);\r\n\t\tmav+=3.5;\r\n\t}\r\n\tfloat muvol=.2;\r\n\tif(section2>8&&section2<10) {muvol=.6;s.z=-30.;anim=30.;az=1.3;atspeed=2.;gridsize=1.;}\r\n\r\n\tfloat rand = rnd2(uv);\r\n\tfloat dither=0.9+0.1*rand;\r\n\t\r\n\ts.yz*=rot(az);\r\n\ts.xz *= rot(mav);\r\n\r\n\tif(scene==0) {\r\n\t\ts.z-=max(20.-time,0.)*3.;\r\n\t}\r\n\t\r\n\tfloat avance=0.;\r\n\tfloat tar=10.;\r\n\tif(scene==1) {\r\n\t\tavance=fract(section)*80.-40.; // traveling\r\n\t\ttar*=float(1-section2%2*2)*10.;//+(section>7.25?1:0)*7;\r\n\t}\r\n\ts.z -= avance;\r\n\tt.z -= avance+tar; // cam dir\r\n\ts -= tunnel(s);\r\n\tt -= tunnel(t);\r\n\t\r\n\tvec3 cz = normalize(t-s);\r\n\tvec3 cx = normalize(cross(cz, vec3(sin(time)*piv,1,0)));\r\n\tvec3 cy = cross(cz, cx);\r\n\r\n\tvec3 r = normalize(cx*uv.x + cy*uv.y + cz*fov);\r\n\t\r\n\t// main raymarching loop\r\n\tvec3 p = s;\r\n\tfloat dd=0.;\r\n\tfor(int i=0; i<100; ++i) {\r\n\t\tfloat d = map2(p)*0.7*dither;\r\n\t\tif(d<0.001) {break;}\r\n\t\tif(dd>100.) {dd=100.;break;}\t\t\r\n\t\tp+=r*d;\r\n\t\tdd+=d;\r\n\t}\r\n\r\n\tfloat curmat=mat;\r\n\tvec3 lop=localp;\r\n\r\n\tvec2 off=vec2(0.01,0);\r\n\tvec3 n = normalize(vec3(map2(p+off.xyy)-map2(p-off.xyy),map2(p+off.yxy)-map2(p-off.yxy),map2(p+off.yyx)-map2(p-off.yyx))-.001);\r\n\t\t\r\n\tif(scene==1){\r\n\t\tlight=normalize(vec3(-p.x,-p.y,10.*sin(time)));\r\n\t}\r\n\r\n\tfloat ao=(c0(map2(p+n*0.2)/0.2)*.5+.5) * c0(map2(p+n*0.05)/0.05);\r\n\t\r\n\tfloat deg = 1.-c0(dd/100.);\r\n\tfloat fog = c0(deg*deg);\r\n\r\n    // shadow raymarching (cheap)\r\n\tvec3 sp = p + n * 0.5 - r * 0.2;\r\n\tfor(int i=0; i<10; ++i) {\r\n\t\tfloat d=map2(sp);\r\n\t\tshad=min(shad,d);\r\n\t\tsp+=d*light*0.6*dither;\r\n\t}\r\n\t\t\t\t\r\n\tshad=c0((shad-.02)*3.);\r\n\tvec2 gg=abs(fract(lop.xy*5.)-0.5);\r\n\tfloat windows=curmat*smoothstep(0.35,0.3,max(gg.x,gg.y))*step(abs(n.y),.9)*(1.-fx);\r\n\t\t\r\n\tfloat spec=max(0.,dot(n,normalize(light-r)));\r\n\r\n\tfloat fre=pow(1.-abs(dot(n,r)),5.);\r\n\tvec3 col = (max(0., dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)\r\n        +sky(r)*pow(spec,5.)+curmat*10.*pow(spec,50.))\r\n     * (1.-windows)+(1.-windows*.4)*(fre * ao*2.+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2))\r\n        *mix(vec3(1),vec3(0.2,0.2,0.7),fx)+sky(reflect(r,n))*windows*spec*fre *10.\r\n        +atmo(p)*6.*fog*fx+sky(r) * exp((1.-fog)*3.)*0.2*pow(1.-fx,10.)+vec3(0.2,0.5,1.0)\r\n        * pow(at*0.002,2.)*5.*pow(fx,0.3);\r\n\r\n\t/*\r\n\t// maximized version\r\n\t// diffuse and spec\r\n\tcol += max(0, dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)+sky(r)*pow(spec,5)+curmat*10*pow(spec,50)) * (1-windows);\r\n\t\r\n\t// fresnel\r\n\tfloat fre=pow(1-abs(dot(n,r)),5);\r\n\tcol += (fre * ao*2+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2);\r\n\t\r\n\t// night color mood\r\n\tcol*=mix(vec3(1),vec3(0.2,0.2,0.7),fx);\r\n\r\n\t// sky reflection inside the windows\r\n\tcol += sky(reflect(r,n))*windows*spec*fre *10;\r\n\t\r\n\t// emissive from the ground during night\r\n\tcol += atmo(p)*6*fog*fx;\r\n\t\r\n\t// sky fog and atmosphere\r\n\tcol += sky(r) * exp((1-fog)*3)*0.2*pow(1-fx,10);\r\n\tcol += vec3(0.2,0.5,1.0) * pow(at*0.002,2)*5*pow(fx,0.3);\r\n\t*/\r\n\t\r\n    // \"volumetric\" for night scenes\r\n\tvec3 rp=r*muvol;\r\n\tvec3 vp=s+rp*rand;\r\n\tfor(int i=0; i<100; ++i) {\r\n\t\tif(length(vp-s)>dd) break;\r\n\t\tcol+=atmo(vp)*fx;\r\n\t\tvp+=rp;\r\n\t}\r\n\t\r\n\tvec2 vig=abs(uv)-vec2(0.5,0.2);\t\r\n\tcol = c0(pow(1.-exp(-col*pow(0.5-length(max(vec2(0),vig)),0.5)*2.5),vec3(1.8)))*c0(time/5.)*c0((12.25-section)*10.);\r\n\t/*\r\n\t// maximised version\r\n\t// filmic lol\r\n\tcol = 1-exp(-col*2.5);\r\n\tcol = c0(pow(col,vec3(2.1)));\r\n\t\r\n\t// fade in/out\r\n\tcol *= c0(time/5);\r\n\tcol *= c0((11.3-section)*10);\r\n\t*/\r\n\t\r\n\tfragColor = vec4(col, 1);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n----- Night Mist ------\r\n-- by NuSan & Valden --\r\n    \r\n3rd place at Revision 2019 - PC 4k intro\r\n\r\nhttp://www.pouet.net/prod.php?which=81046\r\nhttps://youtu.be/m7IFUjf_8gg\r\n\r\nNuSan: Concept, visual, code\r\nValden: Music\r\n\r\nOriginal tools: Leviathan 2.0 by Armak, 4klang by Alcatraz, Shader Minifier by LLB\r\n*/\r\n\r\n#define time iTime\r\n#define bpm (time*1.5)\r\n#define section (bpm/16.)\r\nint section2 = 0;\r\nfloat pi = acos(float(-1));\r\n\r\nfloat box(vec3 p,vec3 s) {p=abs(p)-s;return max(p.x,max(p.y,p.z));}\r\nfloat cyl(vec3 p,float s, float h) {return max(length(p.xz)-s,abs(p.y)-h);}\r\nfloat smin(float a,float b,float h) {float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;}\r\n\r\n#define rep(a,s) (fract((a)/s+.5)-.5)*s\r\n#define repa(a,s) abs(fract((a)/s+.5)-.5)*s\r\n#define repc(a,s) (smoothstep(0,1,abs(frac//(a)/s+.5)-.5)*2)*s*0.5)\r\n#define c0(a) clamp(a,0.,1.)\r\n\r\nmat2 rot(float a) {\tfloat ca=cos(a),sa=sin(a); return mat2(ca,sa,-sa,ca);}\r\n\r\nfloat noi2(vec2 p) {\r\n  vec2 ip=floor(p);\r\n  p=smoothstep(0.0,1.0,fract(p));\r\n  vec4 v=fract(sin(dot(ip,vec2(7,137))+vec4(0,7,137,144))*8986.352);\r\n  vec2 v2=mix(v.xz,v.yw,p.x);\r\n  return mix(v2.x,v2.y,p.y);\r\n}\r\n\r\nint scene=0;\r\nfloat mont=0.;\r\nfloat decal=0.;\r\nfloat anim=0.;\r\n\r\n// shift the world on x/y axis according to z axis value\r\nvec3 tunnel(vec3 p) {\r\n  vec3 o=vec3(0);\r\n  if(scene==1) {\r\n  \to.x+=sin(p.z*0.05)*6.;\r\n  \to.x+=sin(p.z*0.15)*3.;\r\n  \to.y+=sin(p.z*0.07)*7.;\r\n  }\r\n  return o;\r\n}\r\n\r\n// morph the world into plane, cylinder or sphere\r\nvec3 morph(vec3 p) {\r\n\r\n\tp+=tunnel(p);\r\n\tvec3 rop=p; // plane\r\n\t\r\n\t// cylinder\r\n\tif(scene==1) rop=vec3(atan(p.y,p.x)*5., length(p.xy)-10., p.z*0.5);\r\n\r\n\tif(scene==3) {\r\n\t\t// sphere\r\n\t\trop = vec3(abs(atan(p.z,p.x))*10.-5., (10.-length(p)), abs(atan(length(p.xz),p.y))*10.-16.);\r\n\t}\r\n\t\r\n\treturn rop;\r\n}\r\n\r\n// kaleidoscopic folding for the city\r\nvec3 kalei(vec3 p, inout vec2 ad) {\r\n\t\r\n\tfloat s=10.+fract(section*4.)*anim;\r\n\tfor(int i=0;i<5;++i) {\r\n\t\tp.xz *= rot(float(i)+12.7);\r\n\t\tfloat freq=100.0;\r\n\t\tad.x+=sign(p.x)*sign(p.z)*(float(i)*0.72+.2);\r\n\t\tad.y=min(ad.y,min(abs(p.x),abs(p.z)));\r\n\t\tp.xz = repa(p.xz,freq);\r\n\t\tp.xz -=s;\r\n\t\ts*=0.5;\r\n\t}\t\r\n\t// change scene\r\n\tp.x += decal;\r\n\treturn p;\r\n}\r\n\r\nfloat at=0.;\r\nfloat mat=0.;\r\nvec3 localp;\r\n// give signed distance field at position p\r\nfloat map2(vec3 p) {\r\n\tp=morph(p); // morph the world into plane, cylinder or sphere\r\n\r\n\tvec3 bp=p;\r\n\tvec2 uv=p.xz;\r\n\r\n\tvec2 off=sin(p.xz*vec2(0.2,0.35)*10.+sin(p.y*10.));\r\n\t\r\n\tvec2 ad=vec2(0);\r\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\r\n\t\r\n\tfloat d=box(p, vec3(0.4));\r\n\t\r\n\tat+=1./(d+0.1);\r\n\r\n\tfloat city=min( min( box(p-vec3(0,0,0.5), vec3(0.55)) , box(p-vec3(0.5,0,-0.3), vec3(0.2,2,0.2))) , cyl(p-vec3(1.0,0,0),0.3,3.) );\r\n\r\n\td=min(d,city);\r\n\tlocalp=p;\r\n\r\n\tvec3 rp=p;\r\n\trp.xz=rep(rp.xz,0.5);\r\n\trp.xz+=off*0.05;\r\n\t// fields\r\n\tfloat blob=box(p-vec3(3,0,0), vec3(1.6));\r\n\td=min(d,min(max(smin(cyl(rp,0.1,9.),-5.-p.y,-5.),blob), max(abs(blob-0.2)-0.05,-.7-p.y)));\r\n\t\r\n\tvec3 ap=abs(abs(p+vec3(-2,1.2,0))-vec3(4,0.6,1.2));\r\n\td=min(d,max(box(ap,vec3(.7)), box(0.7-max(ap,ap.yzx),vec3(0.2)))); // grid\r\n\t\t\t\r\n\t\t\t\r\n\t// terrain/mountain\r\n\td=smin(min(d,(noi2(uv*0.1)*5.+noi2(uv*0.2)*3. + pow(abs(noi2(uv)*0.2+noi2(uv*2.)*0.1+noi2(uv*4.)*0.05-0.5),5.)*10.-4.-bp.y+mont)*.9), -bp.y, 0.2); // Combine terrain\r\n\t\t\t\r\n\tmat=abs(d-city)<0.01?1.:0.;\r\n\r\n\td=max(d,0.00001); // anti glitch? avoid some nan/inf values\r\n\t\r\n\treturn d;\r\n}\r\n\r\nfloat rnd1(float t) {\r\n  return fract(sin(t*478.556)*8522.412);\r\n}\r\n\r\nfloat rnd2(vec2 t) {\r\n  return fract(dot(sin(t*741.145 + t.yx*422.988), vec2(7789.532)));\r\n}\r\n\r\n// give volumetric amount at position p\r\nfloat atspeed=1.;\r\nfloat gridsize=5.;\r\nvec3 atmo(vec3 p) {\r\n\tvec3 bp=p;\r\n\tp=morph(p); // morph the world into plane, cylinder or sphere\r\n\tvec2 ad=vec2(0,10);\r\n\tp=kalei(p,ad); // kaleidoscopic folding for the city\r\n\t\r\n\tvec3 col=vec3(0);\r\n\r\n\tvec3 back=vec3(0.5,0.2,1.0);\r\n\tback.xy*=rot(ad.x);\r\n\tback=abs(back);\r\n\tfloat fade=c0((p.y+8.)*0.03);\r\n\tfloat ff=rnd2(floor(p.xz*gridsize));\r\n\tfloat pulse=0.7;//fract(bpm*0.25);\r\n\tcol += ff*back*5.0*smoothstep(0.1,0.2,ad.y)*pow(smoothstep(0.9*pulse,1.0*pulse,sin(rnd1(ad.x)*1.7*pi+bpm*pi*atspeed) ),10.)*fade*fade;\r\n\t\r\n\treturn col;\r\n}\r\n\r\nvec3 sky(vec3 r) {\r\n\treturn mix(vec3(0.2,0.5,1.0), vec3(2.0,1.1,0.6), smoothstep(0.2,1.,-r.z));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\r\n    uv -= 0.5;\r\n    uv /= vec2(iResolution.y / iResolution.x, 1);\r\n    \r\n    section2 = int(section);\r\n    \r\n\tfloat fov=.4;\r\n\tfloat shad = 1.;\r\n\t\r\n    // change scenes according time\r\n\tif(section2>3 && section<4.) anim=30.;\r\n\tmont=(section2>1 && section2<10)?100.:0.;\r\n\tif(section2>5 && section<8.) { decal=4.-floor((section-5.)*4.)*.5; fov=rnd1(floor(bpm))+.2;}\r\n\tif(section2>3&&section2<8) scene=1;\r\n\tif(section2>9) {scene=3;atspeed=2.;}\r\n\r\n\tfloat fx=c0((2.-abs(section-4.1))*4.)+c0((1.-abs(section-10.))*4.); // night\r\n\t\r\n\tvec3 s = vec3(0,-2,-10); // distance cam\r\n\tvec3 light = normalize(-vec3(1,2.5,3)); // light height\r\n\t\t\r\n\tvec3 t = vec3(0.3,0.5,0);\r\n\r\n    // camera setting by scenes\r\n\tfloat div=1.;\r\n\tfloat camoff= section2>9 ? 0. : (rnd1(floor(section*div)));\r\n\r\n\tfloat mav=time*0.5+camoff*50.;\r\n\tfloat piv=.2;\r\n\tfloat az=0.7;\r\n\tif(scene==0) {\r\n\t\ts.y=camoff*(section2>6?12.5:14.);\r\n\t}\r\n\tif(scene==1) {\r\n\t\ts.z=6.;\r\n\t\taz=2.3*sin(section*5.);\r\n\t\tmav=10.;\r\n\t}\r\n\tif(scene==3) {\r\n\t\taz=0.2;\r\n\t\ts.z=20.;\r\n\t\tt=vec3(0,0,10);\r\n\t\tmav=min((section-11.55)*6.,(section-12.15)*3.);\r\n\t\tmav*=c0(-mav);\r\n\t\tpiv*=c0(-mav);\r\n\t\tmav+=3.5;\r\n\t}\r\n\tfloat muvol=.2;\r\n\tif(section2>8&&section2<10) {muvol=.6;s.z=-30.;anim=30.;az=1.3;atspeed=2.;gridsize=1.;}\r\n\r\n\tfloat rand = rnd2(uv);\r\n\tfloat dither=0.9+0.1*rand;\r\n\t\r\n\ts.yz*=rot(az);\r\n\ts.xz *= rot(mav);\r\n\r\n\tif(scene==0) {\r\n\t\ts.z-=max(20.-time,0.)*3.;\r\n\t}\r\n\t\r\n\tfloat avance=0.;\r\n\tfloat tar=10.;\r\n\tif(scene==1) {\r\n\t\tavance=fract(section)*80.-40.; // traveling\r\n\t\ttar*=float(1-section2%2*2)*10.;//+(section>7.25?1:0)*7;\r\n\t}\r\n\ts.z -= avance;\r\n\tt.z -= avance+tar; // cam dir\r\n\ts -= tunnel(s);\r\n\tt -= tunnel(t);\r\n\t\r\n\tvec3 cz = normalize(t-s);\r\n\tvec3 cx = normalize(cross(cz, vec3(sin(time)*piv,1,0)));\r\n\tvec3 cy = cross(cz, cx);\r\n\r\n\tvec3 r = normalize(cx*uv.x + cy*uv.y + cz*fov);\r\n\t\r\n\t// main raymarching loop\r\n\tvec3 p = s;\r\n\tfloat dd=0.;\r\n\tfor(int i=0; i<100; ++i) {\r\n\t\tfloat d = map2(p)*0.7*dither;\r\n\t\tif(d<0.001) {break;}\r\n\t\tif(dd>100.) {dd=100.;break;}\t\t\r\n\t\tp+=r*d;\r\n\t\tdd+=d;\r\n\t}\r\n\r\n\tfloat curmat=mat;\r\n\tvec3 lop=localp;\r\n\r\n\tvec2 off=vec2(0.01,0);\r\n\tvec3 n = normalize(vec3(map2(p+off.xyy)-map2(p-off.xyy),map2(p+off.yxy)-map2(p-off.yxy),map2(p+off.yyx)-map2(p-off.yyx))-.001);\r\n\t\t\r\n\tif(scene==1){\r\n\t\tlight=normalize(vec3(-p.x,-p.y,10.*sin(time)));\r\n\t}\r\n\r\n\tfloat ao=(c0(map2(p+n*0.2)/0.2)*.5+.5) * c0(map2(p+n*0.05)/0.05);\r\n\t\r\n\tfloat deg = 1.-c0(dd/100.);\r\n\tfloat fog = c0(deg*deg);\r\n\r\n    // shadow raymarching (cheap)\r\n\tvec3 sp = p + n * 0.5 - r * 0.2;\r\n\tfor(int i=0; i<10; ++i) {\r\n\t\tfloat d=map2(sp);\r\n\t\tshad=min(shad,d);\r\n\t\tsp+=d*light*0.6*dither;\r\n\t}\r\n\t\t\t\t\r\n\tshad=c0((shad-.02)*3.);\r\n\tvec2 gg=abs(fract(lop.xy*5.)-0.5);\r\n\tfloat windows=curmat*smoothstep(0.35,0.3,max(gg.x,gg.y))*step(abs(n.y),.9)*(1.-fx);\r\n\t\t\r\n\tfloat spec=max(0.,dot(n,normalize(light-r)));\r\n\r\n\tfloat fre=pow(1.-abs(dot(n,r)),5.);\r\n\tvec3 col = (max(0., dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)\r\n        +sky(r)*pow(spec,5.)+curmat*10.*pow(spec,50.))\r\n     * (1.-windows)+(1.-windows*.4)*(fre * ao*2.+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2))\r\n        *mix(vec3(1),vec3(0.2,0.2,0.7),fx)+sky(reflect(r,n))*windows*spec*fre *10.\r\n        +atmo(p)*6.*fog*fx+sky(r) * exp((1.-fog)*3.)*0.2*pow(1.-fx,10.)+vec3(0.2,0.5,1.0)\r\n        * pow(at*0.002,2.)*5.*pow(fx,0.3);\r\n\r\n\t/*\r\n\t// maximized version\r\n\t// diffuse and spec\r\n\tcol += max(0, dot(n,light)) * fog*ao * shad * (vec3(2.0,1.1,0.6)+sky(r)*pow(spec,5)+curmat*10*pow(spec,50)) * (1-windows);\r\n\t\r\n\t// fresnel\r\n\tfloat fre=pow(1-abs(dot(n,r)),5);\r\n\tcol += (fre * ao*2+0.3)*fog*(-n.y*.5+.5)*(curmat*0.7+.2);\r\n\t\r\n\t// night color mood\r\n\tcol*=mix(vec3(1),vec3(0.2,0.2,0.7),fx);\r\n\r\n\t// sky reflection inside the windows\r\n\tcol += sky(reflect(r,n))*windows*spec*fre *10;\r\n\t\r\n\t// emissive from the ground during night\r\n\tcol += atmo(p)*6*fog*fx;\r\n\t\r\n\t// sky fog and atmosphere\r\n\tcol += sky(r) * exp((1-fog)*3)*0.2*pow(1-fx,10);\r\n\tcol += vec3(0.2,0.5,1.0) * pow(at*0.002,2)*5*pow(fx,0.3);\r\n\t*/\r\n\t\r\n    // \"volumetric\" for night scenes\r\n\tvec3 rp=r*muvol;\r\n\tvec3 vp=s+rp*rand;\r\n\tfor(int i=0; i<100; ++i) {\r\n\t\tif(length(vp-s)>dd) break;\r\n\t\tcol+=atmo(vp)*fx;\r\n\t\tvp+=rp;\r\n\t}\r\n\t\r\n\tvec2 vig=abs(uv)-vec2(0.5,0.2);\t\r\n\tcol = c0(pow(1.-exp(-col*pow(0.5-length(max(vec2(0),vig)),0.5)*2.5),vec3(1.8)))*c0(time/5.)*c0((12.25-section)*10.);\r\n\t/*\r\n\t// maximised version\r\n\t// filmic lol\r\n\tcol = 1-exp(-col*2.5);\r\n\tcol = c0(pow(col,vec3(2.1)));\r\n\t\r\n\t// fade in/out\r\n\tcol *= c0(time/5);\r\n\tcol *= c0((11.3-section)*10);\r\n\t*/\r\n\t\r\n\tfragColor = vec4(col, 1);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Interesting findings from original NES Super Mario Bros.:\r\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\r\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\r\n// -Overworld (main theme) drum sound uses only the APU noise generator\r\n\r\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\r\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\r\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\r\n\r\nconst float MARIO_SPEED\t = 89.0;\r\nconst float GOOMBA_SPEED = 32.0;\r\nconst float INTRO_LENGTH = 2.0;\r\n\r\nvoid SpriteBlock( inout vec3 color, float x, float y )\r\n{\r\n    // black\r\n    float idx = 1.0;\r\n    \r\n    // light orange\r\n    idx = x < y ? 3.0 : idx;\r\n    \r\n    // dark orange\r\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\r\n    idx = x == 15.0 - y ? 2.0 : idx;\r\n    \r\n    color = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteHill( inout vec3 color, float x, float y )\r\n{\r\n    float idx = 0.0;\r\n    \r\n    // dark green\r\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\r\n    \r\n    // black\r\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\r\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\r\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\r\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\r\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n}\r\n\r\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\r\n{\r\n    float offset = h * 16.0;\r\n\r\n    // light green\r\n\tfloat idx = 3.0;\r\n    \r\n    // dark green\r\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\r\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \r\n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\r\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \r\n    \r\n    // black\r\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\r\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\r\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \r\n    \r\n    // transparent\r\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\r\n{\r\n\tfloat idx = 0.0;\r\n    \r\n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\r\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\r\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\r\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\r\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\r\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\r\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\r\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\r\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\r\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\r\n\tcolor = idx == 2.0 ? colorB \t\t: color;\r\n\tcolor = idx == 3.0 ? colorC \t\t: color;\r\n}\r\n\r\nvoid SpriteFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? 43690.0 : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\r\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\r\n{\r\n\tfloat idx = 0.0;\r\n\r\n    // second frame is flipped first frame\r\n    x = frame == 1.0 ? 15.0 - x : x;\r\n\r\n    if ( frame <= 1.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\r\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\r\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\r\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\r\n        idx = y ==  6.0 ? 43690.0 : idx;\r\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\r\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\r\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\r\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\r\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\r\n\t\tidx = y == 3.0 ? 43690.0 : idx;\r\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\r\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\r\n}\r\n\r\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\r\n{    \r\n\tfloat idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\r\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\r\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\r\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\r\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\r\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\r\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\r\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\r\n    }\r\n\telse\r\n\t{\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\r\n\t}\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 0.0 ? 21845.0 : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\r\n}\r\n\r\nvoid SpriteMushroom( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\r\n\tidx = y == 5.0 ? 43690.0 : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGround( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\r\n\tidx = y == 7.0 ? 1360.0  : idx;\r\n\tidx = y == 6.0 ? 6836.0  : idx;\r\n\tidx = y == 5.0 ? 27309.0 : idx;\r\n\tidx = y == 4.0 ? 27309.0 : idx;\r\n\tidx = y == 3.0 ? 27305.0 : idx;\r\n\tidx = y == 2.0 ? 27305.0 : idx;\r\n\tidx = y == 1.0 ? 6820.0  : idx;\r\n\tidx = y == 0.0 ? 1360.0  : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 3.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 4.0 )\r\n    {\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\r\n    }\r\n    else if ( frame == 5.0 )\r\n    {\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\r\n    }\r\n    else if ( frame == 6.0 )\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \r\n}\r\n\r\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n    }\r\n    \r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteBrick( inout vec3 color, float x, float y )\r\n{    \r\n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \r\n    float xmod8 = floor( mod( x, 8.0 ) );\r\n    float ymod8 = floor( mod( y, 8.0 ) );\r\n    \r\n    // dark orange\r\n    float idx = 2.0;\r\n   \r\n    // black\r\n    idx = ymod4 == 0.0 ? 1.0 : idx;\r\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\r\n\r\n    // light orange\r\n    idx = y == 15.0 ? 3.0 : idx;\r\n\r\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid DrawCastle( inout vec3 color, float x, float y )\r\n{\r\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\r\n\t{\r\n\t\tfloat ymod4    = mod( y, 4.0 );\r\n\t\tfloat xmod8    = mod( x, 8.0 );\r\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\r\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\r\n\t\tfloat ymod8    = mod( y, 8.0 );\r\n\r\n\t\t// dark orange\r\n\t\tfloat idx = 2.0;\r\n\r\n\t\t// black\r\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\r\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\r\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \r\n\r\n\t\t// white\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\r\n\r\n\t\t// transparent\r\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\r\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\r\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \r\n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\r\n\r\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\r\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n\t}\r\n}\r\n\r\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\r\n{\r\n    if ( x >= 0.0 && x <= 15.0 )\r\n    {\r\n        SpriteKoopa( color, x, y, frame );\r\n    }\r\n}\r\n\r\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\r\n{\r\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\r\n    DrawKoopa( color, x, worldY - 16.0, frame );    \r\n}\r\n\r\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\r\n{\r\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\r\n    t = 1.0 - abs( 2.0 * t - 1.0 );\r\n\r\n    questionY -= floor( t * 8.0 );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {            \r\n    \tif ( time >= questionHitTime )\r\n        {                \r\n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\r\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n            {\r\n                color = RGB( 231, 90, 16 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n         \tSpriteQuestion( color, questionX, questionY, questionT );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawW( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 || x >= 10.0 ) \r\n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawO( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\r\n             || ( x >= 2.0 && x <= 4.0 )\r\n             || ( x >= 9.0 && x <= 11.0 )\r\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawR( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 )\r\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\r\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\r\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\r\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\r\n             || ( x >= 8.0  && y <= 1.0 )\r\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawL( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( x <= 3.0 || y <= 1.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawD( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n    \tcolor = RGB( 255, 255, 255 );        \r\n        \r\n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \r\n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \r\n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\r\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\r\n           )\r\n        {\r\n            color = RGB( 0, 0, 0 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid Draw1( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( y <= 1.0 )\r\n             || ( x >= 5.0 && x <= 8.0 )\r\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawM( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( y >= 4.0 && y <= 7.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\r\n{\r\n    color = RGB( 0, 0, 0 );\r\n        \r\n    float offset \t= 18.0;     \r\n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\r\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\r\n    float marioX\t= textX - offset * 4.0;\r\n    float marioY\t= textY + 16.0 * 3.0;\r\n\t\r\n    DrawW( color, textX - offset * 0.0, textY );\r\n    DrawO( color, textX - offset * 1.0, textY );\r\n    DrawR( color, textX - offset * 2.0, textY );\r\n    DrawL( color, textX - offset * 3.0, textY );\r\n    DrawD( color, textX - offset * 4.0, textY );\r\n    Draw1( color, textX - offset * 6.0, textY );\r\n    DrawM( color, textX - offset * 7.0, textY );\r\n    Draw1( color, textX - offset * 8.0, textY );\r\n    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 )\r\n    {\r\n    \tSpriteMario( color, marioX, marioY, 4.0 );\r\n    }\r\n}\r\n\r\nfloat CoinAnimY( float worldY, float time, float coinTime )\r\n{\r\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\r\n}\r\n\r\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\r\n{\r\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\r\n}\r\n\r\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\r\n{\r\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\r\n}\r\n\r\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\r\n{\r\n    float mushroomPauseStart \t= 16.25;    \r\n    float mushroomPauseLength \t= 2.0;    \r\n    float flagPauseStart\t\t= 38.95;\r\n    float flagPauseLength\t\t= 1.5;\r\n\r\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\r\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\r\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\r\n    float worldX \t\t= pixelX + cameraX;\r\n    float worldY  \t\t= pixelY - 8.0;\r\n    float tileX\t\t\t= floor( worldX / 16.0 );\r\n    float tileY\t\t\t= floor( worldY / 16.0 );\r\n    float tile2X\t\t= floor( worldX / 32.0 );\r\n    float tile2Y\t\t= floor( worldY / 32.0 );    \r\n    float worldXMod16\t= mod( worldX, 16.0 );\r\n    float worldYMod16 \t= mod( worldY, 16.0 );\r\n\r\n\r\n    // default background color\r\n    color = RGB( 92, 148, 252 );\r\n\r\n    \r\n    // draw hills\r\n    float bigHillX \t = mod( worldX, 768.0 );\r\n    float smallHillX = mod( worldX - 240.0, 768.0 );\r\n    float hillX \t = min( bigHillX, smallHillX );\r\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\r\n    SpriteHill( color, hillX, hillY );\r\n\r\n\r\n    // draw clouds and bushes\r\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\r\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\r\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\r\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \r\n    float scCloudX  = min( sc1CloudX, sc2CloudX );\r\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\r\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \r\n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\r\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\r\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\r\n    float sCloudX\t= min( scCloudX, sbCloudX );\r\n    float mCloudX\t= min( mcCloudX, mbCloudX );\r\n    float lCloudX\t= min( lcCloudX, lbCloudX );\r\n    float cloudX\t= min( cCloudX, bCloudX );\r\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\r\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\r\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\r\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\r\n    {\r\n        if ( cloudSeg == 1.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\r\n        }\r\n        if ( cloudSeg == 2.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\r\n        }\r\n        \r\n    \tSpriteCloud( color, cloudX, cloudY, isBush );\r\n    }\r\n\r\n    \r\n    \r\n    // draw flag pole\r\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \r\n    {\r\n        color = RGB( 189, 255, 24 );\r\n    }\r\n    \r\n    // draw flag\r\n    float flagX = worldX - 3160.0;\r\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( flagX >= 0.0 && flagX <= 15.0 )\r\n    {\r\n    \tSpriteFlag( color, flagX, flagY );\r\n    }     \r\n    \r\n    // draw flagpole end\r\n    float flagpoleEndX = worldX - 3172.0;\r\n    float flagpoleEndY = worldY - 176.0;\r\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\r\n    {\r\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\r\n    }\r\n    \r\n    \r\n\r\n    // draw blocks\r\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\r\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\r\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\r\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \r\n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\r\n         || ( tileX == 198.0 && tileY == 1.0 )\r\n       )\r\n    {\r\n        SpriteBlock( color, worldXMod16, worldYMod16 );\r\n    }\r\n    \r\n    \r\n    // draw pipes\r\n    float pipeY = worldY - 16.0;  \r\n    float pipeH\t= 0.0;    \r\n    float pipeX = worldX - 179.0 * 16.0;\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 163.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 57.0 * 16.0;\r\n        pipeH = 2.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 46.0 * 16.0;\r\n        pipeH = 2.0;\r\n    } \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 38.0 * 16.0;\r\n        pipeH = 1.0;\r\n    }         \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 28.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\r\n\t{\r\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\r\n\t}\r\n    \r\n    \r\n    // draw mushroom\r\n    float mushroomStart = 15.7;    \r\n    if ( time >= mushroomStart && time <= 17.0 )\r\n    {\r\n        float jumpTime = 0.5;\r\n        \r\n        float mushroomX = worldX - 1248.0;\r\n        float mushroomY = worldY - 4.0 * 16.0;\r\n        if ( time >= mushroomStart )\r\n        {\r\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 )\r\n        {\r\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 + 0.4 )\r\n        {\r\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\r\n        }\r\n        \r\n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\r\n        {\r\n        \tSpriteMushroom( color, mushroomX, mushroomY );\r\n        }\r\n    }\r\n\r\n    \r\n    // draw coins\r\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\r\n    float coinX \t= worldX - 2720.0;\r\n    float coinTime \t= 33.9;    \r\n    float coinY \t= CoinAnimY( worldY, time, coinTime );\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 1696.0;\r\n    \tcoinTime \t= 22.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \r\n    }\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 352.0;\r\n    \tcoinTime \t= 5.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\r\n    } \r\n    \r\n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\r\n    {   \r\n        SpriteCoin( color, coinX, coinY, coinFrame );\r\n    }\r\n\r\n    \r\n    // draw questions\r\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \r\n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\r\n    }\r\n    \r\n    \r\n    // draw hitted questions\r\n    float questionHitTime \t= 33.9;\r\n    float questionX \t\t= worldX - 2720.0;\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 22.4;\r\n        questionX\t\t= worldX - 1696.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 15.4;\r\n        questionX\t\t= worldX - 1248.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 5.3;\r\n        questionX\t\t= worldX - 352.0;\r\n    }    \r\n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \r\n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {\r\n    \tSpriteQuestion( color, questionX, questionY, questionT );\r\n    }\r\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n    {\r\n        color = RGB( 231, 90, 16 );\r\n    }    \r\n\r\n    \r\n    // draw bricks\r\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteBrick( color, worldXMod16, worldYMod16 );\r\n    }   \r\n    \r\n    \r\n    // draw castle flag\r\n    float castleFlagX = worldX - 3264.0;\r\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\r\n    {\r\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\r\n\t}\r\n    \r\n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\r\n\r\n    // draw ground\r\n    if ( tileY <= 0.0\r\n         && !( tileX >= 69.0  && tileX < 71.0 )\r\n         && !( tileX >= 86.0  && tileX < 89.0 ) \r\n         && !( tileX >= 153.0 && tileX < 155.0 ) \r\n       )\r\n    {\r\n        SpriteGround( color, worldXMod16, worldYMod16 );\r\n    }    \r\n    \r\n\r\n    // draw Koopa\r\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\r\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\r\n    \r\n    \r\n    // draw stomped walking Goombas\r\n    float goombaY \t\t\t= worldY - 16.0;        \r\n    float goombaLifeTime \t= 26.3;\r\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 25.3;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n\t\tgoombaLifeTime \t= 23.5;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n        goombaLifeTime \t= 20.29;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 10.3;\r\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    }\r\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }    \r\n    \r\n    // draw walking Goombas\r\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\r\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\r\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }\r\n    \r\n\r\n    \r\n    // Mario jump\r\n    float marioBigJump1 \t= 27.1;\r\n    float marioBigJump2 \t= 29.75;\r\n    float marioBigJump3 \t= 35.05;    \r\n    float marioJumpTime \t= 0.0;\r\n    float marioJumpScale\t= 0.0;\r\n    \r\n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\r\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\r\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\r\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\r\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\r\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\r\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\r\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\r\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\r\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\r\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\r\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\r\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\r\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\r\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\r\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\r\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\r\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\r\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\r\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \r\n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\r\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\r\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\r\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\r\n    \r\n    float marioJumpOffset \t\t= 0.0;\r\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\r\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\r\n    {\r\n        float t = ( time - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n    \r\n    // Mario land\r\n    float marioLandTime \t= 0.0;\r\n    float marioLandAplitude = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\r\n    \r\n    float marioLandLength = marioLandAplitude / 120.0;\r\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\r\n    {\r\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\r\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\r\n    }\r\n    \r\n    \r\n    // Mario flag jump\r\n    marioJumpTime \t\t= flagPauseStart - 0.3;\r\n    marioJumpLength \t= 1.5  * 0.45;\r\n    marioJumpAmplitude\t= 76.0 * 0.45;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \r\n    {\r\n        float time2 = time;\r\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \r\n        {\r\n            time2 = flagPauseStart;\r\n        }\r\n        else if ( time >= flagPauseStart )\r\n        {\r\n            time2 = time - flagPauseLength;\r\n        }\r\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n\r\n    // Mario base (ground offset)\r\n    float marioBase = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }\r\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\r\n    {\r\n        marioBase = 16.0 * 3.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\r\n    {\r\n        marioBase = 16.0 * 7.0;\r\n    }\r\n\r\n    float marioX\t\t= pixelX - 112.0;\r\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \r\n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\r\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\r\n    {\r\n    \tmarioFrame = 1.0;\r\n    }    \r\n    if ( time > mushroomPauseStart + 0.7 )\r\n    {\r\n        float t = time - mushroomPauseStart - 0.7;\r\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\r\n        {\r\n            // super mario offset\r\n            marioFrame += 4.0;\r\n        }\r\n    }    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\r\n    {\r\n        SpriteMario( color, marioX, marioY, marioFrame );\r\n    }\r\n}\r\n\r\nvec2 CRTCurveUV( vec2 uv )\r\n{\r\n    uv = uv * 2.0 - 1.0;\r\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\r\n    uv = uv + uv * offset * offset;\r\n    uv = uv * 0.5 + 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid DrawVignette( inout vec3 color, vec2 uv )\r\n{    \r\n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\r\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\r\n    color *= vignette;\r\n}\r\n\r\nvoid DrawScanline( inout vec3 color, vec2 uv )\r\n{\r\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\r\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \r\n    color *= scanline * grille * 1.2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\r\n    float resMultX  = floor( iResolution.x / 224.0 );\r\n    float resMultY  = floor( iResolution.y / 192.0 );\r\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\r\n    \r\n    float time\t\t\t= iTime;\r\n    float screenWidth\t= floor( iResolution.x * resRcp );\r\n    float screenHeight\t= floor( iResolution.y * resRcp );\r\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\r\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\r\n\r\n    vec3 color = RGB( 92, 148, 252 );\r\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\r\n    if ( time < INTRO_LENGTH )\r\n    {\r\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\r\n    }    \r\n\r\n    \r\n    // CRT effects (curvature, vignette, scanlines and CRT grille)\r\n    vec2 uv    = fragCoord.xy / iResolution.xy;\r\n    vec2 crtUV = CRTCurveUV( uv );\r\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\r\n    {\r\n        color = vec3( 0.0, 0.0, 0.0 );\r\n    }\r\n    DrawVignette( color, crtUV );\r\n    DrawScanline( color, uv );\r\n    \r\n\tfragColor.xyz \t= color;\r\n    fragColor.w\t\t= 1.0;\r\n}","inputs":[],"outputs":[],"code":"// Interesting findings from original NES Super Mario Bros.:\r\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\r\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\r\n// -Overworld (main theme) drum sound uses only the APU noise generator\r\n\r\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\r\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\r\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\r\n\r\nconst float MARIO_SPEED\t = 89.0;\r\nconst float GOOMBA_SPEED = 32.0;\r\nconst float INTRO_LENGTH = 2.0;\r\n\r\nvoid SpriteBlock( inout vec3 color, float x, float y )\r\n{\r\n    // black\r\n    float idx = 1.0;\r\n    \r\n    // light orange\r\n    idx = x < y ? 3.0 : idx;\r\n    \r\n    // dark orange\r\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\r\n    idx = x == 15.0 - y ? 2.0 : idx;\r\n    \r\n    color = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteHill( inout vec3 color, float x, float y )\r\n{\r\n    float idx = 0.0;\r\n    \r\n    // dark green\r\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\r\n    \r\n    // black\r\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\r\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\r\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\r\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\r\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n}\r\n\r\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\r\n{\r\n    float offset = h * 16.0;\r\n\r\n    // light green\r\n\tfloat idx = 3.0;\r\n    \r\n    // dark green\r\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\r\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \r\n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\r\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \r\n    \r\n    // black\r\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\r\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\r\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \r\n    \r\n    // transparent\r\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\r\n{\r\n\tfloat idx = 0.0;\r\n    \r\n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\r\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\r\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\r\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\r\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\r\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\r\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\r\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\r\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\r\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\r\n\tcolor = idx == 2.0 ? colorB \t\t: color;\r\n\tcolor = idx == 3.0 ? colorC \t\t: color;\r\n}\r\n\r\nvoid SpriteFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? 43690.0 : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\r\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\r\n{\r\n\tfloat idx = 0.0;\r\n\r\n    // second frame is flipped first frame\r\n    x = frame == 1.0 ? 15.0 - x : x;\r\n\r\n    if ( frame <= 1.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\r\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\r\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\r\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\r\n        idx = y ==  6.0 ? 43690.0 : idx;\r\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\r\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\r\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\r\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\r\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\r\n\t\tidx = y == 3.0 ? 43690.0 : idx;\r\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\r\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\r\n}\r\n\r\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\r\n{    \r\n\tfloat idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\r\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\r\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\r\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\r\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\r\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\r\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\r\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\r\n    }\r\n\telse\r\n\t{\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\r\n\t}\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 0.0 ? 21845.0 : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\r\n}\r\n\r\nvoid SpriteMushroom( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\r\n\tidx = y == 5.0 ? 43690.0 : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGround( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\r\n\tidx = y == 7.0 ? 1360.0  : idx;\r\n\tidx = y == 6.0 ? 6836.0  : idx;\r\n\tidx = y == 5.0 ? 27309.0 : idx;\r\n\tidx = y == 4.0 ? 27309.0 : idx;\r\n\tidx = y == 3.0 ? 27305.0 : idx;\r\n\tidx = y == 2.0 ? 27305.0 : idx;\r\n\tidx = y == 1.0 ? 6820.0  : idx;\r\n\tidx = y == 0.0 ? 1360.0  : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 3.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 4.0 )\r\n    {\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\r\n    }\r\n    else if ( frame == 5.0 )\r\n    {\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\r\n    }\r\n    else if ( frame == 6.0 )\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \r\n}\r\n\r\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n    }\r\n    \r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteBrick( inout vec3 color, float x, float y )\r\n{    \r\n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \r\n    float xmod8 = floor( mod( x, 8.0 ) );\r\n    float ymod8 = floor( mod( y, 8.0 ) );\r\n    \r\n    // dark orange\r\n    float idx = 2.0;\r\n   \r\n    // black\r\n    idx = ymod4 == 0.0 ? 1.0 : idx;\r\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\r\n\r\n    // light orange\r\n    idx = y == 15.0 ? 3.0 : idx;\r\n\r\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid DrawCastle( inout vec3 color, float x, float y )\r\n{\r\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\r\n\t{\r\n\t\tfloat ymod4    = mod( y, 4.0 );\r\n\t\tfloat xmod8    = mod( x, 8.0 );\r\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\r\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\r\n\t\tfloat ymod8    = mod( y, 8.0 );\r\n\r\n\t\t// dark orange\r\n\t\tfloat idx = 2.0;\r\n\r\n\t\t// black\r\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\r\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\r\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \r\n\r\n\t\t// white\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\r\n\r\n\t\t// transparent\r\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\r\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\r\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \r\n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\r\n\r\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\r\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n\t}\r\n}\r\n\r\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\r\n{\r\n    if ( x >= 0.0 && x <= 15.0 )\r\n    {\r\n        SpriteKoopa( color, x, y, frame );\r\n    }\r\n}\r\n\r\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\r\n{\r\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\r\n    DrawKoopa( color, x, worldY - 16.0, frame );    \r\n}\r\n\r\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\r\n{\r\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\r\n    t = 1.0 - abs( 2.0 * t - 1.0 );\r\n\r\n    questionY -= floor( t * 8.0 );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {            \r\n    \tif ( time >= questionHitTime )\r\n        {                \r\n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\r\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n            {\r\n                color = RGB( 231, 90, 16 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n         \tSpriteQuestion( color, questionX, questionY, questionT );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawW( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 || x >= 10.0 ) \r\n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawO( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\r\n             || ( x >= 2.0 && x <= 4.0 )\r\n             || ( x >= 9.0 && x <= 11.0 )\r\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawR( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 )\r\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\r\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\r\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\r\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\r\n             || ( x >= 8.0  && y <= 1.0 )\r\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawL( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( x <= 3.0 || y <= 1.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawD( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n    \tcolor = RGB( 255, 255, 255 );        \r\n        \r\n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \r\n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \r\n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\r\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\r\n           )\r\n        {\r\n            color = RGB( 0, 0, 0 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid Draw1( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( y <= 1.0 )\r\n             || ( x >= 5.0 && x <= 8.0 )\r\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawM( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( y >= 4.0 && y <= 7.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\r\n{\r\n    color = RGB( 0, 0, 0 );\r\n        \r\n    float offset \t= 18.0;     \r\n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\r\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\r\n    float marioX\t= textX - offset * 4.0;\r\n    float marioY\t= textY + 16.0 * 3.0;\r\n\t\r\n    DrawW( color, textX - offset * 0.0, textY );\r\n    DrawO( color, textX - offset * 1.0, textY );\r\n    DrawR( color, textX - offset * 2.0, textY );\r\n    DrawL( color, textX - offset * 3.0, textY );\r\n    DrawD( color, textX - offset * 4.0, textY );\r\n    Draw1( color, textX - offset * 6.0, textY );\r\n    DrawM( color, textX - offset * 7.0, textY );\r\n    Draw1( color, textX - offset * 8.0, textY );\r\n    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 )\r\n    {\r\n    \tSpriteMario( color, marioX, marioY, 4.0 );\r\n    }\r\n}\r\n\r\nfloat CoinAnimY( float worldY, float time, float coinTime )\r\n{\r\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\r\n}\r\n\r\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\r\n{\r\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\r\n}\r\n\r\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\r\n{\r\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\r\n}\r\n\r\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\r\n{\r\n    float mushroomPauseStart \t= 16.25;    \r\n    float mushroomPauseLength \t= 2.0;    \r\n    float flagPauseStart\t\t= 38.95;\r\n    float flagPauseLength\t\t= 1.5;\r\n\r\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\r\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\r\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\r\n    float worldX \t\t= pixelX + cameraX;\r\n    float worldY  \t\t= pixelY - 8.0;\r\n    float tileX\t\t\t= floor( worldX / 16.0 );\r\n    float tileY\t\t\t= floor( worldY / 16.0 );\r\n    float tile2X\t\t= floor( worldX / 32.0 );\r\n    float tile2Y\t\t= floor( worldY / 32.0 );    \r\n    float worldXMod16\t= mod( worldX, 16.0 );\r\n    float worldYMod16 \t= mod( worldY, 16.0 );\r\n\r\n\r\n    // default background color\r\n    color = RGB( 92, 148, 252 );\r\n\r\n    \r\n    // draw hills\r\n    float bigHillX \t = mod( worldX, 768.0 );\r\n    float smallHillX = mod( worldX - 240.0, 768.0 );\r\n    float hillX \t = min( bigHillX, smallHillX );\r\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\r\n    SpriteHill( color, hillX, hillY );\r\n\r\n\r\n    // draw clouds and bushes\r\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\r\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\r\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\r\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \r\n    float scCloudX  = min( sc1CloudX, sc2CloudX );\r\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\r\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \r\n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\r\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\r\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\r\n    float sCloudX\t= min( scCloudX, sbCloudX );\r\n    float mCloudX\t= min( mcCloudX, mbCloudX );\r\n    float lCloudX\t= min( lcCloudX, lbCloudX );\r\n    float cloudX\t= min( cCloudX, bCloudX );\r\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\r\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\r\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\r\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\r\n    {\r\n        if ( cloudSeg == 1.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\r\n        }\r\n        if ( cloudSeg == 2.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\r\n        }\r\n        \r\n    \tSpriteCloud( color, cloudX, cloudY, isBush );\r\n    }\r\n\r\n    \r\n    \r\n    // draw flag pole\r\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \r\n    {\r\n        color = RGB( 189, 255, 24 );\r\n    }\r\n    \r\n    // draw flag\r\n    float flagX = worldX - 3160.0;\r\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( flagX >= 0.0 && flagX <= 15.0 )\r\n    {\r\n    \tSpriteFlag( color, flagX, flagY );\r\n    }     \r\n    \r\n    // draw flagpole end\r\n    float flagpoleEndX = worldX - 3172.0;\r\n    float flagpoleEndY = worldY - 176.0;\r\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\r\n    {\r\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\r\n    }\r\n    \r\n    \r\n\r\n    // draw blocks\r\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\r\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\r\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\r\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \r\n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\r\n         || ( tileX == 198.0 && tileY == 1.0 )\r\n       )\r\n    {\r\n        SpriteBlock( color, worldXMod16, worldYMod16 );\r\n    }\r\n    \r\n    \r\n    // draw pipes\r\n    float pipeY = worldY - 16.0;  \r\n    float pipeH\t= 0.0;    \r\n    float pipeX = worldX - 179.0 * 16.0;\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 163.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 57.0 * 16.0;\r\n        pipeH = 2.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 46.0 * 16.0;\r\n        pipeH = 2.0;\r\n    } \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 38.0 * 16.0;\r\n        pipeH = 1.0;\r\n    }         \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 28.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\r\n\t{\r\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\r\n\t}\r\n    \r\n    \r\n    // draw mushroom\r\n    float mushroomStart = 15.7;    \r\n    if ( time >= mushroomStart && time <= 17.0 )\r\n    {\r\n        float jumpTime = 0.5;\r\n        \r\n        float mushroomX = worldX - 1248.0;\r\n        float mushroomY = worldY - 4.0 * 16.0;\r\n        if ( time >= mushroomStart )\r\n        {\r\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 )\r\n        {\r\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 + 0.4 )\r\n        {\r\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\r\n        }\r\n        \r\n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\r\n        {\r\n        \tSpriteMushroom( color, mushroomX, mushroomY );\r\n        }\r\n    }\r\n\r\n    \r\n    // draw coins\r\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\r\n    float coinX \t= worldX - 2720.0;\r\n    float coinTime \t= 33.9;    \r\n    float coinY \t= CoinAnimY( worldY, time, coinTime );\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 1696.0;\r\n    \tcoinTime \t= 22.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \r\n    }\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 352.0;\r\n    \tcoinTime \t= 5.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\r\n    } \r\n    \r\n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\r\n    {   \r\n        SpriteCoin( color, coinX, coinY, coinFrame );\r\n    }\r\n\r\n    \r\n    // draw questions\r\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \r\n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\r\n    }\r\n    \r\n    \r\n    // draw hitted questions\r\n    float questionHitTime \t= 33.9;\r\n    float questionX \t\t= worldX - 2720.0;\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 22.4;\r\n        questionX\t\t= worldX - 1696.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 15.4;\r\n        questionX\t\t= worldX - 1248.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 5.3;\r\n        questionX\t\t= worldX - 352.0;\r\n    }    \r\n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \r\n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {\r\n    \tSpriteQuestion( color, questionX, questionY, questionT );\r\n    }\r\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n    {\r\n        color = RGB( 231, 90, 16 );\r\n    }    \r\n\r\n    \r\n    // draw bricks\r\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteBrick( color, worldXMod16, worldYMod16 );\r\n    }   \r\n    \r\n    \r\n    // draw castle flag\r\n    float castleFlagX = worldX - 3264.0;\r\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\r\n    {\r\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\r\n\t}\r\n    \r\n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\r\n\r\n    // draw ground\r\n    if ( tileY <= 0.0\r\n         && !( tileX >= 69.0  && tileX < 71.0 )\r\n         && !( tileX >= 86.0  && tileX < 89.0 ) \r\n         && !( tileX >= 153.0 && tileX < 155.0 ) \r\n       )\r\n    {\r\n        SpriteGround( color, worldXMod16, worldYMod16 );\r\n    }    \r\n    \r\n\r\n    // draw Koopa\r\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\r\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\r\n    \r\n    \r\n    // draw stomped walking Goombas\r\n    float goombaY \t\t\t= worldY - 16.0;        \r\n    float goombaLifeTime \t= 26.3;\r\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 25.3;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n\t\tgoombaLifeTime \t= 23.5;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n        goombaLifeTime \t= 20.29;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 10.3;\r\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    }\r\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }    \r\n    \r\n    // draw walking Goombas\r\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\r\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\r\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }\r\n    \r\n\r\n    \r\n    // Mario jump\r\n    float marioBigJump1 \t= 27.1;\r\n    float marioBigJump2 \t= 29.75;\r\n    float marioBigJump3 \t= 35.05;    \r\n    float marioJumpTime \t= 0.0;\r\n    float marioJumpScale\t= 0.0;\r\n    \r\n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\r\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\r\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\r\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\r\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\r\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\r\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\r\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\r\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\r\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\r\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\r\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\r\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\r\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\r\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\r\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\r\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\r\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\r\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\r\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \r\n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\r\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\r\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\r\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\r\n    \r\n    float marioJumpOffset \t\t= 0.0;\r\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\r\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\r\n    {\r\n        float t = ( time - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n    \r\n    // Mario land\r\n    float marioLandTime \t= 0.0;\r\n    float marioLandAplitude = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\r\n    \r\n    float marioLandLength = marioLandAplitude / 120.0;\r\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\r\n    {\r\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\r\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\r\n    }\r\n    \r\n    \r\n    // Mario flag jump\r\n    marioJumpTime \t\t= flagPauseStart - 0.3;\r\n    marioJumpLength \t= 1.5  * 0.45;\r\n    marioJumpAmplitude\t= 76.0 * 0.45;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \r\n    {\r\n        float time2 = time;\r\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \r\n        {\r\n            time2 = flagPauseStart;\r\n        }\r\n        else if ( time >= flagPauseStart )\r\n        {\r\n            time2 = time - flagPauseLength;\r\n        }\r\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n\r\n    // Mario base (ground offset)\r\n    float marioBase = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }\r\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\r\n    {\r\n        marioBase = 16.0 * 3.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\r\n    {\r\n        marioBase = 16.0 * 7.0;\r\n    }\r\n\r\n    float marioX\t\t= pixelX - 112.0;\r\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \r\n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\r\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\r\n    {\r\n    \tmarioFrame = 1.0;\r\n    }    \r\n    if ( time > mushroomPauseStart + 0.7 )\r\n    {\r\n        float t = time - mushroomPauseStart - 0.7;\r\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\r\n        {\r\n            // super mario offset\r\n            marioFrame += 4.0;\r\n        }\r\n    }    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\r\n    {\r\n        SpriteMario( color, marioX, marioY, marioFrame );\r\n    }\r\n}\r\n\r\nvec2 CRTCurveUV( vec2 uv )\r\n{\r\n    uv = uv * 2.0 - 1.0;\r\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\r\n    uv = uv + uv * offset * offset;\r\n    uv = uv * 0.5 + 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid DrawVignette( inout vec3 color, vec2 uv )\r\n{    \r\n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\r\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\r\n    color *= vignette;\r\n}\r\n\r\nvoid DrawScanline( inout vec3 color, vec2 uv )\r\n{\r\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\r\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \r\n    color *= scanline * grille * 1.2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\r\n    float resMultX  = floor( iResolution.x / 224.0 );\r\n    float resMultY  = floor( iResolution.y / 192.0 );\r\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\r\n    \r\n    float time\t\t\t= iTime;\r\n    float screenWidth\t= floor( iResolution.x * resRcp );\r\n    float screenHeight\t= floor( iResolution.y * resRcp );\r\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\r\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\r\n\r\n    vec3 color = RGB( 92, 148, 252 );\r\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\r\n    if ( time < INTRO_LENGTH )\r\n    {\r\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\r\n    }    \r\n\r\n    \r\n    // CRT effects (curvature, vignette, scanlines and CRT grille)\r\n    vec2 uv    = fragCoord.xy / iResolution.xy;\r\n    vec2 crtUV = CRTCurveUV( uv );\r\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\r\n    {\r\n        color = vec3( 0.0, 0.0, 0.0 );\r\n    }\r\n    DrawVignette( color, crtUV );\r\n    DrawScanline( color, uv );\r\n    \r\n\tfragColor.xyz \t= color;\r\n    fragColor.w\t\t= 1.0;\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"[SIG15] Mario World 1-1","id":"44193e25748d40dd99347ab7fcb82422","date":null,"viewed":0,"name":"[SIG15] Mario World 1-1","description":"NES Super Mario Bros. World 1-1. My favorite game moment (just like for most kids in the early 90s). 20 years later implemented in a single shader.\nhttps://www.shadertoy.com/view/XtlSD7","likes":0,"published":null,"tags":["2d"," sound"," music"," crt"," sprite"," mario"," nes"," sig15"]},"ver":null,"info":{"Name":"[SIG15] Mario World 1-1","id":"44193e25748d40dd99347ab7fcb82422","date":null,"viewed":0,"name":"[SIG15] Mario World 1-1","description":"NES Super Mario Bros. World 1-1. My favorite game moment (just like for most kids in the early 90s). 20 years later implemented in a single shader.\nhttps://www.shadertoy.com/view/XtlSD7","likes":0,"published":null,"tags":["2d"," sound"," music"," crt"," sprite"," mario"," nes"," sig15"]},"renderpass":[{"Code":"// Interesting findings from original NES Super Mario Bros.:\r\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\r\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\r\n// -Overworld (main theme) drum sound uses only the APU noise generator\r\n\r\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\r\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\r\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\r\n\r\nconst float MARIO_SPEED\t = 89.0;\r\nconst float GOOMBA_SPEED = 32.0;\r\nconst float INTRO_LENGTH = 2.0;\r\n\r\nvoid SpriteBlock( inout vec3 color, float x, float y )\r\n{\r\n    // black\r\n    float idx = 1.0;\r\n    \r\n    // light orange\r\n    idx = x < y ? 3.0 : idx;\r\n    \r\n    // dark orange\r\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\r\n    idx = x == 15.0 - y ? 2.0 : idx;\r\n    \r\n    color = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteHill( inout vec3 color, float x, float y )\r\n{\r\n    float idx = 0.0;\r\n    \r\n    // dark green\r\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\r\n    \r\n    // black\r\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\r\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\r\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\r\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\r\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n}\r\n\r\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\r\n{\r\n    float offset = h * 16.0;\r\n\r\n    // light green\r\n\tfloat idx = 3.0;\r\n    \r\n    // dark green\r\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\r\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \r\n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\r\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \r\n    \r\n    // black\r\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\r\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\r\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \r\n    \r\n    // transparent\r\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\r\n{\r\n\tfloat idx = 0.0;\r\n    \r\n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\r\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\r\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\r\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\r\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\r\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\r\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\r\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\r\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\r\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\r\n\tcolor = idx == 2.0 ? colorB \t\t: color;\r\n\tcolor = idx == 3.0 ? colorC \t\t: color;\r\n}\r\n\r\nvoid SpriteFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? 43690.0 : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\r\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\r\n{\r\n\tfloat idx = 0.0;\r\n\r\n    // second frame is flipped first frame\r\n    x = frame == 1.0 ? 15.0 - x : x;\r\n\r\n    if ( frame <= 1.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\r\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\r\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\r\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\r\n        idx = y ==  6.0 ? 43690.0 : idx;\r\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\r\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\r\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\r\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\r\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\r\n\t\tidx = y == 3.0 ? 43690.0 : idx;\r\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\r\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\r\n}\r\n\r\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\r\n{    \r\n\tfloat idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\r\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\r\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\r\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\r\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\r\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\r\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\r\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\r\n    }\r\n\telse\r\n\t{\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\r\n\t}\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 0.0 ? 21845.0 : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\r\n}\r\n\r\nvoid SpriteMushroom( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\r\n\tidx = y == 5.0 ? 43690.0 : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGround( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\r\n\tidx = y == 7.0 ? 1360.0  : idx;\r\n\tidx = y == 6.0 ? 6836.0  : idx;\r\n\tidx = y == 5.0 ? 27309.0 : idx;\r\n\tidx = y == 4.0 ? 27309.0 : idx;\r\n\tidx = y == 3.0 ? 27305.0 : idx;\r\n\tidx = y == 2.0 ? 27305.0 : idx;\r\n\tidx = y == 1.0 ? 6820.0  : idx;\r\n\tidx = y == 0.0 ? 1360.0  : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 3.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 4.0 )\r\n    {\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\r\n    }\r\n    else if ( frame == 5.0 )\r\n    {\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\r\n    }\r\n    else if ( frame == 6.0 )\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \r\n}\r\n\r\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n    }\r\n    \r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteBrick( inout vec3 color, float x, float y )\r\n{    \r\n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \r\n    float xmod8 = floor( mod( x, 8.0 ) );\r\n    float ymod8 = floor( mod( y, 8.0 ) );\r\n    \r\n    // dark orange\r\n    float idx = 2.0;\r\n   \r\n    // black\r\n    idx = ymod4 == 0.0 ? 1.0 : idx;\r\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\r\n\r\n    // light orange\r\n    idx = y == 15.0 ? 3.0 : idx;\r\n\r\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid DrawCastle( inout vec3 color, float x, float y )\r\n{\r\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\r\n\t{\r\n\t\tfloat ymod4    = mod( y, 4.0 );\r\n\t\tfloat xmod8    = mod( x, 8.0 );\r\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\r\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\r\n\t\tfloat ymod8    = mod( y, 8.0 );\r\n\r\n\t\t// dark orange\r\n\t\tfloat idx = 2.0;\r\n\r\n\t\t// black\r\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\r\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\r\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \r\n\r\n\t\t// white\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\r\n\r\n\t\t// transparent\r\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\r\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\r\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \r\n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\r\n\r\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\r\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n\t}\r\n}\r\n\r\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\r\n{\r\n    if ( x >= 0.0 && x <= 15.0 )\r\n    {\r\n        SpriteKoopa( color, x, y, frame );\r\n    }\r\n}\r\n\r\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\r\n{\r\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\r\n    DrawKoopa( color, x, worldY - 16.0, frame );    \r\n}\r\n\r\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\r\n{\r\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\r\n    t = 1.0 - abs( 2.0 * t - 1.0 );\r\n\r\n    questionY -= floor( t * 8.0 );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {            \r\n    \tif ( time >= questionHitTime )\r\n        {                \r\n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\r\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n            {\r\n                color = RGB( 231, 90, 16 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n         \tSpriteQuestion( color, questionX, questionY, questionT );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawW( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 || x >= 10.0 ) \r\n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawO( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\r\n             || ( x >= 2.0 && x <= 4.0 )\r\n             || ( x >= 9.0 && x <= 11.0 )\r\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawR( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 )\r\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\r\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\r\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\r\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\r\n             || ( x >= 8.0  && y <= 1.0 )\r\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawL( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( x <= 3.0 || y <= 1.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawD( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n    \tcolor = RGB( 255, 255, 255 );        \r\n        \r\n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \r\n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \r\n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\r\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\r\n           )\r\n        {\r\n            color = RGB( 0, 0, 0 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid Draw1( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( y <= 1.0 )\r\n             || ( x >= 5.0 && x <= 8.0 )\r\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawM( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( y >= 4.0 && y <= 7.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\r\n{\r\n    color = RGB( 0, 0, 0 );\r\n        \r\n    float offset \t= 18.0;     \r\n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\r\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\r\n    float marioX\t= textX - offset * 4.0;\r\n    float marioY\t= textY + 16.0 * 3.0;\r\n\t\r\n    DrawW( color, textX - offset * 0.0, textY );\r\n    DrawO( color, textX - offset * 1.0, textY );\r\n    DrawR( color, textX - offset * 2.0, textY );\r\n    DrawL( color, textX - offset * 3.0, textY );\r\n    DrawD( color, textX - offset * 4.0, textY );\r\n    Draw1( color, textX - offset * 6.0, textY );\r\n    DrawM( color, textX - offset * 7.0, textY );\r\n    Draw1( color, textX - offset * 8.0, textY );\r\n    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 )\r\n    {\r\n    \tSpriteMario( color, marioX, marioY, 4.0 );\r\n    }\r\n}\r\n\r\nfloat CoinAnimY( float worldY, float time, float coinTime )\r\n{\r\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\r\n}\r\n\r\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\r\n{\r\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\r\n}\r\n\r\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\r\n{\r\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\r\n}\r\n\r\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\r\n{\r\n    float mushroomPauseStart \t= 16.25;    \r\n    float mushroomPauseLength \t= 2.0;    \r\n    float flagPauseStart\t\t= 38.95;\r\n    float flagPauseLength\t\t= 1.5;\r\n\r\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\r\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\r\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\r\n    float worldX \t\t= pixelX + cameraX;\r\n    float worldY  \t\t= pixelY - 8.0;\r\n    float tileX\t\t\t= floor( worldX / 16.0 );\r\n    float tileY\t\t\t= floor( worldY / 16.0 );\r\n    float tile2X\t\t= floor( worldX / 32.0 );\r\n    float tile2Y\t\t= floor( worldY / 32.0 );    \r\n    float worldXMod16\t= mod( worldX, 16.0 );\r\n    float worldYMod16 \t= mod( worldY, 16.0 );\r\n\r\n\r\n    // default background color\r\n    color = RGB( 92, 148, 252 );\r\n\r\n    \r\n    // draw hills\r\n    float bigHillX \t = mod( worldX, 768.0 );\r\n    float smallHillX = mod( worldX - 240.0, 768.0 );\r\n    float hillX \t = min( bigHillX, smallHillX );\r\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\r\n    SpriteHill( color, hillX, hillY );\r\n\r\n\r\n    // draw clouds and bushes\r\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\r\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\r\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\r\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \r\n    float scCloudX  = min( sc1CloudX, sc2CloudX );\r\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\r\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \r\n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\r\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\r\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\r\n    float sCloudX\t= min( scCloudX, sbCloudX );\r\n    float mCloudX\t= min( mcCloudX, mbCloudX );\r\n    float lCloudX\t= min( lcCloudX, lbCloudX );\r\n    float cloudX\t= min( cCloudX, bCloudX );\r\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\r\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\r\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\r\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\r\n    {\r\n        if ( cloudSeg == 1.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\r\n        }\r\n        if ( cloudSeg == 2.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\r\n        }\r\n        \r\n    \tSpriteCloud( color, cloudX, cloudY, isBush );\r\n    }\r\n\r\n    \r\n    \r\n    // draw flag pole\r\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \r\n    {\r\n        color = RGB( 189, 255, 24 );\r\n    }\r\n    \r\n    // draw flag\r\n    float flagX = worldX - 3160.0;\r\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( flagX >= 0.0 && flagX <= 15.0 )\r\n    {\r\n    \tSpriteFlag( color, flagX, flagY );\r\n    }     \r\n    \r\n    // draw flagpole end\r\n    float flagpoleEndX = worldX - 3172.0;\r\n    float flagpoleEndY = worldY - 176.0;\r\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\r\n    {\r\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\r\n    }\r\n    \r\n    \r\n\r\n    // draw blocks\r\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\r\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\r\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\r\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \r\n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\r\n         || ( tileX == 198.0 && tileY == 1.0 )\r\n       )\r\n    {\r\n        SpriteBlock( color, worldXMod16, worldYMod16 );\r\n    }\r\n    \r\n    \r\n    // draw pipes\r\n    float pipeY = worldY - 16.0;  \r\n    float pipeH\t= 0.0;    \r\n    float pipeX = worldX - 179.0 * 16.0;\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 163.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 57.0 * 16.0;\r\n        pipeH = 2.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 46.0 * 16.0;\r\n        pipeH = 2.0;\r\n    } \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 38.0 * 16.0;\r\n        pipeH = 1.0;\r\n    }         \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 28.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\r\n\t{\r\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\r\n\t}\r\n    \r\n    \r\n    // draw mushroom\r\n    float mushroomStart = 15.7;    \r\n    if ( time >= mushroomStart && time <= 17.0 )\r\n    {\r\n        float jumpTime = 0.5;\r\n        \r\n        float mushroomX = worldX - 1248.0;\r\n        float mushroomY = worldY - 4.0 * 16.0;\r\n        if ( time >= mushroomStart )\r\n        {\r\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 )\r\n        {\r\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 + 0.4 )\r\n        {\r\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\r\n        }\r\n        \r\n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\r\n        {\r\n        \tSpriteMushroom( color, mushroomX, mushroomY );\r\n        }\r\n    }\r\n\r\n    \r\n    // draw coins\r\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\r\n    float coinX \t= worldX - 2720.0;\r\n    float coinTime \t= 33.9;    \r\n    float coinY \t= CoinAnimY( worldY, time, coinTime );\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 1696.0;\r\n    \tcoinTime \t= 22.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \r\n    }\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 352.0;\r\n    \tcoinTime \t= 5.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\r\n    } \r\n    \r\n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\r\n    {   \r\n        SpriteCoin( color, coinX, coinY, coinFrame );\r\n    }\r\n\r\n    \r\n    // draw questions\r\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \r\n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\r\n    }\r\n    \r\n    \r\n    // draw hitted questions\r\n    float questionHitTime \t= 33.9;\r\n    float questionX \t\t= worldX - 2720.0;\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 22.4;\r\n        questionX\t\t= worldX - 1696.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 15.4;\r\n        questionX\t\t= worldX - 1248.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 5.3;\r\n        questionX\t\t= worldX - 352.0;\r\n    }    \r\n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \r\n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {\r\n    \tSpriteQuestion( color, questionX, questionY, questionT );\r\n    }\r\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n    {\r\n        color = RGB( 231, 90, 16 );\r\n    }    \r\n\r\n    \r\n    // draw bricks\r\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteBrick( color, worldXMod16, worldYMod16 );\r\n    }   \r\n    \r\n    \r\n    // draw castle flag\r\n    float castleFlagX = worldX - 3264.0;\r\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\r\n    {\r\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\r\n\t}\r\n    \r\n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\r\n\r\n    // draw ground\r\n    if ( tileY <= 0.0\r\n         && !( tileX >= 69.0  && tileX < 71.0 )\r\n         && !( tileX >= 86.0  && tileX < 89.0 ) \r\n         && !( tileX >= 153.0 && tileX < 155.0 ) \r\n       )\r\n    {\r\n        SpriteGround( color, worldXMod16, worldYMod16 );\r\n    }    \r\n    \r\n\r\n    // draw Koopa\r\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\r\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\r\n    \r\n    \r\n    // draw stomped walking Goombas\r\n    float goombaY \t\t\t= worldY - 16.0;        \r\n    float goombaLifeTime \t= 26.3;\r\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 25.3;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n\t\tgoombaLifeTime \t= 23.5;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n        goombaLifeTime \t= 20.29;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 10.3;\r\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    }\r\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }    \r\n    \r\n    // draw walking Goombas\r\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\r\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\r\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }\r\n    \r\n\r\n    \r\n    // Mario jump\r\n    float marioBigJump1 \t= 27.1;\r\n    float marioBigJump2 \t= 29.75;\r\n    float marioBigJump3 \t= 35.05;    \r\n    float marioJumpTime \t= 0.0;\r\n    float marioJumpScale\t= 0.0;\r\n    \r\n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\r\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\r\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\r\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\r\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\r\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\r\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\r\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\r\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\r\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\r\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\r\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\r\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\r\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\r\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\r\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\r\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\r\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\r\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\r\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \r\n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\r\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\r\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\r\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\r\n    \r\n    float marioJumpOffset \t\t= 0.0;\r\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\r\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\r\n    {\r\n        float t = ( time - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n    \r\n    // Mario land\r\n    float marioLandTime \t= 0.0;\r\n    float marioLandAplitude = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\r\n    \r\n    float marioLandLength = marioLandAplitude / 120.0;\r\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\r\n    {\r\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\r\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\r\n    }\r\n    \r\n    \r\n    // Mario flag jump\r\n    marioJumpTime \t\t= flagPauseStart - 0.3;\r\n    marioJumpLength \t= 1.5  * 0.45;\r\n    marioJumpAmplitude\t= 76.0 * 0.45;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \r\n    {\r\n        float time2 = time;\r\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \r\n        {\r\n            time2 = flagPauseStart;\r\n        }\r\n        else if ( time >= flagPauseStart )\r\n        {\r\n            time2 = time - flagPauseLength;\r\n        }\r\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n\r\n    // Mario base (ground offset)\r\n    float marioBase = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }\r\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\r\n    {\r\n        marioBase = 16.0 * 3.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\r\n    {\r\n        marioBase = 16.0 * 7.0;\r\n    }\r\n\r\n    float marioX\t\t= pixelX - 112.0;\r\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \r\n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\r\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\r\n    {\r\n    \tmarioFrame = 1.0;\r\n    }    \r\n    if ( time > mushroomPauseStart + 0.7 )\r\n    {\r\n        float t = time - mushroomPauseStart - 0.7;\r\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\r\n        {\r\n            // super mario offset\r\n            marioFrame += 4.0;\r\n        }\r\n    }    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\r\n    {\r\n        SpriteMario( color, marioX, marioY, marioFrame );\r\n    }\r\n}\r\n\r\nvec2 CRTCurveUV( vec2 uv )\r\n{\r\n    uv = uv * 2.0 - 1.0;\r\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\r\n    uv = uv + uv * offset * offset;\r\n    uv = uv * 0.5 + 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid DrawVignette( inout vec3 color, vec2 uv )\r\n{    \r\n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\r\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\r\n    color *= vignette;\r\n}\r\n\r\nvoid DrawScanline( inout vec3 color, vec2 uv )\r\n{\r\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\r\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \r\n    color *= scanline * grille * 1.2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\r\n    float resMultX  = floor( iResolution.x / 224.0 );\r\n    float resMultY  = floor( iResolution.y / 192.0 );\r\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\r\n    \r\n    float time\t\t\t= iTime;\r\n    float screenWidth\t= floor( iResolution.x * resRcp );\r\n    float screenHeight\t= floor( iResolution.y * resRcp );\r\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\r\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\r\n\r\n    vec3 color = RGB( 92, 148, 252 );\r\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\r\n    if ( time < INTRO_LENGTH )\r\n    {\r\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\r\n    }    \r\n\r\n    \r\n    // CRT effects (curvature, vignette, scanlines and CRT grille)\r\n    vec2 uv    = fragCoord.xy / iResolution.xy;\r\n    vec2 crtUV = CRTCurveUV( uv );\r\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\r\n    {\r\n        color = vec3( 0.0, 0.0, 0.0 );\r\n    }\r\n    DrawVignette( color, crtUV );\r\n    DrawScanline( color, uv );\r\n    \r\n\tfragColor.xyz \t= color;\r\n    fragColor.w\t\t= 1.0;\r\n}","inputs":[],"outputs":[],"code":"// Interesting findings from original NES Super Mario Bros.:\r\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\r\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\r\n// -Overworld (main theme) drum sound uses only the APU noise generator\r\n\r\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\r\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\r\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\r\n\r\nconst float MARIO_SPEED\t = 89.0;\r\nconst float GOOMBA_SPEED = 32.0;\r\nconst float INTRO_LENGTH = 2.0;\r\n\r\nvoid SpriteBlock( inout vec3 color, float x, float y )\r\n{\r\n    // black\r\n    float idx = 1.0;\r\n    \r\n    // light orange\r\n    idx = x < y ? 3.0 : idx;\r\n    \r\n    // dark orange\r\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\r\n    idx = x == 15.0 - y ? 2.0 : idx;\r\n    \r\n    color = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteHill( inout vec3 color, float x, float y )\r\n{\r\n    float idx = 0.0;\r\n    \r\n    // dark green\r\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\r\n    \r\n    // black\r\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\r\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\r\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\r\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\r\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n}\r\n\r\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\r\n{\r\n    float offset = h * 16.0;\r\n\r\n    // light green\r\n\tfloat idx = 3.0;\r\n    \r\n    // dark green\r\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\r\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \r\n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\r\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \r\n    \r\n    // black\r\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\r\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\r\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \r\n    \r\n    // transparent\r\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\r\n{\r\n\tfloat idx = 0.0;\r\n    \r\n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\r\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\r\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\r\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\r\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\r\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\r\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\r\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\r\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\r\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\r\n\tcolor = idx == 2.0 ? colorB \t\t: color;\r\n\tcolor = idx == 3.0 ? colorC \t\t: color;\r\n}\r\n\r\nvoid SpriteFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? 43690.0 : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\r\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\r\n{\r\n\tfloat idx = 0.0;\r\n\r\n    // second frame is flipped first frame\r\n    x = frame == 1.0 ? 15.0 - x : x;\r\n\r\n    if ( frame <= 1.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\r\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\r\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\r\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\r\n        idx = y ==  6.0 ? 43690.0 : idx;\r\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\r\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\r\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\r\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\r\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\r\n\t\tidx = y == 3.0 ? 43690.0 : idx;\r\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\r\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\r\n}\r\n\r\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\r\n{    \r\n\tfloat idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\r\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\r\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\r\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\r\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\r\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\r\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\r\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\r\n    }\r\n\telse\r\n\t{\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\r\n\t}\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 0.0 ? 21845.0 : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\r\n}\r\n\r\nvoid SpriteMushroom( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\r\n\tidx = y == 5.0 ? 43690.0 : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGround( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\r\n\tidx = y == 7.0 ? 1360.0  : idx;\r\n\tidx = y == 6.0 ? 6836.0  : idx;\r\n\tidx = y == 5.0 ? 27309.0 : idx;\r\n\tidx = y == 4.0 ? 27309.0 : idx;\r\n\tidx = y == 3.0 ? 27305.0 : idx;\r\n\tidx = y == 2.0 ? 27305.0 : idx;\r\n\tidx = y == 1.0 ? 6820.0  : idx;\r\n\tidx = y == 0.0 ? 1360.0  : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 3.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 4.0 )\r\n    {\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\r\n    }\r\n    else if ( frame == 5.0 )\r\n    {\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\r\n    }\r\n    else if ( frame == 6.0 )\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \r\n}\r\n\r\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n    }\r\n    \r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteBrick( inout vec3 color, float x, float y )\r\n{    \r\n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \r\n    float xmod8 = floor( mod( x, 8.0 ) );\r\n    float ymod8 = floor( mod( y, 8.0 ) );\r\n    \r\n    // dark orange\r\n    float idx = 2.0;\r\n   \r\n    // black\r\n    idx = ymod4 == 0.0 ? 1.0 : idx;\r\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\r\n\r\n    // light orange\r\n    idx = y == 15.0 ? 3.0 : idx;\r\n\r\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid DrawCastle( inout vec3 color, float x, float y )\r\n{\r\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\r\n\t{\r\n\t\tfloat ymod4    = mod( y, 4.0 );\r\n\t\tfloat xmod8    = mod( x, 8.0 );\r\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\r\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\r\n\t\tfloat ymod8    = mod( y, 8.0 );\r\n\r\n\t\t// dark orange\r\n\t\tfloat idx = 2.0;\r\n\r\n\t\t// black\r\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\r\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\r\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \r\n\r\n\t\t// white\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\r\n\r\n\t\t// transparent\r\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\r\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\r\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \r\n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\r\n\r\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\r\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n\t}\r\n}\r\n\r\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\r\n{\r\n    if ( x >= 0.0 && x <= 15.0 )\r\n    {\r\n        SpriteKoopa( color, x, y, frame );\r\n    }\r\n}\r\n\r\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\r\n{\r\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\r\n    DrawKoopa( color, x, worldY - 16.0, frame );    \r\n}\r\n\r\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\r\n{\r\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\r\n    t = 1.0 - abs( 2.0 * t - 1.0 );\r\n\r\n    questionY -= floor( t * 8.0 );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {            \r\n    \tif ( time >= questionHitTime )\r\n        {                \r\n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\r\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n            {\r\n                color = RGB( 231, 90, 16 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n         \tSpriteQuestion( color, questionX, questionY, questionT );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawW( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 || x >= 10.0 ) \r\n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawO( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\r\n             || ( x >= 2.0 && x <= 4.0 )\r\n             || ( x >= 9.0 && x <= 11.0 )\r\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawR( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 )\r\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\r\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\r\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\r\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\r\n             || ( x >= 8.0  && y <= 1.0 )\r\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawL( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( x <= 3.0 || y <= 1.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawD( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n    \tcolor = RGB( 255, 255, 255 );        \r\n        \r\n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \r\n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \r\n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\r\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\r\n           )\r\n        {\r\n            color = RGB( 0, 0, 0 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid Draw1( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( y <= 1.0 )\r\n             || ( x >= 5.0 && x <= 8.0 )\r\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawM( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( y >= 4.0 && y <= 7.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\r\n{\r\n    color = RGB( 0, 0, 0 );\r\n        \r\n    float offset \t= 18.0;     \r\n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\r\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\r\n    float marioX\t= textX - offset * 4.0;\r\n    float marioY\t= textY + 16.0 * 3.0;\r\n\t\r\n    DrawW( color, textX - offset * 0.0, textY );\r\n    DrawO( color, textX - offset * 1.0, textY );\r\n    DrawR( color, textX - offset * 2.0, textY );\r\n    DrawL( color, textX - offset * 3.0, textY );\r\n    DrawD( color, textX - offset * 4.0, textY );\r\n    Draw1( color, textX - offset * 6.0, textY );\r\n    DrawM( color, textX - offset * 7.0, textY );\r\n    Draw1( color, textX - offset * 8.0, textY );\r\n    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 )\r\n    {\r\n    \tSpriteMario( color, marioX, marioY, 4.0 );\r\n    }\r\n}\r\n\r\nfloat CoinAnimY( float worldY, float time, float coinTime )\r\n{\r\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\r\n}\r\n\r\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\r\n{\r\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\r\n}\r\n\r\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\r\n{\r\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\r\n}\r\n\r\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\r\n{\r\n    float mushroomPauseStart \t= 16.25;    \r\n    float mushroomPauseLength \t= 2.0;    \r\n    float flagPauseStart\t\t= 38.95;\r\n    float flagPauseLength\t\t= 1.5;\r\n\r\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\r\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\r\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\r\n    float worldX \t\t= pixelX + cameraX;\r\n    float worldY  \t\t= pixelY - 8.0;\r\n    float tileX\t\t\t= floor( worldX / 16.0 );\r\n    float tileY\t\t\t= floor( worldY / 16.0 );\r\n    float tile2X\t\t= floor( worldX / 32.0 );\r\n    float tile2Y\t\t= floor( worldY / 32.0 );    \r\n    float worldXMod16\t= mod( worldX, 16.0 );\r\n    float worldYMod16 \t= mod( worldY, 16.0 );\r\n\r\n\r\n    // default background color\r\n    color = RGB( 92, 148, 252 );\r\n\r\n    \r\n    // draw hills\r\n    float bigHillX \t = mod( worldX, 768.0 );\r\n    float smallHillX = mod( worldX - 240.0, 768.0 );\r\n    float hillX \t = min( bigHillX, smallHillX );\r\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\r\n    SpriteHill( color, hillX, hillY );\r\n\r\n\r\n    // draw clouds and bushes\r\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\r\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\r\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\r\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \r\n    float scCloudX  = min( sc1CloudX, sc2CloudX );\r\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\r\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \r\n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\r\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\r\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\r\n    float sCloudX\t= min( scCloudX, sbCloudX );\r\n    float mCloudX\t= min( mcCloudX, mbCloudX );\r\n    float lCloudX\t= min( lcCloudX, lbCloudX );\r\n    float cloudX\t= min( cCloudX, bCloudX );\r\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\r\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\r\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\r\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\r\n    {\r\n        if ( cloudSeg == 1.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\r\n        }\r\n        if ( cloudSeg == 2.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\r\n        }\r\n        \r\n    \tSpriteCloud( color, cloudX, cloudY, isBush );\r\n    }\r\n\r\n    \r\n    \r\n    // draw flag pole\r\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \r\n    {\r\n        color = RGB( 189, 255, 24 );\r\n    }\r\n    \r\n    // draw flag\r\n    float flagX = worldX - 3160.0;\r\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( flagX >= 0.0 && flagX <= 15.0 )\r\n    {\r\n    \tSpriteFlag( color, flagX, flagY );\r\n    }     \r\n    \r\n    // draw flagpole end\r\n    float flagpoleEndX = worldX - 3172.0;\r\n    float flagpoleEndY = worldY - 176.0;\r\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\r\n    {\r\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\r\n    }\r\n    \r\n    \r\n\r\n    // draw blocks\r\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\r\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\r\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\r\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \r\n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\r\n         || ( tileX == 198.0 && tileY == 1.0 )\r\n       )\r\n    {\r\n        SpriteBlock( color, worldXMod16, worldYMod16 );\r\n    }\r\n    \r\n    \r\n    // draw pipes\r\n    float pipeY = worldY - 16.0;  \r\n    float pipeH\t= 0.0;    \r\n    float pipeX = worldX - 179.0 * 16.0;\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 163.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 57.0 * 16.0;\r\n        pipeH = 2.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 46.0 * 16.0;\r\n        pipeH = 2.0;\r\n    } \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 38.0 * 16.0;\r\n        pipeH = 1.0;\r\n    }         \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 28.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\r\n\t{\r\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\r\n\t}\r\n    \r\n    \r\n    // draw mushroom\r\n    float mushroomStart = 15.7;    \r\n    if ( time >= mushroomStart && time <= 17.0 )\r\n    {\r\n        float jumpTime = 0.5;\r\n        \r\n        float mushroomX = worldX - 1248.0;\r\n        float mushroomY = worldY - 4.0 * 16.0;\r\n        if ( time >= mushroomStart )\r\n        {\r\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 )\r\n        {\r\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 + 0.4 )\r\n        {\r\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\r\n        }\r\n        \r\n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\r\n        {\r\n        \tSpriteMushroom( color, mushroomX, mushroomY );\r\n        }\r\n    }\r\n\r\n    \r\n    // draw coins\r\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\r\n    float coinX \t= worldX - 2720.0;\r\n    float coinTime \t= 33.9;    \r\n    float coinY \t= CoinAnimY( worldY, time, coinTime );\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 1696.0;\r\n    \tcoinTime \t= 22.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \r\n    }\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 352.0;\r\n    \tcoinTime \t= 5.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\r\n    } \r\n    \r\n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\r\n    {   \r\n        SpriteCoin( color, coinX, coinY, coinFrame );\r\n    }\r\n\r\n    \r\n    // draw questions\r\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \r\n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\r\n    }\r\n    \r\n    \r\n    // draw hitted questions\r\n    float questionHitTime \t= 33.9;\r\n    float questionX \t\t= worldX - 2720.0;\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 22.4;\r\n        questionX\t\t= worldX - 1696.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 15.4;\r\n        questionX\t\t= worldX - 1248.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 5.3;\r\n        questionX\t\t= worldX - 352.0;\r\n    }    \r\n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \r\n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {\r\n    \tSpriteQuestion( color, questionX, questionY, questionT );\r\n    }\r\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n    {\r\n        color = RGB( 231, 90, 16 );\r\n    }    \r\n\r\n    \r\n    // draw bricks\r\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteBrick( color, worldXMod16, worldYMod16 );\r\n    }   \r\n    \r\n    \r\n    // draw castle flag\r\n    float castleFlagX = worldX - 3264.0;\r\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\r\n    {\r\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\r\n\t}\r\n    \r\n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\r\n\r\n    // draw ground\r\n    if ( tileY <= 0.0\r\n         && !( tileX >= 69.0  && tileX < 71.0 )\r\n         && !( tileX >= 86.0  && tileX < 89.0 ) \r\n         && !( tileX >= 153.0 && tileX < 155.0 ) \r\n       )\r\n    {\r\n        SpriteGround( color, worldXMod16, worldYMod16 );\r\n    }    \r\n    \r\n\r\n    // draw Koopa\r\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\r\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\r\n    \r\n    \r\n    // draw stomped walking Goombas\r\n    float goombaY \t\t\t= worldY - 16.0;        \r\n    float goombaLifeTime \t= 26.3;\r\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 25.3;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n\t\tgoombaLifeTime \t= 23.5;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n        goombaLifeTime \t= 20.29;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 10.3;\r\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    }\r\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }    \r\n    \r\n    // draw walking Goombas\r\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\r\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\r\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }\r\n    \r\n\r\n    \r\n    // Mario jump\r\n    float marioBigJump1 \t= 27.1;\r\n    float marioBigJump2 \t= 29.75;\r\n    float marioBigJump3 \t= 35.05;    \r\n    float marioJumpTime \t= 0.0;\r\n    float marioJumpScale\t= 0.0;\r\n    \r\n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\r\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\r\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\r\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\r\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\r\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\r\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\r\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\r\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\r\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\r\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\r\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\r\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\r\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\r\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\r\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\r\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\r\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\r\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\r\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \r\n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\r\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\r\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\r\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\r\n    \r\n    float marioJumpOffset \t\t= 0.0;\r\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\r\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\r\n    {\r\n        float t = ( time - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n    \r\n    // Mario land\r\n    float marioLandTime \t= 0.0;\r\n    float marioLandAplitude = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\r\n    \r\n    float marioLandLength = marioLandAplitude / 120.0;\r\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\r\n    {\r\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\r\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\r\n    }\r\n    \r\n    \r\n    // Mario flag jump\r\n    marioJumpTime \t\t= flagPauseStart - 0.3;\r\n    marioJumpLength \t= 1.5  * 0.45;\r\n    marioJumpAmplitude\t= 76.0 * 0.45;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \r\n    {\r\n        float time2 = time;\r\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \r\n        {\r\n            time2 = flagPauseStart;\r\n        }\r\n        else if ( time >= flagPauseStart )\r\n        {\r\n            time2 = time - flagPauseLength;\r\n        }\r\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n\r\n    // Mario base (ground offset)\r\n    float marioBase = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }\r\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\r\n    {\r\n        marioBase = 16.0 * 3.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\r\n    {\r\n        marioBase = 16.0 * 7.0;\r\n    }\r\n\r\n    float marioX\t\t= pixelX - 112.0;\r\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \r\n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\r\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\r\n    {\r\n    \tmarioFrame = 1.0;\r\n    }    \r\n    if ( time > mushroomPauseStart + 0.7 )\r\n    {\r\n        float t = time - mushroomPauseStart - 0.7;\r\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\r\n        {\r\n            // super mario offset\r\n            marioFrame += 4.0;\r\n        }\r\n    }    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\r\n    {\r\n        SpriteMario( color, marioX, marioY, marioFrame );\r\n    }\r\n}\r\n\r\nvec2 CRTCurveUV( vec2 uv )\r\n{\r\n    uv = uv * 2.0 - 1.0;\r\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\r\n    uv = uv + uv * offset * offset;\r\n    uv = uv * 0.5 + 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid DrawVignette( inout vec3 color, vec2 uv )\r\n{    \r\n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\r\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\r\n    color *= vignette;\r\n}\r\n\r\nvoid DrawScanline( inout vec3 color, vec2 uv )\r\n{\r\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\r\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \r\n    color *= scanline * grille * 1.2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\r\n    float resMultX  = floor( iResolution.x / 224.0 );\r\n    float resMultY  = floor( iResolution.y / 192.0 );\r\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\r\n    \r\n    float time\t\t\t= iTime;\r\n    float screenWidth\t= floor( iResolution.x * resRcp );\r\n    float screenHeight\t= floor( iResolution.y * resRcp );\r\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\r\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\r\n\r\n    vec3 color = RGB( 92, 148, 252 );\r\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\r\n    if ( time < INTRO_LENGTH )\r\n    {\r\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\r\n    }    \r\n\r\n    \r\n    // CRT effects (curvature, vignette, scanlines and CRT grille)\r\n    vec2 uv    = fragCoord.xy / iResolution.xy;\r\n    vec2 crtUV = CRTCurveUV( uv );\r\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\r\n    {\r\n        color = vec3( 0.0, 0.0, 0.0 );\r\n    }\r\n    DrawVignette( color, crtUV );\r\n    DrawScanline( color, uv );\r\n    \r\n\tfragColor.xyz \t= color;\r\n    fragColor.w\t\t= 1.0;\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// simplification of https://www.shadertoy.com/view/lt2GDt\r\n// used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define H(n) fract( 1e4 * sin( n.x+n.y/.7 +vec2(1,12.34) ) )\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, p,c;\r\n    U = 5.* (U+U - R ) / R.y + iTime; \r\n    float l;\r\n    \r\n    O += 1e9-O;  // --- Worley noise: return O.xyz = sorted distance to first 3 nodes\r\n    for (int k=0; k<9; k++) // replace loops i,j: -1..1\r\n    { // windows Angle bug with ,, instead of {}\r\n                p = ceil(U) + vec2(k-k/3*3,k/3)-2., // cell id = floor(U)+vec2(i,j)\r\n                l = dot(c = H(p) + p-U , c);        // distance^2 to its node\r\n                  l < O.x  ? O.yz=O.xy, O.x=l       // ordered 3 min distances\r\n                : l < O.y  ? O.z =O.y , O.y=l \r\n                : l < O.z  ?            O.z=l : l;\r\n    }\r\n    O = 5.*sqrt(O); \r\n    \r\n    \r\n    // --- smooth distance to borders and nodes\r\n    \r\n // l = 1./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\r\n // O += smoothstep(.0,.3, l-.5) -O;\r\n    O -= O.x;  O += 4.*( O.y/(O.y/O.z+1.) - .5 ) - O;  // simplified form\r\n}","inputs":[],"outputs":[],"code":"// simplification of https://www.shadertoy.com/view/lt2GDt\r\n// used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define H(n) fract( 1e4 * sin( n.x+n.y/.7 +vec2(1,12.34) ) )\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, p,c;\r\n    U = 5.* (U+U - R ) / R.y + iTime; \r\n    float l;\r\n    \r\n    O += 1e9-O;  // --- Worley noise: return O.xyz = sorted distance to first 3 nodes\r\n    for (int k=0; k<9; k++) // replace loops i,j: -1..1\r\n    { // windows Angle bug with ,, instead of {}\r\n                p = ceil(U) + vec2(k-k/3*3,k/3)-2., // cell id = floor(U)+vec2(i,j)\r\n                l = dot(c = H(p) + p-U , c);        // distance^2 to its node\r\n                  l < O.x  ? O.yz=O.xy, O.x=l       // ordered 3 min distances\r\n                : l < O.y  ? O.z =O.y , O.y=l \r\n                : l < O.z  ?            O.z=l : l;\r\n    }\r\n    O = 5.*sqrt(O); \r\n    \r\n    \r\n    // --- smooth distance to borders and nodes\r\n    \r\n // l = 1./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\r\n // O += smoothstep(.0,.3, l-.5) -O;\r\n    O -= O.x;  O += 4.*( O.y/(O.y/O.z+1.) - .5 ) - O;  // simplified form\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"2D trabeculum","id":"8f2874314c8447419d13dfcdb8ca4e19","date":null,"viewed":0,"name":"2D trabeculum","description":"Voronoi diagram are nice, but for CG use several goodies are welcome. \nHere, I show how to make an organic look (no sharp angle), i.e., trabeculum patterns. \nhttps://www.shadertoy.com/view/4dKSDV","likes":0,"published":null,"tags":["procedural"," voronoi"," noise"," worley"," short"," trabeculum"]},"ver":null,"info":{"Name":"2D trabeculum","id":"8f2874314c8447419d13dfcdb8ca4e19","date":null,"viewed":0,"name":"2D trabeculum","description":"Voronoi diagram are nice, but for CG use several goodies are welcome. \nHere, I show how to make an organic look (no sharp angle), i.e., trabeculum patterns. \nhttps://www.shadertoy.com/view/4dKSDV","likes":0,"published":null,"tags":["procedural"," voronoi"," noise"," worley"," short"," trabeculum"]},"renderpass":[{"Code":"// simplification of https://www.shadertoy.com/view/lt2GDt\r\n// used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define H(n) fract( 1e4 * sin( n.x+n.y/.7 +vec2(1,12.34) ) )\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, p,c;\r\n    U = 5.* (U+U - R ) / R.y + iTime; \r\n    float l;\r\n    \r\n    O += 1e9-O;  // --- Worley noise: return O.xyz = sorted distance to first 3 nodes\r\n    for (int k=0; k<9; k++) // replace loops i,j: -1..1\r\n    { // windows Angle bug with ,, instead of {}\r\n                p = ceil(U) + vec2(k-k/3*3,k/3)-2., // cell id = floor(U)+vec2(i,j)\r\n                l = dot(c = H(p) + p-U , c);        // distance^2 to its node\r\n                  l < O.x  ? O.yz=O.xy, O.x=l       // ordered 3 min distances\r\n                : l < O.y  ? O.z =O.y , O.y=l \r\n                : l < O.z  ?            O.z=l : l;\r\n    }\r\n    O = 5.*sqrt(O); \r\n    \r\n    \r\n    // --- smooth distance to borders and nodes\r\n    \r\n // l = 1./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\r\n // O += smoothstep(.0,.3, l-.5) -O;\r\n    O -= O.x;  O += 4.*( O.y/(O.y/O.z+1.) - .5 ) - O;  // simplified form\r\n}","inputs":[],"outputs":[],"code":"// simplification of https://www.shadertoy.com/view/lt2GDt\r\n// used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define H(n) fract( 1e4 * sin( n.x+n.y/.7 +vec2(1,12.34) ) )\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, p,c;\r\n    U = 5.* (U+U - R ) / R.y + iTime; \r\n    float l;\r\n    \r\n    O += 1e9-O;  // --- Worley noise: return O.xyz = sorted distance to first 3 nodes\r\n    for (int k=0; k<9; k++) // replace loops i,j: -1..1\r\n    { // windows Angle bug with ,, instead of {}\r\n                p = ceil(U) + vec2(k-k/3*3,k/3)-2., // cell id = floor(U)+vec2(i,j)\r\n                l = dot(c = H(p) + p-U , c);        // distance^2 to its node\r\n                  l < O.x  ? O.yz=O.xy, O.x=l       // ordered 3 min distances\r\n                : l < O.y  ? O.z =O.y , O.y=l \r\n                : l < O.z  ?            O.z=l : l;\r\n    }\r\n    O = 5.*sqrt(O); \r\n    \r\n    \r\n    // --- smooth distance to borders and nodes\r\n    \r\n // l = 1./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\r\n // O += smoothstep(.0,.3, l-.5) -O;\r\n    O -= O.x;  O += 4.*( O.y/(O.y/O.z+1.) - .5 ) - O;  // simplified form\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// better trabeculum ( compare to https://www.shadertoy.com/view/4dKSDV )\r\n// relying on simplification ( cf https://www.shadertoy.com/view/llGGDw )\r\n// of IQ's Voronoi distance https://www.shadertoy.com/view/ldl3W8\r\n\r\n#define ANIMATE\r\n\r\nvec2 hash2( vec2 p )\r\n{\r\n\t// texture based white noise\r\n\t//return texture( iChannel0, (p+.5)/256., -100. ).xy;\r\n\t\r\n    // procedural white noise\t\r\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\r\n}\r\n\r\nvec2 dist(vec2 g, vec2 x) {\r\n    vec2 n = floor(x), f = fract(x),\r\n         o = hash2( n + g );\r\n\t#ifdef ANIMATE\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 voronoi( vec2 x )\r\n{\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec2 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec2  g = vec2(i,j), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    md = 8.;\r\n    for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ ) {\r\n            vec2 g = mg + vec2(i,j),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d = dot( .5*(mr+r), normalize(r-mr) );\r\n                if ( d < md ) md3=md2, md2=md, md=d;\r\n                else if (d < md2 ) md3 = md2, md2=d;\r\n                else  if (d < md3 ) md3 = d;\r\n            }\r\n        }\r\n  //return vec3( md, md2, md3 );           // 3 distances to border: useful in 3D\r\n    return vec4( md, md2, mr );            // 2 distances to border + seed pos\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 p )\r\n{\r\n    p /= iResolution.x;\r\n\r\n    vec4 c = voronoi( 8.*p );\r\n    float d = c.x;              // original IQ's constant border width Vorono\u00EF \r\n    d = 2./(1./c.x+1./c.y);     // trabeculum distance adapted from https://www.shadertoy.com/view/4dKSDV\r\n                                // ( Formula (c) Fabrice NEYRET - BSD3:mention author. )\r\n    // d = 2./(1./c.y+1./c.z);  // 3D\r\n    //float K = 1.3; d = pow( (pow(c.x,-K)+pow(c.y,-K))/5., -K );\r\n    //float K = .7; d = pow( (pow(c.x,-K)+pow(c.y,-K))*2., -K );\r\n    \r\n\t// isolines\r\n    vec3 col = vec3(d)*(.5 + .5*sin(64.*d));\r\n    // borders\t\r\n  //col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d*(1.+.5*sin(iTime)) ) );\r\n    col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d-.06-.1*sin(iTime) ) );\r\n\r\n    // feature points\r\n\tfloat dd = length( c.zw );\r\n\tcol =   mix( vec3(1,.6,.1), col, smoothstep( .0, .12, dd) )\r\n\t      + vec3(1,.6,.1)*smoothstep( .04, .0, dd);\r\n\r\n\tO = vec4(col,1.);\r\n}\r\n","inputs":[],"outputs":[],"code":"// better trabeculum ( compare to https://www.shadertoy.com/view/4dKSDV )\r\n// relying on simplification ( cf https://www.shadertoy.com/view/llGGDw )\r\n// of IQ's Voronoi distance https://www.shadertoy.com/view/ldl3W8\r\n\r\n#define ANIMATE\r\n\r\nvec2 hash2( vec2 p )\r\n{\r\n\t// texture based white noise\r\n\t//return texture( iChannel0, (p+.5)/256., -100. ).xy;\r\n\t\r\n    // procedural white noise\t\r\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\r\n}\r\n\r\nvec2 dist(vec2 g, vec2 x) {\r\n    vec2 n = floor(x), f = fract(x),\r\n         o = hash2( n + g );\r\n\t#ifdef ANIMATE\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 voronoi( vec2 x )\r\n{\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec2 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec2  g = vec2(i,j), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    md = 8.;\r\n    for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ ) {\r\n            vec2 g = mg + vec2(i,j),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d = dot( .5*(mr+r), normalize(r-mr) );\r\n                if ( d < md ) md3=md2, md2=md, md=d;\r\n                else if (d < md2 ) md3 = md2, md2=d;\r\n                else  if (d < md3 ) md3 = d;\r\n            }\r\n        }\r\n  //return vec3( md, md2, md3 );           // 3 distances to border: useful in 3D\r\n    return vec4( md, md2, mr );            // 2 distances to border + seed pos\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 p )\r\n{\r\n    p /= iResolution.x;\r\n\r\n    vec4 c = voronoi( 8.*p );\r\n    float d = c.x;              // original IQ's constant border width Vorono\u00EF \r\n    d = 2./(1./c.x+1./c.y);     // trabeculum distance adapted from https://www.shadertoy.com/view/4dKSDV\r\n                                // ( Formula (c) Fabrice NEYRET - BSD3:mention author. )\r\n    // d = 2./(1./c.y+1./c.z);  // 3D\r\n    //float K = 1.3; d = pow( (pow(c.x,-K)+pow(c.y,-K))/5., -K );\r\n    //float K = .7; d = pow( (pow(c.x,-K)+pow(c.y,-K))*2., -K );\r\n    \r\n\t// isolines\r\n    vec3 col = vec3(d)*(.5 + .5*sin(64.*d));\r\n    // borders\t\r\n  //col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d*(1.+.5*sin(iTime)) ) );\r\n    col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d-.06-.1*sin(iTime) ) );\r\n\r\n    // feature points\r\n\tfloat dd = length( c.zw );\r\n\tcol =   mix( vec3(1,.6,.1), col, smoothstep( .0, .12, dd) )\r\n\t      + vec3(1,.6,.1)*smoothstep( .04, .0, dd);\r\n\r\n\tO = vec4(col,1.);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"2D trabeculum - 2","id":"e468274b143a49b8b519b65a5eabb9a5","date":null,"viewed":0,"name":"2D trabeculum - 2","description":"Voronoi diagram are nice, but for CG use several goodies are welcome. \nIQ shown how to regularize the distance to border. \nI shown how to make an organic look (no sharp angle), i.e., trabeculum patterns. \nHere, I join both ideas.\nhttps://www.shadertoy.com/view/MlGGDw","likes":0,"published":null,"tags":["procedural"," 2d"," voronoi"," noise"," worley"," short"," trabeculum"]},"ver":null,"info":{"Name":"2D trabeculum - 2","id":"e468274b143a49b8b519b65a5eabb9a5","date":null,"viewed":0,"name":"2D trabeculum - 2","description":"Voronoi diagram are nice, but for CG use several goodies are welcome. \nIQ shown how to regularize the distance to border. \nI shown how to make an organic look (no sharp angle), i.e., trabeculum patterns. \nHere, I join both ideas.\nhttps://www.shadertoy.com/view/MlGGDw","likes":0,"published":null,"tags":["procedural"," 2d"," voronoi"," noise"," worley"," short"," trabeculum"]},"renderpass":[{"Code":"// better trabeculum ( compare to https://www.shadertoy.com/view/4dKSDV )\r\n// relying on simplification ( cf https://www.shadertoy.com/view/llGGDw )\r\n// of IQ's Voronoi distance https://www.shadertoy.com/view/ldl3W8\r\n\r\n#define ANIMATE\r\n\r\nvec2 hash2( vec2 p )\r\n{\r\n\t// texture based white noise\r\n\t//return texture( iChannel0, (p+.5)/256., -100. ).xy;\r\n\t\r\n    // procedural white noise\t\r\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\r\n}\r\n\r\nvec2 dist(vec2 g, vec2 x) {\r\n    vec2 n = floor(x), f = fract(x),\r\n         o = hash2( n + g );\r\n\t#ifdef ANIMATE\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 voronoi( vec2 x )\r\n{\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec2 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec2  g = vec2(i,j), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    md = 8.;\r\n    for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ ) {\r\n            vec2 g = mg + vec2(i,j),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d = dot( .5*(mr+r), normalize(r-mr) );\r\n                if ( d < md ) md3=md2, md2=md, md=d;\r\n                else if (d < md2 ) md3 = md2, md2=d;\r\n                else  if (d < md3 ) md3 = d;\r\n            }\r\n        }\r\n  //return vec3( md, md2, md3 );           // 3 distances to border: useful in 3D\r\n    return vec4( md, md2, mr );            // 2 distances to border + seed pos\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 p )\r\n{\r\n    p /= iResolution.x;\r\n\r\n    vec4 c = voronoi( 8.*p );\r\n    float d = c.x;              // original IQ's constant border width Vorono\u00EF \r\n    d = 2./(1./c.x+1./c.y);     // trabeculum distance adapted from https://www.shadertoy.com/view/4dKSDV\r\n                                // ( Formula (c) Fabrice NEYRET - BSD3:mention author. )\r\n    // d = 2./(1./c.y+1./c.z);  // 3D\r\n    //float K = 1.3; d = pow( (pow(c.x,-K)+pow(c.y,-K))/5., -K );\r\n    //float K = .7; d = pow( (pow(c.x,-K)+pow(c.y,-K))*2., -K );\r\n    \r\n\t// isolines\r\n    vec3 col = vec3(d)*(.5 + .5*sin(64.*d));\r\n    // borders\t\r\n  //col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d*(1.+.5*sin(iTime)) ) );\r\n    col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d-.06-.1*sin(iTime) ) );\r\n\r\n    // feature points\r\n\tfloat dd = length( c.zw );\r\n\tcol =   mix( vec3(1,.6,.1), col, smoothstep( .0, .12, dd) )\r\n\t      + vec3(1,.6,.1)*smoothstep( .04, .0, dd);\r\n\r\n\tO = vec4(col,1.);\r\n}\r\n","inputs":[],"outputs":[],"code":"// better trabeculum ( compare to https://www.shadertoy.com/view/4dKSDV )\r\n// relying on simplification ( cf https://www.shadertoy.com/view/llGGDw )\r\n// of IQ's Voronoi distance https://www.shadertoy.com/view/ldl3W8\r\n\r\n#define ANIMATE\r\n\r\nvec2 hash2( vec2 p )\r\n{\r\n\t// texture based white noise\r\n\t//return texture( iChannel0, (p+.5)/256., -100. ).xy;\r\n\t\r\n    // procedural white noise\t\r\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\r\n}\r\n\r\nvec2 dist(vec2 g, vec2 x) {\r\n    vec2 n = floor(x), f = fract(x),\r\n         o = hash2( n + g );\r\n\t#ifdef ANIMATE\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 voronoi( vec2 x )\r\n{\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec2 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec2  g = vec2(i,j), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    md = 8.;\r\n    for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ ) {\r\n            vec2 g = mg + vec2(i,j),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d = dot( .5*(mr+r), normalize(r-mr) );\r\n                if ( d < md ) md3=md2, md2=md, md=d;\r\n                else if (d < md2 ) md3 = md2, md2=d;\r\n                else  if (d < md3 ) md3 = d;\r\n            }\r\n        }\r\n  //return vec3( md, md2, md3 );           // 3 distances to border: useful in 3D\r\n    return vec4( md, md2, mr );            // 2 distances to border + seed pos\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 p )\r\n{\r\n    p /= iResolution.x;\r\n\r\n    vec4 c = voronoi( 8.*p );\r\n    float d = c.x;              // original IQ's constant border width Vorono\u00EF \r\n    d = 2./(1./c.x+1./c.y);     // trabeculum distance adapted from https://www.shadertoy.com/view/4dKSDV\r\n                                // ( Formula (c) Fabrice NEYRET - BSD3:mention author. )\r\n    // d = 2./(1./c.y+1./c.z);  // 3D\r\n    //float K = 1.3; d = pow( (pow(c.x,-K)+pow(c.y,-K))/5., -K );\r\n    //float K = .7; d = pow( (pow(c.x,-K)+pow(c.y,-K))*2., -K );\r\n    \r\n\t// isolines\r\n    vec3 col = vec3(d)*(.5 + .5*sin(64.*d));\r\n    // borders\t\r\n  //col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d*(1.+.5*sin(iTime)) ) );\r\n    col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d-.06-.1*sin(iTime) ) );\r\n\r\n    // feature points\r\n\tfloat dd = length( c.zw );\r\n\tcol =   mix( vec3(1,.6,.1), col, smoothstep( .0, .12, dd) )\r\n\t      + vec3(1,.6,.1)*smoothstep( .04, .0, dd);\r\n\r\n\tO = vec4(col,1.);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// **************************************************************************\r\n// Alcatraz - Equilibrium - 4K intro \r\n// by Jochen \"Virgill\" Feldk\u00F6tter (jochen.feldkoetter{a}osnanet.de)\r\n//\r\n// 4kb executable: \thttp://www.pouet.net/prod.php?which=71136\r\n// Youtube: \t\thttps://www.youtube.com/watch?v=T6ulp8b8eHw\r\n// Soundtrack:\t\thttps://soundcloud.com/virgill/virgill-4klang-equilibrium\r\n// **************************************************************************\r\n\r\n\r\nint scene_idx =0;\t\t// scene  0      1     2     3       4     5        6     7      8     9         10    11   12   13      14\r\nfloat scenes_x[15] = float[15] (-0.35,  5.9, -3.2, -1.0 ,  8.0,   0.0,    -1.2, -0.3,  -1.3,  -0.4,     -4.2,  0.0, 1.8, 0.0,     2. );\r\nfloat scenes_y[15] = float[15] (-0.61,  0.7, -3.0,  0.1,   2.6,   4.5,    -0.5, -3.0,  -0.5,   0.1,      2.5,  3.0, 1.0, 3.0,    -3. );\r\nfloat duration = 15.; \r\nfloat time=0.;\r\n\r\n// cubemap (IQ)\r\nvec4 boxmap(sampler2D sam,vec3 p,vec3 n)\r\n{\r\n    vec3 m = pow(abs(n), vec3(32.) );\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\r\n}\r\n\r\n// noise\r\nfloat rnd(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\r\n}\r\n\r\n// signed box\r\nfloat sdBox(vec3 p,vec3 b)\r\n{\r\n  vec3 d = abs(p)-b;\r\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\r\n}\r\n\r\n// rotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n// 3D noise function (shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip = floor(p);\r\n    p -= ip; \r\n    vec3 s = vec3(7,157,113);\r\n    vec4 h = vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p = p*p*(3.-2.*p); \r\n    h = mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\r\n    h.xy = mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\nfloat map(vec3 p)\r\n{\t\r\n\tif (scene_idx>9&&scene_idx<14) \r\n    {\r\n\t\tfloat a = sdBox(p,vec3(1.2,1.5,2.))-0.1;\r\n    \tpR(p.yz,0.2*time);\r\n    \treturn max(a,-sdBox(p,vec3(0.9,0.5,.1))+0.04);\r\n    }\r\n    float displace = 0.001*noise(15.*p+time); \r\n    if (scene_idx == 8 || scene_idx == 9) displace = 0.005*noise(10.*p+time)+0.005*sin(10.*p.x+3.*time)+0.002*sin(14.*p.y+4.*time); //!!!!!!!!!!!!!!!\r\n    if (scene_idx < 4 || (scene_idx > 5 && scene_idx < 10)) return sdBox(p,vec3(1.,1.,1.))-0.4+displace; // box ///////////// vec3 1.1.1\r\n    return length(p)-2.0+0.5*noise(1.5*p-0.02*time);     \r\n}\r\n\r\n// normal calculation\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps = 0.0001;\r\n\tfloat d = map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\n\r\n// sphere tracing inside\r\nfloat castRayx(vec3 ro,vec3 rd) \r\n{\r\n    float precis = .0001;\r\n    float h = precis*2.;\r\n    float t = 0.;\r\n\tfor(int i=0;i<100;i++) \r\n\t{\r\n        if(abs(h)<precis||t>12.)break;\r\n\t\th = -map(ro+rd*t); \r\n        t += h;\r\n\t}\r\n    return t;\r\n}\r\n\r\n// refraction\r\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\r\n{\r\n    float h = 0.;\r\n    t2 = 2.;\r\n\tvec3 dir2 = refract(dir,nor,angle);  \r\n \tfor(int i=0;i<50;i++) \r\n\t{\r\n\t\tif(abs(h)>3.) break;\r\n\t\th = map(pos+dir2*t2);\r\n\t\tt2 -= h;\r\n\t}\r\n    nor2 = calcNormal(pos+dir2*t2);\r\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\r\n}\r\n\r\n// softshadow \r\nfloat softshadow(vec3 ro,vec3 rd) \r\n{\r\n    float sh = 1.;\r\n    float t = .02;\r\n    float h = .0;\r\n    for(int i=0;i<12;i++)  \r\n\t{\r\n        if(t>20.)continue;\r\n        h = map(ro+rd*t);\r\n        sh = min(sh,4.*h/t);\r\n        t += h;\r\n    }\r\n    return sh;\r\n}\r\n\r\n// *********************************************************************************************************\r\n\r\n// main function\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{    \r\n \r\n// time handling    \r\n\ttime=iTime*1.;\r\n\tif (iTime>150.&&iTime<=165.) time=(iTime-150.)*4.+150.;\r\n\tif (iTime>165.) time=iTime+60.;\r\n// scene handling   \r\n    scene_idx = int(floor(time/duration));\r\n    vec2 scene=vec2(scenes_x[scene_idx],scenes_y[scene_idx]); \r\n    \r\n// camera    \r\n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, iResolution.y)),org = vec3(0,0,1.);  \r\n    if (scene_idx==10||scene_idx==12||scene_idx>=14) dir+=0.01*rnd(vec2(time,time)); //stutter\r\n\r\n    \r\n// try this :P\r\n   //scene = iMouse.yx*0.02;\r\n\r\n    pR(dir.zy,scene.x+.8*sin(.02*time));\r\n    pR(dir.xz,scene.y+.8*cos(.05*time-1.));\r\n    \r\n// standard sphere tracing inside an object\r\n    vec3 color,color2 =  vec3(0.);\r\n    float t = castRayx(org,dir);\r\n\tvec3 pos = org+dir*t;\r\n\tvec3 nor = calcNormal(pos);\r\n\r\n// lighting:\r\n    vec3 lig = normalize(vec3(-.2,-6.,.5));\r\n\r\n// scene depth    \r\n    float depth = clamp((1.-0.09*t),0.,1.);\r\n     \r\n    vec3 pos2,nor2 = vec3(0.);\r\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.))*clamp(softshadow(pos,lig),0.,1.);\r\n    \tfloat t2;\r\n\t\tcolor2.b += refr(pos,lig,dir,nor,0.92, t2, nor2)*depth;\r\n    \tcolor2.g += refr(pos,lig,dir,nor,0.90, t2, nor2)*depth;\r\n    \tcolor2.r += refr(pos,lig,dir,nor,0.88, t2, nor2)*depth;\r\n  \t\tcolor2 -= clamp(.1*t2,0.,1.);\t\t\r\n\t    \r\n// texture\r\n        color2 += 0.7*boxmap(iChannel0,0.25*pos+0.5,nor).xyz; \r\n        color2 *= depth; \r\n  \r\n// glow intensity    \r\n    float tmp = 0., T = 1.;\r\n    float intensity = 0.1*-sin(.5*time)-0.05; \r\n\tfor(int i=0; i<32; i++)\r\n\t{\r\n        float nebula = noise(org);\r\n        float density = intensity-map(org+.5*nor2)*nebula;\r\n\t\tif(density>0.)\r\n\t\t{\r\n\t\t\ttmp = density / 128.;\r\n            T *= 1. -tmp * 100.;\r\n\t\t}\r\n\t\torg += dir*0.078;\r\n    }    \r\n\tvec3 basecol = vec3(1.,.35,1./16.);\t\r\n  \r\n    T = clamp(T,0.,1.5); \r\n    color += basecol* exp(4.*(0.5-T) - 0.8);\r\n    color -= vec3(1.1,.015,.06);\r\n  \r\n\r\n    vec3 object = vec3(0.1*color+0.8*color2)*1.3;    \r\n    \r\n    vec2 uv = 0.5-fragCoord.xy/iResolution.xy ; \r\n\r\n    // feedbak noise  \r\n    uv*=0.996;\r\n  \tuv=0.5-uv; \r\n   \tuv.x-=0.005*noise(uv.yxx*32.-time)-0.0025;\r\n   \tuv.y+=0.005*noise(uv.yxx*32.+time)-0.0025; \r\n  \r\n    vec3 bufa= texture(iChannel0,uv).xyz;\r\n\r\n    float saw = mod(time/duration,1.);\r\n    float powsaw = pow(saw,32.); \t\t\t\t\t\r\n \tfloat fade0 =  clamp(mod(1.*time,1.*duration),0.,1.); \t// fade in\r\n    float fade1 =  exp(32.* -powsaw)*fade0; \t\t\t\t// fade out      \r\n    float parabola = 0.75;\r\n    if (scene_idx == 1 || (scene_idx >= 4 && scene_idx<=7) || scene_idx>=9) parabola = 0.8-pow(4.*saw*(1.-saw),2.)*0.6;\r\n    if (scene_idx >13)  parabola=clamp(saw+0.3,0.,0.99);\r\n       \r\n    \r\n // noise   \r\n\tobject += 0.25*(0.5-rnd(uv.xy*time))*parabola;\t\t\t//noise  \r\n    if (scene_idx>3) object -= 0.04*rnd(vec2(time,time));   //flutter    \r\n    \r\n    if (iTime>180.) {object = vec3(0); bufa=vec3(0);}\r\n\r\n    fragColor = clamp(vec4(mix(object,bufa,parabola)*fade1,0.),0.,1.0);   \r\n\r\n \r\n    \r\n    \r\n\r\n}\r\n\r\n\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"// **************************************************************************\r\n// Alcatraz - Equilibrium - 4K intro \r\n// by Jochen \"Virgill\" Feldk\u00F6tter (jochen.feldkoetter{a}osnanet.de)\r\n//\r\n// 4kb executable: \thttp://www.pouet.net/prod.php?which=71136\r\n// Youtube: \t\thttps://www.youtube.com/watch?v=T6ulp8b8eHw\r\n// Soundtrack:\t\thttps://soundcloud.com/virgill/virgill-4klang-equilibrium\r\n// **************************************************************************\r\n\r\n\r\nint scene_idx =0;\t\t// scene  0      1     2     3       4     5        6     7      8     9         10    11   12   13      14\r\nfloat scenes_x[15] = float[15] (-0.35,  5.9, -3.2, -1.0 ,  8.0,   0.0,    -1.2, -0.3,  -1.3,  -0.4,     -4.2,  0.0, 1.8, 0.0,     2. );\r\nfloat scenes_y[15] = float[15] (-0.61,  0.7, -3.0,  0.1,   2.6,   4.5,    -0.5, -3.0,  -0.5,   0.1,      2.5,  3.0, 1.0, 3.0,    -3. );\r\nfloat duration = 15.; \r\nfloat time=0.;\r\n\r\n// cubemap (IQ)\r\nvec4 boxmap(sampler2D sam,vec3 p,vec3 n)\r\n{\r\n    vec3 m = pow(abs(n), vec3(32.) );\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\r\n}\r\n\r\n// noise\r\nfloat rnd(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\r\n}\r\n\r\n// signed box\r\nfloat sdBox(vec3 p,vec3 b)\r\n{\r\n  vec3 d = abs(p)-b;\r\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\r\n}\r\n\r\n// rotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n// 3D noise function (shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip = floor(p);\r\n    p -= ip; \r\n    vec3 s = vec3(7,157,113);\r\n    vec4 h = vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p = p*p*(3.-2.*p); \r\n    h = mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\r\n    h.xy = mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\nfloat map(vec3 p)\r\n{\t\r\n\tif (scene_idx>9&&scene_idx<14) \r\n    {\r\n\t\tfloat a = sdBox(p,vec3(1.2,1.5,2.))-0.1;\r\n    \tpR(p.yz,0.2*time);\r\n    \treturn max(a,-sdBox(p,vec3(0.9,0.5,.1))+0.04);\r\n    }\r\n    float displace = 0.001*noise(15.*p+time); \r\n    if (scene_idx == 8 || scene_idx == 9) displace = 0.005*noise(10.*p+time)+0.005*sin(10.*p.x+3.*time)+0.002*sin(14.*p.y+4.*time); //!!!!!!!!!!!!!!!\r\n    if (scene_idx < 4 || (scene_idx > 5 && scene_idx < 10)) return sdBox(p,vec3(1.,1.,1.))-0.4+displace; // box ///////////// vec3 1.1.1\r\n    return length(p)-2.0+0.5*noise(1.5*p-0.02*time);     \r\n}\r\n\r\n// normal calculation\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps = 0.0001;\r\n\tfloat d = map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\n\r\n// sphere tracing inside\r\nfloat castRayx(vec3 ro,vec3 rd) \r\n{\r\n    float precis = .0001;\r\n    float h = precis*2.;\r\n    float t = 0.;\r\n\tfor(int i=0;i<100;i++) \r\n\t{\r\n        if(abs(h)<precis||t>12.)break;\r\n\t\th = -map(ro+rd*t); \r\n        t += h;\r\n\t}\r\n    return t;\r\n}\r\n\r\n// refraction\r\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\r\n{\r\n    float h = 0.;\r\n    t2 = 2.;\r\n\tvec3 dir2 = refract(dir,nor,angle);  \r\n \tfor(int i=0;i<50;i++) \r\n\t{\r\n\t\tif(abs(h)>3.) break;\r\n\t\th = map(pos+dir2*t2);\r\n\t\tt2 -= h;\r\n\t}\r\n    nor2 = calcNormal(pos+dir2*t2);\r\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\r\n}\r\n\r\n// softshadow \r\nfloat softshadow(vec3 ro,vec3 rd) \r\n{\r\n    float sh = 1.;\r\n    float t = .02;\r\n    float h = .0;\r\n    for(int i=0;i<12;i++)  \r\n\t{\r\n        if(t>20.)continue;\r\n        h = map(ro+rd*t);\r\n        sh = min(sh,4.*h/t);\r\n        t += h;\r\n    }\r\n    return sh;\r\n}\r\n\r\n// *********************************************************************************************************\r\n\r\n// main function\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{    \r\n \r\n// time handling    \r\n\ttime=iTime*1.;\r\n\tif (iTime>150.&&iTime<=165.) time=(iTime-150.)*4.+150.;\r\n\tif (iTime>165.) time=iTime+60.;\r\n// scene handling   \r\n    scene_idx = int(floor(time/duration));\r\n    vec2 scene=vec2(scenes_x[scene_idx],scenes_y[scene_idx]); \r\n    \r\n// camera    \r\n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, iResolution.y)),org = vec3(0,0,1.);  \r\n    if (scene_idx==10||scene_idx==12||scene_idx>=14) dir+=0.01*rnd(vec2(time,time)); //stutter\r\n\r\n    \r\n// try this :P\r\n   //scene = iMouse.yx*0.02;\r\n\r\n    pR(dir.zy,scene.x+.8*sin(.02*time));\r\n    pR(dir.xz,scene.y+.8*cos(.05*time-1.));\r\n    \r\n// standard sphere tracing inside an object\r\n    vec3 color,color2 =  vec3(0.);\r\n    float t = castRayx(org,dir);\r\n\tvec3 pos = org+dir*t;\r\n\tvec3 nor = calcNormal(pos);\r\n\r\n// lighting:\r\n    vec3 lig = normalize(vec3(-.2,-6.,.5));\r\n\r\n// scene depth    \r\n    float depth = clamp((1.-0.09*t),0.,1.);\r\n     \r\n    vec3 pos2,nor2 = vec3(0.);\r\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.))*clamp(softshadow(pos,lig),0.,1.);\r\n    \tfloat t2;\r\n\t\tcolor2.b += refr(pos,lig,dir,nor,0.92, t2, nor2)*depth;\r\n    \tcolor2.g += refr(pos,lig,dir,nor,0.90, t2, nor2)*depth;\r\n    \tcolor2.r += refr(pos,lig,dir,nor,0.88, t2, nor2)*depth;\r\n  \t\tcolor2 -= clamp(.1*t2,0.,1.);\t\t\r\n\t    \r\n// texture\r\n        color2 += 0.7*boxmap(iChannel0,0.25*pos+0.5,nor).xyz; \r\n        color2 *= depth; \r\n  \r\n// glow intensity    \r\n    float tmp = 0., T = 1.;\r\n    float intensity = 0.1*-sin(.5*time)-0.05; \r\n\tfor(int i=0; i<32; i++)\r\n\t{\r\n        float nebula = noise(org);\r\n        float density = intensity-map(org+.5*nor2)*nebula;\r\n\t\tif(density>0.)\r\n\t\t{\r\n\t\t\ttmp = density / 128.;\r\n            T *= 1. -tmp * 100.;\r\n\t\t}\r\n\t\torg += dir*0.078;\r\n    }    \r\n\tvec3 basecol = vec3(1.,.35,1./16.);\t\r\n  \r\n    T = clamp(T,0.,1.5); \r\n    color += basecol* exp(4.*(0.5-T) - 0.8);\r\n    color -= vec3(1.1,.015,.06);\r\n  \r\n\r\n    vec3 object = vec3(0.1*color+0.8*color2)*1.3;    \r\n    \r\n    vec2 uv = 0.5-fragCoord.xy/iResolution.xy ; \r\n\r\n    // feedbak noise  \r\n    uv*=0.996;\r\n  \tuv=0.5-uv; \r\n   \tuv.x-=0.005*noise(uv.yxx*32.-time)-0.0025;\r\n   \tuv.y+=0.005*noise(uv.yxx*32.+time)-0.0025; \r\n  \r\n    vec3 bufa= texture(iChannel0,uv).xyz;\r\n\r\n    float saw = mod(time/duration,1.);\r\n    float powsaw = pow(saw,32.); \t\t\t\t\t\r\n \tfloat fade0 =  clamp(mod(1.*time,1.*duration),0.,1.); \t// fade in\r\n    float fade1 =  exp(32.* -powsaw)*fade0; \t\t\t\t// fade out      \r\n    float parabola = 0.75;\r\n    if (scene_idx == 1 || (scene_idx >= 4 && scene_idx<=7) || scene_idx>=9) parabola = 0.8-pow(4.*saw*(1.-saw),2.)*0.6;\r\n    if (scene_idx >13)  parabola=clamp(saw+0.3,0.,0.99);\r\n       \r\n    \r\n // noise   \r\n\tobject += 0.25*(0.5-rnd(uv.xy*time))*parabola;\t\t\t//noise  \r\n    if (scene_idx>3) object -= 0.04*rnd(vec2(time,time));   //flutter    \r\n    \r\n    if (iTime>180.) {object = vec3(0); bufa=vec3(0);}\r\n\r\n    fragColor = clamp(vec4(mix(object,bufa,parabola)*fade1,0.),0.,1.0);   \r\n\r\n \r\n    \r\n    \r\n\r\n}\r\n\r\n\r\n\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Alcatraz - Equilibrium","id":"0cc35efa89e945a3a369b669d0a49937","date":null,"viewed":0,"name":"Alcatraz - Equilibrium","description":"Equilibrium 4k intro","likes":0,"published":null,"tags":["noise"," intro"," 4k"," demoscene"," fog"," spheretracing"," glow"," feedback"," colorsplit"]},"ver":null,"info":{"Name":"Alcatraz - Equilibrium","id":"0cc35efa89e945a3a369b669d0a49937","date":null,"viewed":0,"name":"Alcatraz - Equilibrium","description":"Equilibrium 4k intro","likes":0,"published":null,"tags":["noise"," intro"," 4k"," demoscene"," fog"," spheretracing"," glow"," feedback"," colorsplit"]},"renderpass":[{"Code":"// **************************************************************************\r\n// Alcatraz - Equilibrium - 4K intro \r\n// by Jochen \"Virgill\" Feldk\u00F6tter (jochen.feldkoetter{a}osnanet.de)\r\n//\r\n// 4kb executable: \thttp://www.pouet.net/prod.php?which=71136\r\n// Youtube: \t\thttps://www.youtube.com/watch?v=T6ulp8b8eHw\r\n// Soundtrack:\t\thttps://soundcloud.com/virgill/virgill-4klang-equilibrium\r\n// **************************************************************************\r\n\r\n\r\nint scene_idx =0;\t\t// scene  0      1     2     3       4     5        6     7      8     9         10    11   12   13      14\r\nfloat scenes_x[15] = float[15] (-0.35,  5.9, -3.2, -1.0 ,  8.0,   0.0,    -1.2, -0.3,  -1.3,  -0.4,     -4.2,  0.0, 1.8, 0.0,     2. );\r\nfloat scenes_y[15] = float[15] (-0.61,  0.7, -3.0,  0.1,   2.6,   4.5,    -0.5, -3.0,  -0.5,   0.1,      2.5,  3.0, 1.0, 3.0,    -3. );\r\nfloat duration = 15.; \r\nfloat time=0.;\r\n\r\n// cubemap (IQ)\r\nvec4 boxmap(sampler2D sam,vec3 p,vec3 n)\r\n{\r\n    vec3 m = pow(abs(n), vec3(32.) );\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\r\n}\r\n\r\n// noise\r\nfloat rnd(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\r\n}\r\n\r\n// signed box\r\nfloat sdBox(vec3 p,vec3 b)\r\n{\r\n  vec3 d = abs(p)-b;\r\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\r\n}\r\n\r\n// rotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n// 3D noise function (shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip = floor(p);\r\n    p -= ip; \r\n    vec3 s = vec3(7,157,113);\r\n    vec4 h = vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p = p*p*(3.-2.*p); \r\n    h = mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\r\n    h.xy = mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\nfloat map(vec3 p)\r\n{\t\r\n\tif (scene_idx>9&&scene_idx<14) \r\n    {\r\n\t\tfloat a = sdBox(p,vec3(1.2,1.5,2.))-0.1;\r\n    \tpR(p.yz,0.2*time);\r\n    \treturn max(a,-sdBox(p,vec3(0.9,0.5,.1))+0.04);\r\n    }\r\n    float displace = 0.001*noise(15.*p+time); \r\n    if (scene_idx == 8 || scene_idx == 9) displace = 0.005*noise(10.*p+time)+0.005*sin(10.*p.x+3.*time)+0.002*sin(14.*p.y+4.*time); //!!!!!!!!!!!!!!!\r\n    if (scene_idx < 4 || (scene_idx > 5 && scene_idx < 10)) return sdBox(p,vec3(1.,1.,1.))-0.4+displace; // box ///////////// vec3 1.1.1\r\n    return length(p)-2.0+0.5*noise(1.5*p-0.02*time);     \r\n}\r\n\r\n// normal calculation\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps = 0.0001;\r\n\tfloat d = map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\n\r\n// sphere tracing inside\r\nfloat castRayx(vec3 ro,vec3 rd) \r\n{\r\n    float precis = .0001;\r\n    float h = precis*2.;\r\n    float t = 0.;\r\n\tfor(int i=0;i<100;i++) \r\n\t{\r\n        if(abs(h)<precis||t>12.)break;\r\n\t\th = -map(ro+rd*t); \r\n        t += h;\r\n\t}\r\n    return t;\r\n}\r\n\r\n// refraction\r\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\r\n{\r\n    float h = 0.;\r\n    t2 = 2.;\r\n\tvec3 dir2 = refract(dir,nor,angle);  \r\n \tfor(int i=0;i<50;i++) \r\n\t{\r\n\t\tif(abs(h)>3.) break;\r\n\t\th = map(pos+dir2*t2);\r\n\t\tt2 -= h;\r\n\t}\r\n    nor2 = calcNormal(pos+dir2*t2);\r\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\r\n}\r\n\r\n// softshadow \r\nfloat softshadow(vec3 ro,vec3 rd) \r\n{\r\n    float sh = 1.;\r\n    float t = .02;\r\n    float h = .0;\r\n    for(int i=0;i<12;i++)  \r\n\t{\r\n        if(t>20.)continue;\r\n        h = map(ro+rd*t);\r\n        sh = min(sh,4.*h/t);\r\n        t += h;\r\n    }\r\n    return sh;\r\n}\r\n\r\n// *********************************************************************************************************\r\n\r\n// main function\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{    \r\n \r\n// time handling    \r\n\ttime=iTime*1.;\r\n\tif (iTime>150.&&iTime<=165.) time=(iTime-150.)*4.+150.;\r\n\tif (iTime>165.) time=iTime+60.;\r\n// scene handling   \r\n    scene_idx = int(floor(time/duration));\r\n    vec2 scene=vec2(scenes_x[scene_idx],scenes_y[scene_idx]); \r\n    \r\n// camera    \r\n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, iResolution.y)),org = vec3(0,0,1.);  \r\n    if (scene_idx==10||scene_idx==12||scene_idx>=14) dir+=0.01*rnd(vec2(time,time)); //stutter\r\n\r\n    \r\n// try this :P\r\n   //scene = iMouse.yx*0.02;\r\n\r\n    pR(dir.zy,scene.x+.8*sin(.02*time));\r\n    pR(dir.xz,scene.y+.8*cos(.05*time-1.));\r\n    \r\n// standard sphere tracing inside an object\r\n    vec3 color,color2 =  vec3(0.);\r\n    float t = castRayx(org,dir);\r\n\tvec3 pos = org+dir*t;\r\n\tvec3 nor = calcNormal(pos);\r\n\r\n// lighting:\r\n    vec3 lig = normalize(vec3(-.2,-6.,.5));\r\n\r\n// scene depth    \r\n    float depth = clamp((1.-0.09*t),0.,1.);\r\n     \r\n    vec3 pos2,nor2 = vec3(0.);\r\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.))*clamp(softshadow(pos,lig),0.,1.);\r\n    \tfloat t2;\r\n\t\tcolor2.b += refr(pos,lig,dir,nor,0.92, t2, nor2)*depth;\r\n    \tcolor2.g += refr(pos,lig,dir,nor,0.90, t2, nor2)*depth;\r\n    \tcolor2.r += refr(pos,lig,dir,nor,0.88, t2, nor2)*depth;\r\n  \t\tcolor2 -= clamp(.1*t2,0.,1.);\t\t\r\n\t    \r\n// texture\r\n        color2 += 0.7*boxmap(iChannel0,0.25*pos+0.5,nor).xyz; \r\n        color2 *= depth; \r\n  \r\n// glow intensity    \r\n    float tmp = 0., T = 1.;\r\n    float intensity = 0.1*-sin(.5*time)-0.05; \r\n\tfor(int i=0; i<32; i++)\r\n\t{\r\n        float nebula = noise(org);\r\n        float density = intensity-map(org+.5*nor2)*nebula;\r\n\t\tif(density>0.)\r\n\t\t{\r\n\t\t\ttmp = density / 128.;\r\n            T *= 1. -tmp * 100.;\r\n\t\t}\r\n\t\torg += dir*0.078;\r\n    }    \r\n\tvec3 basecol = vec3(1.,.35,1./16.);\t\r\n  \r\n    T = clamp(T,0.,1.5); \r\n    color += basecol* exp(4.*(0.5-T) - 0.8);\r\n    color -= vec3(1.1,.015,.06);\r\n  \r\n\r\n    vec3 object = vec3(0.1*color+0.8*color2)*1.3;    \r\n    \r\n    vec2 uv = 0.5-fragCoord.xy/iResolution.xy ; \r\n\r\n    // feedbak noise  \r\n    uv*=0.996;\r\n  \tuv=0.5-uv; \r\n   \tuv.x-=0.005*noise(uv.yxx*32.-time)-0.0025;\r\n   \tuv.y+=0.005*noise(uv.yxx*32.+time)-0.0025; \r\n  \r\n    vec3 bufa= texture(iChannel0,uv).xyz;\r\n\r\n    float saw = mod(time/duration,1.);\r\n    float powsaw = pow(saw,32.); \t\t\t\t\t\r\n \tfloat fade0 =  clamp(mod(1.*time,1.*duration),0.,1.); \t// fade in\r\n    float fade1 =  exp(32.* -powsaw)*fade0; \t\t\t\t// fade out      \r\n    float parabola = 0.75;\r\n    if (scene_idx == 1 || (scene_idx >= 4 && scene_idx<=7) || scene_idx>=9) parabola = 0.8-pow(4.*saw*(1.-saw),2.)*0.6;\r\n    if (scene_idx >13)  parabola=clamp(saw+0.3,0.,0.99);\r\n       \r\n    \r\n // noise   \r\n\tobject += 0.25*(0.5-rnd(uv.xy*time))*parabola;\t\t\t//noise  \r\n    if (scene_idx>3) object -= 0.04*rnd(vec2(time,time));   //flutter    \r\n    \r\n    if (iTime>180.) {object = vec3(0); bufa=vec3(0);}\r\n\r\n    fragColor = clamp(vec4(mix(object,bufa,parabola)*fade1,0.),0.,1.0);   \r\n\r\n \r\n    \r\n    \r\n\r\n}\r\n\r\n\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"// **************************************************************************\r\n// Alcatraz - Equilibrium - 4K intro \r\n// by Jochen \"Virgill\" Feldk\u00F6tter (jochen.feldkoetter{a}osnanet.de)\r\n//\r\n// 4kb executable: \thttp://www.pouet.net/prod.php?which=71136\r\n// Youtube: \t\thttps://www.youtube.com/watch?v=T6ulp8b8eHw\r\n// Soundtrack:\t\thttps://soundcloud.com/virgill/virgill-4klang-equilibrium\r\n// **************************************************************************\r\n\r\n\r\nint scene_idx =0;\t\t// scene  0      1     2     3       4     5        6     7      8     9         10    11   12   13      14\r\nfloat scenes_x[15] = float[15] (-0.35,  5.9, -3.2, -1.0 ,  8.0,   0.0,    -1.2, -0.3,  -1.3,  -0.4,     -4.2,  0.0, 1.8, 0.0,     2. );\r\nfloat scenes_y[15] = float[15] (-0.61,  0.7, -3.0,  0.1,   2.6,   4.5,    -0.5, -3.0,  -0.5,   0.1,      2.5,  3.0, 1.0, 3.0,    -3. );\r\nfloat duration = 15.; \r\nfloat time=0.;\r\n\r\n// cubemap (IQ)\r\nvec4 boxmap(sampler2D sam,vec3 p,vec3 n)\r\n{\r\n    vec3 m = pow(abs(n), vec3(32.) );\r\n\tvec4 x = texture( sam, p.yz );\r\n\tvec4 y = texture( sam, p.zx );\r\n\tvec4 z = texture( sam, p.xy );\r\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\r\n}\r\n\r\n// noise\r\nfloat rnd(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\r\n}\r\n\r\n// signed box\r\nfloat sdBox(vec3 p,vec3 b)\r\n{\r\n  vec3 d = abs(p)-b;\r\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\r\n}\r\n\r\n// rotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n// 3D noise function (shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip = floor(p);\r\n    p -= ip; \r\n    vec3 s = vec3(7,157,113);\r\n    vec4 h = vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p = p*p*(3.-2.*p); \r\n    h = mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\r\n    h.xy = mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\nfloat map(vec3 p)\r\n{\t\r\n\tif (scene_idx>9&&scene_idx<14) \r\n    {\r\n\t\tfloat a = sdBox(p,vec3(1.2,1.5,2.))-0.1;\r\n    \tpR(p.yz,0.2*time);\r\n    \treturn max(a,-sdBox(p,vec3(0.9,0.5,.1))+0.04);\r\n    }\r\n    float displace = 0.001*noise(15.*p+time); \r\n    if (scene_idx == 8 || scene_idx == 9) displace = 0.005*noise(10.*p+time)+0.005*sin(10.*p.x+3.*time)+0.002*sin(14.*p.y+4.*time); //!!!!!!!!!!!!!!!\r\n    if (scene_idx < 4 || (scene_idx > 5 && scene_idx < 10)) return sdBox(p,vec3(1.,1.,1.))-0.4+displace; // box ///////////// vec3 1.1.1\r\n    return length(p)-2.0+0.5*noise(1.5*p-0.02*time);     \r\n}\r\n\r\n// normal calculation\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps = 0.0001;\r\n\tfloat d = map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\n\r\n// sphere tracing inside\r\nfloat castRayx(vec3 ro,vec3 rd) \r\n{\r\n    float precis = .0001;\r\n    float h = precis*2.;\r\n    float t = 0.;\r\n\tfor(int i=0;i<100;i++) \r\n\t{\r\n        if(abs(h)<precis||t>12.)break;\r\n\t\th = -map(ro+rd*t); \r\n        t += h;\r\n\t}\r\n    return t;\r\n}\r\n\r\n// refraction\r\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\r\n{\r\n    float h = 0.;\r\n    t2 = 2.;\r\n\tvec3 dir2 = refract(dir,nor,angle);  \r\n \tfor(int i=0;i<50;i++) \r\n\t{\r\n\t\tif(abs(h)>3.) break;\r\n\t\th = map(pos+dir2*t2);\r\n\t\tt2 -= h;\r\n\t}\r\n    nor2 = calcNormal(pos+dir2*t2);\r\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\r\n}\r\n\r\n// softshadow \r\nfloat softshadow(vec3 ro,vec3 rd) \r\n{\r\n    float sh = 1.;\r\n    float t = .02;\r\n    float h = .0;\r\n    for(int i=0;i<12;i++)  \r\n\t{\r\n        if(t>20.)continue;\r\n        h = map(ro+rd*t);\r\n        sh = min(sh,4.*h/t);\r\n        t += h;\r\n    }\r\n    return sh;\r\n}\r\n\r\n// *********************************************************************************************************\r\n\r\n// main function\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{    \r\n \r\n// time handling    \r\n\ttime=iTime*1.;\r\n\tif (iTime>150.&&iTime<=165.) time=(iTime-150.)*4.+150.;\r\n\tif (iTime>165.) time=iTime+60.;\r\n// scene handling   \r\n    scene_idx = int(floor(time/duration));\r\n    vec2 scene=vec2(scenes_x[scene_idx],scenes_y[scene_idx]); \r\n    \r\n// camera    \r\n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, iResolution.y)),org = vec3(0,0,1.);  \r\n    if (scene_idx==10||scene_idx==12||scene_idx>=14) dir+=0.01*rnd(vec2(time,time)); //stutter\r\n\r\n    \r\n// try this :P\r\n   //scene = iMouse.yx*0.02;\r\n\r\n    pR(dir.zy,scene.x+.8*sin(.02*time));\r\n    pR(dir.xz,scene.y+.8*cos(.05*time-1.));\r\n    \r\n// standard sphere tracing inside an object\r\n    vec3 color,color2 =  vec3(0.);\r\n    float t = castRayx(org,dir);\r\n\tvec3 pos = org+dir*t;\r\n\tvec3 nor = calcNormal(pos);\r\n\r\n// lighting:\r\n    vec3 lig = normalize(vec3(-.2,-6.,.5));\r\n\r\n// scene depth    \r\n    float depth = clamp((1.-0.09*t),0.,1.);\r\n     \r\n    vec3 pos2,nor2 = vec3(0.);\r\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.))*clamp(softshadow(pos,lig),0.,1.);\r\n    \tfloat t2;\r\n\t\tcolor2.b += refr(pos,lig,dir,nor,0.92, t2, nor2)*depth;\r\n    \tcolor2.g += refr(pos,lig,dir,nor,0.90, t2, nor2)*depth;\r\n    \tcolor2.r += refr(pos,lig,dir,nor,0.88, t2, nor2)*depth;\r\n  \t\tcolor2 -= clamp(.1*t2,0.,1.);\t\t\r\n\t    \r\n// texture\r\n        color2 += 0.7*boxmap(iChannel0,0.25*pos+0.5,nor).xyz; \r\n        color2 *= depth; \r\n  \r\n// glow intensity    \r\n    float tmp = 0., T = 1.;\r\n    float intensity = 0.1*-sin(.5*time)-0.05; \r\n\tfor(int i=0; i<32; i++)\r\n\t{\r\n        float nebula = noise(org);\r\n        float density = intensity-map(org+.5*nor2)*nebula;\r\n\t\tif(density>0.)\r\n\t\t{\r\n\t\t\ttmp = density / 128.;\r\n            T *= 1. -tmp * 100.;\r\n\t\t}\r\n\t\torg += dir*0.078;\r\n    }    \r\n\tvec3 basecol = vec3(1.,.35,1./16.);\t\r\n  \r\n    T = clamp(T,0.,1.5); \r\n    color += basecol* exp(4.*(0.5-T) - 0.8);\r\n    color -= vec3(1.1,.015,.06);\r\n  \r\n\r\n    vec3 object = vec3(0.1*color+0.8*color2)*1.3;    \r\n    \r\n    vec2 uv = 0.5-fragCoord.xy/iResolution.xy ; \r\n\r\n    // feedbak noise  \r\n    uv*=0.996;\r\n  \tuv=0.5-uv; \r\n   \tuv.x-=0.005*noise(uv.yxx*32.-time)-0.0025;\r\n   \tuv.y+=0.005*noise(uv.yxx*32.+time)-0.0025; \r\n  \r\n    vec3 bufa= texture(iChannel0,uv).xyz;\r\n\r\n    float saw = mod(time/duration,1.);\r\n    float powsaw = pow(saw,32.); \t\t\t\t\t\r\n \tfloat fade0 =  clamp(mod(1.*time,1.*duration),0.,1.); \t// fade in\r\n    float fade1 =  exp(32.* -powsaw)*fade0; \t\t\t\t// fade out      \r\n    float parabola = 0.75;\r\n    if (scene_idx == 1 || (scene_idx >= 4 && scene_idx<=7) || scene_idx>=9) parabola = 0.8-pow(4.*saw*(1.-saw),2.)*0.6;\r\n    if (scene_idx >13)  parabola=clamp(saw+0.3,0.,0.99);\r\n       \r\n    \r\n // noise   \r\n\tobject += 0.25*(0.5-rnd(uv.xy*time))*parabola;\t\t\t//noise  \r\n    if (scene_idx>3) object -= 0.04*rnd(vec2(time,time));   //flutter    \r\n    \r\n    if (iTime>180.) {object = vec3(0); bufa=vec3(0);}\r\n\r\n    fragColor = clamp(vec4(mix(object,bufa,parabola)*fade1,0.),0.,1.0);   \r\n\r\n \r\n    \r\n    \r\n\r\n}\r\n\r\n\r\n\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// The MIT License\r\n// Copyright \u00A9 2016 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n// Computing normals analytically has the benefit of being faster if you need them often, \r\n// while numerical normals are easier to filter for antialiasing. See line 200.\r\n//\r\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\r\n//\r\n// See this too: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\r\n\r\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\r\n\r\n\r\n//---------------------------------------------------------------\r\n// value noise, and its analytical derivatives\r\n//---------------------------------------------------------------\r\n\r\nvec4 noised( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n\tvec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    \r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    \r\n    float a = hash(n+  0.0);\r\n    float b = hash(n+  1.0);\r\n    float c = hash(n+157.0);\r\n    float d = hash(n+158.0);\r\n    float e = hash(n+113.0);\r\n\tfloat f = hash(n+114.0);\r\n    float g = hash(n+270.0);\r\n    float h = hash(n+271.0);\r\n\t\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\r\n}\r\n\r\n//---------------------------------------------------------------\r\n\r\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\r\n{\r\n    vec3 d = abs(p) - b;\r\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\r\n    return vec4( x, n );\r\n}\r\n\r\nvec4 fbmd( in vec3 x )\r\n{\r\n    const float scale  = 1.5;\r\n\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n\tfloat f = 1.0;\r\n    vec3  d = vec3(0.0);\r\n    for( int i=0; i<8; i++ )\r\n    {\r\n        vec4 n = noised(f*x*scale);\r\n        a += b*n.x;           // accumulate values\t\t\r\n        d += b*n.yzw*f*scale; // accumulate derivatives\r\n        b *= 0.5;             // amplitude decrease\r\n        f *= 1.8;             // frequency increase\r\n    }\r\n\r\n\treturn vec4( a, d );\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tvec4 d1 = fbmd( p );\r\n    d1.x -= 0.37;\r\n\td1.x *= 0.7;\r\n    d1.yzw = normalize(d1.yzw);\r\n\r\n    // clip to box\r\n    vec4 d2 = sdBox( p, vec3(1.5) );\r\n    return (d1.x>d2.x) ? d1 : d2;\r\n}\r\n\r\n// ray-box intersection in box space\r\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \r\n{\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\r\n\treturn vec2( tN, tF );\r\n}\r\n\r\n// raymarch\r\nvec4 interesect( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 res = vec4(-1.0);\r\n\r\n    // bounding volume    \r\n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\r\n    if( dis.y<0.0 ) return res;\r\n\r\n    // raymarch\r\n    float tmax = dis.y;\r\n    float t = dis.x;\r\n\tfor( int i=0; i<128; i++ )\r\n\t{\r\n        vec3 pos = ro + t*rd;\r\n\t\tvec4 hnor = map( pos );\r\n        res = vec4(t,hnor.yzw);\r\n        \r\n\t\tif( hnor.x<0.001 ) break;\r\n\t\tt += hnor.x;\r\n        if( t>tmax ) break;\r\n\t}\r\n\r\n\tif( t>tmax ) res = vec4(-1.0);\r\n\treturn res;\r\n}\r\n\r\n// compute normal numerically\r\n#ifdef SHOW_NUMERICAL_NORMALS\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n\tvec2 eps = vec2( 0.0001, 0.0 );\r\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n#endif\r\n\r\n// fibonazzi points in s aphsre, more info:\r\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\r\nvec3 forwardSF( float i, float n) \r\n{\r\n    const float PI  = 3.141592653589793238;\r\n    const float PHI = 1.618033988749894848;\r\n    float phi = 2.0*PI*fract(i/PHI);\r\n    float zi = 1.0 - (2.0*i+1.0)/n;\r\n    float sinTheta = sqrt( 1.0 - zi*zi);\r\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat ao = 0.0;\r\n    for( int i=0; i<32; i++ )\r\n    {\r\n        vec3 ap = forwardSF( float(i), 32.0 );\r\n        float h = hash(float(i));\r\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\r\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\r\n    }\r\n\tao /= 32.0;\r\n\t\r\n    return clamp( ao*5.0, 0.0, 1.0 );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n   \r\n\t// camera anim\r\n    float an = 0.1*iTime;\r\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\r\n\tvec3 ta = vec3( 0.0 );\r\n\t\r\n    // camera matrix\t\r\n\tvec3  cw = normalize( ta-ro );\r\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\r\n\tvec3  cv = normalize( cross(cu,cw) );\r\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\r\n\r\n\t// render\r\n\tvec3 col = vec3(0.0);\r\n    vec4 tnor = interesect( ro, rd );\r\n\tfloat t = tnor.x;\r\n\r\n    if( t>0.0 )\r\n\t{\r\n\t\tvec3 pos = ro + t*rd;\r\n        #ifndef SHOW_NUMERICAL_NORMALS\r\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\r\n        #else\r\n        vec3 nor = calcNormal( pos );\r\n        #endif\r\n        float occ = calcAO( pos, nor );\r\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\r\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\r\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\r\n        //col = 0.5+0.5*nor;\r\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\r\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\r\n\t}\r\n\r\n    col = sqrt(col);\r\n\t\r\n    fragColor=vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// The MIT License\r\n// Copyright \u00A9 2016 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n// Computing normals analytically has the benefit of being faster if you need them often, \r\n// while numerical normals are easier to filter for antialiasing. See line 200.\r\n//\r\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\r\n//\r\n// See this too: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\r\n\r\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\r\n\r\n\r\n//---------------------------------------------------------------\r\n// value noise, and its analytical derivatives\r\n//---------------------------------------------------------------\r\n\r\nvec4 noised( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n\tvec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    \r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    \r\n    float a = hash(n+  0.0);\r\n    float b = hash(n+  1.0);\r\n    float c = hash(n+157.0);\r\n    float d = hash(n+158.0);\r\n    float e = hash(n+113.0);\r\n\tfloat f = hash(n+114.0);\r\n    float g = hash(n+270.0);\r\n    float h = hash(n+271.0);\r\n\t\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\r\n}\r\n\r\n//---------------------------------------------------------------\r\n\r\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\r\n{\r\n    vec3 d = abs(p) - b;\r\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\r\n    return vec4( x, n );\r\n}\r\n\r\nvec4 fbmd( in vec3 x )\r\n{\r\n    const float scale  = 1.5;\r\n\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n\tfloat f = 1.0;\r\n    vec3  d = vec3(0.0);\r\n    for( int i=0; i<8; i++ )\r\n    {\r\n        vec4 n = noised(f*x*scale);\r\n        a += b*n.x;           // accumulate values\t\t\r\n        d += b*n.yzw*f*scale; // accumulate derivatives\r\n        b *= 0.5;             // amplitude decrease\r\n        f *= 1.8;             // frequency increase\r\n    }\r\n\r\n\treturn vec4( a, d );\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tvec4 d1 = fbmd( p );\r\n    d1.x -= 0.37;\r\n\td1.x *= 0.7;\r\n    d1.yzw = normalize(d1.yzw);\r\n\r\n    // clip to box\r\n    vec4 d2 = sdBox( p, vec3(1.5) );\r\n    return (d1.x>d2.x) ? d1 : d2;\r\n}\r\n\r\n// ray-box intersection in box space\r\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \r\n{\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\r\n\treturn vec2( tN, tF );\r\n}\r\n\r\n// raymarch\r\nvec4 interesect( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 res = vec4(-1.0);\r\n\r\n    // bounding volume    \r\n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\r\n    if( dis.y<0.0 ) return res;\r\n\r\n    // raymarch\r\n    float tmax = dis.y;\r\n    float t = dis.x;\r\n\tfor( int i=0; i<128; i++ )\r\n\t{\r\n        vec3 pos = ro + t*rd;\r\n\t\tvec4 hnor = map( pos );\r\n        res = vec4(t,hnor.yzw);\r\n        \r\n\t\tif( hnor.x<0.001 ) break;\r\n\t\tt += hnor.x;\r\n        if( t>tmax ) break;\r\n\t}\r\n\r\n\tif( t>tmax ) res = vec4(-1.0);\r\n\treturn res;\r\n}\r\n\r\n// compute normal numerically\r\n#ifdef SHOW_NUMERICAL_NORMALS\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n\tvec2 eps = vec2( 0.0001, 0.0 );\r\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n#endif\r\n\r\n// fibonazzi points in s aphsre, more info:\r\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\r\nvec3 forwardSF( float i, float n) \r\n{\r\n    const float PI  = 3.141592653589793238;\r\n    const float PHI = 1.618033988749894848;\r\n    float phi = 2.0*PI*fract(i/PHI);\r\n    float zi = 1.0 - (2.0*i+1.0)/n;\r\n    float sinTheta = sqrt( 1.0 - zi*zi);\r\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat ao = 0.0;\r\n    for( int i=0; i<32; i++ )\r\n    {\r\n        vec3 ap = forwardSF( float(i), 32.0 );\r\n        float h = hash(float(i));\r\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\r\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\r\n    }\r\n\tao /= 32.0;\r\n\t\r\n    return clamp( ao*5.0, 0.0, 1.0 );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n   \r\n\t// camera anim\r\n    float an = 0.1*iTime;\r\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\r\n\tvec3 ta = vec3( 0.0 );\r\n\t\r\n    // camera matrix\t\r\n\tvec3  cw = normalize( ta-ro );\r\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\r\n\tvec3  cv = normalize( cross(cu,cw) );\r\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\r\n\r\n\t// render\r\n\tvec3 col = vec3(0.0);\r\n    vec4 tnor = interesect( ro, rd );\r\n\tfloat t = tnor.x;\r\n\r\n    if( t>0.0 )\r\n\t{\r\n\t\tvec3 pos = ro + t*rd;\r\n        #ifndef SHOW_NUMERICAL_NORMALS\r\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\r\n        #else\r\n        vec3 nor = calcNormal( pos );\r\n        #endif\r\n        float occ = calcAO( pos, nor );\r\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\r\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\r\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\r\n        //col = 0.5+0.5*nor;\r\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\r\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\r\n\t}\r\n\r\n    col = sqrt(col);\r\n\t\r\n    fragColor=vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Analytic Normals 3D","id":"9802cc4ad5894ac888f546b6e1863ec9","date":null,"viewed":0,"name":"Analytic Normals 3D","description":"Left, analytical normals of Value Noise. Right, numerical normals (central differences). See http://iquilezles.org/www/articles/morenoise/morenoise.htm for more info. See https://www.shadertoy.com/view/MdsSRs for the 2D case.\nhttps://www.shadertoy.com/view/XttSz2","likes":0,"published":null,"tags":["3d"," noise"," normals"," analytical"," numerical"]},"ver":null,"info":{"Name":"Analytic Normals 3D","id":"9802cc4ad5894ac888f546b6e1863ec9","date":null,"viewed":0,"name":"Analytic Normals 3D","description":"Left, analytical normals of Value Noise. Right, numerical normals (central differences). See http://iquilezles.org/www/articles/morenoise/morenoise.htm for more info. See https://www.shadertoy.com/view/MdsSRs for the 2D case.\nhttps://www.shadertoy.com/view/XttSz2","likes":0,"published":null,"tags":["3d"," noise"," normals"," analytical"," numerical"]},"renderpass":[{"Code":"// The MIT License\r\n// Copyright \u00A9 2016 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n// Computing normals analytically has the benefit of being faster if you need them often, \r\n// while numerical normals are easier to filter for antialiasing. See line 200.\r\n//\r\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\r\n//\r\n// See this too: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\r\n\r\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\r\n\r\n\r\n//---------------------------------------------------------------\r\n// value noise, and its analytical derivatives\r\n//---------------------------------------------------------------\r\n\r\nvec4 noised( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n\tvec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    \r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    \r\n    float a = hash(n+  0.0);\r\n    float b = hash(n+  1.0);\r\n    float c = hash(n+157.0);\r\n    float d = hash(n+158.0);\r\n    float e = hash(n+113.0);\r\n\tfloat f = hash(n+114.0);\r\n    float g = hash(n+270.0);\r\n    float h = hash(n+271.0);\r\n\t\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\r\n}\r\n\r\n//---------------------------------------------------------------\r\n\r\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\r\n{\r\n    vec3 d = abs(p) - b;\r\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\r\n    return vec4( x, n );\r\n}\r\n\r\nvec4 fbmd( in vec3 x )\r\n{\r\n    const float scale  = 1.5;\r\n\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n\tfloat f = 1.0;\r\n    vec3  d = vec3(0.0);\r\n    for( int i=0; i<8; i++ )\r\n    {\r\n        vec4 n = noised(f*x*scale);\r\n        a += b*n.x;           // accumulate values\t\t\r\n        d += b*n.yzw*f*scale; // accumulate derivatives\r\n        b *= 0.5;             // amplitude decrease\r\n        f *= 1.8;             // frequency increase\r\n    }\r\n\r\n\treturn vec4( a, d );\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tvec4 d1 = fbmd( p );\r\n    d1.x -= 0.37;\r\n\td1.x *= 0.7;\r\n    d1.yzw = normalize(d1.yzw);\r\n\r\n    // clip to box\r\n    vec4 d2 = sdBox( p, vec3(1.5) );\r\n    return (d1.x>d2.x) ? d1 : d2;\r\n}\r\n\r\n// ray-box intersection in box space\r\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \r\n{\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\r\n\treturn vec2( tN, tF );\r\n}\r\n\r\n// raymarch\r\nvec4 interesect( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 res = vec4(-1.0);\r\n\r\n    // bounding volume    \r\n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\r\n    if( dis.y<0.0 ) return res;\r\n\r\n    // raymarch\r\n    float tmax = dis.y;\r\n    float t = dis.x;\r\n\tfor( int i=0; i<128; i++ )\r\n\t{\r\n        vec3 pos = ro + t*rd;\r\n\t\tvec4 hnor = map( pos );\r\n        res = vec4(t,hnor.yzw);\r\n        \r\n\t\tif( hnor.x<0.001 ) break;\r\n\t\tt += hnor.x;\r\n        if( t>tmax ) break;\r\n\t}\r\n\r\n\tif( t>tmax ) res = vec4(-1.0);\r\n\treturn res;\r\n}\r\n\r\n// compute normal numerically\r\n#ifdef SHOW_NUMERICAL_NORMALS\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n\tvec2 eps = vec2( 0.0001, 0.0 );\r\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n#endif\r\n\r\n// fibonazzi points in s aphsre, more info:\r\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\r\nvec3 forwardSF( float i, float n) \r\n{\r\n    const float PI  = 3.141592653589793238;\r\n    const float PHI = 1.618033988749894848;\r\n    float phi = 2.0*PI*fract(i/PHI);\r\n    float zi = 1.0 - (2.0*i+1.0)/n;\r\n    float sinTheta = sqrt( 1.0 - zi*zi);\r\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat ao = 0.0;\r\n    for( int i=0; i<32; i++ )\r\n    {\r\n        vec3 ap = forwardSF( float(i), 32.0 );\r\n        float h = hash(float(i));\r\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\r\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\r\n    }\r\n\tao /= 32.0;\r\n\t\r\n    return clamp( ao*5.0, 0.0, 1.0 );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n   \r\n\t// camera anim\r\n    float an = 0.1*iTime;\r\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\r\n\tvec3 ta = vec3( 0.0 );\r\n\t\r\n    // camera matrix\t\r\n\tvec3  cw = normalize( ta-ro );\r\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\r\n\tvec3  cv = normalize( cross(cu,cw) );\r\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\r\n\r\n\t// render\r\n\tvec3 col = vec3(0.0);\r\n    vec4 tnor = interesect( ro, rd );\r\n\tfloat t = tnor.x;\r\n\r\n    if( t>0.0 )\r\n\t{\r\n\t\tvec3 pos = ro + t*rd;\r\n        #ifndef SHOW_NUMERICAL_NORMALS\r\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\r\n        #else\r\n        vec3 nor = calcNormal( pos );\r\n        #endif\r\n        float occ = calcAO( pos, nor );\r\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\r\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\r\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\r\n        //col = 0.5+0.5*nor;\r\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\r\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\r\n\t}\r\n\r\n    col = sqrt(col);\r\n\t\r\n    fragColor=vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// The MIT License\r\n// Copyright \u00A9 2016 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n// Computing normals analytically has the benefit of being faster if you need them often, \r\n// while numerical normals are easier to filter for antialiasing. See line 200.\r\n//\r\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\r\n//\r\n// See this too: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\r\n\r\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\r\n\r\n\r\n//---------------------------------------------------------------\r\n// value noise, and its analytical derivatives\r\n//---------------------------------------------------------------\r\n\r\nvec4 noised( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n\tvec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    \r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    \r\n    float a = hash(n+  0.0);\r\n    float b = hash(n+  1.0);\r\n    float c = hash(n+157.0);\r\n    float d = hash(n+158.0);\r\n    float e = hash(n+113.0);\r\n\tfloat f = hash(n+114.0);\r\n    float g = hash(n+270.0);\r\n    float h = hash(n+271.0);\r\n\t\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\r\n}\r\n\r\n//---------------------------------------------------------------\r\n\r\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\r\n{\r\n    vec3 d = abs(p) - b;\r\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\r\n    return vec4( x, n );\r\n}\r\n\r\nvec4 fbmd( in vec3 x )\r\n{\r\n    const float scale  = 1.5;\r\n\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n\tfloat f = 1.0;\r\n    vec3  d = vec3(0.0);\r\n    for( int i=0; i<8; i++ )\r\n    {\r\n        vec4 n = noised(f*x*scale);\r\n        a += b*n.x;           // accumulate values\t\t\r\n        d += b*n.yzw*f*scale; // accumulate derivatives\r\n        b *= 0.5;             // amplitude decrease\r\n        f *= 1.8;             // frequency increase\r\n    }\r\n\r\n\treturn vec4( a, d );\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tvec4 d1 = fbmd( p );\r\n    d1.x -= 0.37;\r\n\td1.x *= 0.7;\r\n    d1.yzw = normalize(d1.yzw);\r\n\r\n    // clip to box\r\n    vec4 d2 = sdBox( p, vec3(1.5) );\r\n    return (d1.x>d2.x) ? d1 : d2;\r\n}\r\n\r\n// ray-box intersection in box space\r\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \r\n{\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\r\n\treturn vec2( tN, tF );\r\n}\r\n\r\n// raymarch\r\nvec4 interesect( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 res = vec4(-1.0);\r\n\r\n    // bounding volume    \r\n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\r\n    if( dis.y<0.0 ) return res;\r\n\r\n    // raymarch\r\n    float tmax = dis.y;\r\n    float t = dis.x;\r\n\tfor( int i=0; i<128; i++ )\r\n\t{\r\n        vec3 pos = ro + t*rd;\r\n\t\tvec4 hnor = map( pos );\r\n        res = vec4(t,hnor.yzw);\r\n        \r\n\t\tif( hnor.x<0.001 ) break;\r\n\t\tt += hnor.x;\r\n        if( t>tmax ) break;\r\n\t}\r\n\r\n\tif( t>tmax ) res = vec4(-1.0);\r\n\treturn res;\r\n}\r\n\r\n// compute normal numerically\r\n#ifdef SHOW_NUMERICAL_NORMALS\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n\tvec2 eps = vec2( 0.0001, 0.0 );\r\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n#endif\r\n\r\n// fibonazzi points in s aphsre, more info:\r\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\r\nvec3 forwardSF( float i, float n) \r\n{\r\n    const float PI  = 3.141592653589793238;\r\n    const float PHI = 1.618033988749894848;\r\n    float phi = 2.0*PI*fract(i/PHI);\r\n    float zi = 1.0 - (2.0*i+1.0)/n;\r\n    float sinTheta = sqrt( 1.0 - zi*zi);\r\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat ao = 0.0;\r\n    for( int i=0; i<32; i++ )\r\n    {\r\n        vec3 ap = forwardSF( float(i), 32.0 );\r\n        float h = hash(float(i));\r\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\r\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\r\n    }\r\n\tao /= 32.0;\r\n\t\r\n    return clamp( ao*5.0, 0.0, 1.0 );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n   \r\n\t// camera anim\r\n    float an = 0.1*iTime;\r\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\r\n\tvec3 ta = vec3( 0.0 );\r\n\t\r\n    // camera matrix\t\r\n\tvec3  cw = normalize( ta-ro );\r\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\r\n\tvec3  cv = normalize( cross(cu,cw) );\r\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\r\n\r\n\t// render\r\n\tvec3 col = vec3(0.0);\r\n    vec4 tnor = interesect( ro, rd );\r\n\tfloat t = tnor.x;\r\n\r\n    if( t>0.0 )\r\n\t{\r\n\t\tvec3 pos = ro + t*rd;\r\n        #ifndef SHOW_NUMERICAL_NORMALS\r\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\r\n        #else\r\n        vec3 nor = calcNormal( pos );\r\n        #endif\r\n        float occ = calcAO( pos, nor );\r\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\r\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\r\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\r\n        //col = 0.5+0.5*nor;\r\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\r\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\r\n\t}\r\n\r\n    col = sqrt(col);\r\n\t\r\n    fragColor=vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","inputs":[],"outputs":[],"code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Annotated Ray Tracing","id":"9b37e05ade204245a09c06921a913d6e","date":null,"viewed":0,"name":"Annotated Ray Tracing","description":"See https://www.tinycranes.com/blog/2015/05/annotated-realtime-raytracing/","likes":0,"published":null,"tags":["raytracing"," spheres"]},"ver":null,"info":{"Name":"Annotated Ray Tracing","id":"9b37e05ade204245a09c06921a913d6e","date":null,"viewed":0,"name":"Annotated Ray Tracing","description":"See https://www.tinycranes.com/blog/2015/05/annotated-realtime-raytracing/","likes":0,"published":null,"tags":["raytracing"," spheres"]},"renderpass":[{"Code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","inputs":[],"outputs":[],"code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define BUMP 0\r\n\r\n#define PI acos(-1.0)\r\n#define TAU PI*2.0\r\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\r\n\r\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\r\n#define hash(n)fract(sin(n+1234.5)*55555.0)\r\n\r\nvec3 randVec(float n)\r\n{\r\n\tvec3 v=vec3(1,0,0);\r\n    v.xy*=rot(asin(hash(n)*2.-1.));\r\n    n+=123.0;\r\n    v.xz*=rot((hash(n)*2.-1.)*PI);\r\n\treturn v;\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    vec3 r=vec3(1,99,999);\r\n    vec4 s=dot(floor(p),r)+vec4(0,r.y,r.z,r.y+r.z);\r\n    p=smoothstep(0.,1.,fract(p));\r\n    s=mix(hash(s),hash(s+1.),p.x);\r\n    s.xy=mix(s.xz,s.yw,p.y);\r\n    return mix(s.x,s.y,p.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n   \tfloat n = 0.0;\r\n    float amp = 0.8;\r\n\tfor (int i=0; i<4; i++)\r\n\t{\r\n\t\tn += noise(p)*amp;\r\n\t\tamp *= 0.5;\r\n\t}\r\n\treturn min(n, 1.0);\r\n}\r\n\r\nfloat deRing(vec3 p)\r\n{\r\n    p.x-=clamp(p.x,-1.0,1.0);\r\n    return length(vec2(length(p.xy)-1.0,p.z))-0.5;\r\n}\r\n\r\nfloat deChain(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    vec3 q;\r\n    q=p;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q));\r\n    q=p;\r\n    q.x-=3.0;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q.xzy));\r\n#if BUMP\r\n    de+=fbm(p*5.0)*0.01;\r\n#endif\r\n    return de;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    for(float i=0.0; i<10.0; i++)\r\n    {\r\n        vec3 q = p;\r\n        q+=randVec(i*3.22)*10.0-5.0;\r\n        vec3 v = randVec(i+7753.2223);\r\n        vec3 w=normalize(v);\r\n        vec3 u=normalize(cross(w,v.yzx));\r\n        q *= mat3(u,cross(u,w),w);\r\n        de=min(de, deChain(q));\r\n    }    \r\n    return de;\r\n}\r\n\r\nvec3 calcNormal(vec3 pos){\r\n  vec2 e = vec2(1,-1) * 0.002;\r\n  return normalize(\r\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \r\n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\r\n  );\r\n}\r\n\r\n#define quantize(t, a)floor(t*a)/a\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\r\n    float s=uv.y;\r\n    float g=quantize(fract(uv.y+iTime*0.5),30.0);\r\n    uv.x += 0.1*sin(iTime*8.0+g*10.0)*\r\n        step(hash(floor(iTime*2.0))*0.4+0.6,hash(g))*\r\n        step(0.95,sin(iTime*0.5+1.5*sin(iTime*2.0)));\r\n    vec3 ro=vec3(0,5,-10);\r\n    ro= vec3(cos(iTime*0.5+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.8+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\r\n    ro*=3.5;\r\n    vec3 ta=vec3(3);\r\n    ta.xz*=rot(iTime);\r\n    ta.xy*=rot(iTime*0.3);\r\n    vec3 w = normalize(ta-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\r\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\r\n    vec3 col=vec3(0.12,0.1,0.03)+fbm(vec3(uv,iTime*0.5)*0.8)*0.3;\r\n    float t=1.0,d;\r\n    for(int i=0;i<96;i++)\r\n    {\r\n        t+=d=map(ro+rd*t);\r\n        if (d<0.001) break;\r\n    }\r\n    if(d<0.001)\r\n    {\r\n        vec3 p=ro+rd*t;\r\n        vec3 nor = calcNormal(p);\r\n        vec3 li = normalize(vec3(1));\r\n        vec3 bg=col;\r\n        col= vec3(1,0.95,0.85);\r\n        col*=exp2(-2.*pow(max(0.0, 1.0-map(p+nor*0.3)/0.3),2.0));\r\n        col*=max(0.,dot(nor,li));\r\n        col*=max(0.0,0.5+nor.y*0.5);\r\n        col+=pow(max(0.0,dot(reflect(normalize(p-ro),nor),li)),20.0);\r\n        col = mix(bg, col, exp(-t*t*0.0003));\r\n    }\r\n    col *= sin(s * 250.0 - iTime * 5.0) * 0.2 + 0.9;\r\n    fragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"#define BUMP 0\r\n\r\n#define PI acos(-1.0)\r\n#define TAU PI*2.0\r\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\r\n\r\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\r\n#define hash(n)fract(sin(n+1234.5)*55555.0)\r\n\r\nvec3 randVec(float n)\r\n{\r\n\tvec3 v=vec3(1,0,0);\r\n    v.xy*=rot(asin(hash(n)*2.-1.));\r\n    n+=123.0;\r\n    v.xz*=rot((hash(n)*2.-1.)*PI);\r\n\treturn v;\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    vec3 r=vec3(1,99,999);\r\n    vec4 s=dot(floor(p),r)+vec4(0,r.y,r.z,r.y+r.z);\r\n    p=smoothstep(0.,1.,fract(p));\r\n    s=mix(hash(s),hash(s+1.),p.x);\r\n    s.xy=mix(s.xz,s.yw,p.y);\r\n    return mix(s.x,s.y,p.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n   \tfloat n = 0.0;\r\n    float amp = 0.8;\r\n\tfor (int i=0; i<4; i++)\r\n\t{\r\n\t\tn += noise(p)*amp;\r\n\t\tamp *= 0.5;\r\n\t}\r\n\treturn min(n, 1.0);\r\n}\r\n\r\nfloat deRing(vec3 p)\r\n{\r\n    p.x-=clamp(p.x,-1.0,1.0);\r\n    return length(vec2(length(p.xy)-1.0,p.z))-0.5;\r\n}\r\n\r\nfloat deChain(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    vec3 q;\r\n    q=p;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q));\r\n    q=p;\r\n    q.x-=3.0;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q.xzy));\r\n#if BUMP\r\n    de+=fbm(p*5.0)*0.01;\r\n#endif\r\n    return de;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    for(float i=0.0; i<10.0; i++)\r\n    {\r\n        vec3 q = p;\r\n        q+=randVec(i*3.22)*10.0-5.0;\r\n        vec3 v = randVec(i+7753.2223);\r\n        vec3 w=normalize(v);\r\n        vec3 u=normalize(cross(w,v.yzx));\r\n        q *= mat3(u,cross(u,w),w);\r\n        de=min(de, deChain(q));\r\n    }    \r\n    return de;\r\n}\r\n\r\nvec3 calcNormal(vec3 pos){\r\n  vec2 e = vec2(1,-1) * 0.002;\r\n  return normalize(\r\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \r\n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\r\n  );\r\n}\r\n\r\n#define quantize(t, a)floor(t*a)/a\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\r\n    float s=uv.y;\r\n    float g=quantize(fract(uv.y+iTime*0.5),30.0);\r\n    uv.x += 0.1*sin(iTime*8.0+g*10.0)*\r\n        step(hash(floor(iTime*2.0))*0.4+0.6,hash(g))*\r\n        step(0.95,sin(iTime*0.5+1.5*sin(iTime*2.0)));\r\n    vec3 ro=vec3(0,5,-10);\r\n    ro= vec3(cos(iTime*0.5+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.8+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\r\n    ro*=3.5;\r\n    vec3 ta=vec3(3);\r\n    ta.xz*=rot(iTime);\r\n    ta.xy*=rot(iTime*0.3);\r\n    vec3 w = normalize(ta-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\r\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\r\n    vec3 col=vec3(0.12,0.1,0.03)+fbm(vec3(uv,iTime*0.5)*0.8)*0.3;\r\n    float t=1.0,d;\r\n    for(int i=0;i<96;i++)\r\n    {\r\n        t+=d=map(ro+rd*t);\r\n        if (d<0.001) break;\r\n    }\r\n    if(d<0.001)\r\n    {\r\n        vec3 p=ro+rd*t;\r\n        vec3 nor = calcNormal(p);\r\n        vec3 li = normalize(vec3(1));\r\n        vec3 bg=col;\r\n        col= vec3(1,0.95,0.85);\r\n        col*=exp2(-2.*pow(max(0.0, 1.0-map(p+nor*0.3)/0.3),2.0));\r\n        col*=max(0.,dot(nor,li));\r\n        col*=max(0.0,0.5+nor.y*0.5);\r\n        col+=pow(max(0.0,dot(reflect(normalize(p-ro),nor),li)),20.0);\r\n        col = mix(bg, col, exp(-t*t*0.0003));\r\n    }\r\n    col *= sin(s * 250.0 - iTime * 5.0) * 0.2 + 0.9;\r\n    fragColor = vec4(col, 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Blocked with chains","id":"12f19e8a384c47ad9bff11f467050212","date":null,"viewed":0,"name":"Blocked with chains","description":"Blocked with chains","likes":0,"published":null,"tags":[""]},"ver":null,"info":{"Name":"Blocked with chains","id":"12f19e8a384c47ad9bff11f467050212","date":null,"viewed":0,"name":"Blocked with chains","description":"Blocked with chains","likes":0,"published":null,"tags":[""]},"renderpass":[{"Code":"#define BUMP 0\r\n\r\n#define PI acos(-1.0)\r\n#define TAU PI*2.0\r\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\r\n\r\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\r\n#define hash(n)fract(sin(n+1234.5)*55555.0)\r\n\r\nvec3 randVec(float n)\r\n{\r\n\tvec3 v=vec3(1,0,0);\r\n    v.xy*=rot(asin(hash(n)*2.-1.));\r\n    n+=123.0;\r\n    v.xz*=rot((hash(n)*2.-1.)*PI);\r\n\treturn v;\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    vec3 r=vec3(1,99,999);\r\n    vec4 s=dot(floor(p),r)+vec4(0,r.y,r.z,r.y+r.z);\r\n    p=smoothstep(0.,1.,fract(p));\r\n    s=mix(hash(s),hash(s+1.),p.x);\r\n    s.xy=mix(s.xz,s.yw,p.y);\r\n    return mix(s.x,s.y,p.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n   \tfloat n = 0.0;\r\n    float amp = 0.8;\r\n\tfor (int i=0; i<4; i++)\r\n\t{\r\n\t\tn += noise(p)*amp;\r\n\t\tamp *= 0.5;\r\n\t}\r\n\treturn min(n, 1.0);\r\n}\r\n\r\nfloat deRing(vec3 p)\r\n{\r\n    p.x-=clamp(p.x,-1.0,1.0);\r\n    return length(vec2(length(p.xy)-1.0,p.z))-0.5;\r\n}\r\n\r\nfloat deChain(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    vec3 q;\r\n    q=p;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q));\r\n    q=p;\r\n    q.x-=3.0;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q.xzy));\r\n#if BUMP\r\n    de+=fbm(p*5.0)*0.01;\r\n#endif\r\n    return de;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    for(float i=0.0; i<10.0; i++)\r\n    {\r\n        vec3 q = p;\r\n        q+=randVec(i*3.22)*10.0-5.0;\r\n        vec3 v = randVec(i+7753.2223);\r\n        vec3 w=normalize(v);\r\n        vec3 u=normalize(cross(w,v.yzx));\r\n        q *= mat3(u,cross(u,w),w);\r\n        de=min(de, deChain(q));\r\n    }    \r\n    return de;\r\n}\r\n\r\nvec3 calcNormal(vec3 pos){\r\n  vec2 e = vec2(1,-1) * 0.002;\r\n  return normalize(\r\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \r\n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\r\n  );\r\n}\r\n\r\n#define quantize(t, a)floor(t*a)/a\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\r\n    float s=uv.y;\r\n    float g=quantize(fract(uv.y+iTime*0.5),30.0);\r\n    uv.x += 0.1*sin(iTime*8.0+g*10.0)*\r\n        step(hash(floor(iTime*2.0))*0.4+0.6,hash(g))*\r\n        step(0.95,sin(iTime*0.5+1.5*sin(iTime*2.0)));\r\n    vec3 ro=vec3(0,5,-10);\r\n    ro= vec3(cos(iTime*0.5+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.8+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\r\n    ro*=3.5;\r\n    vec3 ta=vec3(3);\r\n    ta.xz*=rot(iTime);\r\n    ta.xy*=rot(iTime*0.3);\r\n    vec3 w = normalize(ta-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\r\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\r\n    vec3 col=vec3(0.12,0.1,0.03)+fbm(vec3(uv,iTime*0.5)*0.8)*0.3;\r\n    float t=1.0,d;\r\n    for(int i=0;i<96;i++)\r\n    {\r\n        t+=d=map(ro+rd*t);\r\n        if (d<0.001) break;\r\n    }\r\n    if(d<0.001)\r\n    {\r\n        vec3 p=ro+rd*t;\r\n        vec3 nor = calcNormal(p);\r\n        vec3 li = normalize(vec3(1));\r\n        vec3 bg=col;\r\n        col= vec3(1,0.95,0.85);\r\n        col*=exp2(-2.*pow(max(0.0, 1.0-map(p+nor*0.3)/0.3),2.0));\r\n        col*=max(0.,dot(nor,li));\r\n        col*=max(0.0,0.5+nor.y*0.5);\r\n        col+=pow(max(0.0,dot(reflect(normalize(p-ro),nor),li)),20.0);\r\n        col = mix(bg, col, exp(-t*t*0.0003));\r\n    }\r\n    col *= sin(s * 250.0 - iTime * 5.0) * 0.2 + 0.9;\r\n    fragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"#define BUMP 0\r\n\r\n#define PI acos(-1.0)\r\n#define TAU PI*2.0\r\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\r\n\r\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\r\n#define hash(n)fract(sin(n+1234.5)*55555.0)\r\n\r\nvec3 randVec(float n)\r\n{\r\n\tvec3 v=vec3(1,0,0);\r\n    v.xy*=rot(asin(hash(n)*2.-1.));\r\n    n+=123.0;\r\n    v.xz*=rot((hash(n)*2.-1.)*PI);\r\n\treturn v;\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    vec3 r=vec3(1,99,999);\r\n    vec4 s=dot(floor(p),r)+vec4(0,r.y,r.z,r.y+r.z);\r\n    p=smoothstep(0.,1.,fract(p));\r\n    s=mix(hash(s),hash(s+1.),p.x);\r\n    s.xy=mix(s.xz,s.yw,p.y);\r\n    return mix(s.x,s.y,p.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n   \tfloat n = 0.0;\r\n    float amp = 0.8;\r\n\tfor (int i=0; i<4; i++)\r\n\t{\r\n\t\tn += noise(p)*amp;\r\n\t\tamp *= 0.5;\r\n\t}\r\n\treturn min(n, 1.0);\r\n}\r\n\r\nfloat deRing(vec3 p)\r\n{\r\n    p.x-=clamp(p.x,-1.0,1.0);\r\n    return length(vec2(length(p.xy)-1.0,p.z))-0.5;\r\n}\r\n\r\nfloat deChain(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    vec3 q;\r\n    q=p;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q));\r\n    q=p;\r\n    q.x-=3.0;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q.xzy));\r\n#if BUMP\r\n    de+=fbm(p*5.0)*0.01;\r\n#endif\r\n    return de;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    for(float i=0.0; i<10.0; i++)\r\n    {\r\n        vec3 q = p;\r\n        q+=randVec(i*3.22)*10.0-5.0;\r\n        vec3 v = randVec(i+7753.2223);\r\n        vec3 w=normalize(v);\r\n        vec3 u=normalize(cross(w,v.yzx));\r\n        q *= mat3(u,cross(u,w),w);\r\n        de=min(de, deChain(q));\r\n    }    \r\n    return de;\r\n}\r\n\r\nvec3 calcNormal(vec3 pos){\r\n  vec2 e = vec2(1,-1) * 0.002;\r\n  return normalize(\r\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \r\n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\r\n  );\r\n}\r\n\r\n#define quantize(t, a)floor(t*a)/a\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\r\n    float s=uv.y;\r\n    float g=quantize(fract(uv.y+iTime*0.5),30.0);\r\n    uv.x += 0.1*sin(iTime*8.0+g*10.0)*\r\n        step(hash(floor(iTime*2.0))*0.4+0.6,hash(g))*\r\n        step(0.95,sin(iTime*0.5+1.5*sin(iTime*2.0)));\r\n    vec3 ro=vec3(0,5,-10);\r\n    ro= vec3(cos(iTime*0.5+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.8+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\r\n    ro*=3.5;\r\n    vec3 ta=vec3(3);\r\n    ta.xz*=rot(iTime);\r\n    ta.xy*=rot(iTime*0.3);\r\n    vec3 w = normalize(ta-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\r\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\r\n    vec3 col=vec3(0.12,0.1,0.03)+fbm(vec3(uv,iTime*0.5)*0.8)*0.3;\r\n    float t=1.0,d;\r\n    for(int i=0;i<96;i++)\r\n    {\r\n        t+=d=map(ro+rd*t);\r\n        if (d<0.001) break;\r\n    }\r\n    if(d<0.001)\r\n    {\r\n        vec3 p=ro+rd*t;\r\n        vec3 nor = calcNormal(p);\r\n        vec3 li = normalize(vec3(1));\r\n        vec3 bg=col;\r\n        col= vec3(1,0.95,0.85);\r\n        col*=exp2(-2.*pow(max(0.0, 1.0-map(p+nor*0.3)/0.3),2.0));\r\n        col*=max(0.,dot(nor,li));\r\n        col*=max(0.0,0.5+nor.y*0.5);\r\n        col+=pow(max(0.0,dot(reflect(normalize(p-ro),nor),li)),20.0);\r\n        col = mix(bg, col, exp(-t*t*0.0003));\r\n    }\r\n    col *= sin(s * 250.0 - iTime * 5.0) * 0.2 + 0.9;\r\n    fragColor = vec4(col, 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Brush Experiment 3","id":"967daff3cc654ceba92483c53cab5825","date":null,"viewed":0,"name":"Brush Experiment 3","description":"Expanding on experiment 2, but for drawing circles. Mouse X controls falloff. Code is heavily commented showing the concept, not optimized at all.\nhttps://www.shadertoy.com/view/ltj3Wc","likes":0,"published":null,"tags":["2d"," brush"," calligraphy"]},"ver":null,"info":{"Name":"Brush Experiment 3","id":"967daff3cc654ceba92483c53cab5825","date":null,"viewed":0,"name":"Brush Experiment 3","description":"Expanding on experiment 2, but for drawing circles. Mouse X controls falloff. Code is heavily commented showing the concept, not optimized at all.\nhttps://www.shadertoy.com/view/ltj3Wc","likes":0,"published":null,"tags":["2d"," brush"," calligraphy"]},"renderpass":[{"Code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tuv.x *=  iResolution.x / iResolution.y;\r\n\r\n    // background\t \r\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\r\n\r\n    // bubbles\t\r\n\tfor( int i=0; i<40; i++ )\r\n\t{\r\n        // bubble seeds\r\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\r\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\r\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\r\n\r\n        // buble size, position and color\r\n\t\tfloat rad = 0.1 + 0.5*siz;\r\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\r\n\t\tfloat dis = length( uv - pos );\r\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\r\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\r\n\t\t\r\n        // render\r\n\t\tfloat f = length(uv-pos)/rad;\r\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\r\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\r\n\t}\r\n\r\n    // vigneting\t\r\n\tcolor *= sqrt(1.5-0.5*length(uv));\r\n\r\n\tfragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tuv.x *=  iResolution.x / iResolution.y;\r\n\r\n    // background\t \r\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\r\n\r\n    // bubbles\t\r\n\tfor( int i=0; i<40; i++ )\r\n\t{\r\n        // bubble seeds\r\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\r\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\r\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\r\n\r\n        // buble size, position and color\r\n\t\tfloat rad = 0.1 + 0.5*siz;\r\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\r\n\t\tfloat dis = length( uv - pos );\r\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\r\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\r\n\t\t\r\n        // render\r\n\t\tfloat f = length(uv-pos)/rad;\r\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\r\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\r\n\t}\r\n\r\n    // vigneting\t\r\n\tcolor *= sqrt(1.5-0.5*length(uv));\r\n\r\n\tfragColor = vec4(color,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Bubbles","id":"dfa31a54b7744220b2e60b7c18e337f1","date":null,"viewed":0,"name":"Bubbles","description":"Happy Bubbles ^_^\nhttps://www.shadertoy.com/view/4dl3zn","likes":0,"published":null,"tags":["2d"]},"ver":null,"info":{"Name":"Bubbles","id":"dfa31a54b7744220b2e60b7c18e337f1","date":null,"viewed":0,"name":"Bubbles","description":"Happy Bubbles ^_^\nhttps://www.shadertoy.com/view/4dl3zn","likes":0,"published":null,"tags":["2d"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tuv.x *=  iResolution.x / iResolution.y;\r\n\r\n    // background\t \r\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\r\n\r\n    // bubbles\t\r\n\tfor( int i=0; i<40; i++ )\r\n\t{\r\n        // bubble seeds\r\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\r\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\r\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\r\n\r\n        // buble size, position and color\r\n\t\tfloat rad = 0.1 + 0.5*siz;\r\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\r\n\t\tfloat dis = length( uv - pos );\r\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\r\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\r\n\t\t\r\n        // render\r\n\t\tfloat f = length(uv-pos)/rad;\r\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\r\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\r\n\t}\r\n\r\n    // vigneting\t\r\n\tcolor *= sqrt(1.5-0.5*length(uv));\r\n\r\n\tfragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tuv.x *=  iResolution.x / iResolution.y;\r\n\r\n    // background\t \r\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\r\n\r\n    // bubbles\t\r\n\tfor( int i=0; i<40; i++ )\r\n\t{\r\n        // bubble seeds\r\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\r\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\r\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\r\n\r\n        // buble size, position and color\r\n\t\tfloat rad = 0.1 + 0.5*siz;\r\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\r\n\t\tfloat dis = length( uv - pos );\r\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\r\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\r\n\t\t\r\n        // render\r\n\t\tfloat f = length(uv-pos)/rad;\r\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\r\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\r\n\t}\r\n\r\n    // vigneting\t\r\n\tcolor *= sqrt(1.5-0.5*length(uv));\r\n\r\n\tfragColor = vec4(color,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Bump Mapping","id":"3l3GWS","date":"1577616030","viewed":34,"name":"Bump Mapping","description":"\u51F9\u51F8\u8D34\u56FE","likes":2,"published":"Public","tags":["noise","bump"]},"ver":"0.1","info":{"Name":"Bump Mapping","id":"3l3GWS","date":"1577616030","viewed":34,"name":"Bump Mapping","description":"\u51F9\u51F8\u8D34\u56FE","likes":2,"published":"Public","tags":["noise","bump"]},"renderpass":[{"Code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Catmull-Rom Spline Demo","id":"3tt3zS","date":"1576731439","viewed":48,"name":"Catmull-Rom Spline Demo","description":"Catmull-Rom\u6837\u6761\u7EBF\u63D2\u503C\u793A\u4F8B","likes":1,"published":"Public","tags":["spline","catmullrom","interpolating"]},"ver":"0.1","info":{"Name":"Catmull-Rom Spline Demo","id":"3tt3zS","date":"1576731439","viewed":48,"name":"Catmull-Rom Spline Demo","description":"Catmull-Rom\u6837\u6761\u7EBF\u63D2\u503C\u793A\u4F8B","likes":1,"published":"Public","tags":["spline","catmullrom","interpolating"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\r\n/*\r\nvoid mainImage( out vec4 O, in vec2 U )    // compact version by FabriceNeyret2 (having problems with it on windows)\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         i = ceil(p);\r\n    O -= O - C(i-p) * D(i-p, .5 + .4 * sin( iDate.w*SPEED + (i.x+i.y)*FREQUENCY + vec2(1.6,0) ));\r\n}*/\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         f = fract(p);\r\n    p=floor(p);\r\n    float t=(p.x+p.y)*FREQUENCY\r\n           +iTime*SPEED;\r\n    vec2 o=vec2(cos(t),sin(t))*.4+.5;\r\n    O.xyz = vec3(C(f)*D(f,o));\r\n}","inputs":[],"outputs":[],"code":"#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\r\n/*\r\nvoid mainImage( out vec4 O, in vec2 U )    // compact version by FabriceNeyret2 (having problems with it on windows)\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         i = ceil(p);\r\n    O -= O - C(i-p) * D(i-p, .5 + .4 * sin( iDate.w*SPEED + (i.x+i.y)*FREQUENCY + vec2(1.6,0) ));\r\n}*/\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         f = fract(p);\r\n    p=floor(p);\r\n    float t=(p.x+p.y)*FREQUENCY\r\n           +iTime*SPEED;\r\n    vec2 o=vec2(cos(t),sin(t))*.4+.5;\r\n    O.xyz = vec3(C(f)*D(f,o));\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"CircleWave","id":"c904d7f2bbbc41099884298668c704b6","date":null,"viewed":0,"name":"CircleWave","description":"wave effect","likes":0,"published":null,"tags":["wavecircle2d"]},"ver":null,"info":{"Name":"CircleWave","id":"c904d7f2bbbc41099884298668c704b6","date":null,"viewed":0,"name":"CircleWave","description":"wave effect","likes":0,"published":null,"tags":["wavecircle2d"]},"renderpass":[{"Code":"#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\r\n/*\r\nvoid mainImage( out vec4 O, in vec2 U )    // compact version by FabriceNeyret2 (having problems with it on windows)\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         i = ceil(p);\r\n    O -= O - C(i-p) * D(i-p, .5 + .4 * sin( iDate.w*SPEED + (i.x+i.y)*FREQUENCY + vec2(1.6,0) ));\r\n}*/\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         f = fract(p);\r\n    p=floor(p);\r\n    float t=(p.x+p.y)*FREQUENCY\r\n           +iTime*SPEED;\r\n    vec2 o=vec2(cos(t),sin(t))*.4+.5;\r\n    O.xyz = vec3(C(f)*D(f,o));\r\n}","inputs":[],"outputs":[],"code":"#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\r\n/*\r\nvoid mainImage( out vec4 O, in vec2 U )    // compact version by FabriceNeyret2 (having problems with it on windows)\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         i = ceil(p);\r\n    O -= O - C(i-p) * D(i-p, .5 + .4 * sin( iDate.w*SPEED + (i.x+i.y)*FREQUENCY + vec2(1.6,0) ));\r\n}*/\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         f = fract(p);\r\n    p=floor(p);\r\n    float t=(p.x+p.y)*FREQUENCY\r\n           +iTime*SPEED;\r\n    vec2 o=vec2(cos(t),sin(t))*.4+.5;\r\n    O.xyz = vec3(C(f)*D(f,o));\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// inspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\n\r\n#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? 1.-d : 0. )\r\n//#define P(i)    if (i.y<10.) O.gb += D(i-p, .5 + r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0) ));\r\n#define P(i)    R = r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0)); if ((p-R).y<10.1) O.b++, O.g+= D(i-p,.5+R);\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    O -= O;\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         I = vec2(.5,0);\r\n  //float r = 1.*U.y/R.y;\r\n    float r = .5*exp(-4.*(.5-U.y/R.y));\r\n\r\n    P( ceil(p))\r\n    P((ceil(p+.5)-.5))\r\n    P((ceil(p+I)-I))\r\n\r\n}","inputs":[],"outputs":[],"code":"// inspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\n\r\n#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? 1.-d : 0. )\r\n//#define P(i)    if (i.y<10.) O.gb += D(i-p, .5 + r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0) ));\r\n#define P(i)    R = r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0)); if ((p-R).y<10.1) O.b++, O.g+= D(i-p,.5+R);\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    O -= O;\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         I = vec2(.5,0);\r\n  //float r = 1.*U.y/R.y;\r\n    float r = .5*exp(-4.*(.5-U.y/R.y));\r\n\r\n    P( ceil(p))\r\n    P((ceil(p+.5)-.5))\r\n    P((ceil(p+I)-I))\r\n\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"CircleWave2 ","id":"055a4349f6a2432f9100cc087ff82aef","date":null,"viewed":0,"name":"CircleWave2 ","description":"trochoid waves caused by dephased rotations of water.\r\ninspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\nhttps://www.shadertoy.com/view/Xd33DH","likes":0,"published":null,"tags":["waves"," trochoid"," incompressible"," gerstner"]},"ver":null,"info":{"Name":"CircleWave2 ","id":"055a4349f6a2432f9100cc087ff82aef","date":null,"viewed":0,"name":"CircleWave2 ","description":"trochoid waves caused by dephased rotations of water.\r\ninspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\nhttps://www.shadertoy.com/view/Xd33DH","likes":0,"published":null,"tags":["waves"," trochoid"," incompressible"," gerstner"]},"renderpass":[{"Code":"// inspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\n\r\n#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? 1.-d : 0. )\r\n//#define P(i)    if (i.y<10.) O.gb += D(i-p, .5 + r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0) ));\r\n#define P(i)    R = r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0)); if ((p-R).y<10.1) O.b++, O.g+= D(i-p,.5+R);\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    O -= O;\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         I = vec2(.5,0);\r\n  //float r = 1.*U.y/R.y;\r\n    float r = .5*exp(-4.*(.5-U.y/R.y));\r\n\r\n    P( ceil(p))\r\n    P((ceil(p+.5)-.5))\r\n    P((ceil(p+I)-I))\r\n\r\n}","inputs":[],"outputs":[],"code":"// inspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\n\r\n#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? 1.-d : 0. )\r\n//#define P(i)    if (i.y<10.) O.gb += D(i-p, .5 + r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0) ));\r\n#define P(i)    R = r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0)); if ((p-R).y<10.1) O.b++, O.g+= D(i-p,.5+R);\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    O -= O;\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         I = vec2(.5,0);\r\n  //float r = 1.*U.y/R.y;\r\n    float r = .5*exp(-4.*(.5-U.y/R.y));\r\n\r\n    P( ceil(p))\r\n    P((ceil(p+.5)-.5))\r\n    P((ceil(p+I)-I))\r\n\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\r\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\r\n\r\nvec2 sphere1Pos = vec2(0.,0.);\r\nfloat sphere1Rad = .7;         // sphere radius\r\n\r\nfloat planePos = .1;\r\n\r\nvec2 sphere2Pos = vec2(1.,0.);\r\nfloat sphere2Rad = .2;         \r\n\r\n// cloud appearance (superseeded by mouse tuning)\r\n\r\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\r\nfloat sharp = 0.3;            // cloud sharness (0= ultra sharp ).\r\n\r\n\r\n\r\n#define ANIM 1         // 1/0\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n    return fract(sin(n-765.36334)*43758.5453);\r\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE==1\r\n\treturn res;\r\n#elif NOISE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n\r\n// smooth distance to sphere = [-1,1] around radius +- thickness H\r\n\r\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\r\n{\r\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\r\n\tfloat d = (1.-length(p))/H;  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\t\r\n// smooth distance to plane = [-1,1] around plane +- thickness H\r\n\r\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\r\n{\r\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\r\n\tfloat d = -p.x/(H*planeRad);  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\r\n// smooth intersect operator\r\n\r\nfloat inter(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*d0*d1 -1.;\r\n}\r\n\r\n// smooth union operator\r\n\r\nfloat add(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*(d0+d1-d0*d1) -1.;\r\n}\r\n\r\n// jitter the distance around 0  and smoothclamp\r\n\r\nfloat perturb(vec2 p, float d, float H) {\r\n#if ANIM\r\n   float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\r\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\r\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\r\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\r\n\t\r\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\r\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\r\n}\r\n\r\n// convert [-1,1] distances into densities\r\n\r\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\r\n\treturn smoothstep(-sharp,sharp,d);\r\n}\r\n\r\n\r\n// user-define shape\r\n\t\r\nfloat shape(vec2 uv,float n) {\r\n\t\r\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\r\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\r\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\r\n\tfloat v;\r\n\r\n#define globalNoise false\r\n\t\r\n\tif (globalNoise || (n==0.)) {\r\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\r\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\r\n\t}\r\n\telse {\r\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\r\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\r\n\t}\r\n\t\r\n\treturn v;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = 2.* (fragCoord.xy / iResolution.y - vec2(.8,.5) );\r\n\tif (iMouse.z>0.) {       \t\t\t\t   // mouse tuning\r\n\t\tvec2 m = iMouse.xy / iResolution.xy;\r\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \r\n\t}\r\n\r\n\tfloat v = dist2dens( shape(uv,1.) ); \r\n\tvec3 col = vec3(v);\r\n\t\r\n\tif (uv.y<0.) {                   \t // bottom half scren: display bounds\r\n\t\t\r\n\t\tsharp = 1e-5; // no noise for bounds\r\n\t\tfloat d = shape(uv,0.), dv = fwidth(d);\r\n\t\t\r\n\t\tv = dist2dens(d-0.99+dv)-dist2dens(d-0.99); // inner bound : draw on top\r\n\t\tcol = mix(col, vec3(v,0.,0.),v);\t\r\n\t\t\r\n\t\tv = dist2dens(d+.5*dv)-dist2dens(d-.5*dv);  // mid-bound: draw on top\r\n\t\tcol = mix(col, vec3(0.,v,0.),v);\r\n\t\t\r\n\t\tv = dist2dens(d+.99)-dist2dens(d+0.99-dv);  // exterior bound : draw below\r\n\t\tfloat alpha = max(col.r,col.g);\r\n\t\tcol = mix(vec3(0.,0.,v),col, alpha);\t\r\n\t\talpha = max(col.b,alpha);\r\n\t\t\r\n\t\tv = dist2dens(sphere(uv, sphere1Pos, sphere1Rad)+.99); // sphere without plane clipping\r\n\t\tcol = mix(v*vec3(0.,0.,.3),col, alpha);\t\r\n\t}\r\n\t\r\n    fragColor = vec4(col,0.); \r\n}\r\n","inputs":[],"outputs":[],"code":"#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\r\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\r\n\r\nvec2 sphere1Pos = vec2(0.,0.);\r\nfloat sphere1Rad = .7;         // sphere radius\r\n\r\nfloat planePos = .1;\r\n\r\nvec2 sphere2Pos = vec2(1.,0.);\r\nfloat sphere2Rad = .2;         \r\n\r\n// cloud appearance (superseeded by mouse tuning)\r\n\r\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\r\nfloat sharp = 0.3;            // cloud sharness (0= ultra sharp ).\r\n\r\n\r\n\r\n#define ANIM 1         // 1/0\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n    return fract(sin(n-765.36334)*43758.5453);\r\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE==1\r\n\treturn res;\r\n#elif NOISE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n\r\n// smooth distance to sphere = [-1,1] around radius +- thickness H\r\n\r\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\r\n{\r\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\r\n\tfloat d = (1.-length(p))/H;  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\t\r\n// smooth distance to plane = [-1,1] around plane +- thickness H\r\n\r\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\r\n{\r\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\r\n\tfloat d = -p.x/(H*planeRad);  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\r\n// smooth intersect operator\r\n\r\nfloat inter(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*d0*d1 -1.;\r\n}\r\n\r\n// smooth union operator\r\n\r\nfloat add(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*(d0+d1-d0*d1) -1.;\r\n}\r\n\r\n// jitter the distance around 0  and smoothclamp\r\n\r\nfloat perturb(vec2 p, float d, float H) {\r\n#if ANIM\r\n   float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\r\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\r\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\r\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\r\n\t\r\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\r\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\r\n}\r\n\r\n// convert [-1,1] distances into densities\r\n\r\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\r\n\treturn smoothstep(-sharp,sharp,d);\r\n}\r\n\r\n\r\n// user-define shape\r\n\t\r\nfloat shape(vec2 uv,float n) {\r\n\t\r\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\r\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\r\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\r\n\tfloat v;\r\n\r\n#define globalNoise false\r\n\t\r\n\tif (globalNoise || (n==0.)) {\r\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\r\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\r\n\t}\r\n\telse {\r\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\r\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\r\n\t}\r\n\t\r\n\treturn v;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = 2.* (fragCoord.xy / iResolution.y - vec2(.8,.5) );\r\n\tif (iMouse.z>0.) {       \t\t\t\t   // mouse tuning\r\n\t\tvec2 m = iMouse.xy / iResolution.xy;\r\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \r\n\t}\r\n\r\n\tfloat v = dist2dens( shape(uv,1.) ); \r\n\tvec3 col = vec3(v);\r\n\t\r\n\tif (uv.y<0.) {                   \t // bottom half scren: display bounds\r\n\t\t\r\n\t\tsharp = 1e-5; // no noise for bounds\r\n\t\tfloat d = shape(uv,0.), dv = fwidth(d);\r\n\t\t\r\n\t\tv = dist2dens(d-0.99+dv)-dist2dens(d-0.99); // inner bound : draw on top\r\n\t\tcol = mix(col, vec3(v,0.,0.),v);\t\r\n\t\t\r\n\t\tv = dist2dens(d+.5*dv)-dist2dens(d-.5*dv);  // mid-bound: draw on top\r\n\t\tcol = mix(col, vec3(0.,v,0.),v);\r\n\t\t\r\n\t\tv = dist2dens(d+.99)-dist2dens(d+0.99-dv);  // exterior bound : draw below\r\n\t\tfloat alpha = max(col.r,col.g);\r\n\t\tcol = mix(vec3(0.,0.,v),col, alpha);\t\r\n\t\talpha = max(col.b,alpha);\r\n\t\t\r\n\t\tv = dist2dens(sphere(uv, sphere1Pos, sphere1Rad)+.99); // sphere without plane clipping\r\n\t\tcol = mix(v*vec3(0.,0.,.3),col, alpha);\t\r\n\t}\r\n\t\r\n    fragColor = vec4(col,0.); \r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"clipped disc hypertexture 1","id":"41ff66540f354e74b84c58880788dd2d","date":null,"viewed":0,"name":"clipped disc hypertexture 1","description":"hypertexture (here, sphere clipped by plane) with well controlled thickness, i.e., noise saturating the \"skin\" range.\nmouse.x tune noise layer thickness\nmouse.y tune noise bluriness\nSee #define for more tunings\nhttps://www.shadertoy.com/view/lssSRn","likes":0,"published":null,"tags":["procedural"]},"ver":null,"info":{"Name":"clipped disc hypertexture 1","id":"41ff66540f354e74b84c58880788dd2d","date":null,"viewed":0,"name":"clipped disc hypertexture 1","description":"hypertexture (here, sphere clipped by plane) with well controlled thickness, i.e., noise saturating the \"skin\" range.\nmouse.x tune noise layer thickness\nmouse.y tune noise bluriness\nSee #define for more tunings\nhttps://www.shadertoy.com/view/lssSRn","likes":0,"published":null,"tags":["procedural"]},"renderpass":[{"Code":"#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\r\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\r\n\r\nvec2 sphere1Pos = vec2(0.,0.);\r\nfloat sphere1Rad = .7;         // sphere radius\r\n\r\nfloat planePos = .1;\r\n\r\nvec2 sphere2Pos = vec2(1.,0.);\r\nfloat sphere2Rad = .2;         \r\n\r\n// cloud appearance (superseeded by mouse tuning)\r\n\r\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\r\nfloat sharp = 0.3;            // cloud sharness (0= ultra sharp ).\r\n\r\n\r\n\r\n#define ANIM 1         // 1/0\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n    return fract(sin(n-765.36334)*43758.5453);\r\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE==1\r\n\treturn res;\r\n#elif NOISE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n\r\n// smooth distance to sphere = [-1,1] around radius +- thickness H\r\n\r\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\r\n{\r\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\r\n\tfloat d = (1.-length(p))/H;  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\t\r\n// smooth distance to plane = [-1,1] around plane +- thickness H\r\n\r\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\r\n{\r\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\r\n\tfloat d = -p.x/(H*planeRad);  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\r\n// smooth intersect operator\r\n\r\nfloat inter(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*d0*d1 -1.;\r\n}\r\n\r\n// smooth union operator\r\n\r\nfloat add(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*(d0+d1-d0*d1) -1.;\r\n}\r\n\r\n// jitter the distance around 0  and smoothclamp\r\n\r\nfloat perturb(vec2 p, float d, float H) {\r\n#if ANIM\r\n   float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\r\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\r\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\r\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\r\n\t\r\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\r\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\r\n}\r\n\r\n// convert [-1,1] distances into densities\r\n\r\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\r\n\treturn smoothstep(-sharp,sharp,d);\r\n}\r\n\r\n\r\n// user-define shape\r\n\t\r\nfloat shape(vec2 uv,float n) {\r\n\t\r\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\r\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\r\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\r\n\tfloat v;\r\n\r\n#define globalNoise false\r\n\t\r\n\tif (globalNoise || (n==0.)) {\r\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\r\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\r\n\t}\r\n\telse {\r\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\r\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\r\n\t}\r\n\t\r\n\treturn v;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = 2.* (fragCoord.xy / iResolution.y - vec2(.8,.5) );\r\n\tif (iMouse.z>0.) {       \t\t\t\t   // mouse tuning\r\n\t\tvec2 m = iMouse.xy / iResolution.xy;\r\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \r\n\t}\r\n\r\n\tfloat v = dist2dens( shape(uv,1.) ); \r\n\tvec3 col = vec3(v);\r\n\t\r\n\tif (uv.y<0.) {                   \t // bottom half scren: display bounds\r\n\t\t\r\n\t\tsharp = 1e-5; // no noise for bounds\r\n\t\tfloat d = shape(uv,0.), dv = fwidth(d);\r\n\t\t\r\n\t\tv = dist2dens(d-0.99+dv)-dist2dens(d-0.99); // inner bound : draw on top\r\n\t\tcol = mix(col, vec3(v,0.,0.),v);\t\r\n\t\t\r\n\t\tv = dist2dens(d+.5*dv)-dist2dens(d-.5*dv);  // mid-bound: draw on top\r\n\t\tcol = mix(col, vec3(0.,v,0.),v);\r\n\t\t\r\n\t\tv = dist2dens(d+.99)-dist2dens(d+0.99-dv);  // exterior bound : draw below\r\n\t\tfloat alpha = max(col.r,col.g);\r\n\t\tcol = mix(vec3(0.,0.,v),col, alpha);\t\r\n\t\talpha = max(col.b,alpha);\r\n\t\t\r\n\t\tv = dist2dens(sphere(uv, sphere1Pos, sphere1Rad)+.99); // sphere without plane clipping\r\n\t\tcol = mix(v*vec3(0.,0.,.3),col, alpha);\t\r\n\t}\r\n\t\r\n    fragColor = vec4(col,0.); \r\n}\r\n","inputs":[],"outputs":[],"code":"#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\r\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\r\n\r\nvec2 sphere1Pos = vec2(0.,0.);\r\nfloat sphere1Rad = .7;         // sphere radius\r\n\r\nfloat planePos = .1;\r\n\r\nvec2 sphere2Pos = vec2(1.,0.);\r\nfloat sphere2Rad = .2;         \r\n\r\n// cloud appearance (superseeded by mouse tuning)\r\n\r\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\r\nfloat sharp = 0.3;            // cloud sharness (0= ultra sharp ).\r\n\r\n\r\n\r\n#define ANIM 1         // 1/0\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n    return fract(sin(n-765.36334)*43758.5453);\r\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE==1\r\n\treturn res;\r\n#elif NOISE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n\r\n// smooth distance to sphere = [-1,1] around radius +- thickness H\r\n\r\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\r\n{\r\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\r\n\tfloat d = (1.-length(p))/H;  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\t\r\n// smooth distance to plane = [-1,1] around plane +- thickness H\r\n\r\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\r\n{\r\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\r\n\tfloat d = -p.x/(H*planeRad);  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\r\n// smooth intersect operator\r\n\r\nfloat inter(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*d0*d1 -1.;\r\n}\r\n\r\n// smooth union operator\r\n\r\nfloat add(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*(d0+d1-d0*d1) -1.;\r\n}\r\n\r\n// jitter the distance around 0  and smoothclamp\r\n\r\nfloat perturb(vec2 p, float d, float H) {\r\n#if ANIM\r\n   float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\r\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\r\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\r\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\r\n\t\r\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\r\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\r\n}\r\n\r\n// convert [-1,1] distances into densities\r\n\r\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\r\n\treturn smoothstep(-sharp,sharp,d);\r\n}\r\n\r\n\r\n// user-define shape\r\n\t\r\nfloat shape(vec2 uv,float n) {\r\n\t\r\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\r\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\r\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\r\n\tfloat v;\r\n\r\n#define globalNoise false\r\n\t\r\n\tif (globalNoise || (n==0.)) {\r\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\r\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\r\n\t}\r\n\telse {\r\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\r\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\r\n\t}\r\n\t\r\n\treturn v;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = 2.* (fragCoord.xy / iResolution.y - vec2(.8,.5) );\r\n\tif (iMouse.z>0.) {       \t\t\t\t   // mouse tuning\r\n\t\tvec2 m = iMouse.xy / iResolution.xy;\r\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \r\n\t}\r\n\r\n\tfloat v = dist2dens( shape(uv,1.) ); \r\n\tvec3 col = vec3(v);\r\n\t\r\n\tif (uv.y<0.) {                   \t // bottom half scren: display bounds\r\n\t\t\r\n\t\tsharp = 1e-5; // no noise for bounds\r\n\t\tfloat d = shape(uv,0.), dv = fwidth(d);\r\n\t\t\r\n\t\tv = dist2dens(d-0.99+dv)-dist2dens(d-0.99); // inner bound : draw on top\r\n\t\tcol = mix(col, vec3(v,0.,0.),v);\t\r\n\t\t\r\n\t\tv = dist2dens(d+.5*dv)-dist2dens(d-.5*dv);  // mid-bound: draw on top\r\n\t\tcol = mix(col, vec3(0.,v,0.),v);\r\n\t\t\r\n\t\tv = dist2dens(d+.99)-dist2dens(d+0.99-dv);  // exterior bound : draw below\r\n\t\tfloat alpha = max(col.r,col.g);\r\n\t\tcol = mix(vec3(0.,0.,v),col, alpha);\t\r\n\t\talpha = max(col.b,alpha);\r\n\t\t\r\n\t\tv = dist2dens(sphere(uv, sphere1Pos, sphere1Rad)+.99); // sphere without plane clipping\r\n\t\tcol = mix(v*vec3(0.,0.,.3),col, alpha);\t\r\n\t}\r\n\t\r\n    fragColor = vec4(col,0.); \r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Naive texture fetching of atan() based UVs can create some\r\n// discontinuities in the derivatives (see a line of weird pixels\r\n// on the left side of the sccren if you enable NAIVE_IMPLEMENTATION\r\n// and if the viewport resolution is an odd number).\r\n//\r\n// This shader shows one way to fix it, in lines 41 and 42. More info:\r\n//\r\n// http://www.iquilezles.org/www/articles/tunnel/tunnel.htm\r\n\r\n\r\n#define NAIVE_IMPLEMENTATION\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\r\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fbm(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\r\n\r\nvec3 randomColorMap(in vec2 p){\r\n    return vec3(fbm(p),fbm(p+0.01),fbm(p+1.11));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized coordinates (-1 to 1 vertically)\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n\r\n    // angle of each pixel to the center of the screen\r\n    float a = atan(p.y,p.x);\r\n\r\n    #if 0\r\n    // cylindrical tunnel\r\n    float r = length(p);\r\n    #else\r\n    // squareish tunnel\r\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\r\n    #endif\r\n    \r\n    // index texture by (animated inverse) radious and angle\r\n    vec2 uv = vec2( 0.3/r + 0.2*iTime, a/3.1415927 );\r\n\r\n    #ifdef NAIVE_IMPLEMENTATION\r\n        // naive fecth color\r\n        vec3 col =  randomColorMap(uv);// texture( iChannel0, uv ).xyz;\r\n\t#else\r\n        // fetch color with correct texture gradients, to prevent discontinutity\r\n        vec2 uv2 = vec2( uv.x, atan(p.y,abs(p.x))/3.1415927 );\r\n        vec3 col = textureGrad( iChannel0, uv, dFdx(uv2), dFdy(uv2) ).xyz;\r\n\t#endif\r\n    \r\n    // darken at the center    \r\n    col = col*r;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Naive texture fetching of atan() based UVs can create some\r\n// discontinuities in the derivatives (see a line of weird pixels\r\n// on the left side of the sccren if you enable NAIVE_IMPLEMENTATION\r\n// and if the viewport resolution is an odd number).\r\n//\r\n// This shader shows one way to fix it, in lines 41 and 42. More info:\r\n//\r\n// http://www.iquilezles.org/www/articles/tunnel/tunnel.htm\r\n\r\n\r\n#define NAIVE_IMPLEMENTATION\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\r\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fbm(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\r\n\r\nvec3 randomColorMap(in vec2 p){\r\n    return vec3(fbm(p),fbm(p+0.01),fbm(p+1.11));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized coordinates (-1 to 1 vertically)\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n\r\n    // angle of each pixel to the center of the screen\r\n    float a = atan(p.y,p.x);\r\n\r\n    #if 0\r\n    // cylindrical tunnel\r\n    float r = length(p);\r\n    #else\r\n    // squareish tunnel\r\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\r\n    #endif\r\n    \r\n    // index texture by (animated inverse) radious and angle\r\n    vec2 uv = vec2( 0.3/r + 0.2*iTime, a/3.1415927 );\r\n\r\n    #ifdef NAIVE_IMPLEMENTATION\r\n        // naive fecth color\r\n        vec3 col =  randomColorMap(uv);// texture( iChannel0, uv ).xyz;\r\n\t#else\r\n        // fetch color with correct texture gradients, to prevent discontinutity\r\n        vec2 uv2 = vec2( uv.x, atan(p.y,abs(p.x))/3.1415927 );\r\n        vec3 col = textureGrad( iChannel0, uv, dFdx(uv2), dFdy(uv2) ).xyz;\r\n\t#endif\r\n    \r\n    // darken at the center    \r\n    col = col*r;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Deform - square tunnel","id":"af0d0884f7564ee3b2692b28a83d8b2c","date":null,"viewed":0,"name":"Deform - square tunnel","description":"A 2D square tunnel. If done naively, the tunnel will have a discontinuity in the left side of the screen where the atan() function branches. Taking derivatives on the right where there's no branch and applying them on the left side fixes the problem.\nhttps://www.shadertoy.com/view/Ms2SWW","likes":0,"published":null,"tags":["2d"," planedeformation"," deform"," distance"," metric"]},"ver":null,"info":{"Name":"Deform - square tunnel","id":"af0d0884f7564ee3b2692b28a83d8b2c","date":null,"viewed":0,"name":"Deform - square tunnel","description":"A 2D square tunnel. If done naively, the tunnel will have a discontinuity in the left side of the screen where the atan() function branches. Taking derivatives on the right where there's no branch and applying them on the left side fixes the problem.\nhttps://www.shadertoy.com/view/Ms2SWW","likes":0,"published":null,"tags":["2d"," planedeformation"," deform"," distance"," metric"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Naive texture fetching of atan() based UVs can create some\r\n// discontinuities in the derivatives (see a line of weird pixels\r\n// on the left side of the sccren if you enable NAIVE_IMPLEMENTATION\r\n// and if the viewport resolution is an odd number).\r\n//\r\n// This shader shows one way to fix it, in lines 41 and 42. More info:\r\n//\r\n// http://www.iquilezles.org/www/articles/tunnel/tunnel.htm\r\n\r\n\r\n#define NAIVE_IMPLEMENTATION\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\r\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fbm(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\r\n\r\nvec3 randomColorMap(in vec2 p){\r\n    return vec3(fbm(p),fbm(p+0.01),fbm(p+1.11));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized coordinates (-1 to 1 vertically)\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n\r\n    // angle of each pixel to the center of the screen\r\n    float a = atan(p.y,p.x);\r\n\r\n    #if 0\r\n    // cylindrical tunnel\r\n    float r = length(p);\r\n    #else\r\n    // squareish tunnel\r\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\r\n    #endif\r\n    \r\n    // index texture by (animated inverse) radious and angle\r\n    vec2 uv = vec2( 0.3/r + 0.2*iTime, a/3.1415927 );\r\n\r\n    #ifdef NAIVE_IMPLEMENTATION\r\n        // naive fecth color\r\n        vec3 col =  randomColorMap(uv);// texture( iChannel0, uv ).xyz;\r\n\t#else\r\n        // fetch color with correct texture gradients, to prevent discontinutity\r\n        vec2 uv2 = vec2( uv.x, atan(p.y,abs(p.x))/3.1415927 );\r\n        vec3 col = textureGrad( iChannel0, uv, dFdx(uv2), dFdy(uv2) ).xyz;\r\n\t#endif\r\n    \r\n    // darken at the center    \r\n    col = col*r;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Naive texture fetching of atan() based UVs can create some\r\n// discontinuities in the derivatives (see a line of weird pixels\r\n// on the left side of the sccren if you enable NAIVE_IMPLEMENTATION\r\n// and if the viewport resolution is an odd number).\r\n//\r\n// This shader shows one way to fix it, in lines 41 and 42. More info:\r\n//\r\n// http://www.iquilezles.org/www/articles/tunnel/tunnel.htm\r\n\r\n\r\n#define NAIVE_IMPLEMENTATION\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\r\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fbm(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\r\n\r\nvec3 randomColorMap(in vec2 p){\r\n    return vec3(fbm(p),fbm(p+0.01),fbm(p+1.11));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized coordinates (-1 to 1 vertically)\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n\r\n    // angle of each pixel to the center of the screen\r\n    float a = atan(p.y,p.x);\r\n\r\n    #if 0\r\n    // cylindrical tunnel\r\n    float r = length(p);\r\n    #else\r\n    // squareish tunnel\r\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\r\n    #endif\r\n    \r\n    // index texture by (animated inverse) radious and angle\r\n    vec2 uv = vec2( 0.3/r + 0.2*iTime, a/3.1415927 );\r\n\r\n    #ifdef NAIVE_IMPLEMENTATION\r\n        // naive fecth color\r\n        vec3 col =  randomColorMap(uv);// texture( iChannel0, uv ).xyz;\r\n\t#else\r\n        // fetch color with correct texture gradients, to prevent discontinutity\r\n        vec2 uv2 = vec2( uv.x, atan(p.y,abs(p.x))/3.1415927 );\r\n        vec3 col = textureGrad( iChannel0, uv, dFdx(uv2), dFdy(uv2) ).xyz;\r\n\t#endif\r\n    \r\n    // darken at the center    \r\n    col = col*r;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// efficient distance to spline relying on the iterative construction of splines.\r\n\r\n#define POINTS 8  \t\t // number of control points\r\n\r\nconst int   SUBDIV=5;    // subdivision depth for the analytic method\r\nconst float sampl=120.; // number of samples per spline for the costly method\r\nfloat t;\r\n\r\nbool SHOW_MESH, SHOW_LINE, SHOW_GRAD, SHOW_ISO, SHOW_COSTLY;\r\n\r\n// --- GUI utils\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat cross2(vec2 v0, vec2 v1) {\treturn v0.x*v1.y - v0.y*v1.x; }\r\nfloat amin(float a, float b) { return (abs(a)<abs(b)) ? a : b ; }\r\nfloat amax(float a, float b) { return (abs(a)>abs(b)) ? a : b ; }\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n// --- dist pos to seg P0P1\r\n\r\nbool SIGNED_DIST = true; // if signed, positive distance is at left of oriented segment\r\nbool FLIP=false;         // for normalized turn direction (we want dist negative inside shape)\r\n\r\nfloat dist2seg(vec2 pos, vec2 P0, vec2 P1) {\r\n\tif (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }\r\n\tvec2 P0P1 = P1-P0, P0Pos = pos-P0;\r\n\tfloat d, l2_01=dist2(P0,P1);\r\n\r\n\t// --- if projection out of segment bounds, dist to extremity\r\n\t// Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)\r\n\tfloat l = dot(P0Pos, P0P1)/l2_01;\r\n\tif      (l <= 0.) return distance(pos,P0);\r\n\telse if (l >= 1.) return distance(pos,P1);\r\n\r\n\t// --- dist to seg = dist to line\r\n\telse if (SIGNED_DIST) \r\n\t    { float D = cross2(P0P1,P0Pos); return D/sqrt(l2_01); }\r\n\telse return distance(pos, P0+l*P0P1);\r\n}\r\n\r\n// --- min/max dist to quadrilateral P0P1P2P3 (possibly non-convex)\r\n\r\nvec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\r\n\r\n\tvec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;\r\n\r\n\t// makes the quadri convex if not: the 4 turns must have same sign.\r\n\t//    Note that alternate signs cannot happen (wouldn't loop), so possibility are:\r\n\t// all same, 1 different ('>'), 2 + then 2 - ('X').\r\n\t// for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.\r\n\r\n\t// measure turns direction\r\n#define ssign(v) (((v)>=0.) ? 1 : -1)\r\n\tint t0 = ssign(cross2(P30,P01)), t1 = ssign(cross2(P01,P12)),\t\r\n\t\tt2 = ssign(cross2(P12,P23)), t3 = ssign(cross2(P23,P30));\r\n\tif (SIGNED_DIST &&(t0>0)) // if direct, makes it indirect: we want negative inside\r\n\t\t{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } \r\n\telse  FLIP = false;\r\n\tint t = t0+t1+t2+t3; // sum of turn sign = +- 4, +-2 or 0.\r\n\t\r\n\tfloat d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), \r\n\t\t  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);\r\n\t// take care: dji != -dij at extremities since must be always positive outside\r\n\tfloat d0, d1;\r\n\t\r\n\tif ((t==4)||(t==-4)) // --- all same sign: P0P1P2P3 convex-> paths 0123, 30\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; } \r\n\r\n\telse {\r\n\t  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);\r\n\t  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;\r\n\r\n\t  if (t==0)         // --- 'X' shape\r\n\t\tif(t0==t1)  // swap 2 & 3 : P0P1P3P2 -> paths 013, 320\r\n\t\t    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }\r\n\t\t\t  d0 = amin(d01,d13);\t\t\t\t\td1 = amin(d02,d23); }\r\n\t    else \t    // swap 1 & 2 : P0P2P1P3-> paths 0213, 30\r\n\t\t\t{ d0 = amin( amin( d02, d21 ), d13);\td1 = d30; }\t\t\r\n\r\n\t  else  // t == +-2   //  --- '>' shape : one sign different -> bounding triangle\r\n\t\tif (t1*t<0)       // it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30\r\n\t\t\t{ d0 = amin( d02, d23);\t\t\t\t\td1 = d30; }\r\n\t\telse if (t2*t<0)  // it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30\r\n\t\t\t{ d0 = amin( d01, d13);\t\t\t\t\td1 = d30; }\r\n\t\telse              // it's P0 or P3: in facts, that's fine.\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; }\r\n\t  }\r\n\r\n\treturn vec2( amin(d0,d1), amax(d0,d1) );\r\n}\r\n\r\n\r\n// --- dist to spline - costly (for pixels where smart method failed )\r\n\r\n// TODO: - recursive subdivision\r\n//       - Newton iterations to  min dist\r\n//       - adaptive stepping (especially when used on small spline section)\r\n//       - sampling = diameter*pi*resolution\r\n// (anyway this function has negligible cost since rarely used).\r\nvec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tif (SHOW_COSTLY) return vec2(8.);\r\n\tfloat d = 1e5;\r\n\tfor (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),\r\n\t\t\t P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),\r\n\t\t\t P0123 = mix(P012,P123,x); // is on the spline\r\n\t\tvec2 D = P0123-pos;\r\n\t\td = min(d, dot(D,D));\r\n\t}\r\n\td = sqrt(d);\r\n\treturn vec2(d);\r\n}\r\n\r\n// --- dist to spline - iterative\r\n\r\nvec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tvec2 d0mM, d3mM;\r\n\tfor (int i=0; i<SUBDIV; i++) { // iterative subdivision\r\n\t\tif (i >= n) continue;\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),\r\n\t\t\t P012  = .5*(P01+P12),  P123 = .5*(P12+P23),\r\n\t\t\t P0123 = .5*(P012+P123); // is on the spline\r\n\r\n\t\t\r\n\t\td0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1\r\n\t\td3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2\r\n\t\t\r\n\t\tbool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);\r\n\t\td0mM = abs(d0mM); d3mM=  abs(d3mM);\r\n\t\t\t\r\n\t\tif (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )\r\n\t\t\treturn vec2(0.,float(i));    // draw skeleton\r\n\t\tfloat s;\r\n\r\n\r\n\t\t// inside one of the sub quadri\r\n\t\tif      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;\r\n\t\telse \r\n#if 1\r\n\t\tif (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer\r\n\t\telse if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer\r\n\t\t\telse // ambiguous\r\n\t\t\t  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method\r\n#else\r\n\t\t\tif (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)\r\n#endif\r\n\t\t\r\n\t\tif (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1\r\n\t\telse      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2\r\n   \t}\r\n\t\r\n\tif (n<0) // ambiguity found: switch to costly method\r\n\t\treturn dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); \r\n\t\r\n  \treturn dist2quadri(pos, P0,P1,P2,P3);\r\n}\r\n\r\n\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of control points and tangents.\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tt = iTime;\r\n    fragColor = vec4(0.);\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tvec2 Pc, Tc;\r\n\t\r\n\t// --- tuning \r\n\t\r\n\tvec2 mouse = 2.*(iMouse.xy  / iResolution.y - vec2(.8,.5));\r\n\tSIGNED_DIST = !keyToggle(64+19); \r\n\tfragColor.b += showFlag(vec2(-1.5,.9),uv,(mod(10.*t,2.)<1.))\r\n\t\t\t\t\t+ showFlag(vec2(-1.4,.9),uv,SIGNED_DIST);\r\n\t\r\n\tif (iMouse.z<=0.) {\r\n\t\tfloat fm = mod(.2*t,8.); int m=int(fm);\r\n\t\tSHOW_MESH   =  (mod(fm,2.)>=1.);\r\n\t\tSHOW_LINE   =  (m==2)||(m==3);\r\n\t\tSHOW_GRAD   =  (m==4)||(m==5);\r\n\t\tSHOW_ISO    =  (m==6)||(m==7);\r\n\t\tSHOW_COSTLY =  false;\r\n\t\tPc = P(0.); Tc = P(0.5);\r\n\t} else {\r\n\t\tSHOW_MESH   = keyToggle(64+13); // 'M'\r\n\t\tSHOW_LINE   = keyToggle(64+12); // 'L'\r\n\t\tSHOW_GRAD   = !keyToggle(64+7); // 'G'\r\n\t\tSHOW_ISO    = keyToggle(64+9);  // 'I'\t\r\n\t\tSHOW_COSTLY = keyToggle(64+3);  // 'C'\t\r\n\t\tPc = mouse; Tc = vec2(1.);\r\n\t}\r\n\t\r\n\t\r\n\t// --- dist to spline \r\n\t// TODO:\r\n\t//    - first select possible splines\r\n\t//    - parallel descent in the vector of splines\r\n\t\r\n\tvec2 dmMi[POINTS];\r\n\tvec2 dmM = vec2(1e5);\r\n\tvec2 P0, T0, P3=Pc, T3=Tc;\r\n#if 0\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\t\tfloat d0=dist2(uv,P0), d1=dist2(uv,P0+T0), d2=dist2(uv,P3-T3), d3=dist2(uv,P3);\r\n\t\tfloat dmi = min(min(d0,d1),min(d2,d3)), dMi = max(max(d0,d1),max(d2,d3));\r\n\t\tdmMi[int(i)] = vec2(dmi, dMi);\r\n\t}\r\n#endif\r\n\t\r\n\tdmM = vec2(1e5);\r\n\tP3=Pc, T3=Tc;\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\r\n\t\tvec2 dmMi = abs(dist2spline(uv, P0,P0+T0,P3-T3,P3, SUBDIV)); // draw spline i\r\n\r\n\t\tif (dmMi.x==0.) // display mesh\r\n\t\t\t{ fragColor=mix(vec4(1),vec4(0.,0.,1.,0.),dmMi.y/3.); return; } \r\n\t\tif (dmMi.x==8.) // display ambiguous parts\r\n\t\t\t{ fragColor=vec4(.15,0.,0.,0.); return; } \r\n\t\tdmM = min (dmM, dmMi);\r\n\t}\r\n\t\r\n\t\r\n\t// --- display\r\n\t\r\n\tvec3 col = 1.-abs(vec3(dmM,.5*(dmM.x+dmM.y))); \r\n\tif (SHOW_LINE) col = pow(col, vec3(16.));\r\n\tif (SHOW_ISO ) col = sin(100.*col);\r\n\tif (SHOW_GRAD) col.xy = .5+.5*normalize(vec2(dFdx(col.z),dFdy(col.z)));\r\n\t\r\n\tfragColor += vec4(col.xy, 0.,1.);\r\n}","inputs":[],"outputs":[],"code":"// efficient distance to spline relying on the iterative construction of splines.\r\n\r\n#define POINTS 8  \t\t // number of control points\r\n\r\nconst int   SUBDIV=5;    // subdivision depth for the analytic method\r\nconst float sampl=120.; // number of samples per spline for the costly method\r\nfloat t;\r\n\r\nbool SHOW_MESH, SHOW_LINE, SHOW_GRAD, SHOW_ISO, SHOW_COSTLY;\r\n\r\n// --- GUI utils\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat cross2(vec2 v0, vec2 v1) {\treturn v0.x*v1.y - v0.y*v1.x; }\r\nfloat amin(float a, float b) { return (abs(a)<abs(b)) ? a : b ; }\r\nfloat amax(float a, float b) { return (abs(a)>abs(b)) ? a : b ; }\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n// --- dist pos to seg P0P1\r\n\r\nbool SIGNED_DIST = true; // if signed, positive distance is at left of oriented segment\r\nbool FLIP=false;         // for normalized turn direction (we want dist negative inside shape)\r\n\r\nfloat dist2seg(vec2 pos, vec2 P0, vec2 P1) {\r\n\tif (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }\r\n\tvec2 P0P1 = P1-P0, P0Pos = pos-P0;\r\n\tfloat d, l2_01=dist2(P0,P1);\r\n\r\n\t// --- if projection out of segment bounds, dist to extremity\r\n\t// Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)\r\n\tfloat l = dot(P0Pos, P0P1)/l2_01;\r\n\tif      (l <= 0.) return distance(pos,P0);\r\n\telse if (l >= 1.) return distance(pos,P1);\r\n\r\n\t// --- dist to seg = dist to line\r\n\telse if (SIGNED_DIST) \r\n\t    { float D = cross2(P0P1,P0Pos); return D/sqrt(l2_01); }\r\n\telse return distance(pos, P0+l*P0P1);\r\n}\r\n\r\n// --- min/max dist to quadrilateral P0P1P2P3 (possibly non-convex)\r\n\r\nvec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\r\n\r\n\tvec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;\r\n\r\n\t// makes the quadri convex if not: the 4 turns must have same sign.\r\n\t//    Note that alternate signs cannot happen (wouldn't loop), so possibility are:\r\n\t// all same, 1 different ('>'), 2 + then 2 - ('X').\r\n\t// for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.\r\n\r\n\t// measure turns direction\r\n#define ssign(v) (((v)>=0.) ? 1 : -1)\r\n\tint t0 = ssign(cross2(P30,P01)), t1 = ssign(cross2(P01,P12)),\t\r\n\t\tt2 = ssign(cross2(P12,P23)), t3 = ssign(cross2(P23,P30));\r\n\tif (SIGNED_DIST &&(t0>0)) // if direct, makes it indirect: we want negative inside\r\n\t\t{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } \r\n\telse  FLIP = false;\r\n\tint t = t0+t1+t2+t3; // sum of turn sign = +- 4, +-2 or 0.\r\n\t\r\n\tfloat d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), \r\n\t\t  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);\r\n\t// take care: dji != -dij at extremities since must be always positive outside\r\n\tfloat d0, d1;\r\n\t\r\n\tif ((t==4)||(t==-4)) // --- all same sign: P0P1P2P3 convex-> paths 0123, 30\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; } \r\n\r\n\telse {\r\n\t  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);\r\n\t  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;\r\n\r\n\t  if (t==0)         // --- 'X' shape\r\n\t\tif(t0==t1)  // swap 2 & 3 : P0P1P3P2 -> paths 013, 320\r\n\t\t    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }\r\n\t\t\t  d0 = amin(d01,d13);\t\t\t\t\td1 = amin(d02,d23); }\r\n\t    else \t    // swap 1 & 2 : P0P2P1P3-> paths 0213, 30\r\n\t\t\t{ d0 = amin( amin( d02, d21 ), d13);\td1 = d30; }\t\t\r\n\r\n\t  else  // t == +-2   //  --- '>' shape : one sign different -> bounding triangle\r\n\t\tif (t1*t<0)       // it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30\r\n\t\t\t{ d0 = amin( d02, d23);\t\t\t\t\td1 = d30; }\r\n\t\telse if (t2*t<0)  // it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30\r\n\t\t\t{ d0 = amin( d01, d13);\t\t\t\t\td1 = d30; }\r\n\t\telse              // it's P0 or P3: in facts, that's fine.\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; }\r\n\t  }\r\n\r\n\treturn vec2( amin(d0,d1), amax(d0,d1) );\r\n}\r\n\r\n\r\n// --- dist to spline - costly (for pixels where smart method failed )\r\n\r\n// TODO: - recursive subdivision\r\n//       - Newton iterations to  min dist\r\n//       - adaptive stepping (especially when used on small spline section)\r\n//       - sampling = diameter*pi*resolution\r\n// (anyway this function has negligible cost since rarely used).\r\nvec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tif (SHOW_COSTLY) return vec2(8.);\r\n\tfloat d = 1e5;\r\n\tfor (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),\r\n\t\t\t P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),\r\n\t\t\t P0123 = mix(P012,P123,x); // is on the spline\r\n\t\tvec2 D = P0123-pos;\r\n\t\td = min(d, dot(D,D));\r\n\t}\r\n\td = sqrt(d);\r\n\treturn vec2(d);\r\n}\r\n\r\n// --- dist to spline - iterative\r\n\r\nvec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tvec2 d0mM, d3mM;\r\n\tfor (int i=0; i<SUBDIV; i++) { // iterative subdivision\r\n\t\tif (i >= n) continue;\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),\r\n\t\t\t P012  = .5*(P01+P12),  P123 = .5*(P12+P23),\r\n\t\t\t P0123 = .5*(P012+P123); // is on the spline\r\n\r\n\t\t\r\n\t\td0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1\r\n\t\td3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2\r\n\t\t\r\n\t\tbool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);\r\n\t\td0mM = abs(d0mM); d3mM=  abs(d3mM);\r\n\t\t\t\r\n\t\tif (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )\r\n\t\t\treturn vec2(0.,float(i));    // draw skeleton\r\n\t\tfloat s;\r\n\r\n\r\n\t\t// inside one of the sub quadri\r\n\t\tif      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;\r\n\t\telse \r\n#if 1\r\n\t\tif (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer\r\n\t\telse if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer\r\n\t\t\telse // ambiguous\r\n\t\t\t  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method\r\n#else\r\n\t\t\tif (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)\r\n#endif\r\n\t\t\r\n\t\tif (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1\r\n\t\telse      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2\r\n   \t}\r\n\t\r\n\tif (n<0) // ambiguity found: switch to costly method\r\n\t\treturn dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); \r\n\t\r\n  \treturn dist2quadri(pos, P0,P1,P2,P3);\r\n}\r\n\r\n\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of control points and tangents.\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tt = iTime;\r\n    fragColor = vec4(0.);\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tvec2 Pc, Tc;\r\n\t\r\n\t// --- tuning \r\n\t\r\n\tvec2 mouse = 2.*(iMouse.xy  / iResolution.y - vec2(.8,.5));\r\n\tSIGNED_DIST = !keyToggle(64+19); \r\n\tfragColor.b += showFlag(vec2(-1.5,.9),uv,(mod(10.*t,2.)<1.))\r\n\t\t\t\t\t+ showFlag(vec2(-1.4,.9),uv,SIGNED_DIST);\r\n\t\r\n\tif (iMouse.z<=0.) {\r\n\t\tfloat fm = mod(.2*t,8.); int m=int(fm);\r\n\t\tSHOW_MESH   =  (mod(fm,2.)>=1.);\r\n\t\tSHOW_LINE   =  (m==2)||(m==3);\r\n\t\tSHOW_GRAD   =  (m==4)||(m==5);\r\n\t\tSHOW_ISO    =  (m==6)||(m==7);\r\n\t\tSHOW_COSTLY =  false;\r\n\t\tPc = P(0.); Tc = P(0.5);\r\n\t} else {\r\n\t\tSHOW_MESH   = keyToggle(64+13); // 'M'\r\n\t\tSHOW_LINE   = keyToggle(64+12); // 'L'\r\n\t\tSHOW_GRAD   = !keyToggle(64+7); // 'G'\r\n\t\tSHOW_ISO    = keyToggle(64+9);  // 'I'\t\r\n\t\tSHOW_COSTLY = keyToggle(64+3);  // 'C'\t\r\n\t\tPc = mouse; Tc = vec2(1.);\r\n\t}\r\n\t\r\n\t\r\n\t// --- dist to spline \r\n\t// TODO:\r\n\t//    - first select possible splines\r\n\t//    - parallel descent in the vector of splines\r\n\t\r\n\tvec2 dmMi[POINTS];\r\n\tvec2 dmM = vec2(1e5);\r\n\tvec2 P0, T0, P3=Pc, T3=Tc;\r\n#if 0\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\t\tfloat d0=dist2(uv,P0), d1=dist2(uv,P0+T0), d2=dist2(uv,P3-T3), d3=dist2(uv,P3);\r\n\t\tfloat dmi = min(min(d0,d1),min(d2,d3)), dMi = max(max(d0,d1),max(d2,d3));\r\n\t\tdmMi[int(i)] = vec2(dmi, dMi);\r\n\t}\r\n#endif\r\n\t\r\n\tdmM = vec2(1e5);\r\n\tP3=Pc, T3=Tc;\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\r\n\t\tvec2 dmMi = abs(dist2spline(uv, P0,P0+T0,P3-T3,P3, SUBDIV)); // draw spline i\r\n\r\n\t\tif (dmMi.x==0.) // display mesh\r\n\t\t\t{ fragColor=mix(vec4(1),vec4(0.,0.,1.,0.),dmMi.y/3.); return; } \r\n\t\tif (dmMi.x==8.) // display ambiguous parts\r\n\t\t\t{ fragColor=vec4(.15,0.,0.,0.); return; } \r\n\t\tdmM = min (dmM, dmMi);\r\n\t}\r\n\t\r\n\t\r\n\t// --- display\r\n\t\r\n\tvec3 col = 1.-abs(vec3(dmM,.5*(dmM.x+dmM.y))); \r\n\tif (SHOW_LINE) col = pow(col, vec3(16.));\r\n\tif (SHOW_ISO ) col = sin(100.*col);\r\n\tif (SHOW_GRAD) col.xy = .5+.5*normalize(vec2(dFdx(col.z),dFdy(col.z)));\r\n\t\r\n\tfragColor += vec4(col.xy, 0.,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"dist 2 spline #3","id":"4df813e55f664882847b2110f1d2e851","date":null,"viewed":0,"name":"dist 2 spline #3","description":"M: toggles construction mesh     L: toggles distance field / thin line\nG: show gradient                        I: show isolines\nC: shows parts drawn with the costly algo","likes":0,"published":null,"tags":[" spline"]},"ver":null,"info":{"Name":"dist 2 spline #3","id":"4df813e55f664882847b2110f1d2e851","date":null,"viewed":0,"name":"dist 2 spline #3","description":"M: toggles construction mesh     L: toggles distance field / thin line\nG: show gradient                        I: show isolines\nC: shows parts drawn with the costly algo","likes":0,"published":null,"tags":[" spline"]},"renderpass":[{"Code":"// efficient distance to spline relying on the iterative construction of splines.\r\n\r\n#define POINTS 8  \t\t // number of control points\r\n\r\nconst int   SUBDIV=5;    // subdivision depth for the analytic method\r\nconst float sampl=120.; // number of samples per spline for the costly method\r\nfloat t;\r\n\r\nbool SHOW_MESH, SHOW_LINE, SHOW_GRAD, SHOW_ISO, SHOW_COSTLY;\r\n\r\n// --- GUI utils\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat cross2(vec2 v0, vec2 v1) {\treturn v0.x*v1.y - v0.y*v1.x; }\r\nfloat amin(float a, float b) { return (abs(a)<abs(b)) ? a : b ; }\r\nfloat amax(float a, float b) { return (abs(a)>abs(b)) ? a : b ; }\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n// --- dist pos to seg P0P1\r\n\r\nbool SIGNED_DIST = true; // if signed, positive distance is at left of oriented segment\r\nbool FLIP=false;         // for normalized turn direction (we want dist negative inside shape)\r\n\r\nfloat dist2seg(vec2 pos, vec2 P0, vec2 P1) {\r\n\tif (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }\r\n\tvec2 P0P1 = P1-P0, P0Pos = pos-P0;\r\n\tfloat d, l2_01=dist2(P0,P1);\r\n\r\n\t// --- if projection out of segment bounds, dist to extremity\r\n\t// Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)\r\n\tfloat l = dot(P0Pos, P0P1)/l2_01;\r\n\tif      (l <= 0.) return distance(pos,P0);\r\n\telse if (l >= 1.) return distance(pos,P1);\r\n\r\n\t// --- dist to seg = dist to line\r\n\telse if (SIGNED_DIST) \r\n\t    { float D = cross2(P0P1,P0Pos); return D/sqrt(l2_01); }\r\n\telse return distance(pos, P0+l*P0P1);\r\n}\r\n\r\n// --- min/max dist to quadrilateral P0P1P2P3 (possibly non-convex)\r\n\r\nvec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\r\n\r\n\tvec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;\r\n\r\n\t// makes the quadri convex if not: the 4 turns must have same sign.\r\n\t//    Note that alternate signs cannot happen (wouldn't loop), so possibility are:\r\n\t// all same, 1 different ('>'), 2 + then 2 - ('X').\r\n\t// for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.\r\n\r\n\t// measure turns direction\r\n#define ssign(v) (((v)>=0.) ? 1 : -1)\r\n\tint t0 = ssign(cross2(P30,P01)), t1 = ssign(cross2(P01,P12)),\t\r\n\t\tt2 = ssign(cross2(P12,P23)), t3 = ssign(cross2(P23,P30));\r\n\tif (SIGNED_DIST &&(t0>0)) // if direct, makes it indirect: we want negative inside\r\n\t\t{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } \r\n\telse  FLIP = false;\r\n\tint t = t0+t1+t2+t3; // sum of turn sign = +- 4, +-2 or 0.\r\n\t\r\n\tfloat d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), \r\n\t\t  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);\r\n\t// take care: dji != -dij at extremities since must be always positive outside\r\n\tfloat d0, d1;\r\n\t\r\n\tif ((t==4)||(t==-4)) // --- all same sign: P0P1P2P3 convex-> paths 0123, 30\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; } \r\n\r\n\telse {\r\n\t  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);\r\n\t  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;\r\n\r\n\t  if (t==0)         // --- 'X' shape\r\n\t\tif(t0==t1)  // swap 2 & 3 : P0P1P3P2 -> paths 013, 320\r\n\t\t    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }\r\n\t\t\t  d0 = amin(d01,d13);\t\t\t\t\td1 = amin(d02,d23); }\r\n\t    else \t    // swap 1 & 2 : P0P2P1P3-> paths 0213, 30\r\n\t\t\t{ d0 = amin( amin( d02, d21 ), d13);\td1 = d30; }\t\t\r\n\r\n\t  else  // t == +-2   //  --- '>' shape : one sign different -> bounding triangle\r\n\t\tif (t1*t<0)       // it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30\r\n\t\t\t{ d0 = amin( d02, d23);\t\t\t\t\td1 = d30; }\r\n\t\telse if (t2*t<0)  // it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30\r\n\t\t\t{ d0 = amin( d01, d13);\t\t\t\t\td1 = d30; }\r\n\t\telse              // it's P0 or P3: in facts, that's fine.\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; }\r\n\t  }\r\n\r\n\treturn vec2( amin(d0,d1), amax(d0,d1) );\r\n}\r\n\r\n\r\n// --- dist to spline - costly (for pixels where smart method failed )\r\n\r\n// TODO: - recursive subdivision\r\n//       - Newton iterations to  min dist\r\n//       - adaptive stepping (especially when used on small spline section)\r\n//       - sampling = diameter*pi*resolution\r\n// (anyway this function has negligible cost since rarely used).\r\nvec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tif (SHOW_COSTLY) return vec2(8.);\r\n\tfloat d = 1e5;\r\n\tfor (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),\r\n\t\t\t P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),\r\n\t\t\t P0123 = mix(P012,P123,x); // is on the spline\r\n\t\tvec2 D = P0123-pos;\r\n\t\td = min(d, dot(D,D));\r\n\t}\r\n\td = sqrt(d);\r\n\treturn vec2(d);\r\n}\r\n\r\n// --- dist to spline - iterative\r\n\r\nvec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tvec2 d0mM, d3mM;\r\n\tfor (int i=0; i<SUBDIV; i++) { // iterative subdivision\r\n\t\tif (i >= n) continue;\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),\r\n\t\t\t P012  = .5*(P01+P12),  P123 = .5*(P12+P23),\r\n\t\t\t P0123 = .5*(P012+P123); // is on the spline\r\n\r\n\t\t\r\n\t\td0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1\r\n\t\td3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2\r\n\t\t\r\n\t\tbool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);\r\n\t\td0mM = abs(d0mM); d3mM=  abs(d3mM);\r\n\t\t\t\r\n\t\tif (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )\r\n\t\t\treturn vec2(0.,float(i));    // draw skeleton\r\n\t\tfloat s;\r\n\r\n\r\n\t\t// inside one of the sub quadri\r\n\t\tif      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;\r\n\t\telse \r\n#if 1\r\n\t\tif (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer\r\n\t\telse if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer\r\n\t\t\telse // ambiguous\r\n\t\t\t  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method\r\n#else\r\n\t\t\tif (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)\r\n#endif\r\n\t\t\r\n\t\tif (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1\r\n\t\telse      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2\r\n   \t}\r\n\t\r\n\tif (n<0) // ambiguity found: switch to costly method\r\n\t\treturn dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); \r\n\t\r\n  \treturn dist2quadri(pos, P0,P1,P2,P3);\r\n}\r\n\r\n\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of control points and tangents.\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tt = iTime;\r\n    fragColor = vec4(0.);\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tvec2 Pc, Tc;\r\n\t\r\n\t// --- tuning \r\n\t\r\n\tvec2 mouse = 2.*(iMouse.xy  / iResolution.y - vec2(.8,.5));\r\n\tSIGNED_DIST = !keyToggle(64+19); \r\n\tfragColor.b += showFlag(vec2(-1.5,.9),uv,(mod(10.*t,2.)<1.))\r\n\t\t\t\t\t+ showFlag(vec2(-1.4,.9),uv,SIGNED_DIST);\r\n\t\r\n\tif (iMouse.z<=0.) {\r\n\t\tfloat fm = mod(.2*t,8.); int m=int(fm);\r\n\t\tSHOW_MESH   =  (mod(fm,2.)>=1.);\r\n\t\tSHOW_LINE   =  (m==2)||(m==3);\r\n\t\tSHOW_GRAD   =  (m==4)||(m==5);\r\n\t\tSHOW_ISO    =  (m==6)||(m==7);\r\n\t\tSHOW_COSTLY =  false;\r\n\t\tPc = P(0.); Tc = P(0.5);\r\n\t} else {\r\n\t\tSHOW_MESH   = keyToggle(64+13); // 'M'\r\n\t\tSHOW_LINE   = keyToggle(64+12); // 'L'\r\n\t\tSHOW_GRAD   = !keyToggle(64+7); // 'G'\r\n\t\tSHOW_ISO    = keyToggle(64+9);  // 'I'\t\r\n\t\tSHOW_COSTLY = keyToggle(64+3);  // 'C'\t\r\n\t\tPc = mouse; Tc = vec2(1.);\r\n\t}\r\n\t\r\n\t\r\n\t// --- dist to spline \r\n\t// TODO:\r\n\t//    - first select possible splines\r\n\t//    - parallel descent in the vector of splines\r\n\t\r\n\tvec2 dmMi[POINTS];\r\n\tvec2 dmM = vec2(1e5);\r\n\tvec2 P0, T0, P3=Pc, T3=Tc;\r\n#if 0\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\t\tfloat d0=dist2(uv,P0), d1=dist2(uv,P0+T0), d2=dist2(uv,P3-T3), d3=dist2(uv,P3);\r\n\t\tfloat dmi = min(min(d0,d1),min(d2,d3)), dMi = max(max(d0,d1),max(d2,d3));\r\n\t\tdmMi[int(i)] = vec2(dmi, dMi);\r\n\t}\r\n#endif\r\n\t\r\n\tdmM = vec2(1e5);\r\n\tP3=Pc, T3=Tc;\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\r\n\t\tvec2 dmMi = abs(dist2spline(uv, P0,P0+T0,P3-T3,P3, SUBDIV)); // draw spline i\r\n\r\n\t\tif (dmMi.x==0.) // display mesh\r\n\t\t\t{ fragColor=mix(vec4(1),vec4(0.,0.,1.,0.),dmMi.y/3.); return; } \r\n\t\tif (dmMi.x==8.) // display ambiguous parts\r\n\t\t\t{ fragColor=vec4(.15,0.,0.,0.); return; } \r\n\t\tdmM = min (dmM, dmMi);\r\n\t}\r\n\t\r\n\t\r\n\t// --- display\r\n\t\r\n\tvec3 col = 1.-abs(vec3(dmM,.5*(dmM.x+dmM.y))); \r\n\tif (SHOW_LINE) col = pow(col, vec3(16.));\r\n\tif (SHOW_ISO ) col = sin(100.*col);\r\n\tif (SHOW_GRAD) col.xy = .5+.5*normalize(vec2(dFdx(col.z),dFdy(col.z)));\r\n\t\r\n\tfragColor += vec4(col.xy, 0.,1.);\r\n}","inputs":[],"outputs":[],"code":"// efficient distance to spline relying on the iterative construction of splines.\r\n\r\n#define POINTS 8  \t\t // number of control points\r\n\r\nconst int   SUBDIV=5;    // subdivision depth for the analytic method\r\nconst float sampl=120.; // number of samples per spline for the costly method\r\nfloat t;\r\n\r\nbool SHOW_MESH, SHOW_LINE, SHOW_GRAD, SHOW_ISO, SHOW_COSTLY;\r\n\r\n// --- GUI utils\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat cross2(vec2 v0, vec2 v1) {\treturn v0.x*v1.y - v0.y*v1.x; }\r\nfloat amin(float a, float b) { return (abs(a)<abs(b)) ? a : b ; }\r\nfloat amax(float a, float b) { return (abs(a)>abs(b)) ? a : b ; }\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n// --- dist pos to seg P0P1\r\n\r\nbool SIGNED_DIST = true; // if signed, positive distance is at left of oriented segment\r\nbool FLIP=false;         // for normalized turn direction (we want dist negative inside shape)\r\n\r\nfloat dist2seg(vec2 pos, vec2 P0, vec2 P1) {\r\n\tif (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }\r\n\tvec2 P0P1 = P1-P0, P0Pos = pos-P0;\r\n\tfloat d, l2_01=dist2(P0,P1);\r\n\r\n\t// --- if projection out of segment bounds, dist to extremity\r\n\t// Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)\r\n\tfloat l = dot(P0Pos, P0P1)/l2_01;\r\n\tif      (l <= 0.) return distance(pos,P0);\r\n\telse if (l >= 1.) return distance(pos,P1);\r\n\r\n\t// --- dist to seg = dist to line\r\n\telse if (SIGNED_DIST) \r\n\t    { float D = cross2(P0P1,P0Pos); return D/sqrt(l2_01); }\r\n\telse return distance(pos, P0+l*P0P1);\r\n}\r\n\r\n// --- min/max dist to quadrilateral P0P1P2P3 (possibly non-convex)\r\n\r\nvec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\r\n\r\n\tvec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;\r\n\r\n\t// makes the quadri convex if not: the 4 turns must have same sign.\r\n\t//    Note that alternate signs cannot happen (wouldn't loop), so possibility are:\r\n\t// all same, 1 different ('>'), 2 + then 2 - ('X').\r\n\t// for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.\r\n\r\n\t// measure turns direction\r\n#define ssign(v) (((v)>=0.) ? 1 : -1)\r\n\tint t0 = ssign(cross2(P30,P01)), t1 = ssign(cross2(P01,P12)),\t\r\n\t\tt2 = ssign(cross2(P12,P23)), t3 = ssign(cross2(P23,P30));\r\n\tif (SIGNED_DIST &&(t0>0)) // if direct, makes it indirect: we want negative inside\r\n\t\t{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } \r\n\telse  FLIP = false;\r\n\tint t = t0+t1+t2+t3; // sum of turn sign = +- 4, +-2 or 0.\r\n\t\r\n\tfloat d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), \r\n\t\t  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);\r\n\t// take care: dji != -dij at extremities since must be always positive outside\r\n\tfloat d0, d1;\r\n\t\r\n\tif ((t==4)||(t==-4)) // --- all same sign: P0P1P2P3 convex-> paths 0123, 30\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; } \r\n\r\n\telse {\r\n\t  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);\r\n\t  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;\r\n\r\n\t  if (t==0)         // --- 'X' shape\r\n\t\tif(t0==t1)  // swap 2 & 3 : P0P1P3P2 -> paths 013, 320\r\n\t\t    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }\r\n\t\t\t  d0 = amin(d01,d13);\t\t\t\t\td1 = amin(d02,d23); }\r\n\t    else \t    // swap 1 & 2 : P0P2P1P3-> paths 0213, 30\r\n\t\t\t{ d0 = amin( amin( d02, d21 ), d13);\td1 = d30; }\t\t\r\n\r\n\t  else  // t == +-2   //  --- '>' shape : one sign different -> bounding triangle\r\n\t\tif (t1*t<0)       // it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30\r\n\t\t\t{ d0 = amin( d02, d23);\t\t\t\t\td1 = d30; }\r\n\t\telse if (t2*t<0)  // it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30\r\n\t\t\t{ d0 = amin( d01, d13);\t\t\t\t\td1 = d30; }\r\n\t\telse              // it's P0 or P3: in facts, that's fine.\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; }\r\n\t  }\r\n\r\n\treturn vec2( amin(d0,d1), amax(d0,d1) );\r\n}\r\n\r\n\r\n// --- dist to spline - costly (for pixels where smart method failed )\r\n\r\n// TODO: - recursive subdivision\r\n//       - Newton iterations to  min dist\r\n//       - adaptive stepping (especially when used on small spline section)\r\n//       - sampling = diameter*pi*resolution\r\n// (anyway this function has negligible cost since rarely used).\r\nvec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tif (SHOW_COSTLY) return vec2(8.);\r\n\tfloat d = 1e5;\r\n\tfor (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),\r\n\t\t\t P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),\r\n\t\t\t P0123 = mix(P012,P123,x); // is on the spline\r\n\t\tvec2 D = P0123-pos;\r\n\t\td = min(d, dot(D,D));\r\n\t}\r\n\td = sqrt(d);\r\n\treturn vec2(d);\r\n}\r\n\r\n// --- dist to spline - iterative\r\n\r\nvec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tvec2 d0mM, d3mM;\r\n\tfor (int i=0; i<SUBDIV; i++) { // iterative subdivision\r\n\t\tif (i >= n) continue;\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),\r\n\t\t\t P012  = .5*(P01+P12),  P123 = .5*(P12+P23),\r\n\t\t\t P0123 = .5*(P012+P123); // is on the spline\r\n\r\n\t\t\r\n\t\td0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1\r\n\t\td3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2\r\n\t\t\r\n\t\tbool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);\r\n\t\td0mM = abs(d0mM); d3mM=  abs(d3mM);\r\n\t\t\t\r\n\t\tif (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )\r\n\t\t\treturn vec2(0.,float(i));    // draw skeleton\r\n\t\tfloat s;\r\n\r\n\r\n\t\t// inside one of the sub quadri\r\n\t\tif      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;\r\n\t\telse \r\n#if 1\r\n\t\tif (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer\r\n\t\telse if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer\r\n\t\t\telse // ambiguous\r\n\t\t\t  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method\r\n#else\r\n\t\t\tif (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)\r\n#endif\r\n\t\t\r\n\t\tif (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1\r\n\t\telse      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2\r\n   \t}\r\n\t\r\n\tif (n<0) // ambiguity found: switch to costly method\r\n\t\treturn dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); \r\n\t\r\n  \treturn dist2quadri(pos, P0,P1,P2,P3);\r\n}\r\n\r\n\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of control points and tangents.\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tt = iTime;\r\n    fragColor = vec4(0.);\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tvec2 Pc, Tc;\r\n\t\r\n\t// --- tuning \r\n\t\r\n\tvec2 mouse = 2.*(iMouse.xy  / iResolution.y - vec2(.8,.5));\r\n\tSIGNED_DIST = !keyToggle(64+19); \r\n\tfragColor.b += showFlag(vec2(-1.5,.9),uv,(mod(10.*t,2.)<1.))\r\n\t\t\t\t\t+ showFlag(vec2(-1.4,.9),uv,SIGNED_DIST);\r\n\t\r\n\tif (iMouse.z<=0.) {\r\n\t\tfloat fm = mod(.2*t,8.); int m=int(fm);\r\n\t\tSHOW_MESH   =  (mod(fm,2.)>=1.);\r\n\t\tSHOW_LINE   =  (m==2)||(m==3);\r\n\t\tSHOW_GRAD   =  (m==4)||(m==5);\r\n\t\tSHOW_ISO    =  (m==6)||(m==7);\r\n\t\tSHOW_COSTLY =  false;\r\n\t\tPc = P(0.); Tc = P(0.5);\r\n\t} else {\r\n\t\tSHOW_MESH   = keyToggle(64+13); // 'M'\r\n\t\tSHOW_LINE   = keyToggle(64+12); // 'L'\r\n\t\tSHOW_GRAD   = !keyToggle(64+7); // 'G'\r\n\t\tSHOW_ISO    = keyToggle(64+9);  // 'I'\t\r\n\t\tSHOW_COSTLY = keyToggle(64+3);  // 'C'\t\r\n\t\tPc = mouse; Tc = vec2(1.);\r\n\t}\r\n\t\r\n\t\r\n\t// --- dist to spline \r\n\t// TODO:\r\n\t//    - first select possible splines\r\n\t//    - parallel descent in the vector of splines\r\n\t\r\n\tvec2 dmMi[POINTS];\r\n\tvec2 dmM = vec2(1e5);\r\n\tvec2 P0, T0, P3=Pc, T3=Tc;\r\n#if 0\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\t\tfloat d0=dist2(uv,P0), d1=dist2(uv,P0+T0), d2=dist2(uv,P3-T3), d3=dist2(uv,P3);\r\n\t\tfloat dmi = min(min(d0,d1),min(d2,d3)), dMi = max(max(d0,d1),max(d2,d3));\r\n\t\tdmMi[int(i)] = vec2(dmi, dMi);\r\n\t}\r\n#endif\r\n\t\r\n\tdmM = vec2(1e5);\r\n\tP3=Pc, T3=Tc;\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\r\n\t\tvec2 dmMi = abs(dist2spline(uv, P0,P0+T0,P3-T3,P3, SUBDIV)); // draw spline i\r\n\r\n\t\tif (dmMi.x==0.) // display mesh\r\n\t\t\t{ fragColor=mix(vec4(1),vec4(0.,0.,1.,0.),dmMi.y/3.); return; } \r\n\t\tif (dmMi.x==8.) // display ambiguous parts\r\n\t\t\t{ fragColor=vec4(.15,0.,0.,0.); return; } \r\n\t\tdmM = min (dmM, dmMi);\r\n\t}\r\n\t\r\n\t\r\n\t// --- display\r\n\t\r\n\tvec3 col = 1.-abs(vec3(dmM,.5*(dmM.x+dmM.y))); \r\n\tif (SHOW_LINE) col = pow(col, vec3(16.));\r\n\tif (SHOW_ISO ) col = sin(100.*col);\r\n\tif (SHOW_GRAD) col.xy = .5+.5*normalize(vec2(dFdx(col.z),dFdy(col.z)));\r\n\t\r\n\tfragColor += vec4(col.xy, 0.,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//******************************************************************************************\r\n// Dreamcatcher 4k Intro   Shadertoy port\r\n//\r\n// All code by Jan \"LJ\" Scheurer\r\n//\r\n// Music by Jochen \"Virgill\" Feldkoetter\r\n//\r\n// http://www.pouet.net/prod.php?which=67977\r\n// https://demozoo.org/productions/161855/\r\n//******************************************************************************************\r\n\r\n#define time (iTime-0.95)\r\n\r\nfloat x(float x)\r\n{\r\nreturn abs(smoothstep(-1.,1.,time-x)*2.-1.);\r\n}\r\nvec2 m;\r\nmat2 s(float m)\r\n{\r\nfloat z=sin(m),x=cos(m);\r\nreturn mat2(x,z,-z,x);\r\n}\r\nfloat s(float x,float m,float z)\r\n{\r\nreturn-log(exp(-z*x)+exp(-z*m))/z;\r\n}\r\nfloat x(float x,float m,float z)\r\n{\r\nreturn-log(exp(z*x)+exp(z*m))/-z;\r\n}\r\nfloat n(vec3 m)\r\n{\r\nreturn dot(m,normalize(sign(m+1e-07)));\r\n}\r\nfloat f(vec3 m)\r\n{\r\nreturn fract(sin(dot(vec3(12,26,48),m))*49512.);\r\n}\r\nconst vec2 v=vec2(0,1);\r\nfloat f(vec3 m,vec3 x)\r\n{\r\nreturn mix(mix(f(m+v.xxx),f(m+v.yxx),x.x),mix(f(m+v.xyx),f(m+v.yyx),x.x),x.y);\r\n}\r\nfloat n(vec3 m,bool x)\r\n{\r\nvec3 z=floor(m),y=x?vec3(.5):fract(m);\r\nreturn mix(f(z,y),f(z+v.xxy,y),y.z);\r\n}\r\nfloat p(vec3 m)\r\n{\r\nreturn n(m,false);\r\n}\r\nfloat r(vec3 m)\r\n{\r\nm.y*=.5;\r\nfloat z=0.;\r\nfor(int x=1;x<6;x++)\r\n{\r\nfloat y=float(x*x);\r\nz+=p(m*y)/y;\r\n}\r\nreturn z/4.;\r\n}\r\nfloat a(vec3 m)\r\n{\r\nreturn pow(r(m)+.4,3.)*4.;\r\n}\r\nfloat i(vec3 m)\r\n{\r\nfloat z=m.x,y=m.y,v=m.z,c=abs(z);\r\nreturn s(s(x(-length(vec2(y+.35,v-.55))+.05,x(x(x(-abs(y+1.)+.35,x(x(mix(mix(s(mix(length(m)-.5,c-.4,\r\nsmoothstep(0.,-1.,y)*.2),min(max(c+.35,max(abs(y-.2)-.1,abs(abs(v)-.2))),max(abs(c-.4)+.3,max(abs(y-.25),\r\nabs(v)-.12))),10.),length(vec2(c-.4,y))-.3,-.3),length(m+vec3(0.,.5,.5))-.5,-.4),-length(vec3(c-.3,y,v-.5))+.1,17.),\r\n-length(vec3(c-.05,y+.2,v-.5))-.02,17.),6.),-length(vec2(y,v-.9))+.3,20.),-length(vec2(c-.7,y+.4))+.4+\r\nsmoothstep(.4,-.1,v)*.1,10.),15.),max(length(vec2(abs(y+.35+z*z*5.)-.035,v-.475))-.1+z*z*10.,c-.4),50.),\r\nmax(length(vec3(c-.25,y,v-.42))-.15,-y+.05+.1*cos(time*.7)-c*.4),60.)+a(m*10.)*.012;\r\n}\r\nfloat w(vec3 m)\r\n{\r\nreturn m.x=abs(m.x)-.25,m.z-=.45,length(m)-.1;\r\n}\r\nfloat d(vec3 m)\r\n{\r\nm.y+=1.275;\r\nvec3 z=abs(m)-vec3(.4,.2,0.);\r\nreturn s(min(max(max(z.x,z.y),z.z),length(max(z,0.))-.32),length(vec3(z.x-.2,m.y-.4,m.z-.14))-.2,30.)-a(m*2.)*.05;\r\n}\r\nfloat g(vec3 m)\r\n{\r\nreturn min(s(i(m),d(m),8.),w(m));\r\n}\r\nfloat l(vec3 m)\r\n{\r\nreturn m.xz*=s(time*.1),(r(m*3.*p(m*3.+vec2(0.,time*.2).xyx))*1.5-length(m)+1.2)*.5;\r\n}\r\nfloat e(vec3 m)\r\n{\r\nfloat z=sin(m.z*.1);\r\nm.x+=z;\r\nreturn min(a(m*.7)*2.+p(m*.3)*6.+min(m.y*3.,0.)*.5-length(m.xy)+2.+z,m.y+2.+r(m+p(m*2.)-time))*.5;\r\n}\r\nfloat y(vec3 m)\r\n{\r\nm.xz*=s(time*.2*step(time,122.8));\r\nvec3 x=m;\r\nm.xz=mod(m.xz+3.5,7.)-3.5;\r\nfor(int z=0;z<10;z++)\r\nm.xz=abs(m.xz)-.8,m.xz*=s(.9),m.xy*=s(.8);\r\nm=reflect(m,normalize(sign(m+1e-06))*.2);\r\nreturn n(m)-.5-n(x)*.11;\r\n}\r\nfloat c(vec3 m)\r\n{\r\nreturn time<20.4?g(m):time<40.85?l(m):time<81.7?e(m):time<102.?l(m):time<143.?y(m):g(m);\r\n}\r\nconst vec2 z=vec2(.01,0);\r\nvec3 o(vec3 m)\r\n{\r\nreturn normalize(vec3(c(m+z.xyy)-c(m-z.xyy),c(m+z.yxy)-c(m-z.yxy),c(m+z.yyx)-c(m-z.yyx)));\r\n}\r\nvec3 u(vec3 m)\r\n{\r\nreturn vec3(pow(a(m*4.+a(m*15.+time))+.3,3.),.1,.7);\r\n}\r\nvec3 a(vec3 m,vec3 x,vec3 z,float y)\r\n{\r\nvec3 v=o(z),c=normalize(m-z),a=vec3(-.47,.67,.57);\r\nfloat f=length(z),s=max(dot(v,a),0.),p=pow(max(dot(v,normalize(c+a)),0.),200.)*r(z*1300.)*3.,l=w(z);\r\nreturn time<20.4||time>143.?l<.001?u(reflect(v,c))*.25+p*10.:vec3(.8+r(z*60.)*2.,.9,.7)*s*s+p+step(3.,f)*u(x):\r\nmin(time<40.85||time>81.7&&time<102.?(2.7-z)*pow(y,1.4):time<102.?vec3(1.,.8+max(-z.y*.7-.5,0.),.5+length(z.xy)*.12)*pow(y,1.4)+p:vec3(.3,.2+length(z)*.1,.9-length(z)*.02)*1.5*pow(y,1.4)+p,1.);\r\n}\r\nvec3 b(vec3 z)\r\n{\r\nfloat y=length(vec2(m.x*(time>20.4&&time<143.?.65:1.),m.y))*(step(time,20.4)*.2+.8);\r\nreturn z*smoothstep(180.,167.,time)*smoothstep(0.,8.,time)*x(40.85)*x(61.)*x(81.7)*x(102.)*x(107.2)*x(112.4)*x(117.6)\r\n*x(122.8)*x(143.)*max(1.-y*.5,0.)*(1.-y+max(y-.9,0.)*a((m*s(time*.2)).xyy*20./n(m.xyy)));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\r\n    m=(fragCoord.xy/iResolution.xy*2.-1.)*vec2(iResolution.x/iResolution.y,1.);\r\nvec3 z,y,x;\r\nfloat r,v,f=0.;\r\nif(time<20.4||time>143.)\r\n{\r\nr=smoothstep(0.,20.,time-143.),v=1.-r*1.5;\r\nz=vec3(0,.16,.65-smoothstep(15.5,20.,time)*.058+r*.8),y=normalize(vec3(m,-1.));\r\nmat2 p=s(-.5*v),w=s(-.3*v);\r\nz.yz*=w;\r\ny.yz*=w;\r\nz.xz*=p;\r\ny.xz*=p;\r\n}\r\nelse\r\n if(time<40.85||time>81.7&&time<102.)\r\nz=vec3(0.,0.,-1.1+smoothstep(20.4,40.85,time)*2.3),y=normalize(vec3(time<81.7?m:abs(m),-1.+(time<81.7?0.:length(m)*floor((time-81.7)/5.2)*.5)));\r\nelse\r\n if(time<102.)\r\n{\r\nz=vec3(m,-time+5.),y=normalize(vec3(m,-1.75+length(m)*.5));\r\nif(time<61.)\r\ny.yz*=s(-1.5),y.xz*=s(time*.3);\r\n}\r\nelse\r\n if(time<107.2)\r\nz=vec3(-.5,-.8,1),y=normalize(vec3(m,-1.3)),y.yz*=s(1.4);\r\nelse if(time<112.4)\r\nz=vec3(1.,-.75+(time-107.2)*.1,1.-(time-107.2)*.2),y=normalize(vec3(m,-.7)),y.yz*=s(1.4);\r\nelse if(time<117.6)\r\nz=vec3(0,-.8+(time-112.4)*.2,0),y=normalize(vec3(m,-1)).xzy;\r\nelse if(time<122.8)\r\nz=vec3(0.,1.-(time-117.7)*.2,0.),y=normalize(vec3(m,-1.));\r\nelse if(time<143.)\r\nz=vec3(0.,1.,-5.+(time-117.7)*.2),y=normalize(vec3(m*s(time*.2),-1.+smoothstep(0.,21.,time-122.8)*.8));\r\n\r\nint p;\r\nfor(int i=0;i<70;i++)\r\n{\r\np=i;\r\nx=z+y*f;\r\nfloat w=c(x);\r\nif(w<.0001)\r\nbreak;\r\nf+=w;\r\n}\r\nf=float(p)/60.;\r\nfragColor=vec4(b(a(z,y,x,f)),1.);\r\n    //fragColor = pow(fragColor,vec4(1.0/2.2));\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"//******************************************************************************************\r\n// Dreamcatcher 4k Intro   Shadertoy port\r\n//\r\n// All code by Jan \"LJ\" Scheurer\r\n//\r\n// Music by Jochen \"Virgill\" Feldkoetter\r\n//\r\n// http://www.pouet.net/prod.php?which=67977\r\n// https://demozoo.org/productions/161855/\r\n//******************************************************************************************\r\n\r\n#define time (iTime-0.95)\r\n\r\nfloat x(float x)\r\n{\r\nreturn abs(smoothstep(-1.,1.,time-x)*2.-1.);\r\n}\r\nvec2 m;\r\nmat2 s(float m)\r\n{\r\nfloat z=sin(m),x=cos(m);\r\nreturn mat2(x,z,-z,x);\r\n}\r\nfloat s(float x,float m,float z)\r\n{\r\nreturn-log(exp(-z*x)+exp(-z*m))/z;\r\n}\r\nfloat x(float x,float m,float z)\r\n{\r\nreturn-log(exp(z*x)+exp(z*m))/-z;\r\n}\r\nfloat n(vec3 m)\r\n{\r\nreturn dot(m,normalize(sign(m+1e-07)));\r\n}\r\nfloat f(vec3 m)\r\n{\r\nreturn fract(sin(dot(vec3(12,26,48),m))*49512.);\r\n}\r\nconst vec2 v=vec2(0,1);\r\nfloat f(vec3 m,vec3 x)\r\n{\r\nreturn mix(mix(f(m+v.xxx),f(m+v.yxx),x.x),mix(f(m+v.xyx),f(m+v.yyx),x.x),x.y);\r\n}\r\nfloat n(vec3 m,bool x)\r\n{\r\nvec3 z=floor(m),y=x?vec3(.5):fract(m);\r\nreturn mix(f(z,y),f(z+v.xxy,y),y.z);\r\n}\r\nfloat p(vec3 m)\r\n{\r\nreturn n(m,false);\r\n}\r\nfloat r(vec3 m)\r\n{\r\nm.y*=.5;\r\nfloat z=0.;\r\nfor(int x=1;x<6;x++)\r\n{\r\nfloat y=float(x*x);\r\nz+=p(m*y)/y;\r\n}\r\nreturn z/4.;\r\n}\r\nfloat a(vec3 m)\r\n{\r\nreturn pow(r(m)+.4,3.)*4.;\r\n}\r\nfloat i(vec3 m)\r\n{\r\nfloat z=m.x,y=m.y,v=m.z,c=abs(z);\r\nreturn s(s(x(-length(vec2(y+.35,v-.55))+.05,x(x(x(-abs(y+1.)+.35,x(x(mix(mix(s(mix(length(m)-.5,c-.4,\r\nsmoothstep(0.,-1.,y)*.2),min(max(c+.35,max(abs(y-.2)-.1,abs(abs(v)-.2))),max(abs(c-.4)+.3,max(abs(y-.25),\r\nabs(v)-.12))),10.),length(vec2(c-.4,y))-.3,-.3),length(m+vec3(0.,.5,.5))-.5,-.4),-length(vec3(c-.3,y,v-.5))+.1,17.),\r\n-length(vec3(c-.05,y+.2,v-.5))-.02,17.),6.),-length(vec2(y,v-.9))+.3,20.),-length(vec2(c-.7,y+.4))+.4+\r\nsmoothstep(.4,-.1,v)*.1,10.),15.),max(length(vec2(abs(y+.35+z*z*5.)-.035,v-.475))-.1+z*z*10.,c-.4),50.),\r\nmax(length(vec3(c-.25,y,v-.42))-.15,-y+.05+.1*cos(time*.7)-c*.4),60.)+a(m*10.)*.012;\r\n}\r\nfloat w(vec3 m)\r\n{\r\nreturn m.x=abs(m.x)-.25,m.z-=.45,length(m)-.1;\r\n}\r\nfloat d(vec3 m)\r\n{\r\nm.y+=1.275;\r\nvec3 z=abs(m)-vec3(.4,.2,0.);\r\nreturn s(min(max(max(z.x,z.y),z.z),length(max(z,0.))-.32),length(vec3(z.x-.2,m.y-.4,m.z-.14))-.2,30.)-a(m*2.)*.05;\r\n}\r\nfloat g(vec3 m)\r\n{\r\nreturn min(s(i(m),d(m),8.),w(m));\r\n}\r\nfloat l(vec3 m)\r\n{\r\nreturn m.xz*=s(time*.1),(r(m*3.*p(m*3.+vec2(0.,time*.2).xyx))*1.5-length(m)+1.2)*.5;\r\n}\r\nfloat e(vec3 m)\r\n{\r\nfloat z=sin(m.z*.1);\r\nm.x+=z;\r\nreturn min(a(m*.7)*2.+p(m*.3)*6.+min(m.y*3.,0.)*.5-length(m.xy)+2.+z,m.y+2.+r(m+p(m*2.)-time))*.5;\r\n}\r\nfloat y(vec3 m)\r\n{\r\nm.xz*=s(time*.2*step(time,122.8));\r\nvec3 x=m;\r\nm.xz=mod(m.xz+3.5,7.)-3.5;\r\nfor(int z=0;z<10;z++)\r\nm.xz=abs(m.xz)-.8,m.xz*=s(.9),m.xy*=s(.8);\r\nm=reflect(m,normalize(sign(m+1e-06))*.2);\r\nreturn n(m)-.5-n(x)*.11;\r\n}\r\nfloat c(vec3 m)\r\n{\r\nreturn time<20.4?g(m):time<40.85?l(m):time<81.7?e(m):time<102.?l(m):time<143.?y(m):g(m);\r\n}\r\nconst vec2 z=vec2(.01,0);\r\nvec3 o(vec3 m)\r\n{\r\nreturn normalize(vec3(c(m+z.xyy)-c(m-z.xyy),c(m+z.yxy)-c(m-z.yxy),c(m+z.yyx)-c(m-z.yyx)));\r\n}\r\nvec3 u(vec3 m)\r\n{\r\nreturn vec3(pow(a(m*4.+a(m*15.+time))+.3,3.),.1,.7);\r\n}\r\nvec3 a(vec3 m,vec3 x,vec3 z,float y)\r\n{\r\nvec3 v=o(z),c=normalize(m-z),a=vec3(-.47,.67,.57);\r\nfloat f=length(z),s=max(dot(v,a),0.),p=pow(max(dot(v,normalize(c+a)),0.),200.)*r(z*1300.)*3.,l=w(z);\r\nreturn time<20.4||time>143.?l<.001?u(reflect(v,c))*.25+p*10.:vec3(.8+r(z*60.)*2.,.9,.7)*s*s+p+step(3.,f)*u(x):\r\nmin(time<40.85||time>81.7&&time<102.?(2.7-z)*pow(y,1.4):time<102.?vec3(1.,.8+max(-z.y*.7-.5,0.),.5+length(z.xy)*.12)*pow(y,1.4)+p:vec3(.3,.2+length(z)*.1,.9-length(z)*.02)*1.5*pow(y,1.4)+p,1.);\r\n}\r\nvec3 b(vec3 z)\r\n{\r\nfloat y=length(vec2(m.x*(time>20.4&&time<143.?.65:1.),m.y))*(step(time,20.4)*.2+.8);\r\nreturn z*smoothstep(180.,167.,time)*smoothstep(0.,8.,time)*x(40.85)*x(61.)*x(81.7)*x(102.)*x(107.2)*x(112.4)*x(117.6)\r\n*x(122.8)*x(143.)*max(1.-y*.5,0.)*(1.-y+max(y-.9,0.)*a((m*s(time*.2)).xyy*20./n(m.xyy)));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\r\n    m=(fragCoord.xy/iResolution.xy*2.-1.)*vec2(iResolution.x/iResolution.y,1.);\r\nvec3 z,y,x;\r\nfloat r,v,f=0.;\r\nif(time<20.4||time>143.)\r\n{\r\nr=smoothstep(0.,20.,time-143.),v=1.-r*1.5;\r\nz=vec3(0,.16,.65-smoothstep(15.5,20.,time)*.058+r*.8),y=normalize(vec3(m,-1.));\r\nmat2 p=s(-.5*v),w=s(-.3*v);\r\nz.yz*=w;\r\ny.yz*=w;\r\nz.xz*=p;\r\ny.xz*=p;\r\n}\r\nelse\r\n if(time<40.85||time>81.7&&time<102.)\r\nz=vec3(0.,0.,-1.1+smoothstep(20.4,40.85,time)*2.3),y=normalize(vec3(time<81.7?m:abs(m),-1.+(time<81.7?0.:length(m)*floor((time-81.7)/5.2)*.5)));\r\nelse\r\n if(time<102.)\r\n{\r\nz=vec3(m,-time+5.),y=normalize(vec3(m,-1.75+length(m)*.5));\r\nif(time<61.)\r\ny.yz*=s(-1.5),y.xz*=s(time*.3);\r\n}\r\nelse\r\n if(time<107.2)\r\nz=vec3(-.5,-.8,1),y=normalize(vec3(m,-1.3)),y.yz*=s(1.4);\r\nelse if(time<112.4)\r\nz=vec3(1.,-.75+(time-107.2)*.1,1.-(time-107.2)*.2),y=normalize(vec3(m,-.7)),y.yz*=s(1.4);\r\nelse if(time<117.6)\r\nz=vec3(0,-.8+(time-112.4)*.2,0),y=normalize(vec3(m,-1)).xzy;\r\nelse if(time<122.8)\r\nz=vec3(0.,1.-(time-117.7)*.2,0.),y=normalize(vec3(m,-1.));\r\nelse if(time<143.)\r\nz=vec3(0.,1.,-5.+(time-117.7)*.2),y=normalize(vec3(m*s(time*.2),-1.+smoothstep(0.,21.,time-122.8)*.8));\r\n\r\nint p;\r\nfor(int i=0;i<70;i++)\r\n{\r\np=i;\r\nx=z+y*f;\r\nfloat w=c(x);\r\nif(w<.0001)\r\nbreak;\r\nf+=w;\r\n}\r\nf=float(p)/60.;\r\nfragColor=vec4(b(a(z,y,x,f)),1.);\r\n    //fragColor = pow(fragColor,vec4(1.0/2.2));\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Dreamcatcher","id":"ca4cbeaa475142e1be855e35f1563080","date":null,"viewed":0,"name":"Dreamcatcher","description":"Dreamcatcher 4k Intro   (Shadertoy port)\nAll code by Jan \"LJ\" Scheurer\nMusic by Jochen \"Virgill\" Feldkoetter\nhttp://www.pouet.net/prod.php?which=67977\nhttps://demozoo.org/productions/161855/","likes":0,"published":null,"tags":["raymarching"," tunnel"," intro"," 4k"," demoscene"," alien"]},"ver":null,"info":{"Name":"Dreamcatcher","id":"ca4cbeaa475142e1be855e35f1563080","date":null,"viewed":0,"name":"Dreamcatcher","description":"Dreamcatcher 4k Intro   (Shadertoy port)\nAll code by Jan \"LJ\" Scheurer\nMusic by Jochen \"Virgill\" Feldkoetter\nhttp://www.pouet.net/prod.php?which=67977\nhttps://demozoo.org/productions/161855/","likes":0,"published":null,"tags":["raymarching"," tunnel"," intro"," 4k"," demoscene"," alien"]},"renderpass":[{"Code":"//******************************************************************************************\r\n// Dreamcatcher 4k Intro   Shadertoy port\r\n//\r\n// All code by Jan \"LJ\" Scheurer\r\n//\r\n// Music by Jochen \"Virgill\" Feldkoetter\r\n//\r\n// http://www.pouet.net/prod.php?which=67977\r\n// https://demozoo.org/productions/161855/\r\n//******************************************************************************************\r\n\r\n#define time (iTime-0.95)\r\n\r\nfloat x(float x)\r\n{\r\nreturn abs(smoothstep(-1.,1.,time-x)*2.-1.);\r\n}\r\nvec2 m;\r\nmat2 s(float m)\r\n{\r\nfloat z=sin(m),x=cos(m);\r\nreturn mat2(x,z,-z,x);\r\n}\r\nfloat s(float x,float m,float z)\r\n{\r\nreturn-log(exp(-z*x)+exp(-z*m))/z;\r\n}\r\nfloat x(float x,float m,float z)\r\n{\r\nreturn-log(exp(z*x)+exp(z*m))/-z;\r\n}\r\nfloat n(vec3 m)\r\n{\r\nreturn dot(m,normalize(sign(m+1e-07)));\r\n}\r\nfloat f(vec3 m)\r\n{\r\nreturn fract(sin(dot(vec3(12,26,48),m))*49512.);\r\n}\r\nconst vec2 v=vec2(0,1);\r\nfloat f(vec3 m,vec3 x)\r\n{\r\nreturn mix(mix(f(m+v.xxx),f(m+v.yxx),x.x),mix(f(m+v.xyx),f(m+v.yyx),x.x),x.y);\r\n}\r\nfloat n(vec3 m,bool x)\r\n{\r\nvec3 z=floor(m),y=x?vec3(.5):fract(m);\r\nreturn mix(f(z,y),f(z+v.xxy,y),y.z);\r\n}\r\nfloat p(vec3 m)\r\n{\r\nreturn n(m,false);\r\n}\r\nfloat r(vec3 m)\r\n{\r\nm.y*=.5;\r\nfloat z=0.;\r\nfor(int x=1;x<6;x++)\r\n{\r\nfloat y=float(x*x);\r\nz+=p(m*y)/y;\r\n}\r\nreturn z/4.;\r\n}\r\nfloat a(vec3 m)\r\n{\r\nreturn pow(r(m)+.4,3.)*4.;\r\n}\r\nfloat i(vec3 m)\r\n{\r\nfloat z=m.x,y=m.y,v=m.z,c=abs(z);\r\nreturn s(s(x(-length(vec2(y+.35,v-.55))+.05,x(x(x(-abs(y+1.)+.35,x(x(mix(mix(s(mix(length(m)-.5,c-.4,\r\nsmoothstep(0.,-1.,y)*.2),min(max(c+.35,max(abs(y-.2)-.1,abs(abs(v)-.2))),max(abs(c-.4)+.3,max(abs(y-.25),\r\nabs(v)-.12))),10.),length(vec2(c-.4,y))-.3,-.3),length(m+vec3(0.,.5,.5))-.5,-.4),-length(vec3(c-.3,y,v-.5))+.1,17.),\r\n-length(vec3(c-.05,y+.2,v-.5))-.02,17.),6.),-length(vec2(y,v-.9))+.3,20.),-length(vec2(c-.7,y+.4))+.4+\r\nsmoothstep(.4,-.1,v)*.1,10.),15.),max(length(vec2(abs(y+.35+z*z*5.)-.035,v-.475))-.1+z*z*10.,c-.4),50.),\r\nmax(length(vec3(c-.25,y,v-.42))-.15,-y+.05+.1*cos(time*.7)-c*.4),60.)+a(m*10.)*.012;\r\n}\r\nfloat w(vec3 m)\r\n{\r\nreturn m.x=abs(m.x)-.25,m.z-=.45,length(m)-.1;\r\n}\r\nfloat d(vec3 m)\r\n{\r\nm.y+=1.275;\r\nvec3 z=abs(m)-vec3(.4,.2,0.);\r\nreturn s(min(max(max(z.x,z.y),z.z),length(max(z,0.))-.32),length(vec3(z.x-.2,m.y-.4,m.z-.14))-.2,30.)-a(m*2.)*.05;\r\n}\r\nfloat g(vec3 m)\r\n{\r\nreturn min(s(i(m),d(m),8.),w(m));\r\n}\r\nfloat l(vec3 m)\r\n{\r\nreturn m.xz*=s(time*.1),(r(m*3.*p(m*3.+vec2(0.,time*.2).xyx))*1.5-length(m)+1.2)*.5;\r\n}\r\nfloat e(vec3 m)\r\n{\r\nfloat z=sin(m.z*.1);\r\nm.x+=z;\r\nreturn min(a(m*.7)*2.+p(m*.3)*6.+min(m.y*3.,0.)*.5-length(m.xy)+2.+z,m.y+2.+r(m+p(m*2.)-time))*.5;\r\n}\r\nfloat y(vec3 m)\r\n{\r\nm.xz*=s(time*.2*step(time,122.8));\r\nvec3 x=m;\r\nm.xz=mod(m.xz+3.5,7.)-3.5;\r\nfor(int z=0;z<10;z++)\r\nm.xz=abs(m.xz)-.8,m.xz*=s(.9),m.xy*=s(.8);\r\nm=reflect(m,normalize(sign(m+1e-06))*.2);\r\nreturn n(m)-.5-n(x)*.11;\r\n}\r\nfloat c(vec3 m)\r\n{\r\nreturn time<20.4?g(m):time<40.85?l(m):time<81.7?e(m):time<102.?l(m):time<143.?y(m):g(m);\r\n}\r\nconst vec2 z=vec2(.01,0);\r\nvec3 o(vec3 m)\r\n{\r\nreturn normalize(vec3(c(m+z.xyy)-c(m-z.xyy),c(m+z.yxy)-c(m-z.yxy),c(m+z.yyx)-c(m-z.yyx)));\r\n}\r\nvec3 u(vec3 m)\r\n{\r\nreturn vec3(pow(a(m*4.+a(m*15.+time))+.3,3.),.1,.7);\r\n}\r\nvec3 a(vec3 m,vec3 x,vec3 z,float y)\r\n{\r\nvec3 v=o(z),c=normalize(m-z),a=vec3(-.47,.67,.57);\r\nfloat f=length(z),s=max(dot(v,a),0.),p=pow(max(dot(v,normalize(c+a)),0.),200.)*r(z*1300.)*3.,l=w(z);\r\nreturn time<20.4||time>143.?l<.001?u(reflect(v,c))*.25+p*10.:vec3(.8+r(z*60.)*2.,.9,.7)*s*s+p+step(3.,f)*u(x):\r\nmin(time<40.85||time>81.7&&time<102.?(2.7-z)*pow(y,1.4):time<102.?vec3(1.,.8+max(-z.y*.7-.5,0.),.5+length(z.xy)*.12)*pow(y,1.4)+p:vec3(.3,.2+length(z)*.1,.9-length(z)*.02)*1.5*pow(y,1.4)+p,1.);\r\n}\r\nvec3 b(vec3 z)\r\n{\r\nfloat y=length(vec2(m.x*(time>20.4&&time<143.?.65:1.),m.y))*(step(time,20.4)*.2+.8);\r\nreturn z*smoothstep(180.,167.,time)*smoothstep(0.,8.,time)*x(40.85)*x(61.)*x(81.7)*x(102.)*x(107.2)*x(112.4)*x(117.6)\r\n*x(122.8)*x(143.)*max(1.-y*.5,0.)*(1.-y+max(y-.9,0.)*a((m*s(time*.2)).xyy*20./n(m.xyy)));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\r\n    m=(fragCoord.xy/iResolution.xy*2.-1.)*vec2(iResolution.x/iResolution.y,1.);\r\nvec3 z,y,x;\r\nfloat r,v,f=0.;\r\nif(time<20.4||time>143.)\r\n{\r\nr=smoothstep(0.,20.,time-143.),v=1.-r*1.5;\r\nz=vec3(0,.16,.65-smoothstep(15.5,20.,time)*.058+r*.8),y=normalize(vec3(m,-1.));\r\nmat2 p=s(-.5*v),w=s(-.3*v);\r\nz.yz*=w;\r\ny.yz*=w;\r\nz.xz*=p;\r\ny.xz*=p;\r\n}\r\nelse\r\n if(time<40.85||time>81.7&&time<102.)\r\nz=vec3(0.,0.,-1.1+smoothstep(20.4,40.85,time)*2.3),y=normalize(vec3(time<81.7?m:abs(m),-1.+(time<81.7?0.:length(m)*floor((time-81.7)/5.2)*.5)));\r\nelse\r\n if(time<102.)\r\n{\r\nz=vec3(m,-time+5.),y=normalize(vec3(m,-1.75+length(m)*.5));\r\nif(time<61.)\r\ny.yz*=s(-1.5),y.xz*=s(time*.3);\r\n}\r\nelse\r\n if(time<107.2)\r\nz=vec3(-.5,-.8,1),y=normalize(vec3(m,-1.3)),y.yz*=s(1.4);\r\nelse if(time<112.4)\r\nz=vec3(1.,-.75+(time-107.2)*.1,1.-(time-107.2)*.2),y=normalize(vec3(m,-.7)),y.yz*=s(1.4);\r\nelse if(time<117.6)\r\nz=vec3(0,-.8+(time-112.4)*.2,0),y=normalize(vec3(m,-1)).xzy;\r\nelse if(time<122.8)\r\nz=vec3(0.,1.-(time-117.7)*.2,0.),y=normalize(vec3(m,-1.));\r\nelse if(time<143.)\r\nz=vec3(0.,1.,-5.+(time-117.7)*.2),y=normalize(vec3(m*s(time*.2),-1.+smoothstep(0.,21.,time-122.8)*.8));\r\n\r\nint p;\r\nfor(int i=0;i<70;i++)\r\n{\r\np=i;\r\nx=z+y*f;\r\nfloat w=c(x);\r\nif(w<.0001)\r\nbreak;\r\nf+=w;\r\n}\r\nf=float(p)/60.;\r\nfragColor=vec4(b(a(z,y,x,f)),1.);\r\n    //fragColor = pow(fragColor,vec4(1.0/2.2));\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"//******************************************************************************************\r\n// Dreamcatcher 4k Intro   Shadertoy port\r\n//\r\n// All code by Jan \"LJ\" Scheurer\r\n//\r\n// Music by Jochen \"Virgill\" Feldkoetter\r\n//\r\n// http://www.pouet.net/prod.php?which=67977\r\n// https://demozoo.org/productions/161855/\r\n//******************************************************************************************\r\n\r\n#define time (iTime-0.95)\r\n\r\nfloat x(float x)\r\n{\r\nreturn abs(smoothstep(-1.,1.,time-x)*2.-1.);\r\n}\r\nvec2 m;\r\nmat2 s(float m)\r\n{\r\nfloat z=sin(m),x=cos(m);\r\nreturn mat2(x,z,-z,x);\r\n}\r\nfloat s(float x,float m,float z)\r\n{\r\nreturn-log(exp(-z*x)+exp(-z*m))/z;\r\n}\r\nfloat x(float x,float m,float z)\r\n{\r\nreturn-log(exp(z*x)+exp(z*m))/-z;\r\n}\r\nfloat n(vec3 m)\r\n{\r\nreturn dot(m,normalize(sign(m+1e-07)));\r\n}\r\nfloat f(vec3 m)\r\n{\r\nreturn fract(sin(dot(vec3(12,26,48),m))*49512.);\r\n}\r\nconst vec2 v=vec2(0,1);\r\nfloat f(vec3 m,vec3 x)\r\n{\r\nreturn mix(mix(f(m+v.xxx),f(m+v.yxx),x.x),mix(f(m+v.xyx),f(m+v.yyx),x.x),x.y);\r\n}\r\nfloat n(vec3 m,bool x)\r\n{\r\nvec3 z=floor(m),y=x?vec3(.5):fract(m);\r\nreturn mix(f(z,y),f(z+v.xxy,y),y.z);\r\n}\r\nfloat p(vec3 m)\r\n{\r\nreturn n(m,false);\r\n}\r\nfloat r(vec3 m)\r\n{\r\nm.y*=.5;\r\nfloat z=0.;\r\nfor(int x=1;x<6;x++)\r\n{\r\nfloat y=float(x*x);\r\nz+=p(m*y)/y;\r\n}\r\nreturn z/4.;\r\n}\r\nfloat a(vec3 m)\r\n{\r\nreturn pow(r(m)+.4,3.)*4.;\r\n}\r\nfloat i(vec3 m)\r\n{\r\nfloat z=m.x,y=m.y,v=m.z,c=abs(z);\r\nreturn s(s(x(-length(vec2(y+.35,v-.55))+.05,x(x(x(-abs(y+1.)+.35,x(x(mix(mix(s(mix(length(m)-.5,c-.4,\r\nsmoothstep(0.,-1.,y)*.2),min(max(c+.35,max(abs(y-.2)-.1,abs(abs(v)-.2))),max(abs(c-.4)+.3,max(abs(y-.25),\r\nabs(v)-.12))),10.),length(vec2(c-.4,y))-.3,-.3),length(m+vec3(0.,.5,.5))-.5,-.4),-length(vec3(c-.3,y,v-.5))+.1,17.),\r\n-length(vec3(c-.05,y+.2,v-.5))-.02,17.),6.),-length(vec2(y,v-.9))+.3,20.),-length(vec2(c-.7,y+.4))+.4+\r\nsmoothstep(.4,-.1,v)*.1,10.),15.),max(length(vec2(abs(y+.35+z*z*5.)-.035,v-.475))-.1+z*z*10.,c-.4),50.),\r\nmax(length(vec3(c-.25,y,v-.42))-.15,-y+.05+.1*cos(time*.7)-c*.4),60.)+a(m*10.)*.012;\r\n}\r\nfloat w(vec3 m)\r\n{\r\nreturn m.x=abs(m.x)-.25,m.z-=.45,length(m)-.1;\r\n}\r\nfloat d(vec3 m)\r\n{\r\nm.y+=1.275;\r\nvec3 z=abs(m)-vec3(.4,.2,0.);\r\nreturn s(min(max(max(z.x,z.y),z.z),length(max(z,0.))-.32),length(vec3(z.x-.2,m.y-.4,m.z-.14))-.2,30.)-a(m*2.)*.05;\r\n}\r\nfloat g(vec3 m)\r\n{\r\nreturn min(s(i(m),d(m),8.),w(m));\r\n}\r\nfloat l(vec3 m)\r\n{\r\nreturn m.xz*=s(time*.1),(r(m*3.*p(m*3.+vec2(0.,time*.2).xyx))*1.5-length(m)+1.2)*.5;\r\n}\r\nfloat e(vec3 m)\r\n{\r\nfloat z=sin(m.z*.1);\r\nm.x+=z;\r\nreturn min(a(m*.7)*2.+p(m*.3)*6.+min(m.y*3.,0.)*.5-length(m.xy)+2.+z,m.y+2.+r(m+p(m*2.)-time))*.5;\r\n}\r\nfloat y(vec3 m)\r\n{\r\nm.xz*=s(time*.2*step(time,122.8));\r\nvec3 x=m;\r\nm.xz=mod(m.xz+3.5,7.)-3.5;\r\nfor(int z=0;z<10;z++)\r\nm.xz=abs(m.xz)-.8,m.xz*=s(.9),m.xy*=s(.8);\r\nm=reflect(m,normalize(sign(m+1e-06))*.2);\r\nreturn n(m)-.5-n(x)*.11;\r\n}\r\nfloat c(vec3 m)\r\n{\r\nreturn time<20.4?g(m):time<40.85?l(m):time<81.7?e(m):time<102.?l(m):time<143.?y(m):g(m);\r\n}\r\nconst vec2 z=vec2(.01,0);\r\nvec3 o(vec3 m)\r\n{\r\nreturn normalize(vec3(c(m+z.xyy)-c(m-z.xyy),c(m+z.yxy)-c(m-z.yxy),c(m+z.yyx)-c(m-z.yyx)));\r\n}\r\nvec3 u(vec3 m)\r\n{\r\nreturn vec3(pow(a(m*4.+a(m*15.+time))+.3,3.),.1,.7);\r\n}\r\nvec3 a(vec3 m,vec3 x,vec3 z,float y)\r\n{\r\nvec3 v=o(z),c=normalize(m-z),a=vec3(-.47,.67,.57);\r\nfloat f=length(z),s=max(dot(v,a),0.),p=pow(max(dot(v,normalize(c+a)),0.),200.)*r(z*1300.)*3.,l=w(z);\r\nreturn time<20.4||time>143.?l<.001?u(reflect(v,c))*.25+p*10.:vec3(.8+r(z*60.)*2.,.9,.7)*s*s+p+step(3.,f)*u(x):\r\nmin(time<40.85||time>81.7&&time<102.?(2.7-z)*pow(y,1.4):time<102.?vec3(1.,.8+max(-z.y*.7-.5,0.),.5+length(z.xy)*.12)*pow(y,1.4)+p:vec3(.3,.2+length(z)*.1,.9-length(z)*.02)*1.5*pow(y,1.4)+p,1.);\r\n}\r\nvec3 b(vec3 z)\r\n{\r\nfloat y=length(vec2(m.x*(time>20.4&&time<143.?.65:1.),m.y))*(step(time,20.4)*.2+.8);\r\nreturn z*smoothstep(180.,167.,time)*smoothstep(0.,8.,time)*x(40.85)*x(61.)*x(81.7)*x(102.)*x(107.2)*x(112.4)*x(117.6)\r\n*x(122.8)*x(143.)*max(1.-y*.5,0.)*(1.-y+max(y-.9,0.)*a((m*s(time*.2)).xyy*20./n(m.xyy)));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\r\n    m=(fragCoord.xy/iResolution.xy*2.-1.)*vec2(iResolution.x/iResolution.y,1.);\r\nvec3 z,y,x;\r\nfloat r,v,f=0.;\r\nif(time<20.4||time>143.)\r\n{\r\nr=smoothstep(0.,20.,time-143.),v=1.-r*1.5;\r\nz=vec3(0,.16,.65-smoothstep(15.5,20.,time)*.058+r*.8),y=normalize(vec3(m,-1.));\r\nmat2 p=s(-.5*v),w=s(-.3*v);\r\nz.yz*=w;\r\ny.yz*=w;\r\nz.xz*=p;\r\ny.xz*=p;\r\n}\r\nelse\r\n if(time<40.85||time>81.7&&time<102.)\r\nz=vec3(0.,0.,-1.1+smoothstep(20.4,40.85,time)*2.3),y=normalize(vec3(time<81.7?m:abs(m),-1.+(time<81.7?0.:length(m)*floor((time-81.7)/5.2)*.5)));\r\nelse\r\n if(time<102.)\r\n{\r\nz=vec3(m,-time+5.),y=normalize(vec3(m,-1.75+length(m)*.5));\r\nif(time<61.)\r\ny.yz*=s(-1.5),y.xz*=s(time*.3);\r\n}\r\nelse\r\n if(time<107.2)\r\nz=vec3(-.5,-.8,1),y=normalize(vec3(m,-1.3)),y.yz*=s(1.4);\r\nelse if(time<112.4)\r\nz=vec3(1.,-.75+(time-107.2)*.1,1.-(time-107.2)*.2),y=normalize(vec3(m,-.7)),y.yz*=s(1.4);\r\nelse if(time<117.6)\r\nz=vec3(0,-.8+(time-112.4)*.2,0),y=normalize(vec3(m,-1)).xzy;\r\nelse if(time<122.8)\r\nz=vec3(0.,1.-(time-117.7)*.2,0.),y=normalize(vec3(m,-1.));\r\nelse if(time<143.)\r\nz=vec3(0.,1.,-5.+(time-117.7)*.2),y=normalize(vec3(m*s(time*.2),-1.+smoothstep(0.,21.,time-122.8)*.8));\r\n\r\nint p;\r\nfor(int i=0;i<70;i++)\r\n{\r\np=i;\r\nx=z+y*f;\r\nfloat w=c(x);\r\nif(w<.0001)\r\nbreak;\r\nf+=w;\r\n}\r\nf=float(p)/60.;\r\nfragColor=vec4(b(a(z,y,x,f)),1.);\r\n    //fragColor = pow(fragColor,vec4(1.0/2.2));\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define Wmin 50.    // spectrum shape of exciter \r\n#define Wmax 200.\r\n#define Wsamples 150.\r\n#define AMP(w) (1./(w))\r\n\r\n#define COL 0\t\t// water reflects\r\n#define CAM 1\t\t// perspective camera\r\n#define PULSE 1     // time shape of exciter  1: square 2: smooth\r\n// SPACE to toggle spreaded source\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- rand\r\nfloat hash(float x) { return fract(sin(3234.*x)*6563.234); }\r\n\r\n// --- solve degree 3 equation\r\nfloat solveP3(float a, float c, float d) {\r\n\tc /= a; d /= a;\r\n\tfloat C = -d/2.*(1.+sqrt(1.+(c*c*c)/(d*d)*4./27.));  \r\n\tC = sign(C)*pow(abs(C),1./3.);\r\n    return C-c/(3.*C);\r\n}\r\n\r\n// --- Pierson-Moskowitz oceanographic spectrum   V = wind at 20m height\r\nfloat PM(float w,float V) { return 8.1E-3*9.81*9.81/pow(w,5.)*exp(-0.74*pow(9.81/(V*w),4.)); }\r\n\r\n// --- drop exciter\r\nfloat pulse(float t) {\r\n#if   PULSE==1\r\n\treturn (mod(t,1.)<.1) ? 1.: 0.;      // square signal\r\n#elif PULSE==2\r\n\treturn pow(.5+.5*cos(6.283*t),20.);  // smoothed signal\r\n#endif\r\n}\r\n\r\n// === main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat t = .3*iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\r\n\tvec2 m  =      2.*( iMouse.xy / iResolution.y - vec2(.9,.5));\r\n\tif (length(iMouse.zw)==0.) m = vec2(1e-5);\r\n\t\r\n#if CAM\r\n\t// set view conditions and get water plane position viewed in the pixel\r\n\tfloat b = 3.14*length(m), a = atan(m.y,m.x);\r\n\tvec3 eye = vec3(sin(b)*cos(a),sin(b)*sin(a),cos(b)); // vec3(2.*m,2.);\r\n\tmat3 M; \t\t\t\t\t// view matrix\r\n\tM[0] = normalize(-eye);\r\n\tM[2] = normalize(vec3(0.,0.,1.)-M[0].z*M[0]);\r\n\tM[1] = cross(M[0],M[2]);\r\n\tvec3 ray = normalize(M*vec3(1.,uv));\r\n\tif (abs(ray.z)>1e-3) {\r\n\t\tfloat l = -eye.z/ray.z; vec3 P = eye + l*ray; // point on water plane\r\n\t\tuv = P.xy;\r\n\t}\r\n#endif\r\n\t\r\n\tvec2 dir = normalize(uv);\r\n\tfloat d = 10.*length(uv);\r\n\tfloat x = 0., y = 0.; vec4 col = vec4(0.);\r\n\t\r\n\t// k = 2Pi/L , w = 2Pi/T\r\n\t// complete waves dispertion equation: w^2 = (gk + sigma/rho k^3) tanh(kh)\r\n\t// here, ignore tan(kh) ( = deep water case )\r\n\t\r\n\t// sum on wave spectrum // < 85: gravity waves  > 85: capillary waves\r\n\tfor (float w = Wmin; w < Wmax; w += (Wmax-Wmin)/Wsamples) \r\n\t{  \r\n\t    float k = solveP3(9.81, 0.074/1000.,-w*w);  // k(w)\r\n\t\tif (keyToggle(32)) d = 10.*length(uv+.03*(2.*vec2(hash(1./w),1.+hash(1./w))-1.));\r\n\t\tfloat phi =k*d-w*t ,\t\t\t\t\t\t// wave phase\r\n\t\t\t  phi0 = 6.283*hash(w);   \t\t\t\t// random phasing(w)\r\n\t\tfloat A = 2.*AMP(w) * pulse(-phi/w);\t\t// amplitude\r\n#if !COL\r\n\t\ty += A*sin(phi+phi0);\r\n\t\t// x += A*cos(phi+phi0);\r\n#else\r\n\t\tA *= 1.;\r\n\t\t// normal to the surface, and ray reflection in the cubemap.\r\n\t\tvec3 N = normalize(vec3( A*k*cos(phi+phi0)*dir,-(1.-A*k*sin(phi+phi0)))),\r\n\t\t\t V = reflect(ray,N);\r\n\t\tcol += texture(iChannel0, V.xzy );\r\n#endif\r\n\t}\r\n\t\r\n#if COL\r\n\tfragColor = vec4(col/Wsamples); \r\n#else\r\n\tfragColor = vec4(.5+y); fragColor.b += .1;\r\n#endif\r\n}","inputs":[],"outputs":[],"code":"#define Wmin 50.    // spectrum shape of exciter \r\n#define Wmax 200.\r\n#define Wsamples 150.\r\n#define AMP(w) (1./(w))\r\n\r\n#define COL 0\t\t// water reflects\r\n#define CAM 1\t\t// perspective camera\r\n#define PULSE 1     // time shape of exciter  1: square 2: smooth\r\n// SPACE to toggle spreaded source\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- rand\r\nfloat hash(float x) { return fract(sin(3234.*x)*6563.234); }\r\n\r\n// --- solve degree 3 equation\r\nfloat solveP3(float a, float c, float d) {\r\n\tc /= a; d /= a;\r\n\tfloat C = -d/2.*(1.+sqrt(1.+(c*c*c)/(d*d)*4./27.));  \r\n\tC = sign(C)*pow(abs(C),1./3.);\r\n    return C-c/(3.*C);\r\n}\r\n\r\n// --- Pierson-Moskowitz oceanographic spectrum   V = wind at 20m height\r\nfloat PM(float w,float V) { return 8.1E-3*9.81*9.81/pow(w,5.)*exp(-0.74*pow(9.81/(V*w),4.)); }\r\n\r\n// --- drop exciter\r\nfloat pulse(float t) {\r\n#if   PULSE==1\r\n\treturn (mod(t,1.)<.1) ? 1.: 0.;      // square signal\r\n#elif PULSE==2\r\n\treturn pow(.5+.5*cos(6.283*t),20.);  // smoothed signal\r\n#endif\r\n}\r\n\r\n// === main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat t = .3*iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\r\n\tvec2 m  =      2.*( iMouse.xy / iResolution.y - vec2(.9,.5));\r\n\tif (length(iMouse.zw)==0.) m = vec2(1e-5);\r\n\t\r\n#if CAM\r\n\t// set view conditions and get water plane position viewed in the pixel\r\n\tfloat b = 3.14*length(m), a = atan(m.y,m.x);\r\n\tvec3 eye = vec3(sin(b)*cos(a),sin(b)*sin(a),cos(b)); // vec3(2.*m,2.);\r\n\tmat3 M; \t\t\t\t\t// view matrix\r\n\tM[0] = normalize(-eye);\r\n\tM[2] = normalize(vec3(0.,0.,1.)-M[0].z*M[0]);\r\n\tM[1] = cross(M[0],M[2]);\r\n\tvec3 ray = normalize(M*vec3(1.,uv));\r\n\tif (abs(ray.z)>1e-3) {\r\n\t\tfloat l = -eye.z/ray.z; vec3 P = eye + l*ray; // point on water plane\r\n\t\tuv = P.xy;\r\n\t}\r\n#endif\r\n\t\r\n\tvec2 dir = normalize(uv);\r\n\tfloat d = 10.*length(uv);\r\n\tfloat x = 0., y = 0.; vec4 col = vec4(0.);\r\n\t\r\n\t// k = 2Pi/L , w = 2Pi/T\r\n\t// complete waves dispertion equation: w^2 = (gk + sigma/rho k^3) tanh(kh)\r\n\t// here, ignore tan(kh) ( = deep water case )\r\n\t\r\n\t// sum on wave spectrum // < 85: gravity waves  > 85: capillary waves\r\n\tfor (float w = Wmin; w < Wmax; w += (Wmax-Wmin)/Wsamples) \r\n\t{  \r\n\t    float k = solveP3(9.81, 0.074/1000.,-w*w);  // k(w)\r\n\t\tif (keyToggle(32)) d = 10.*length(uv+.03*(2.*vec2(hash(1./w),1.+hash(1./w))-1.));\r\n\t\tfloat phi =k*d-w*t ,\t\t\t\t\t\t// wave phase\r\n\t\t\t  phi0 = 6.283*hash(w);   \t\t\t\t// random phasing(w)\r\n\t\tfloat A = 2.*AMP(w) * pulse(-phi/w);\t\t// amplitude\r\n#if !COL\r\n\t\ty += A*sin(phi+phi0);\r\n\t\t// x += A*cos(phi+phi0);\r\n#else\r\n\t\tA *= 1.;\r\n\t\t// normal to the surface, and ray reflection in the cubemap.\r\n\t\tvec3 N = normalize(vec3( A*k*cos(phi+phi0)*dir,-(1.-A*k*sin(phi+phi0)))),\r\n\t\t\t V = reflect(ray,N);\r\n\t\tcol += texture(iChannel0, V.xzy );\r\n#endif\r\n\t}\r\n\t\r\n#if COL\r\n\tfragColor = vec4(col/Wsamples); \r\n#else\r\n\tfragColor = vec4(.5+y); fragColor.b += .1;\r\n#endif\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"drop splash","id":"3a7e47f2ef5a4d27b72c07e31121f1ac","date":null,"viewed":0,"name":"drop splash","description":"Real drop splashes are *not* sin(k(d-ct)) !\r\n- wave speed depends on wavelenght (dispertion). slowest=.4 cm; faster for larger (gravity) and smaller (capillary)\r\n- vertical displ = A.sin, horiz displ = A.cos -> trochoids, not sinusoids (not drawn here).\r\nhttps://www.shadertoy.com/view/ldlXDN","likes":0,"published":null,"tags":["waves"]},"ver":null,"info":{"Name":"drop splash","id":"3a7e47f2ef5a4d27b72c07e31121f1ac","date":null,"viewed":0,"name":"drop splash","description":"Real drop splashes are *not* sin(k(d-ct)) !\r\n- wave speed depends on wavelenght (dispertion). slowest=.4 cm; faster for larger (gravity) and smaller (capillary)\r\n- vertical displ = A.sin, horiz displ = A.cos -> trochoids, not sinusoids (not drawn here).\r\nhttps://www.shadertoy.com/view/ldlXDN","likes":0,"published":null,"tags":["waves"]},"renderpass":[{"Code":"#define Wmin 50.    // spectrum shape of exciter \r\n#define Wmax 200.\r\n#define Wsamples 150.\r\n#define AMP(w) (1./(w))\r\n\r\n#define COL 0\t\t// water reflects\r\n#define CAM 1\t\t// perspective camera\r\n#define PULSE 1     // time shape of exciter  1: square 2: smooth\r\n// SPACE to toggle spreaded source\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- rand\r\nfloat hash(float x) { return fract(sin(3234.*x)*6563.234); }\r\n\r\n// --- solve degree 3 equation\r\nfloat solveP3(float a, float c, float d) {\r\n\tc /= a; d /= a;\r\n\tfloat C = -d/2.*(1.+sqrt(1.+(c*c*c)/(d*d)*4./27.));  \r\n\tC = sign(C)*pow(abs(C),1./3.);\r\n    return C-c/(3.*C);\r\n}\r\n\r\n// --- Pierson-Moskowitz oceanographic spectrum   V = wind at 20m height\r\nfloat PM(float w,float V) { return 8.1E-3*9.81*9.81/pow(w,5.)*exp(-0.74*pow(9.81/(V*w),4.)); }\r\n\r\n// --- drop exciter\r\nfloat pulse(float t) {\r\n#if   PULSE==1\r\n\treturn (mod(t,1.)<.1) ? 1.: 0.;      // square signal\r\n#elif PULSE==2\r\n\treturn pow(.5+.5*cos(6.283*t),20.);  // smoothed signal\r\n#endif\r\n}\r\n\r\n// === main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat t = .3*iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\r\n\tvec2 m  =      2.*( iMouse.xy / iResolution.y - vec2(.9,.5));\r\n\tif (length(iMouse.zw)==0.) m = vec2(1e-5);\r\n\t\r\n#if CAM\r\n\t// set view conditions and get water plane position viewed in the pixel\r\n\tfloat b = 3.14*length(m), a = atan(m.y,m.x);\r\n\tvec3 eye = vec3(sin(b)*cos(a),sin(b)*sin(a),cos(b)); // vec3(2.*m,2.);\r\n\tmat3 M; \t\t\t\t\t// view matrix\r\n\tM[0] = normalize(-eye);\r\n\tM[2] = normalize(vec3(0.,0.,1.)-M[0].z*M[0]);\r\n\tM[1] = cross(M[0],M[2]);\r\n\tvec3 ray = normalize(M*vec3(1.,uv));\r\n\tif (abs(ray.z)>1e-3) {\r\n\t\tfloat l = -eye.z/ray.z; vec3 P = eye + l*ray; // point on water plane\r\n\t\tuv = P.xy;\r\n\t}\r\n#endif\r\n\t\r\n\tvec2 dir = normalize(uv);\r\n\tfloat d = 10.*length(uv);\r\n\tfloat x = 0., y = 0.; vec4 col = vec4(0.);\r\n\t\r\n\t// k = 2Pi/L , w = 2Pi/T\r\n\t// complete waves dispertion equation: w^2 = (gk + sigma/rho k^3) tanh(kh)\r\n\t// here, ignore tan(kh) ( = deep water case )\r\n\t\r\n\t// sum on wave spectrum // < 85: gravity waves  > 85: capillary waves\r\n\tfor (float w = Wmin; w < Wmax; w += (Wmax-Wmin)/Wsamples) \r\n\t{  \r\n\t    float k = solveP3(9.81, 0.074/1000.,-w*w);  // k(w)\r\n\t\tif (keyToggle(32)) d = 10.*length(uv+.03*(2.*vec2(hash(1./w),1.+hash(1./w))-1.));\r\n\t\tfloat phi =k*d-w*t ,\t\t\t\t\t\t// wave phase\r\n\t\t\t  phi0 = 6.283*hash(w);   \t\t\t\t// random phasing(w)\r\n\t\tfloat A = 2.*AMP(w) * pulse(-phi/w);\t\t// amplitude\r\n#if !COL\r\n\t\ty += A*sin(phi+phi0);\r\n\t\t// x += A*cos(phi+phi0);\r\n#else\r\n\t\tA *= 1.;\r\n\t\t// normal to the surface, and ray reflection in the cubemap.\r\n\t\tvec3 N = normalize(vec3( A*k*cos(phi+phi0)*dir,-(1.-A*k*sin(phi+phi0)))),\r\n\t\t\t V = reflect(ray,N);\r\n\t\tcol += texture(iChannel0, V.xzy );\r\n#endif\r\n\t}\r\n\t\r\n#if COL\r\n\tfragColor = vec4(col/Wsamples); \r\n#else\r\n\tfragColor = vec4(.5+y); fragColor.b += .1;\r\n#endif\r\n}","inputs":[],"outputs":[],"code":"#define Wmin 50.    // spectrum shape of exciter \r\n#define Wmax 200.\r\n#define Wsamples 150.\r\n#define AMP(w) (1./(w))\r\n\r\n#define COL 0\t\t// water reflects\r\n#define CAM 1\t\t// perspective camera\r\n#define PULSE 1     // time shape of exciter  1: square 2: smooth\r\n// SPACE to toggle spreaded source\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- rand\r\nfloat hash(float x) { return fract(sin(3234.*x)*6563.234); }\r\n\r\n// --- solve degree 3 equation\r\nfloat solveP3(float a, float c, float d) {\r\n\tc /= a; d /= a;\r\n\tfloat C = -d/2.*(1.+sqrt(1.+(c*c*c)/(d*d)*4./27.));  \r\n\tC = sign(C)*pow(abs(C),1./3.);\r\n    return C-c/(3.*C);\r\n}\r\n\r\n// --- Pierson-Moskowitz oceanographic spectrum   V = wind at 20m height\r\nfloat PM(float w,float V) { return 8.1E-3*9.81*9.81/pow(w,5.)*exp(-0.74*pow(9.81/(V*w),4.)); }\r\n\r\n// --- drop exciter\r\nfloat pulse(float t) {\r\n#if   PULSE==1\r\n\treturn (mod(t,1.)<.1) ? 1.: 0.;      // square signal\r\n#elif PULSE==2\r\n\treturn pow(.5+.5*cos(6.283*t),20.);  // smoothed signal\r\n#endif\r\n}\r\n\r\n// === main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat t = .3*iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\r\n\tvec2 m  =      2.*( iMouse.xy / iResolution.y - vec2(.9,.5));\r\n\tif (length(iMouse.zw)==0.) m = vec2(1e-5);\r\n\t\r\n#if CAM\r\n\t// set view conditions and get water plane position viewed in the pixel\r\n\tfloat b = 3.14*length(m), a = atan(m.y,m.x);\r\n\tvec3 eye = vec3(sin(b)*cos(a),sin(b)*sin(a),cos(b)); // vec3(2.*m,2.);\r\n\tmat3 M; \t\t\t\t\t// view matrix\r\n\tM[0] = normalize(-eye);\r\n\tM[2] = normalize(vec3(0.,0.,1.)-M[0].z*M[0]);\r\n\tM[1] = cross(M[0],M[2]);\r\n\tvec3 ray = normalize(M*vec3(1.,uv));\r\n\tif (abs(ray.z)>1e-3) {\r\n\t\tfloat l = -eye.z/ray.z; vec3 P = eye + l*ray; // point on water plane\r\n\t\tuv = P.xy;\r\n\t}\r\n#endif\r\n\t\r\n\tvec2 dir = normalize(uv);\r\n\tfloat d = 10.*length(uv);\r\n\tfloat x = 0., y = 0.; vec4 col = vec4(0.);\r\n\t\r\n\t// k = 2Pi/L , w = 2Pi/T\r\n\t// complete waves dispertion equation: w^2 = (gk + sigma/rho k^3) tanh(kh)\r\n\t// here, ignore tan(kh) ( = deep water case )\r\n\t\r\n\t// sum on wave spectrum // < 85: gravity waves  > 85: capillary waves\r\n\tfor (float w = Wmin; w < Wmax; w += (Wmax-Wmin)/Wsamples) \r\n\t{  \r\n\t    float k = solveP3(9.81, 0.074/1000.,-w*w);  // k(w)\r\n\t\tif (keyToggle(32)) d = 10.*length(uv+.03*(2.*vec2(hash(1./w),1.+hash(1./w))-1.));\r\n\t\tfloat phi =k*d-w*t ,\t\t\t\t\t\t// wave phase\r\n\t\t\t  phi0 = 6.283*hash(w);   \t\t\t\t// random phasing(w)\r\n\t\tfloat A = 2.*AMP(w) * pulse(-phi/w);\t\t// amplitude\r\n#if !COL\r\n\t\ty += A*sin(phi+phi0);\r\n\t\t// x += A*cos(phi+phi0);\r\n#else\r\n\t\tA *= 1.;\r\n\t\t// normal to the surface, and ray reflection in the cubemap.\r\n\t\tvec3 N = normalize(vec3( A*k*cos(phi+phi0)*dir,-(1.-A*k*sin(phi+phi0)))),\r\n\t\t\t V = reflect(ray,N);\r\n\t\tcol += texture(iChannel0, V.xzy );\r\n#endif\r\n\t}\r\n\t\r\n#if COL\r\n\tfragColor = vec4(col/Wsamples); \r\n#else\r\n\tfragColor = vec4(.5+y); fragColor.b += .1;\r\n#endif\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"\r\n//#define REFRACT\r\n\r\n// HG_SDF\r\n\r\n#define PI 3.14159265359\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pRi(vec2 p, float a) {\r\n    pR(p, a);\r\n    return p;\r\n}\r\n\r\n#define saturate(x) clamp(x, 0., 1.)\r\n\r\nfloat vmax(vec2 v) {\r\n    return max(v.x, v.y);\r\n}\r\n\r\nfloat vmax(vec3 v) {\r\n    return max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec3 v) {\r\n    return min(min(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec2 v) {\r\n    return min(v.x, v.y);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nfloat fCorner2(vec2 p) {\r\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\r\n}\r\n\r\nfloat fDisc(vec3 p, float r) {\r\n    float l = length(p.xz) - r;\r\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\r\n}\r\n\r\n\r\nfloat fHalfCapsule(vec3 p, float r) {\r\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\r\n}\r\n\r\n\r\n// IQ https://www.shadertoy.com/view/Xds3zN\r\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\r\n{\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    \r\n    float b = (r1-r2)/h;\r\n    float a = sqrt(1.0-b*b);\r\n    float k = dot(q,vec2(-b,a));\r\n    \r\n    if( k < 0.0 ) return length(q) - r1;\r\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\r\n        \r\n    return dot(q, vec2(a,b) ) - r1;\r\n}\r\n\r\nfloat smin2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\r\n    return max(r, min (a, b)) - length(u);\r\n}\r\n\r\nfloat smax2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\r\n    return min(-r, max (a, b)) + length(u);\r\n}\r\n\r\nfloat smin(float a, float b, float k){\r\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\r\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\r\n}\r\n\r\nfloat smax(float a, float b, float k) {\r\n    return -smin(-a, -b, k);\r\n}\r\n\r\nfloat smin3(float a, float b, float k){\r\n    return min(\r\n        smin(a, b, k),\r\n        smin2(a, b, k)\r\n    );\r\n}\r\n\r\nfloat smax3(float a, float b, float k){\r\n    return max(\r\n        smax(a, b, k),\r\n        smax2(a, b, k)\r\n    );\r\n}\r\n\r\n\r\n// Modelling\r\n\r\nfloat ellip(vec3 p, vec3 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ellip(vec2 p, vec2 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat helix(vec3 p, float lead, float thick) {\r\n    // p.z += iTime * .1;\r\n    float d = (mod(atan(p.y, p.x) - p.z * lead, PI * 2.) - PI) / lead;\r\n    d = abs(d) - thick;\r\n    return d;\r\n}\r\n\r\nvoid fMouth(inout float d, vec3 pp) {\r\n    vec3 p;\r\n    // mouth base\r\n    p = pp;\r\n    p += vec3(-.0,.29,-.29);\r\n    pR(p.yz, -.3);\r\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\r\n\r\n    p = pp;\r\n    p += vec3(0,.37,-.4);\r\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.09,.37,-.31);\r\n    d = smin(d, ellip(p, vec3(.04)), .18);\r\n\r\n    // bottom lip\r\n    p = pp;\r\n    p += vec3(0,.455,-.455);\r\n    p.z += smoothstep(.0, .2, p.x) * .05;\r\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\r\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\r\n    float w = .192;\r\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\r\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\r\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\r\n    d = smin(d, bottomlip, lb);\r\n    \r\n    // top lip\r\n    p = pp;\r\n    p += vec3(0,.38,-.45);\r\n    pR(p.xz, -.3);\r\n    ls = vec3(.065,.03,.05);\r\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\r\n    vec3 pl = p * vec3(.78,1,1);\r\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\r\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\r\n    p = pp;\r\n    p += vec3(0,.33,-.45);\r\n    pR(p.yz, .7);\r\n    float cut;\r\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\r\n    float dip = smin(\r\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\r\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\r\n        .025\r\n    );\r\n    cut = smax(cut, dip, .04);\r\n    cut = smax(cut, p.x - .1, .05);\r\n    toplip = smax(toplip, cut, .02);\r\n\r\n    d = smin(d, toplip, .07);\r\n\r\n\r\n    // seam\r\n    p = pp;\r\n    p += vec3(0,.425,-.44);\r\n    lb = length(p);\r\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\r\n    pR(p.yz, .1);\r\n    p.y -= smoothstep(0., .03, p.x) * .002;\r\n    p.y += smoothstep(.03, .1, p.x) * .007;\r\n    p.z -= .133;\r\n    float seam = fDisc(p, .2);\r\n    seam = smax(seam, -d - .015, .01); // fix inside shape\r\n    d = mix(d, smax(d, -seam, lr), .65);\r\n\r\n}\r\n\r\nbool isMap = true;\r\nbool isEye = false;\r\n\r\nfloat mHead(vec3 p) {\r\n\r\n    p.y -= .13;\r\n\r\n    vec3 pa = p;\r\n    p.x = abs(p.x);\r\n    vec3 pp = p;\r\n\r\n    float d = 1e12;\r\n\r\n    // skull back\r\n    p += vec3(0,-.135,.09);\r\n    d = ellip(p, vec3(.395, .385, .395));\r\n\r\n    // skull base\r\n    p = pp;\r\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\r\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\r\n\r\n    // forehead\r\n    p = pp;\r\n    p += vec3(0,-.145,-.175);\r\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\r\n\r\n    p = pp;\r\n    pR(p.yz, -.5);\r\n    float bb = fBox(p, vec3(.5,.67,.7));\r\n    d = smax(d, bb, .2);\r\n\r\n    // face base\r\n    p = pp;\r\n    p += vec3(0,.25,-.13);\r\n    d = smin(d, length(p) - .28, .1);\r\n\r\n    // behind ear\r\n    p = pp;\r\n    p += vec3(-.15,.13,.06);\r\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\r\n\r\n    p = pp;\r\n    p += vec3(-.07,.18,.1);\r\n    d = smin(d, length(p) - .2, .18);\r\n\r\n    // cheek base\r\n    p = pp;\r\n    p += vec3(-.2,.12,-.14);\r\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\r\n\r\n    // jaw base\r\n    p = pp;\r\n    p += vec3(0,.475,-.16);\r\n    pR(p.yz, .8);\r\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\r\n\r\n    // brow\r\n    p = pp;\r\n    p += vec3(0,-.0,-.18);\r\n    vec3 bp = p;\r\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\r\n    brow = length(p) - .36;\r\n    p.x -= .37;\r\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\r\n    p = bp;\r\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\r\n    p = bp;\r\n    pR(p.yz, -.5);\r\n    float peak = -p.y - .165;\r\n    peak += smoothstep(.0, .2, p.x) * .01;\r\n    peak -= smoothstep(.12, .29, p.x) * .025;\r\n    brow = smax(brow, peak, .07);\r\n    p = bp;\r\n    pR(p.yz, .5);\r\n    brow = smax(brow, -p.y - .06, .15);\r\n    d = smin(d, brow, .06);\r\n\r\n    // nose\r\n    p = pp;\r\n    p += vec3(0,.03,-.45);\r\n    pR(p.yz, 3.);\r\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\r\n\r\n    p = pp;\r\n    p += vec3(0,.06,-.47);\r\n    pR(p.yz, 2.77);\r\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\r\n\r\n    // jaw\r\n\r\n    p = pp;\r\n    vec3 jo = vec3(-.25,.4,-.07);\r\n    p = pp + jo;\r\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\r\n\r\n    p = pp;\r\n    p += vec3(0,.63,-.2);\r\n    pR(p.yz, .15);\r\n    float cr = .5;\r\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\r\n\r\n    p = pp + jo;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\r\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\r\n\r\n    p = pa;\r\n    p += vec3(.2,.5,-.1);\r\n    float jb = length(p);\r\n    jb = smoothstep(.0, .4, jb);\r\n    float js = mix(0., -.005, jb);\r\n    jb = mix(.01, .04, jb);\r\n\r\n    d = smin(d, jaw - js, jb);\r\n\r\n    // chin\r\n    p = pp;\r\n    p += vec3(0,.585,-.395);\r\n    p.x *= .7;\r\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\r\n\r\n    // return d;\r\n\r\n    // cheek\r\n\r\n    p = pp;\r\n    p += vec3(-.2,.2,-.28);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, .4);\r\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.26,.02,-.1);\r\n    pR(p.xz, .13);\r\n    pR(p.yz, .5);\r\n    float temple = ellip(p, vec3(.1,.1,.15));\r\n    temple = smax(temple, p.x - .07, .1);\r\n    d = smin(d, temple, .1);\r\n\r\n    p = pp;\r\n    p += vec3(.0,.2,-.32);\r\n    ch = ellip(p, vec3(.1,.08,.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.17,.31,-.17);\r\n    ch = ellip(p, vec3(.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    fMouth(d, pp);\r\n\r\n    // nostrils base\r\n    p = pp;\r\n    p += vec3(0,.3,-.43);\r\n    d = smin(d, length(p) - .05, .07);\r\n\r\n    // nostrils\r\n    p = pp;\r\n    p += vec3(0,.27,-.52);\r\n    pR(p.yz, .2);\r\n    float nostrils = ellip(p, vec3(.055,.05,.06));\r\n\r\n    p = pp;\r\n    p += vec3(-.043,.28,-.48);\r\n    pR(p.xy, .15);\r\n    p.z *= .8;\r\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\r\n\r\n    d = smin(d, nostrils, .02);\r\n\r\n    p = pp;\r\n    p += vec3(-.033,.3,-.515);\r\n    pR(p.xz, .5);\r\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\r\n\r\n    // return d;\r\n\r\n    // eyelids\r\n    p = pp;\r\n    p += vec3(-.16,.07,-.34);\r\n    float eyelids = ellip(p, vec3(.08,.1,.1));\r\n\r\n    p = pp;\r\n    p += vec3(-.16,.09,-.35);\r\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\r\n\r\n    // edge top\r\n    p = pp;\r\n    p += vec3(-.173,.148,-.43);\r\n    p.x *= .97;\r\n    float et = length(p.xy) - .09;\r\n\r\n    // edge bottom\r\n    p = pp;\r\n    p += vec3(-.168,.105,-.43);\r\n    p.x *= .9;\r\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\r\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\r\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\r\n\r\n    float edge = max(max(eb, et), -d);\r\n\r\n    d = smin(d, eyelids, .01);\r\n    d = smin(d, eyelids2, .03);\r\n    d = smax(d, -edge, .005);\r\n\r\n    // eyeball\r\n    p = pp;\r\n    p += vec3(-.165,.0715,-.346);\r\n    float eyeball = length(p) - .088;\r\n    if (isMap) isEye = eyeball < d;\r\n    d = min(d, eyeball);\r\n\r\n    // tear duct\r\n    p = pp;\r\n    p += vec3(-.075,.1,-.37);\r\n    d = min(d, length(p) - .05);\r\n\r\n    return d;\r\n}\r\n\r\nfloat mBg(vec3 p) {\r\n    pR(p.xy, 1420./10.);\r\n    // return length(p) - .1;\r\n\r\n    p.xy -= vec2(23.22, 90.67);\r\n    // p.xy -= vec2(1.);\r\n    p.z += 17.;\r\n    float r = 5.5;\r\n    float rz = 5.;\r\n    float a = floor(p.z / rz);\r\n    pR(p.xy, a * 3.4);\r\n    pR(p.xy, -.002);\r\n    p.xy = mod(p.xy, r) - r / 2.;\r\n    // if (p.z > -1.2) {\r\n        p.z = mod(p.z, rz) - rz / 2.;\r\n    // }\r\n    float d = length(p)- r / 5.;\r\n    return d;\r\n}\r\n\r\nfloat mce(vec3 p) {\r\n    float h = mHead(p);\r\n    // h = length(p) - .5;\r\n    // return h;\r\n    p.y -= .45;\r\n    float s = helix(p.xzy, 35., .06);\r\n    h = abs(h + .01) - .01;\r\n    h = smax(h, s, .005);\r\n    return h;    \r\n}\r\n\r\nfloat inside = 1.;\r\n\r\nvec2 map(vec3 p) {\r\n    float d = mBg(p) * inside;\r\n    float e = p.z + 25.;\r\n    p.z += 17.;\r\n    p.y -= .4;\r\n    float hs = 10.;\r\n    float h = mce(p / hs) * hs;\r\n    vec2 m = vec2(e, 1.);    \r\n    if (h < m.x) {\r\n        m = vec2(h, 2.);\r\n    }\r\n    #ifndef REFRACT\r\n    \tif (inside == -1.) return m;\r\n    #endif\r\n    if (d < m.x) {\r\n        m = vec2(d, 0.);\r\n    }\r\n    return m;\r\n}\r\n\r\nconst int NORMAL_STEPS = 6;\r\nvec3 calcNormal(vec3 pos){\r\n    isMap = false;\r\n    vec3 eps = vec3(.001,0,0);\r\n    vec3 nor = vec3(0);\r\n    float invert = 1.;\r\n    for (int i = 0; i < NORMAL_STEPS; i++){\r\n        nor += map(pos + eps * invert).x * eps * invert;\r\n        eps = eps.zxy;\r\n        invert *= -1.;\r\n    }\r\n    isMap = true;\r\n    return normalize(nor);\r\n}\r\n\r\n// IQ's cos palette\r\n\r\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\r\n    return a + b*cos( 6.28318*(c*t+d) );\r\n}\r\n\r\nvec3 spectrum(float n) {\r\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\r\n}\r\n\r\nvec3 march(vec2 fc) {\r\n    vec2 p = (-iResolution.xy + 2. * fc.xy) / iResolution.y;\r\n    inside = 1.;\r\n    vec3 camPos = vec3(0,0,2.5);\r\n    vec3 rayDirection = normalize(vec3(p,-4));\r\n    vec3 rayPosition = camPos;\r\n    float distance = 0.;\r\n    vec3 c = vec3(0);\r\n    vec3 n;\r\n    bool rf = false;\r\n    vec2 m;\r\n    float ss;\r\n\r\n    for (int i = 0; i < 300; i++) {\r\n\r\n        rayPosition += rayDirection * distance * .8;\r\n        m = map(rayPosition);\r\n        distance = m.x;\r\n\r\n        if (abs(distance) < .005) {\r\n            if (m.y == 0.) {\r\n                n = calcNormal(rayPosition);\r\n                rayDirection = refract(rayDirection, n, 1. / 2.222);\r\n                rayPosition -= n * .001;\r\n                inside *= -1.;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (m.y == 1.) {\r\n        ss = rayPosition.y / 20. + .5;\r\n        ss = saturate(ss);\r\n        c = spectrum(ss/ 2.);\r\n    }\r\n    if (m.y == 2.) {\r\n        n = calcNormal(rayPosition);\r\n        c = n * .5 + .5;\r\n        ss = dot(n, .5*vec3(.5,1,1));\r\n        ss = saturate(ss);\r\n        c = spectrum(ss / 2. - .8);\r\n        c *= mix(1., saturate(ss), .8);\r\n    }\r\n\r\n    c = pow(c, vec3(1./2.2));\r\n    return c;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n    vec4 lastFrame = texture(iChannel0, uv);\r\n    \r\n    if (lastFrame.a != 0. && iFrame > 2) {\r\n        fragColor = lastFrame;\r\n        return;\r\n    }\r\n    \r\n    vec3 c = vec3(0);\r\n    vec2 o = vec2(1./3.,0);    \r\n    for (float i = 0.; i < 4.; i++) {\r\n        if (i == 2.) o *= -1.;\r\n        o = o.yx;\r\n        c += march(gl_FragCoord.xy + o);\r\n    }\r\n    c /= 4.;\r\n    fragColor = vec4(c, 1);\r\n}\r\n","inputs":[],"outputs":[],"code":"\r\n//#define REFRACT\r\n\r\n// HG_SDF\r\n\r\n#define PI 3.14159265359\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pRi(vec2 p, float a) {\r\n    pR(p, a);\r\n    return p;\r\n}\r\n\r\n#define saturate(x) clamp(x, 0., 1.)\r\n\r\nfloat vmax(vec2 v) {\r\n    return max(v.x, v.y);\r\n}\r\n\r\nfloat vmax(vec3 v) {\r\n    return max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec3 v) {\r\n    return min(min(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec2 v) {\r\n    return min(v.x, v.y);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nfloat fCorner2(vec2 p) {\r\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\r\n}\r\n\r\nfloat fDisc(vec3 p, float r) {\r\n    float l = length(p.xz) - r;\r\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\r\n}\r\n\r\n\r\nfloat fHalfCapsule(vec3 p, float r) {\r\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\r\n}\r\n\r\n\r\n// IQ https://www.shadertoy.com/view/Xds3zN\r\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\r\n{\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    \r\n    float b = (r1-r2)/h;\r\n    float a = sqrt(1.0-b*b);\r\n    float k = dot(q,vec2(-b,a));\r\n    \r\n    if( k < 0.0 ) return length(q) - r1;\r\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\r\n        \r\n    return dot(q, vec2(a,b) ) - r1;\r\n}\r\n\r\nfloat smin2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\r\n    return max(r, min (a, b)) - length(u);\r\n}\r\n\r\nfloat smax2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\r\n    return min(-r, max (a, b)) + length(u);\r\n}\r\n\r\nfloat smin(float a, float b, float k){\r\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\r\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\r\n}\r\n\r\nfloat smax(float a, float b, float k) {\r\n    return -smin(-a, -b, k);\r\n}\r\n\r\nfloat smin3(float a, float b, float k){\r\n    return min(\r\n        smin(a, b, k),\r\n        smin2(a, b, k)\r\n    );\r\n}\r\n\r\nfloat smax3(float a, float b, float k){\r\n    return max(\r\n        smax(a, b, k),\r\n        smax2(a, b, k)\r\n    );\r\n}\r\n\r\n\r\n// Modelling\r\n\r\nfloat ellip(vec3 p, vec3 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ellip(vec2 p, vec2 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat helix(vec3 p, float lead, float thick) {\r\n    // p.z += iTime * .1;\r\n    float d = (mod(atan(p.y, p.x) - p.z * lead, PI * 2.) - PI) / lead;\r\n    d = abs(d) - thick;\r\n    return d;\r\n}\r\n\r\nvoid fMouth(inout float d, vec3 pp) {\r\n    vec3 p;\r\n    // mouth base\r\n    p = pp;\r\n    p += vec3(-.0,.29,-.29);\r\n    pR(p.yz, -.3);\r\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\r\n\r\n    p = pp;\r\n    p += vec3(0,.37,-.4);\r\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.09,.37,-.31);\r\n    d = smin(d, ellip(p, vec3(.04)), .18);\r\n\r\n    // bottom lip\r\n    p = pp;\r\n    p += vec3(0,.455,-.455);\r\n    p.z += smoothstep(.0, .2, p.x) * .05;\r\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\r\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\r\n    float w = .192;\r\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\r\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\r\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\r\n    d = smin(d, bottomlip, lb);\r\n    \r\n    // top lip\r\n    p = pp;\r\n    p += vec3(0,.38,-.45);\r\n    pR(p.xz, -.3);\r\n    ls = vec3(.065,.03,.05);\r\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\r\n    vec3 pl = p * vec3(.78,1,1);\r\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\r\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\r\n    p = pp;\r\n    p += vec3(0,.33,-.45);\r\n    pR(p.yz, .7);\r\n    float cut;\r\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\r\n    float dip = smin(\r\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\r\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\r\n        .025\r\n    );\r\n    cut = smax(cut, dip, .04);\r\n    cut = smax(cut, p.x - .1, .05);\r\n    toplip = smax(toplip, cut, .02);\r\n\r\n    d = smin(d, toplip, .07);\r\n\r\n\r\n    // seam\r\n    p = pp;\r\n    p += vec3(0,.425,-.44);\r\n    lb = length(p);\r\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\r\n    pR(p.yz, .1);\r\n    p.y -= smoothstep(0., .03, p.x) * .002;\r\n    p.y += smoothstep(.03, .1, p.x) * .007;\r\n    p.z -= .133;\r\n    float seam = fDisc(p, .2);\r\n    seam = smax(seam, -d - .015, .01); // fix inside shape\r\n    d = mix(d, smax(d, -seam, lr), .65);\r\n\r\n}\r\n\r\nbool isMap = true;\r\nbool isEye = false;\r\n\r\nfloat mHead(vec3 p) {\r\n\r\n    p.y -= .13;\r\n\r\n    vec3 pa = p;\r\n    p.x = abs(p.x);\r\n    vec3 pp = p;\r\n\r\n    float d = 1e12;\r\n\r\n    // skull back\r\n    p += vec3(0,-.135,.09);\r\n    d = ellip(p, vec3(.395, .385, .395));\r\n\r\n    // skull base\r\n    p = pp;\r\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\r\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\r\n\r\n    // forehead\r\n    p = pp;\r\n    p += vec3(0,-.145,-.175);\r\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\r\n\r\n    p = pp;\r\n    pR(p.yz, -.5);\r\n    float bb = fBox(p, vec3(.5,.67,.7));\r\n    d = smax(d, bb, .2);\r\n\r\n    // face base\r\n    p = pp;\r\n    p += vec3(0,.25,-.13);\r\n    d = smin(d, length(p) - .28, .1);\r\n\r\n    // behind ear\r\n    p = pp;\r\n    p += vec3(-.15,.13,.06);\r\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\r\n\r\n    p = pp;\r\n    p += vec3(-.07,.18,.1);\r\n    d = smin(d, length(p) - .2, .18);\r\n\r\n    // cheek base\r\n    p = pp;\r\n    p += vec3(-.2,.12,-.14);\r\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\r\n\r\n    // jaw base\r\n    p = pp;\r\n    p += vec3(0,.475,-.16);\r\n    pR(p.yz, .8);\r\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\r\n\r\n    // brow\r\n    p = pp;\r\n    p += vec3(0,-.0,-.18);\r\n    vec3 bp = p;\r\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\r\n    brow = length(p) - .36;\r\n    p.x -= .37;\r\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\r\n    p = bp;\r\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\r\n    p = bp;\r\n    pR(p.yz, -.5);\r\n    float peak = -p.y - .165;\r\n    peak += smoothstep(.0, .2, p.x) * .01;\r\n    peak -= smoothstep(.12, .29, p.x) * .025;\r\n    brow = smax(brow, peak, .07);\r\n    p = bp;\r\n    pR(p.yz, .5);\r\n    brow = smax(brow, -p.y - .06, .15);\r\n    d = smin(d, brow, .06);\r\n\r\n    // nose\r\n    p = pp;\r\n    p += vec3(0,.03,-.45);\r\n    pR(p.yz, 3.);\r\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\r\n\r\n    p = pp;\r\n    p += vec3(0,.06,-.47);\r\n    pR(p.yz, 2.77);\r\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\r\n\r\n    // jaw\r\n\r\n    p = pp;\r\n    vec3 jo = vec3(-.25,.4,-.07);\r\n    p = pp + jo;\r\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\r\n\r\n    p = pp;\r\n    p += vec3(0,.63,-.2);\r\n    pR(p.yz, .15);\r\n    float cr = .5;\r\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\r\n\r\n    p = pp + jo;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\r\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\r\n\r\n    p = pa;\r\n    p += vec3(.2,.5,-.1);\r\n    float jb = length(p);\r\n    jb = smoothstep(.0, .4, jb);\r\n    float js = mix(0., -.005, jb);\r\n    jb = mix(.01, .04, jb);\r\n\r\n    d = smin(d, jaw - js, jb);\r\n\r\n    // chin\r\n    p = pp;\r\n    p += vec3(0,.585,-.395);\r\n    p.x *= .7;\r\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\r\n\r\n    // return d;\r\n\r\n    // cheek\r\n\r\n    p = pp;\r\n    p += vec3(-.2,.2,-.28);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, .4);\r\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.26,.02,-.1);\r\n    pR(p.xz, .13);\r\n    pR(p.yz, .5);\r\n    float temple = ellip(p, vec3(.1,.1,.15));\r\n    temple = smax(temple, p.x - .07, .1);\r\n    d = smin(d, temple, .1);\r\n\r\n    p = pp;\r\n    p += vec3(.0,.2,-.32);\r\n    ch = ellip(p, vec3(.1,.08,.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.17,.31,-.17);\r\n    ch = ellip(p, vec3(.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    fMouth(d, pp);\r\n\r\n    // nostrils base\r\n    p = pp;\r\n    p += vec3(0,.3,-.43);\r\n    d = smin(d, length(p) - .05, .07);\r\n\r\n    // nostrils\r\n    p = pp;\r\n    p += vec3(0,.27,-.52);\r\n    pR(p.yz, .2);\r\n    float nostrils = ellip(p, vec3(.055,.05,.06));\r\n\r\n    p = pp;\r\n    p += vec3(-.043,.28,-.48);\r\n    pR(p.xy, .15);\r\n    p.z *= .8;\r\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\r\n\r\n    d = smin(d, nostrils, .02);\r\n\r\n    p = pp;\r\n    p += vec3(-.033,.3,-.515);\r\n    pR(p.xz, .5);\r\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\r\n\r\n    // return d;\r\n\r\n    // eyelids\r\n    p = pp;\r\n    p += vec3(-.16,.07,-.34);\r\n    float eyelids = ellip(p, vec3(.08,.1,.1));\r\n\r\n    p = pp;\r\n    p += vec3(-.16,.09,-.35);\r\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\r\n\r\n    // edge top\r\n    p = pp;\r\n    p += vec3(-.173,.148,-.43);\r\n    p.x *= .97;\r\n    float et = length(p.xy) - .09;\r\n\r\n    // edge bottom\r\n    p = pp;\r\n    p += vec3(-.168,.105,-.43);\r\n    p.x *= .9;\r\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\r\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\r\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\r\n\r\n    float edge = max(max(eb, et), -d);\r\n\r\n    d = smin(d, eyelids, .01);\r\n    d = smin(d, eyelids2, .03);\r\n    d = smax(d, -edge, .005);\r\n\r\n    // eyeball\r\n    p = pp;\r\n    p += vec3(-.165,.0715,-.346);\r\n    float eyeball = length(p) - .088;\r\n    if (isMap) isEye = eyeball < d;\r\n    d = min(d, eyeball);\r\n\r\n    // tear duct\r\n    p = pp;\r\n    p += vec3(-.075,.1,-.37);\r\n    d = min(d, length(p) - .05);\r\n\r\n    return d;\r\n}\r\n\r\nfloat mBg(vec3 p) {\r\n    pR(p.xy, 1420./10.);\r\n    // return length(p) - .1;\r\n\r\n    p.xy -= vec2(23.22, 90.67);\r\n    // p.xy -= vec2(1.);\r\n    p.z += 17.;\r\n    float r = 5.5;\r\n    float rz = 5.;\r\n    float a = floor(p.z / rz);\r\n    pR(p.xy, a * 3.4);\r\n    pR(p.xy, -.002);\r\n    p.xy = mod(p.xy, r) - r / 2.;\r\n    // if (p.z > -1.2) {\r\n        p.z = mod(p.z, rz) - rz / 2.;\r\n    // }\r\n    float d = length(p)- r / 5.;\r\n    return d;\r\n}\r\n\r\nfloat mce(vec3 p) {\r\n    float h = mHead(p);\r\n    // h = length(p) - .5;\r\n    // return h;\r\n    p.y -= .45;\r\n    float s = helix(p.xzy, 35., .06);\r\n    h = abs(h + .01) - .01;\r\n    h = smax(h, s, .005);\r\n    return h;    \r\n}\r\n\r\nfloat inside = 1.;\r\n\r\nvec2 map(vec3 p) {\r\n    float d = mBg(p) * inside;\r\n    float e = p.z + 25.;\r\n    p.z += 17.;\r\n    p.y -= .4;\r\n    float hs = 10.;\r\n    float h = mce(p / hs) * hs;\r\n    vec2 m = vec2(e, 1.);    \r\n    if (h < m.x) {\r\n        m = vec2(h, 2.);\r\n    }\r\n    #ifndef REFRACT\r\n    \tif (inside == -1.) return m;\r\n    #endif\r\n    if (d < m.x) {\r\n        m = vec2(d, 0.);\r\n    }\r\n    return m;\r\n}\r\n\r\nconst int NORMAL_STEPS = 6;\r\nvec3 calcNormal(vec3 pos){\r\n    isMap = false;\r\n    vec3 eps = vec3(.001,0,0);\r\n    vec3 nor = vec3(0);\r\n    float invert = 1.;\r\n    for (int i = 0; i < NORMAL_STEPS; i++){\r\n        nor += map(pos + eps * invert).x * eps * invert;\r\n        eps = eps.zxy;\r\n        invert *= -1.;\r\n    }\r\n    isMap = true;\r\n    return normalize(nor);\r\n}\r\n\r\n// IQ's cos palette\r\n\r\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\r\n    return a + b*cos( 6.28318*(c*t+d) );\r\n}\r\n\r\nvec3 spectrum(float n) {\r\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\r\n}\r\n\r\nvec3 march(vec2 fc) {\r\n    vec2 p = (-iResolution.xy + 2. * fc.xy) / iResolution.y;\r\n    inside = 1.;\r\n    vec3 camPos = vec3(0,0,2.5);\r\n    vec3 rayDirection = normalize(vec3(p,-4));\r\n    vec3 rayPosition = camPos;\r\n    float distance = 0.;\r\n    vec3 c = vec3(0);\r\n    vec3 n;\r\n    bool rf = false;\r\n    vec2 m;\r\n    float ss;\r\n\r\n    for (int i = 0; i < 300; i++) {\r\n\r\n        rayPosition += rayDirection * distance * .8;\r\n        m = map(rayPosition);\r\n        distance = m.x;\r\n\r\n        if (abs(distance) < .005) {\r\n            if (m.y == 0.) {\r\n                n = calcNormal(rayPosition);\r\n                rayDirection = refract(rayDirection, n, 1. / 2.222);\r\n                rayPosition -= n * .001;\r\n                inside *= -1.;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (m.y == 1.) {\r\n        ss = rayPosition.y / 20. + .5;\r\n        ss = saturate(ss);\r\n        c = spectrum(ss/ 2.);\r\n    }\r\n    if (m.y == 2.) {\r\n        n = calcNormal(rayPosition);\r\n        c = n * .5 + .5;\r\n        ss = dot(n, .5*vec3(.5,1,1));\r\n        ss = saturate(ss);\r\n        c = spectrum(ss / 2. - .8);\r\n        c *= mix(1., saturate(ss), .8);\r\n    }\r\n\r\n    c = pow(c, vec3(1./2.2));\r\n    return c;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n    vec4 lastFrame = texture(iChannel0, uv);\r\n    \r\n    if (lastFrame.a != 0. && iFrame > 2) {\r\n        fragColor = lastFrame;\r\n        return;\r\n    }\r\n    \r\n    vec3 c = vec3(0);\r\n    vec2 o = vec2(1./3.,0);    \r\n    for (float i = 0.; i < 4.; i++) {\r\n        if (i == 2.) o *= -1.;\r\n        o = o.yx;\r\n        c += march(gl_FragCoord.xy + o);\r\n    }\r\n    c /= 4.;\r\n    fragColor = vec4(c, 1);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"\u1D07 s \u1D04 \u029C \u1D07 \u0280 \u1D21 \u1D00 \u1D20 \u1D07 ","id":"e5dc786dc6424b32bcef05d3d00329cf","date":null,"viewed":0,"name":"\u1D07 s \u1D04 \u029C \u1D07 \u0280 \u1D21 \u1D00 \u1D20 \u1D07 ","description":"4k exe graphics entry for Revision 2019.\nI was really struggling with modelling this until I had a look at Ink Drawing by lnae. I also cheated a bit by 'tracing' a polygon model from Daz 3D.\nhttps://www.shadertoy.com/view/wtf3RM","likes":0,"published":null,"tags":["escher"," helix"," vaporwave"]},"ver":null,"info":{"Name":"\u1D07 s \u1D04 \u029C \u1D07 \u0280 \u1D21 \u1D00 \u1D20 \u1D07 ","id":"e5dc786dc6424b32bcef05d3d00329cf","date":null,"viewed":0,"name":"\u1D07 s \u1D04 \u029C \u1D07 \u0280 \u1D21 \u1D00 \u1D20 \u1D07 ","description":"4k exe graphics entry for Revision 2019.\nI was really struggling with modelling this until I had a look at Ink Drawing by lnae. I also cheated a bit by 'tracing' a polygon model from Daz 3D.\nhttps://www.shadertoy.com/view/wtf3RM","likes":0,"published":null,"tags":["escher"," helix"," vaporwave"]},"renderpass":[{"Code":"\r\n//#define REFRACT\r\n\r\n// HG_SDF\r\n\r\n#define PI 3.14159265359\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pRi(vec2 p, float a) {\r\n    pR(p, a);\r\n    return p;\r\n}\r\n\r\n#define saturate(x) clamp(x, 0., 1.)\r\n\r\nfloat vmax(vec2 v) {\r\n    return max(v.x, v.y);\r\n}\r\n\r\nfloat vmax(vec3 v) {\r\n    return max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec3 v) {\r\n    return min(min(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec2 v) {\r\n    return min(v.x, v.y);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nfloat fCorner2(vec2 p) {\r\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\r\n}\r\n\r\nfloat fDisc(vec3 p, float r) {\r\n    float l = length(p.xz) - r;\r\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\r\n}\r\n\r\n\r\nfloat fHalfCapsule(vec3 p, float r) {\r\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\r\n}\r\n\r\n\r\n// IQ https://www.shadertoy.com/view/Xds3zN\r\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\r\n{\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    \r\n    float b = (r1-r2)/h;\r\n    float a = sqrt(1.0-b*b);\r\n    float k = dot(q,vec2(-b,a));\r\n    \r\n    if( k < 0.0 ) return length(q) - r1;\r\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\r\n        \r\n    return dot(q, vec2(a,b) ) - r1;\r\n}\r\n\r\nfloat smin2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\r\n    return max(r, min (a, b)) - length(u);\r\n}\r\n\r\nfloat smax2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\r\n    return min(-r, max (a, b)) + length(u);\r\n}\r\n\r\nfloat smin(float a, float b, float k){\r\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\r\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\r\n}\r\n\r\nfloat smax(float a, float b, float k) {\r\n    return -smin(-a, -b, k);\r\n}\r\n\r\nfloat smin3(float a, float b, float k){\r\n    return min(\r\n        smin(a, b, k),\r\n        smin2(a, b, k)\r\n    );\r\n}\r\n\r\nfloat smax3(float a, float b, float k){\r\n    return max(\r\n        smax(a, b, k),\r\n        smax2(a, b, k)\r\n    );\r\n}\r\n\r\n\r\n// Modelling\r\n\r\nfloat ellip(vec3 p, vec3 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ellip(vec2 p, vec2 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat helix(vec3 p, float lead, float thick) {\r\n    // p.z += iTime * .1;\r\n    float d = (mod(atan(p.y, p.x) - p.z * lead, PI * 2.) - PI) / lead;\r\n    d = abs(d) - thick;\r\n    return d;\r\n}\r\n\r\nvoid fMouth(inout float d, vec3 pp) {\r\n    vec3 p;\r\n    // mouth base\r\n    p = pp;\r\n    p += vec3(-.0,.29,-.29);\r\n    pR(p.yz, -.3);\r\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\r\n\r\n    p = pp;\r\n    p += vec3(0,.37,-.4);\r\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.09,.37,-.31);\r\n    d = smin(d, ellip(p, vec3(.04)), .18);\r\n\r\n    // bottom lip\r\n    p = pp;\r\n    p += vec3(0,.455,-.455);\r\n    p.z += smoothstep(.0, .2, p.x) * .05;\r\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\r\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\r\n    float w = .192;\r\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\r\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\r\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\r\n    d = smin(d, bottomlip, lb);\r\n    \r\n    // top lip\r\n    p = pp;\r\n    p += vec3(0,.38,-.45);\r\n    pR(p.xz, -.3);\r\n    ls = vec3(.065,.03,.05);\r\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\r\n    vec3 pl = p * vec3(.78,1,1);\r\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\r\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\r\n    p = pp;\r\n    p += vec3(0,.33,-.45);\r\n    pR(p.yz, .7);\r\n    float cut;\r\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\r\n    float dip = smin(\r\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\r\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\r\n        .025\r\n    );\r\n    cut = smax(cut, dip, .04);\r\n    cut = smax(cut, p.x - .1, .05);\r\n    toplip = smax(toplip, cut, .02);\r\n\r\n    d = smin(d, toplip, .07);\r\n\r\n\r\n    // seam\r\n    p = pp;\r\n    p += vec3(0,.425,-.44);\r\n    lb = length(p);\r\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\r\n    pR(p.yz, .1);\r\n    p.y -= smoothstep(0., .03, p.x) * .002;\r\n    p.y += smoothstep(.03, .1, p.x) * .007;\r\n    p.z -= .133;\r\n    float seam = fDisc(p, .2);\r\n    seam = smax(seam, -d - .015, .01); // fix inside shape\r\n    d = mix(d, smax(d, -seam, lr), .65);\r\n\r\n}\r\n\r\nbool isMap = true;\r\nbool isEye = false;\r\n\r\nfloat mHead(vec3 p) {\r\n\r\n    p.y -= .13;\r\n\r\n    vec3 pa = p;\r\n    p.x = abs(p.x);\r\n    vec3 pp = p;\r\n\r\n    float d = 1e12;\r\n\r\n    // skull back\r\n    p += vec3(0,-.135,.09);\r\n    d = ellip(p, vec3(.395, .385, .395));\r\n\r\n    // skull base\r\n    p = pp;\r\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\r\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\r\n\r\n    // forehead\r\n    p = pp;\r\n    p += vec3(0,-.145,-.175);\r\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\r\n\r\n    p = pp;\r\n    pR(p.yz, -.5);\r\n    float bb = fBox(p, vec3(.5,.67,.7));\r\n    d = smax(d, bb, .2);\r\n\r\n    // face base\r\n    p = pp;\r\n    p += vec3(0,.25,-.13);\r\n    d = smin(d, length(p) - .28, .1);\r\n\r\n    // behind ear\r\n    p = pp;\r\n    p += vec3(-.15,.13,.06);\r\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\r\n\r\n    p = pp;\r\n    p += vec3(-.07,.18,.1);\r\n    d = smin(d, length(p) - .2, .18);\r\n\r\n    // cheek base\r\n    p = pp;\r\n    p += vec3(-.2,.12,-.14);\r\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\r\n\r\n    // jaw base\r\n    p = pp;\r\n    p += vec3(0,.475,-.16);\r\n    pR(p.yz, .8);\r\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\r\n\r\n    // brow\r\n    p = pp;\r\n    p += vec3(0,-.0,-.18);\r\n    vec3 bp = p;\r\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\r\n    brow = length(p) - .36;\r\n    p.x -= .37;\r\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\r\n    p = bp;\r\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\r\n    p = bp;\r\n    pR(p.yz, -.5);\r\n    float peak = -p.y - .165;\r\n    peak += smoothstep(.0, .2, p.x) * .01;\r\n    peak -= smoothstep(.12, .29, p.x) * .025;\r\n    brow = smax(brow, peak, .07);\r\n    p = bp;\r\n    pR(p.yz, .5);\r\n    brow = smax(brow, -p.y - .06, .15);\r\n    d = smin(d, brow, .06);\r\n\r\n    // nose\r\n    p = pp;\r\n    p += vec3(0,.03,-.45);\r\n    pR(p.yz, 3.);\r\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\r\n\r\n    p = pp;\r\n    p += vec3(0,.06,-.47);\r\n    pR(p.yz, 2.77);\r\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\r\n\r\n    // jaw\r\n\r\n    p = pp;\r\n    vec3 jo = vec3(-.25,.4,-.07);\r\n    p = pp + jo;\r\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\r\n\r\n    p = pp;\r\n    p += vec3(0,.63,-.2);\r\n    pR(p.yz, .15);\r\n    float cr = .5;\r\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\r\n\r\n    p = pp + jo;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\r\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\r\n\r\n    p = pa;\r\n    p += vec3(.2,.5,-.1);\r\n    float jb = length(p);\r\n    jb = smoothstep(.0, .4, jb);\r\n    float js = mix(0., -.005, jb);\r\n    jb = mix(.01, .04, jb);\r\n\r\n    d = smin(d, jaw - js, jb);\r\n\r\n    // chin\r\n    p = pp;\r\n    p += vec3(0,.585,-.395);\r\n    p.x *= .7;\r\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\r\n\r\n    // return d;\r\n\r\n    // cheek\r\n\r\n    p = pp;\r\n    p += vec3(-.2,.2,-.28);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, .4);\r\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.26,.02,-.1);\r\n    pR(p.xz, .13);\r\n    pR(p.yz, .5);\r\n    float temple = ellip(p, vec3(.1,.1,.15));\r\n    temple = smax(temple, p.x - .07, .1);\r\n    d = smin(d, temple, .1);\r\n\r\n    p = pp;\r\n    p += vec3(.0,.2,-.32);\r\n    ch = ellip(p, vec3(.1,.08,.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.17,.31,-.17);\r\n    ch = ellip(p, vec3(.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    fMouth(d, pp);\r\n\r\n    // nostrils base\r\n    p = pp;\r\n    p += vec3(0,.3,-.43);\r\n    d = smin(d, length(p) - .05, .07);\r\n\r\n    // nostrils\r\n    p = pp;\r\n    p += vec3(0,.27,-.52);\r\n    pR(p.yz, .2);\r\n    float nostrils = ellip(p, vec3(.055,.05,.06));\r\n\r\n    p = pp;\r\n    p += vec3(-.043,.28,-.48);\r\n    pR(p.xy, .15);\r\n    p.z *= .8;\r\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\r\n\r\n    d = smin(d, nostrils, .02);\r\n\r\n    p = pp;\r\n    p += vec3(-.033,.3,-.515);\r\n    pR(p.xz, .5);\r\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\r\n\r\n    // return d;\r\n\r\n    // eyelids\r\n    p = pp;\r\n    p += vec3(-.16,.07,-.34);\r\n    float eyelids = ellip(p, vec3(.08,.1,.1));\r\n\r\n    p = pp;\r\n    p += vec3(-.16,.09,-.35);\r\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\r\n\r\n    // edge top\r\n    p = pp;\r\n    p += vec3(-.173,.148,-.43);\r\n    p.x *= .97;\r\n    float et = length(p.xy) - .09;\r\n\r\n    // edge bottom\r\n    p = pp;\r\n    p += vec3(-.168,.105,-.43);\r\n    p.x *= .9;\r\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\r\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\r\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\r\n\r\n    float edge = max(max(eb, et), -d);\r\n\r\n    d = smin(d, eyelids, .01);\r\n    d = smin(d, eyelids2, .03);\r\n    d = smax(d, -edge, .005);\r\n\r\n    // eyeball\r\n    p = pp;\r\n    p += vec3(-.165,.0715,-.346);\r\n    float eyeball = length(p) - .088;\r\n    if (isMap) isEye = eyeball < d;\r\n    d = min(d, eyeball);\r\n\r\n    // tear duct\r\n    p = pp;\r\n    p += vec3(-.075,.1,-.37);\r\n    d = min(d, length(p) - .05);\r\n\r\n    return d;\r\n}\r\n\r\nfloat mBg(vec3 p) {\r\n    pR(p.xy, 1420./10.);\r\n    // return length(p) - .1;\r\n\r\n    p.xy -= vec2(23.22, 90.67);\r\n    // p.xy -= vec2(1.);\r\n    p.z += 17.;\r\n    float r = 5.5;\r\n    float rz = 5.;\r\n    float a = floor(p.z / rz);\r\n    pR(p.xy, a * 3.4);\r\n    pR(p.xy, -.002);\r\n    p.xy = mod(p.xy, r) - r / 2.;\r\n    // if (p.z > -1.2) {\r\n        p.z = mod(p.z, rz) - rz / 2.;\r\n    // }\r\n    float d = length(p)- r / 5.;\r\n    return d;\r\n}\r\n\r\nfloat mce(vec3 p) {\r\n    float h = mHead(p);\r\n    // h = length(p) - .5;\r\n    // return h;\r\n    p.y -= .45;\r\n    float s = helix(p.xzy, 35., .06);\r\n    h = abs(h + .01) - .01;\r\n    h = smax(h, s, .005);\r\n    return h;    \r\n}\r\n\r\nfloat inside = 1.;\r\n\r\nvec2 map(vec3 p) {\r\n    float d = mBg(p) * inside;\r\n    float e = p.z + 25.;\r\n    p.z += 17.;\r\n    p.y -= .4;\r\n    float hs = 10.;\r\n    float h = mce(p / hs) * hs;\r\n    vec2 m = vec2(e, 1.);    \r\n    if (h < m.x) {\r\n        m = vec2(h, 2.);\r\n    }\r\n    #ifndef REFRACT\r\n    \tif (inside == -1.) return m;\r\n    #endif\r\n    if (d < m.x) {\r\n        m = vec2(d, 0.);\r\n    }\r\n    return m;\r\n}\r\n\r\nconst int NORMAL_STEPS = 6;\r\nvec3 calcNormal(vec3 pos){\r\n    isMap = false;\r\n    vec3 eps = vec3(.001,0,0);\r\n    vec3 nor = vec3(0);\r\n    float invert = 1.;\r\n    for (int i = 0; i < NORMAL_STEPS; i++){\r\n        nor += map(pos + eps * invert).x * eps * invert;\r\n        eps = eps.zxy;\r\n        invert *= -1.;\r\n    }\r\n    isMap = true;\r\n    return normalize(nor);\r\n}\r\n\r\n// IQ's cos palette\r\n\r\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\r\n    return a + b*cos( 6.28318*(c*t+d) );\r\n}\r\n\r\nvec3 spectrum(float n) {\r\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\r\n}\r\n\r\nvec3 march(vec2 fc) {\r\n    vec2 p = (-iResolution.xy + 2. * fc.xy) / iResolution.y;\r\n    inside = 1.;\r\n    vec3 camPos = vec3(0,0,2.5);\r\n    vec3 rayDirection = normalize(vec3(p,-4));\r\n    vec3 rayPosition = camPos;\r\n    float distance = 0.;\r\n    vec3 c = vec3(0);\r\n    vec3 n;\r\n    bool rf = false;\r\n    vec2 m;\r\n    float ss;\r\n\r\n    for (int i = 0; i < 300; i++) {\r\n\r\n        rayPosition += rayDirection * distance * .8;\r\n        m = map(rayPosition);\r\n        distance = m.x;\r\n\r\n        if (abs(distance) < .005) {\r\n            if (m.y == 0.) {\r\n                n = calcNormal(rayPosition);\r\n                rayDirection = refract(rayDirection, n, 1. / 2.222);\r\n                rayPosition -= n * .001;\r\n                inside *= -1.;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (m.y == 1.) {\r\n        ss = rayPosition.y / 20. + .5;\r\n        ss = saturate(ss);\r\n        c = spectrum(ss/ 2.);\r\n    }\r\n    if (m.y == 2.) {\r\n        n = calcNormal(rayPosition);\r\n        c = n * .5 + .5;\r\n        ss = dot(n, .5*vec3(.5,1,1));\r\n        ss = saturate(ss);\r\n        c = spectrum(ss / 2. - .8);\r\n        c *= mix(1., saturate(ss), .8);\r\n    }\r\n\r\n    c = pow(c, vec3(1./2.2));\r\n    return c;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n    vec4 lastFrame = texture(iChannel0, uv);\r\n    \r\n    if (lastFrame.a != 0. && iFrame > 2) {\r\n        fragColor = lastFrame;\r\n        return;\r\n    }\r\n    \r\n    vec3 c = vec3(0);\r\n    vec2 o = vec2(1./3.,0);    \r\n    for (float i = 0.; i < 4.; i++) {\r\n        if (i == 2.) o *= -1.;\r\n        o = o.yx;\r\n        c += march(gl_FragCoord.xy + o);\r\n    }\r\n    c /= 4.;\r\n    fragColor = vec4(c, 1);\r\n}\r\n","inputs":[],"outputs":[],"code":"\r\n//#define REFRACT\r\n\r\n// HG_SDF\r\n\r\n#define PI 3.14159265359\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pRi(vec2 p, float a) {\r\n    pR(p, a);\r\n    return p;\r\n}\r\n\r\n#define saturate(x) clamp(x, 0., 1.)\r\n\r\nfloat vmax(vec2 v) {\r\n    return max(v.x, v.y);\r\n}\r\n\r\nfloat vmax(vec3 v) {\r\n    return max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec3 v) {\r\n    return min(min(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec2 v) {\r\n    return min(v.x, v.y);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nfloat fCorner2(vec2 p) {\r\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\r\n}\r\n\r\nfloat fDisc(vec3 p, float r) {\r\n    float l = length(p.xz) - r;\r\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\r\n}\r\n\r\n\r\nfloat fHalfCapsule(vec3 p, float r) {\r\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\r\n}\r\n\r\n\r\n// IQ https://www.shadertoy.com/view/Xds3zN\r\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\r\n{\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    \r\n    float b = (r1-r2)/h;\r\n    float a = sqrt(1.0-b*b);\r\n    float k = dot(q,vec2(-b,a));\r\n    \r\n    if( k < 0.0 ) return length(q) - r1;\r\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\r\n        \r\n    return dot(q, vec2(a,b) ) - r1;\r\n}\r\n\r\nfloat smin2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\r\n    return max(r, min (a, b)) - length(u);\r\n}\r\n\r\nfloat smax2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\r\n    return min(-r, max (a, b)) + length(u);\r\n}\r\n\r\nfloat smin(float a, float b, float k){\r\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\r\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\r\n}\r\n\r\nfloat smax(float a, float b, float k) {\r\n    return -smin(-a, -b, k);\r\n}\r\n\r\nfloat smin3(float a, float b, float k){\r\n    return min(\r\n        smin(a, b, k),\r\n        smin2(a, b, k)\r\n    );\r\n}\r\n\r\nfloat smax3(float a, float b, float k){\r\n    return max(\r\n        smax(a, b, k),\r\n        smax2(a, b, k)\r\n    );\r\n}\r\n\r\n\r\n// Modelling\r\n\r\nfloat ellip(vec3 p, vec3 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ellip(vec2 p, vec2 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat helix(vec3 p, float lead, float thick) {\r\n    // p.z += iTime * .1;\r\n    float d = (mod(atan(p.y, p.x) - p.z * lead, PI * 2.) - PI) / lead;\r\n    d = abs(d) - thick;\r\n    return d;\r\n}\r\n\r\nvoid fMouth(inout float d, vec3 pp) {\r\n    vec3 p;\r\n    // mouth base\r\n    p = pp;\r\n    p += vec3(-.0,.29,-.29);\r\n    pR(p.yz, -.3);\r\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\r\n\r\n    p = pp;\r\n    p += vec3(0,.37,-.4);\r\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.09,.37,-.31);\r\n    d = smin(d, ellip(p, vec3(.04)), .18);\r\n\r\n    // bottom lip\r\n    p = pp;\r\n    p += vec3(0,.455,-.455);\r\n    p.z += smoothstep(.0, .2, p.x) * .05;\r\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\r\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\r\n    float w = .192;\r\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\r\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\r\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\r\n    d = smin(d, bottomlip, lb);\r\n    \r\n    // top lip\r\n    p = pp;\r\n    p += vec3(0,.38,-.45);\r\n    pR(p.xz, -.3);\r\n    ls = vec3(.065,.03,.05);\r\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\r\n    vec3 pl = p * vec3(.78,1,1);\r\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\r\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\r\n    p = pp;\r\n    p += vec3(0,.33,-.45);\r\n    pR(p.yz, .7);\r\n    float cut;\r\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\r\n    float dip = smin(\r\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\r\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\r\n        .025\r\n    );\r\n    cut = smax(cut, dip, .04);\r\n    cut = smax(cut, p.x - .1, .05);\r\n    toplip = smax(toplip, cut, .02);\r\n\r\n    d = smin(d, toplip, .07);\r\n\r\n\r\n    // seam\r\n    p = pp;\r\n    p += vec3(0,.425,-.44);\r\n    lb = length(p);\r\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\r\n    pR(p.yz, .1);\r\n    p.y -= smoothstep(0., .03, p.x) * .002;\r\n    p.y += smoothstep(.03, .1, p.x) * .007;\r\n    p.z -= .133;\r\n    float seam = fDisc(p, .2);\r\n    seam = smax(seam, -d - .015, .01); // fix inside shape\r\n    d = mix(d, smax(d, -seam, lr), .65);\r\n\r\n}\r\n\r\nbool isMap = true;\r\nbool isEye = false;\r\n\r\nfloat mHead(vec3 p) {\r\n\r\n    p.y -= .13;\r\n\r\n    vec3 pa = p;\r\n    p.x = abs(p.x);\r\n    vec3 pp = p;\r\n\r\n    float d = 1e12;\r\n\r\n    // skull back\r\n    p += vec3(0,-.135,.09);\r\n    d = ellip(p, vec3(.395, .385, .395));\r\n\r\n    // skull base\r\n    p = pp;\r\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\r\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\r\n\r\n    // forehead\r\n    p = pp;\r\n    p += vec3(0,-.145,-.175);\r\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\r\n\r\n    p = pp;\r\n    pR(p.yz, -.5);\r\n    float bb = fBox(p, vec3(.5,.67,.7));\r\n    d = smax(d, bb, .2);\r\n\r\n    // face base\r\n    p = pp;\r\n    p += vec3(0,.25,-.13);\r\n    d = smin(d, length(p) - .28, .1);\r\n\r\n    // behind ear\r\n    p = pp;\r\n    p += vec3(-.15,.13,.06);\r\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\r\n\r\n    p = pp;\r\n    p += vec3(-.07,.18,.1);\r\n    d = smin(d, length(p) - .2, .18);\r\n\r\n    // cheek base\r\n    p = pp;\r\n    p += vec3(-.2,.12,-.14);\r\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\r\n\r\n    // jaw base\r\n    p = pp;\r\n    p += vec3(0,.475,-.16);\r\n    pR(p.yz, .8);\r\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\r\n\r\n    // brow\r\n    p = pp;\r\n    p += vec3(0,-.0,-.18);\r\n    vec3 bp = p;\r\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\r\n    brow = length(p) - .36;\r\n    p.x -= .37;\r\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\r\n    p = bp;\r\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\r\n    p = bp;\r\n    pR(p.yz, -.5);\r\n    float peak = -p.y - .165;\r\n    peak += smoothstep(.0, .2, p.x) * .01;\r\n    peak -= smoothstep(.12, .29, p.x) * .025;\r\n    brow = smax(brow, peak, .07);\r\n    p = bp;\r\n    pR(p.yz, .5);\r\n    brow = smax(brow, -p.y - .06, .15);\r\n    d = smin(d, brow, .06);\r\n\r\n    // nose\r\n    p = pp;\r\n    p += vec3(0,.03,-.45);\r\n    pR(p.yz, 3.);\r\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\r\n\r\n    p = pp;\r\n    p += vec3(0,.06,-.47);\r\n    pR(p.yz, 2.77);\r\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\r\n\r\n    // jaw\r\n\r\n    p = pp;\r\n    vec3 jo = vec3(-.25,.4,-.07);\r\n    p = pp + jo;\r\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\r\n\r\n    p = pp;\r\n    p += vec3(0,.63,-.2);\r\n    pR(p.yz, .15);\r\n    float cr = .5;\r\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\r\n\r\n    p = pp + jo;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\r\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\r\n\r\n    p = pa;\r\n    p += vec3(.2,.5,-.1);\r\n    float jb = length(p);\r\n    jb = smoothstep(.0, .4, jb);\r\n    float js = mix(0., -.005, jb);\r\n    jb = mix(.01, .04, jb);\r\n\r\n    d = smin(d, jaw - js, jb);\r\n\r\n    // chin\r\n    p = pp;\r\n    p += vec3(0,.585,-.395);\r\n    p.x *= .7;\r\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\r\n\r\n    // return d;\r\n\r\n    // cheek\r\n\r\n    p = pp;\r\n    p += vec3(-.2,.2,-.28);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, .4);\r\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.26,.02,-.1);\r\n    pR(p.xz, .13);\r\n    pR(p.yz, .5);\r\n    float temple = ellip(p, vec3(.1,.1,.15));\r\n    temple = smax(temple, p.x - .07, .1);\r\n    d = smin(d, temple, .1);\r\n\r\n    p = pp;\r\n    p += vec3(.0,.2,-.32);\r\n    ch = ellip(p, vec3(.1,.08,.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.17,.31,-.17);\r\n    ch = ellip(p, vec3(.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    fMouth(d, pp);\r\n\r\n    // nostrils base\r\n    p = pp;\r\n    p += vec3(0,.3,-.43);\r\n    d = smin(d, length(p) - .05, .07);\r\n\r\n    // nostrils\r\n    p = pp;\r\n    p += vec3(0,.27,-.52);\r\n    pR(p.yz, .2);\r\n    float nostrils = ellip(p, vec3(.055,.05,.06));\r\n\r\n    p = pp;\r\n    p += vec3(-.043,.28,-.48);\r\n    pR(p.xy, .15);\r\n    p.z *= .8;\r\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\r\n\r\n    d = smin(d, nostrils, .02);\r\n\r\n    p = pp;\r\n    p += vec3(-.033,.3,-.515);\r\n    pR(p.xz, .5);\r\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\r\n\r\n    // return d;\r\n\r\n    // eyelids\r\n    p = pp;\r\n    p += vec3(-.16,.07,-.34);\r\n    float eyelids = ellip(p, vec3(.08,.1,.1));\r\n\r\n    p = pp;\r\n    p += vec3(-.16,.09,-.35);\r\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\r\n\r\n    // edge top\r\n    p = pp;\r\n    p += vec3(-.173,.148,-.43);\r\n    p.x *= .97;\r\n    float et = length(p.xy) - .09;\r\n\r\n    // edge bottom\r\n    p = pp;\r\n    p += vec3(-.168,.105,-.43);\r\n    p.x *= .9;\r\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\r\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\r\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\r\n\r\n    float edge = max(max(eb, et), -d);\r\n\r\n    d = smin(d, eyelids, .01);\r\n    d = smin(d, eyelids2, .03);\r\n    d = smax(d, -edge, .005);\r\n\r\n    // eyeball\r\n    p = pp;\r\n    p += vec3(-.165,.0715,-.346);\r\n    float eyeball = length(p) - .088;\r\n    if (isMap) isEye = eyeball < d;\r\n    d = min(d, eyeball);\r\n\r\n    // tear duct\r\n    p = pp;\r\n    p += vec3(-.075,.1,-.37);\r\n    d = min(d, length(p) - .05);\r\n\r\n    return d;\r\n}\r\n\r\nfloat mBg(vec3 p) {\r\n    pR(p.xy, 1420./10.);\r\n    // return length(p) - .1;\r\n\r\n    p.xy -= vec2(23.22, 90.67);\r\n    // p.xy -= vec2(1.);\r\n    p.z += 17.;\r\n    float r = 5.5;\r\n    float rz = 5.;\r\n    float a = floor(p.z / rz);\r\n    pR(p.xy, a * 3.4);\r\n    pR(p.xy, -.002);\r\n    p.xy = mod(p.xy, r) - r / 2.;\r\n    // if (p.z > -1.2) {\r\n        p.z = mod(p.z, rz) - rz / 2.;\r\n    // }\r\n    float d = length(p)- r / 5.;\r\n    return d;\r\n}\r\n\r\nfloat mce(vec3 p) {\r\n    float h = mHead(p);\r\n    // h = length(p) - .5;\r\n    // return h;\r\n    p.y -= .45;\r\n    float s = helix(p.xzy, 35., .06);\r\n    h = abs(h + .01) - .01;\r\n    h = smax(h, s, .005);\r\n    return h;    \r\n}\r\n\r\nfloat inside = 1.;\r\n\r\nvec2 map(vec3 p) {\r\n    float d = mBg(p) * inside;\r\n    float e = p.z + 25.;\r\n    p.z += 17.;\r\n    p.y -= .4;\r\n    float hs = 10.;\r\n    float h = mce(p / hs) * hs;\r\n    vec2 m = vec2(e, 1.);    \r\n    if (h < m.x) {\r\n        m = vec2(h, 2.);\r\n    }\r\n    #ifndef REFRACT\r\n    \tif (inside == -1.) return m;\r\n    #endif\r\n    if (d < m.x) {\r\n        m = vec2(d, 0.);\r\n    }\r\n    return m;\r\n}\r\n\r\nconst int NORMAL_STEPS = 6;\r\nvec3 calcNormal(vec3 pos){\r\n    isMap = false;\r\n    vec3 eps = vec3(.001,0,0);\r\n    vec3 nor = vec3(0);\r\n    float invert = 1.;\r\n    for (int i = 0; i < NORMAL_STEPS; i++){\r\n        nor += map(pos + eps * invert).x * eps * invert;\r\n        eps = eps.zxy;\r\n        invert *= -1.;\r\n    }\r\n    isMap = true;\r\n    return normalize(nor);\r\n}\r\n\r\n// IQ's cos palette\r\n\r\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\r\n    return a + b*cos( 6.28318*(c*t+d) );\r\n}\r\n\r\nvec3 spectrum(float n) {\r\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\r\n}\r\n\r\nvec3 march(vec2 fc) {\r\n    vec2 p = (-iResolution.xy + 2. * fc.xy) / iResolution.y;\r\n    inside = 1.;\r\n    vec3 camPos = vec3(0,0,2.5);\r\n    vec3 rayDirection = normalize(vec3(p,-4));\r\n    vec3 rayPosition = camPos;\r\n    float distance = 0.;\r\n    vec3 c = vec3(0);\r\n    vec3 n;\r\n    bool rf = false;\r\n    vec2 m;\r\n    float ss;\r\n\r\n    for (int i = 0; i < 300; i++) {\r\n\r\n        rayPosition += rayDirection * distance * .8;\r\n        m = map(rayPosition);\r\n        distance = m.x;\r\n\r\n        if (abs(distance) < .005) {\r\n            if (m.y == 0.) {\r\n                n = calcNormal(rayPosition);\r\n                rayDirection = refract(rayDirection, n, 1. / 2.222);\r\n                rayPosition -= n * .001;\r\n                inside *= -1.;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (m.y == 1.) {\r\n        ss = rayPosition.y / 20. + .5;\r\n        ss = saturate(ss);\r\n        c = spectrum(ss/ 2.);\r\n    }\r\n    if (m.y == 2.) {\r\n        n = calcNormal(rayPosition);\r\n        c = n * .5 + .5;\r\n        ss = dot(n, .5*vec3(.5,1,1));\r\n        ss = saturate(ss);\r\n        c = spectrum(ss / 2. - .8);\r\n        c *= mix(1., saturate(ss), .8);\r\n    }\r\n\r\n    c = pow(c, vec3(1./2.2));\r\n    return c;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n    vec4 lastFrame = texture(iChannel0, uv);\r\n    \r\n    if (lastFrame.a != 0. && iFrame > 2) {\r\n        fragColor = lastFrame;\r\n        return;\r\n    }\r\n    \r\n    vec3 c = vec3(0);\r\n    vec2 o = vec2(1./3.,0);    \r\n    for (float i = 0.; i < 4.; i++) {\r\n        if (i == 2.) o *= -1.;\r\n        o = o.yx;\r\n        c += march(gl_FragCoord.xy + o);\r\n    }\r\n    c /= 4.;\r\n    fragColor = vec4(c, 1);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"////////////////////////////////////////////////////////////////////////////////////////\r\n// INFO:\r\n// - use the mouse to navigate (x is rotation, y is zoom)\r\n// - play with the defines below to change the visuals\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// the more slices the slower\r\n#define SLICES \t\t\t50.0\r\n// start amplitude for the noise\r\n#define START_AMPLITUDE\t0.01\r\n// start frequency for the noise\r\n#define START_FREQUENCY\t1.25\r\n// start density value\r\n#define START_DENSITY\t0.0\r\n// animation speed\r\n#define ANIMATION_SPEED 0.075\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n// iq's 3d noise functions from the elevated shader (incl. modifications where needed)\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// rotation matrix for fbm octaves\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\n\r\n// 3d noise function\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\n// fbm noise for 2-4 octaves including rotation per octave\r\nfloat fbm( vec3 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p );\r\n\tp = m*p*2.02;\r\n    f += 0.2500*noise( p ); \r\n// set to 1 for 2 octaves\t\r\n#if 0\t\r\n\treturn f/0.75;\r\n#else\t\r\n\tp = m*p*2.03;\r\n    f += 0.1250*noise( p );\r\n// set to 1 for 3 octaves, 0 for 4 octaves\t\r\n#if 1\t\r\n\treturn f/0.875;\r\n#else\t\r\n\tp = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n#endif\t\r\n#endif\t\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// color gradient\r\nvec3 gradient(float s)\r\n{\r\n\treturn vec3(0.0, max(1.0-s*2.0, 0.0), max(s>0.5?1.0-(s-0.5)*5.0:1.0, 0.0));\r\n}\r\n\r\n// intersection for a sphere with a ray\r\n#define RADIUS 0.5\r\nbool intersectSphere(vec3 origin, vec3 direction, out float tmin, out float tmax)\r\n{\r\n    bool hit = false;\r\n\tfloat a = dot(direction, direction);\r\n    float b = 2.0*dot(origin, direction);\r\n    float c = dot(origin, origin) - 0.5*0.5;\r\n    float disc = b*b - 4.0*a*c;           // discriminant\r\n    tmin = tmax = 0.0;\r\n\r\n    if (disc > 0.0) {\r\n        // Real root of disc, so intersection\r\n        float sdisc = sqrt(disc);\r\n        float t0 = (-b - sdisc)/(2.0*a);          // closest intersection distance\r\n        float t1 = (-b + sdisc)/(2.0*a);          // furthest intersection distance\r\n\r\n\t\ttmax = t1;\r\n        if (t0 >= 0.0) \r\n            tmin = t0;\r\n        hit = true;\r\n    }\r\n\r\n    return hit;\r\n}\r\n\r\n// rotate around axis\r\nvec2 rt(vec2 x,float y)\r\n{\r\n\treturn vec2(cos(y)*x.x-sin(y)*x.y,sin(y)*x.x+cos(y)*x.y);\r\n}\r\n\r\n// shader main function\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// normalized and aspect ratio corrected pixel coordinate\r\n    vec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n\r\n\t// camera and user input\r\n\tvec3 oo = vec3(0, 0, 1.0-iMouse.y/iResolution.y);\r\n\tvec3 od = normalize(vec3(p.x, p.y, -2.0));\r\n\tvec3 o,d;\t\r\n\to.xz = rt(oo.xz, 6.3*iMouse.x/iResolution.x);\r\n\to.y = oo.y;\r\n\td.xz = rt(od.xz, 6.3*iMouse.x/iResolution.x);\r\n\td.y = od.y;\r\n\r\n\t// render\r\n\tvec4 col = vec4(0, 0, 0, 0);\r\n\tfloat tmin, tmax;\r\n\tif (intersectSphere(o, d, tmin, tmax))\r\n\t{\t\r\n\t\t// step thoug the sphere with max SLICES steps\r\n\t\tfor (float i = 0.0; i < SLICES; i+=1.0)\r\n\t\t{\r\n\t\t\t// stay within the sphere bounds\r\n\t\t\tfloat t = tmin+i/SLICES;\r\n\t\t\tif (t > tmax) \r\n\t\t\t\tbreak;\r\n\t\t\tvec3 curpos = o + d*t;\r\n\t\t\t\r\n\t\t\t// get sphere falloff in s\r\n\t\t\tfloat s = (0.5-length(curpos))*2.0;\r\n\t\t\ts*=s;\r\n\r\n\t\t\t// get turbulence in d\r\n\t\t\tfloat a = START_AMPLITUDE;\r\n\t\t\tfloat b = START_FREQUENCY;\r\n\t\t\tfloat d = START_DENSITY;\r\n\t\t\tfor (int j = 0; j < 3; j++)\t\t\t\t\t\t\t\t\t\r\n\t\t\t{\r\n\t\t\t\td += 0.5/abs((fbm(5.0*curpos*b+ANIMATION_SPEED*iTime/b)*2.0-1.0)/a);\r\n\t\t\t\tb *= 2.0;\r\n\t\t\t\ta /= 2.0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// get gradient color depending on s\r\n\t\t\tcol.rgb += gradient(s)*max(d*s,0.0);\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tfragColor = col;\r\n}","inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////////\r\n// INFO:\r\n// - use the mouse to navigate (x is rotation, y is zoom)\r\n// - play with the defines below to change the visuals\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// the more slices the slower\r\n#define SLICES \t\t\t50.0\r\n// start amplitude for the noise\r\n#define START_AMPLITUDE\t0.01\r\n// start frequency for the noise\r\n#define START_FREQUENCY\t1.25\r\n// start density value\r\n#define START_DENSITY\t0.0\r\n// animation speed\r\n#define ANIMATION_SPEED 0.075\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n// iq's 3d noise functions from the elevated shader (incl. modifications where needed)\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// rotation matrix for fbm octaves\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\n\r\n// 3d noise function\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\n// fbm noise for 2-4 octaves including rotation per octave\r\nfloat fbm( vec3 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p );\r\n\tp = m*p*2.02;\r\n    f += 0.2500*noise( p ); \r\n// set to 1 for 2 octaves\t\r\n#if 0\t\r\n\treturn f/0.75;\r\n#else\t\r\n\tp = m*p*2.03;\r\n    f += 0.1250*noise( p );\r\n// set to 1 for 3 octaves, 0 for 4 octaves\t\r\n#if 1\t\r\n\treturn f/0.875;\r\n#else\t\r\n\tp = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n#endif\t\r\n#endif\t\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// color gradient\r\nvec3 gradient(float s)\r\n{\r\n\treturn vec3(0.0, max(1.0-s*2.0, 0.0), max(s>0.5?1.0-(s-0.5)*5.0:1.0, 0.0));\r\n}\r\n\r\n// intersection for a sphere with a ray\r\n#define RADIUS 0.5\r\nbool intersectSphere(vec3 origin, vec3 direction, out float tmin, out float tmax)\r\n{\r\n    bool hit = false;\r\n\tfloat a = dot(direction, direction);\r\n    float b = 2.0*dot(origin, direction);\r\n    float c = dot(origin, origin) - 0.5*0.5;\r\n    float disc = b*b - 4.0*a*c;           // discriminant\r\n    tmin = tmax = 0.0;\r\n\r\n    if (disc > 0.0) {\r\n        // Real root of disc, so intersection\r\n        float sdisc = sqrt(disc);\r\n        float t0 = (-b - sdisc)/(2.0*a);          // closest intersection distance\r\n        float t1 = (-b + sdisc)/(2.0*a);          // furthest intersection distance\r\n\r\n\t\ttmax = t1;\r\n        if (t0 >= 0.0) \r\n            tmin = t0;\r\n        hit = true;\r\n    }\r\n\r\n    return hit;\r\n}\r\n\r\n// rotate around axis\r\nvec2 rt(vec2 x,float y)\r\n{\r\n\treturn vec2(cos(y)*x.x-sin(y)*x.y,sin(y)*x.x+cos(y)*x.y);\r\n}\r\n\r\n// shader main function\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// normalized and aspect ratio corrected pixel coordinate\r\n    vec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n\r\n\t// camera and user input\r\n\tvec3 oo = vec3(0, 0, 1.0-iMouse.y/iResolution.y);\r\n\tvec3 od = normalize(vec3(p.x, p.y, -2.0));\r\n\tvec3 o,d;\t\r\n\to.xz = rt(oo.xz, 6.3*iMouse.x/iResolution.x);\r\n\to.y = oo.y;\r\n\td.xz = rt(od.xz, 6.3*iMouse.x/iResolution.x);\r\n\td.y = od.y;\r\n\r\n\t// render\r\n\tvec4 col = vec4(0, 0, 0, 0);\r\n\tfloat tmin, tmax;\r\n\tif (intersectSphere(o, d, tmin, tmax))\r\n\t{\t\r\n\t\t// step thoug the sphere with max SLICES steps\r\n\t\tfor (float i = 0.0; i < SLICES; i+=1.0)\r\n\t\t{\r\n\t\t\t// stay within the sphere bounds\r\n\t\t\tfloat t = tmin+i/SLICES;\r\n\t\t\tif (t > tmax) \r\n\t\t\t\tbreak;\r\n\t\t\tvec3 curpos = o + d*t;\r\n\t\t\t\r\n\t\t\t// get sphere falloff in s\r\n\t\t\tfloat s = (0.5-length(curpos))*2.0;\r\n\t\t\ts*=s;\r\n\r\n\t\t\t// get turbulence in d\r\n\t\t\tfloat a = START_AMPLITUDE;\r\n\t\t\tfloat b = START_FREQUENCY;\r\n\t\t\tfloat d = START_DENSITY;\r\n\t\t\tfor (int j = 0; j < 3; j++)\t\t\t\t\t\t\t\t\t\r\n\t\t\t{\r\n\t\t\t\td += 0.5/abs((fbm(5.0*curpos*b+ANIMATION_SPEED*iTime/b)*2.0-1.0)/a);\r\n\t\t\t\tb *= 2.0;\r\n\t\t\t\ta /= 2.0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// get gradient color depending on s\r\n\t\t\tcol.rgb += gradient(s)*max(d*s,0.0);\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tfragColor = col;\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"electron","id":"7401da9b87c541eebafbf4efc97a198e","date":null,"viewed":0,"name":"electron","description":"quick glsl port of an effect used in a 4k from 2007.\nuse mouse to rotate (x) and zoom (y)\nhttps://www.shadertoy.com/view/MslGRn","likes":0,"published":null,"tags":["raycasting"," perlinnoise"," fbm"]},"ver":null,"info":{"Name":"electron","id":"7401da9b87c541eebafbf4efc97a198e","date":null,"viewed":0,"name":"electron","description":"quick glsl port of an effect used in a 4k from 2007.\nuse mouse to rotate (x) and zoom (y)\nhttps://www.shadertoy.com/view/MslGRn","likes":0,"published":null,"tags":["raycasting"," perlinnoise"," fbm"]},"renderpass":[{"Code":"////////////////////////////////////////////////////////////////////////////////////////\r\n// INFO:\r\n// - use the mouse to navigate (x is rotation, y is zoom)\r\n// - play with the defines below to change the visuals\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// the more slices the slower\r\n#define SLICES \t\t\t50.0\r\n// start amplitude for the noise\r\n#define START_AMPLITUDE\t0.01\r\n// start frequency for the noise\r\n#define START_FREQUENCY\t1.25\r\n// start density value\r\n#define START_DENSITY\t0.0\r\n// animation speed\r\n#define ANIMATION_SPEED 0.075\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n// iq's 3d noise functions from the elevated shader (incl. modifications where needed)\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// rotation matrix for fbm octaves\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\n\r\n// 3d noise function\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\n// fbm noise for 2-4 octaves including rotation per octave\r\nfloat fbm( vec3 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p );\r\n\tp = m*p*2.02;\r\n    f += 0.2500*noise( p ); \r\n// set to 1 for 2 octaves\t\r\n#if 0\t\r\n\treturn f/0.75;\r\n#else\t\r\n\tp = m*p*2.03;\r\n    f += 0.1250*noise( p );\r\n// set to 1 for 3 octaves, 0 for 4 octaves\t\r\n#if 1\t\r\n\treturn f/0.875;\r\n#else\t\r\n\tp = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n#endif\t\r\n#endif\t\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// color gradient\r\nvec3 gradient(float s)\r\n{\r\n\treturn vec3(0.0, max(1.0-s*2.0, 0.0), max(s>0.5?1.0-(s-0.5)*5.0:1.0, 0.0));\r\n}\r\n\r\n// intersection for a sphere with a ray\r\n#define RADIUS 0.5\r\nbool intersectSphere(vec3 origin, vec3 direction, out float tmin, out float tmax)\r\n{\r\n    bool hit = false;\r\n\tfloat a = dot(direction, direction);\r\n    float b = 2.0*dot(origin, direction);\r\n    float c = dot(origin, origin) - 0.5*0.5;\r\n    float disc = b*b - 4.0*a*c;           // discriminant\r\n    tmin = tmax = 0.0;\r\n\r\n    if (disc > 0.0) {\r\n        // Real root of disc, so intersection\r\n        float sdisc = sqrt(disc);\r\n        float t0 = (-b - sdisc)/(2.0*a);          // closest intersection distance\r\n        float t1 = (-b + sdisc)/(2.0*a);          // furthest intersection distance\r\n\r\n\t\ttmax = t1;\r\n        if (t0 >= 0.0) \r\n            tmin = t0;\r\n        hit = true;\r\n    }\r\n\r\n    return hit;\r\n}\r\n\r\n// rotate around axis\r\nvec2 rt(vec2 x,float y)\r\n{\r\n\treturn vec2(cos(y)*x.x-sin(y)*x.y,sin(y)*x.x+cos(y)*x.y);\r\n}\r\n\r\n// shader main function\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// normalized and aspect ratio corrected pixel coordinate\r\n    vec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n\r\n\t// camera and user input\r\n\tvec3 oo = vec3(0, 0, 1.0-iMouse.y/iResolution.y);\r\n\tvec3 od = normalize(vec3(p.x, p.y, -2.0));\r\n\tvec3 o,d;\t\r\n\to.xz = rt(oo.xz, 6.3*iMouse.x/iResolution.x);\r\n\to.y = oo.y;\r\n\td.xz = rt(od.xz, 6.3*iMouse.x/iResolution.x);\r\n\td.y = od.y;\r\n\r\n\t// render\r\n\tvec4 col = vec4(0, 0, 0, 0);\r\n\tfloat tmin, tmax;\r\n\tif (intersectSphere(o, d, tmin, tmax))\r\n\t{\t\r\n\t\t// step thoug the sphere with max SLICES steps\r\n\t\tfor (float i = 0.0; i < SLICES; i+=1.0)\r\n\t\t{\r\n\t\t\t// stay within the sphere bounds\r\n\t\t\tfloat t = tmin+i/SLICES;\r\n\t\t\tif (t > tmax) \r\n\t\t\t\tbreak;\r\n\t\t\tvec3 curpos = o + d*t;\r\n\t\t\t\r\n\t\t\t// get sphere falloff in s\r\n\t\t\tfloat s = (0.5-length(curpos))*2.0;\r\n\t\t\ts*=s;\r\n\r\n\t\t\t// get turbulence in d\r\n\t\t\tfloat a = START_AMPLITUDE;\r\n\t\t\tfloat b = START_FREQUENCY;\r\n\t\t\tfloat d = START_DENSITY;\r\n\t\t\tfor (int j = 0; j < 3; j++)\t\t\t\t\t\t\t\t\t\r\n\t\t\t{\r\n\t\t\t\td += 0.5/abs((fbm(5.0*curpos*b+ANIMATION_SPEED*iTime/b)*2.0-1.0)/a);\r\n\t\t\t\tb *= 2.0;\r\n\t\t\t\ta /= 2.0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// get gradient color depending on s\r\n\t\t\tcol.rgb += gradient(s)*max(d*s,0.0);\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tfragColor = col;\r\n}","inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////////\r\n// INFO:\r\n// - use the mouse to navigate (x is rotation, y is zoom)\r\n// - play with the defines below to change the visuals\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// the more slices the slower\r\n#define SLICES \t\t\t50.0\r\n// start amplitude for the noise\r\n#define START_AMPLITUDE\t0.01\r\n// start frequency for the noise\r\n#define START_FREQUENCY\t1.25\r\n// start density value\r\n#define START_DENSITY\t0.0\r\n// animation speed\r\n#define ANIMATION_SPEED 0.075\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n// iq's 3d noise functions from the elevated shader (incl. modifications where needed)\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// rotation matrix for fbm octaves\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\n\r\n// 3d noise function\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\n// fbm noise for 2-4 octaves including rotation per octave\r\nfloat fbm( vec3 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p );\r\n\tp = m*p*2.02;\r\n    f += 0.2500*noise( p ); \r\n// set to 1 for 2 octaves\t\r\n#if 0\t\r\n\treturn f/0.75;\r\n#else\t\r\n\tp = m*p*2.03;\r\n    f += 0.1250*noise( p );\r\n// set to 1 for 3 octaves, 0 for 4 octaves\t\r\n#if 1\t\r\n\treturn f/0.875;\r\n#else\t\r\n\tp = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n#endif\t\r\n#endif\t\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// color gradient\r\nvec3 gradient(float s)\r\n{\r\n\treturn vec3(0.0, max(1.0-s*2.0, 0.0), max(s>0.5?1.0-(s-0.5)*5.0:1.0, 0.0));\r\n}\r\n\r\n// intersection for a sphere with a ray\r\n#define RADIUS 0.5\r\nbool intersectSphere(vec3 origin, vec3 direction, out float tmin, out float tmax)\r\n{\r\n    bool hit = false;\r\n\tfloat a = dot(direction, direction);\r\n    float b = 2.0*dot(origin, direction);\r\n    float c = dot(origin, origin) - 0.5*0.5;\r\n    float disc = b*b - 4.0*a*c;           // discriminant\r\n    tmin = tmax = 0.0;\r\n\r\n    if (disc > 0.0) {\r\n        // Real root of disc, so intersection\r\n        float sdisc = sqrt(disc);\r\n        float t0 = (-b - sdisc)/(2.0*a);          // closest intersection distance\r\n        float t1 = (-b + sdisc)/(2.0*a);          // furthest intersection distance\r\n\r\n\t\ttmax = t1;\r\n        if (t0 >= 0.0) \r\n            tmin = t0;\r\n        hit = true;\r\n    }\r\n\r\n    return hit;\r\n}\r\n\r\n// rotate around axis\r\nvec2 rt(vec2 x,float y)\r\n{\r\n\treturn vec2(cos(y)*x.x-sin(y)*x.y,sin(y)*x.x+cos(y)*x.y);\r\n}\r\n\r\n// shader main function\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// normalized and aspect ratio corrected pixel coordinate\r\n    vec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n\r\n\t// camera and user input\r\n\tvec3 oo = vec3(0, 0, 1.0-iMouse.y/iResolution.y);\r\n\tvec3 od = normalize(vec3(p.x, p.y, -2.0));\r\n\tvec3 o,d;\t\r\n\to.xz = rt(oo.xz, 6.3*iMouse.x/iResolution.x);\r\n\to.y = oo.y;\r\n\td.xz = rt(od.xz, 6.3*iMouse.x/iResolution.x);\r\n\td.y = od.y;\r\n\r\n\t// render\r\n\tvec4 col = vec4(0, 0, 0, 0);\r\n\tfloat tmin, tmax;\r\n\tif (intersectSphere(o, d, tmin, tmax))\r\n\t{\t\r\n\t\t// step thoug the sphere with max SLICES steps\r\n\t\tfor (float i = 0.0; i < SLICES; i+=1.0)\r\n\t\t{\r\n\t\t\t// stay within the sphere bounds\r\n\t\t\tfloat t = tmin+i/SLICES;\r\n\t\t\tif (t > tmax) \r\n\t\t\t\tbreak;\r\n\t\t\tvec3 curpos = o + d*t;\r\n\t\t\t\r\n\t\t\t// get sphere falloff in s\r\n\t\t\tfloat s = (0.5-length(curpos))*2.0;\r\n\t\t\ts*=s;\r\n\r\n\t\t\t// get turbulence in d\r\n\t\t\tfloat a = START_AMPLITUDE;\r\n\t\t\tfloat b = START_FREQUENCY;\r\n\t\t\tfloat d = START_DENSITY;\r\n\t\t\tfor (int j = 0; j < 3; j++)\t\t\t\t\t\t\t\t\t\r\n\t\t\t{\r\n\t\t\t\td += 0.5/abs((fbm(5.0*curpos*b+ANIMATION_SPEED*iTime/b)*2.0-1.0)/a);\r\n\t\t\t\tb *= 2.0;\r\n\t\t\t\ta /= 2.0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// get gradient color depending on s\r\n\t\t\tcol.rgb += gradient(s)*max(d*s,0.0);\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tfragColor = col;\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define LINEAR_DENSITY 1  // 0: constant\r\n#define DENS 2.           // tau.rho\r\n#define rad .3            // sphere radius\r\n#define H   .05           // skin layer thickness (for linear density)\r\n#define ANIM true         // true/false\r\n#define PI 3.14159\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,1.0);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","inputs":[],"outputs":[],"code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define LINEAR_DENSITY 1  // 0: constant\r\n#define DENS 2.           // tau.rho\r\n#define rad .3            // sphere radius\r\n#define H   .05           // skin layer thickness (for linear density)\r\n#define ANIM true         // true/false\r\n#define PI 3.14159\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,1.0);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"enlightened dark cloud","id":"14549e70635646ff90ecf0179c63748c","date":null,"viewed":0,"name":"enlightened dark cloud","description":"Mouse moves the light direction.\nThis is a test of analytical estimation of light scattering within a thin layer. \nDefaut: gradient density within a \"skin\"; no account of curvature.\nhttps://www.shadertoy.com/view/4slGWM","likes":0,"published":null,"tags":["procedural"," noise"," cloud"," scattering"," smoke"," subsurface"," diffusion"]},"ver":null,"info":{"Name":"enlightened dark cloud","id":"14549e70635646ff90ecf0179c63748c","date":null,"viewed":0,"name":"enlightened dark cloud","description":"Mouse moves the light direction.\nThis is a test of analytical estimation of light scattering within a thin layer. \nDefaut: gradient density within a \"skin\"; no account of curvature.\nhttps://www.shadertoy.com/view/4slGWM","likes":0,"published":null,"tags":["procedural"," noise"," cloud"," scattering"," smoke"," subsurface"," diffusion"]},"renderpass":[{"Code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define LINEAR_DENSITY 1  // 0: constant\r\n#define DENS 2.           // tau.rho\r\n#define rad .3            // sphere radius\r\n#define H   .05           // skin layer thickness (for linear density)\r\n#define ANIM true         // true/false\r\n#define PI 3.14159\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,1.0);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","inputs":[],"outputs":[],"code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define LINEAR_DENSITY 1  // 0: constant\r\n#define DENS 2.           // tau.rho\r\n#define rad .3            // sphere radius\r\n#define H   .05           // skin layer thickness (for linear density)\r\n#define ANIM true         // true/false\r\n#define PI 3.14159\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,1.0);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//------------------------------------------------------------------------\r\n//  End of time.  A 4k intro by Virgill/Alcatraz & KK/Altair\r\n//\r\n//  Full intro: http://www.pouet.net/prod.php?which=77102\r\n//  Youtube: https://youtu.be/5lR76o9lWB0\r\n//  4klang music: https://soundcloud.com/virgill/4klang-end-of-time\r\n//  Thanks to these ppl for help + inspiration: Slerpy, LJ, Xtr1m, Gopher\r\n//------------------------------------------------------------------------\r\n\r\nvec3 scol;\r\n\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif(x<d.x) d=vec3(x,y,z);\r\n}\r\n\r\n// 3D noise function (IQ, Shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\n// hemisphere hash function based on a hash by Slerpy\r\nvec3 hashHs(vec3 n, float seed)\r\n{\r\n\tfloat a = fract(sin(seed)*43758.5)*2.-1.;\r\n\tfloat b = 6.283*fract(sin(seed)*41758.5)*2.-1.;\r\n\tfloat c=sqrt(1.-a*a);\r\n\tvec3 r=vec3(c*cos(b), a, c*sin(b));\r\n\treturn r;\r\n}\r\n\r\nfloat sdTorus(vec3 p, vec2 t)\r\n{\r\n\treturn length(vec2(length(p.yz)-t.x, p.x))-t.y;\r\n}\r\n\r\nfloat box(vec2 p)\r\n{\r\n\tp=abs(p); return max(p.x, p.y);\r\n}\r\n\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\n\r\nvec3 map(vec3 p)\r\n{\r\n    vec3 q;\r\n    vec3 d = vec2(0, 1.).yxx;\r\n\tdmin(d, length(p+vec3(cos(0.1*iTime),sin(0.1*iTime),2.5+sin(0.5*iTime)))-.3, 1., .5); \r\n\tdmin(d, length(p+vec3(cos(0.3*iTime),sin(0.3*iTime),2.5-sin(0.5*iTime)))-.3, 1.,-.5); \r\n    q=p;\r\n    q.xy = vec2( (atan(q.x,q.y)+0.*sin(0.9*sqrt(dot(q.xy,q.xy))-0.5*iTime)),1.-length(q.xy));   \r\n    dmin(d, .8-abs(q.y)-.6*noise(5.*q+0.1*iTime)-0.05*noise(40.*q-iTime), 0., 1.); \r\n\treturn d;\r\n\r\n}\r\n\r\n\r\nvec3 normal(vec3 p)\r\n{\r\n\tfloat m = map(p).x;\r\n\tvec2 e = vec2(0,.05);\r\n\treturn normalize(m-vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\r\n}\r\n\r\n\r\nvoid madtracer(in vec3 ro1, in vec3 rd1, in float seed)\r\n{\r\n\tscol = vec3(0);\t\r\n\tfloat t = 0., t2 = 0.;\r\n\tvec3 m1, m2, rd2, ro2, nor2;\r\n\tvec3 roold=ro1;\r\n\tvec3 rdold=rd1;\r\n\tm1.x=0.;\r\n\tfor( int i = 0; i < 140; i++ )\r\n\t{\r\n\r\n\t\tseed = fract(seed+iTime*float(i+1)+.1);\r\n\t\t//ro1=mix(roold, hashHs(ro1, seed), 0.001);\t\t\t\t// antialiasing\r\n        //rd1=mix(rdold,hashHs(rdold,seed),0.06*m1.x); \t\r\n\t\tm1 = map(ro1+rd1*t);\r\n\t\tt+=m1.z!=0. ? 0.25*abs(m1.x)+0.0008 : 0.25*m1.x;\r\n\t\tro2 = ro1 + rd1*t;\r\n\t\tnor2 = normal(ro2); \t\t\t\t\t\t\t\t\t// normal of new origin\r\n\t\tseed = fract(seed+iTime*float(i+2)+.1);\r\n        rd2 = mix(reflect(rd1, nor2), hashHs(nor2, seed), m1.y);// reflect depending on material\r\n\t\tm2 = map(ro2+rd2*t2);\r\n\t\tt2+=m2.z!=0. ? 0.25*abs(m2.x) : 0.25*m2.x;\r\n\t\tscol+=.007*(vec3(1.+m2.z, 1., 1.-m2.z)*step(1., m2.y)+vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y));\r\n\t}\r\n}\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\r\n\t// borders\r\n\tif( uv.y>.2&&uv.y<0.8)\r\n\t{\r\n\t\tfloat seed = sin(fragCoord.x + fragCoord.y)*sin(fragCoord.x - fragCoord.y);\r\n\t\tvec3 bufa= texture(iChannel0, uv).xyz;\r\n\r\n\t\t// camera\r\n\t\tvec3 ro, rd;\r\n\t\tvec2 uv2 = (2.*fragCoord.xy-iResolution.xy)/iResolution.x;\r\n\t\tro = vec3(0, 0,-5);\r\n\t\trd = normalize(vec3(uv2, 1));\r\n\t\t// rotate scene\r\n\t\tpR(rd.xz, .4*-sin(.11*iTime));\r\n\t\tpR(rd.yz, .3*sin(.13*iTime));\r\n\t\tpR(rd.xy, .1*-cos(.15*iTime));\r\n\t\t// render    \r\n\t\tmadtracer(ro, rd, seed);\r\n\r\n\t\tfragColor =clamp(vec4(0.7*scol+0.7*bufa, 0.), 0., 1.); // with blur\r\n\t}\r\n}\r\n","inputs":[],"outputs":[],"code":"//------------------------------------------------------------------------\r\n//  End of time.  A 4k intro by Virgill/Alcatraz & KK/Altair\r\n//\r\n//  Full intro: http://www.pouet.net/prod.php?which=77102\r\n//  Youtube: https://youtu.be/5lR76o9lWB0\r\n//  4klang music: https://soundcloud.com/virgill/4klang-end-of-time\r\n//  Thanks to these ppl for help + inspiration: Slerpy, LJ, Xtr1m, Gopher\r\n//------------------------------------------------------------------------\r\n\r\nvec3 scol;\r\n\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif(x<d.x) d=vec3(x,y,z);\r\n}\r\n\r\n// 3D noise function (IQ, Shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\n// hemisphere hash function based on a hash by Slerpy\r\nvec3 hashHs(vec3 n, float seed)\r\n{\r\n\tfloat a = fract(sin(seed)*43758.5)*2.-1.;\r\n\tfloat b = 6.283*fract(sin(seed)*41758.5)*2.-1.;\r\n\tfloat c=sqrt(1.-a*a);\r\n\tvec3 r=vec3(c*cos(b), a, c*sin(b));\r\n\treturn r;\r\n}\r\n\r\nfloat sdTorus(vec3 p, vec2 t)\r\n{\r\n\treturn length(vec2(length(p.yz)-t.x, p.x))-t.y;\r\n}\r\n\r\nfloat box(vec2 p)\r\n{\r\n\tp=abs(p); return max(p.x, p.y);\r\n}\r\n\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\n\r\nvec3 map(vec3 p)\r\n{\r\n    vec3 q;\r\n    vec3 d = vec2(0, 1.).yxx;\r\n\tdmin(d, length(p+vec3(cos(0.1*iTime),sin(0.1*iTime),2.5+sin(0.5*iTime)))-.3, 1., .5); \r\n\tdmin(d, length(p+vec3(cos(0.3*iTime),sin(0.3*iTime),2.5-sin(0.5*iTime)))-.3, 1.,-.5); \r\n    q=p;\r\n    q.xy = vec2( (atan(q.x,q.y)+0.*sin(0.9*sqrt(dot(q.xy,q.xy))-0.5*iTime)),1.-length(q.xy));   \r\n    dmin(d, .8-abs(q.y)-.6*noise(5.*q+0.1*iTime)-0.05*noise(40.*q-iTime), 0., 1.); \r\n\treturn d;\r\n\r\n}\r\n\r\n\r\nvec3 normal(vec3 p)\r\n{\r\n\tfloat m = map(p).x;\r\n\tvec2 e = vec2(0,.05);\r\n\treturn normalize(m-vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\r\n}\r\n\r\n\r\nvoid madtracer(in vec3 ro1, in vec3 rd1, in float seed)\r\n{\r\n\tscol = vec3(0);\t\r\n\tfloat t = 0., t2 = 0.;\r\n\tvec3 m1, m2, rd2, ro2, nor2;\r\n\tvec3 roold=ro1;\r\n\tvec3 rdold=rd1;\r\n\tm1.x=0.;\r\n\tfor( int i = 0; i < 140; i++ )\r\n\t{\r\n\r\n\t\tseed = fract(seed+iTime*float(i+1)+.1);\r\n\t\t//ro1=mix(roold, hashHs(ro1, seed), 0.001);\t\t\t\t// antialiasing\r\n        //rd1=mix(rdold,hashHs(rdold,seed),0.06*m1.x); \t\r\n\t\tm1 = map(ro1+rd1*t);\r\n\t\tt+=m1.z!=0. ? 0.25*abs(m1.x)+0.0008 : 0.25*m1.x;\r\n\t\tro2 = ro1 + rd1*t;\r\n\t\tnor2 = normal(ro2); \t\t\t\t\t\t\t\t\t// normal of new origin\r\n\t\tseed = fract(seed+iTime*float(i+2)+.1);\r\n        rd2 = mix(reflect(rd1, nor2), hashHs(nor2, seed), m1.y);// reflect depending on material\r\n\t\tm2 = map(ro2+rd2*t2);\r\n\t\tt2+=m2.z!=0. ? 0.25*abs(m2.x) : 0.25*m2.x;\r\n\t\tscol+=.007*(vec3(1.+m2.z, 1., 1.-m2.z)*step(1., m2.y)+vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y));\r\n\t}\r\n}\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\r\n\t// borders\r\n\tif( uv.y>.2&&uv.y<0.8)\r\n\t{\r\n\t\tfloat seed = sin(fragCoord.x + fragCoord.y)*sin(fragCoord.x - fragCoord.y);\r\n\t\tvec3 bufa= texture(iChannel0, uv).xyz;\r\n\r\n\t\t// camera\r\n\t\tvec3 ro, rd;\r\n\t\tvec2 uv2 = (2.*fragCoord.xy-iResolution.xy)/iResolution.x;\r\n\t\tro = vec3(0, 0,-5);\r\n\t\trd = normalize(vec3(uv2, 1));\r\n\t\t// rotate scene\r\n\t\tpR(rd.xz, .4*-sin(.11*iTime));\r\n\t\tpR(rd.yz, .3*sin(.13*iTime));\r\n\t\tpR(rd.xy, .1*-cos(.15*iTime));\r\n\t\t// render    \r\n\t\tmadtracer(ro, rd, seed);\r\n\r\n\t\tfragColor =clamp(vec4(0.7*scol+0.7*bufa, 0.), 0., 1.); // with blur\r\n\t}\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"EOT - dark matter","id":"3cfa27e1746544bb982e04e033857095","date":null,"viewed":0,"name":"EOT - dark matter","description":"End of time by Alcatraz & Altair - dark matter scene\nFull intro: http://www.pouet.net/prod.php?which=77102\nintroducing Madtracing [tm]\nhttps://www.shadertoy.com/view/XlGcRD","likes":0,"published":null,"tags":["intro"," 4k"," demoscene"," pathtracing"," madtracer"," madtracing"]},"ver":null,"info":{"Name":"EOT - dark matter","id":"3cfa27e1746544bb982e04e033857095","date":null,"viewed":0,"name":"EOT - dark matter","description":"End of time by Alcatraz & Altair - dark matter scene\nFull intro: http://www.pouet.net/prod.php?which=77102\nintroducing Madtracing [tm]\nhttps://www.shadertoy.com/view/XlGcRD","likes":0,"published":null,"tags":["intro"," 4k"," demoscene"," pathtracing"," madtracer"," madtracing"]},"renderpass":[{"Code":"//------------------------------------------------------------------------\r\n//  End of time.  A 4k intro by Virgill/Alcatraz & KK/Altair\r\n//\r\n//  Full intro: http://www.pouet.net/prod.php?which=77102\r\n//  Youtube: https://youtu.be/5lR76o9lWB0\r\n//  4klang music: https://soundcloud.com/virgill/4klang-end-of-time\r\n//  Thanks to these ppl for help + inspiration: Slerpy, LJ, Xtr1m, Gopher\r\n//------------------------------------------------------------------------\r\n\r\nvec3 scol;\r\n\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif(x<d.x) d=vec3(x,y,z);\r\n}\r\n\r\n// 3D noise function (IQ, Shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\n// hemisphere hash function based on a hash by Slerpy\r\nvec3 hashHs(vec3 n, float seed)\r\n{\r\n\tfloat a = fract(sin(seed)*43758.5)*2.-1.;\r\n\tfloat b = 6.283*fract(sin(seed)*41758.5)*2.-1.;\r\n\tfloat c=sqrt(1.-a*a);\r\n\tvec3 r=vec3(c*cos(b), a, c*sin(b));\r\n\treturn r;\r\n}\r\n\r\nfloat sdTorus(vec3 p, vec2 t)\r\n{\r\n\treturn length(vec2(length(p.yz)-t.x, p.x))-t.y;\r\n}\r\n\r\nfloat box(vec2 p)\r\n{\r\n\tp=abs(p); return max(p.x, p.y);\r\n}\r\n\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\n\r\nvec3 map(vec3 p)\r\n{\r\n    vec3 q;\r\n    vec3 d = vec2(0, 1.).yxx;\r\n\tdmin(d, length(p+vec3(cos(0.1*iTime),sin(0.1*iTime),2.5+sin(0.5*iTime)))-.3, 1., .5); \r\n\tdmin(d, length(p+vec3(cos(0.3*iTime),sin(0.3*iTime),2.5-sin(0.5*iTime)))-.3, 1.,-.5); \r\n    q=p;\r\n    q.xy = vec2( (atan(q.x,q.y)+0.*sin(0.9*sqrt(dot(q.xy,q.xy))-0.5*iTime)),1.-length(q.xy));   \r\n    dmin(d, .8-abs(q.y)-.6*noise(5.*q+0.1*iTime)-0.05*noise(40.*q-iTime), 0., 1.); \r\n\treturn d;\r\n\r\n}\r\n\r\n\r\nvec3 normal(vec3 p)\r\n{\r\n\tfloat m = map(p).x;\r\n\tvec2 e = vec2(0,.05);\r\n\treturn normalize(m-vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\r\n}\r\n\r\n\r\nvoid madtracer(in vec3 ro1, in vec3 rd1, in float seed)\r\n{\r\n\tscol = vec3(0);\t\r\n\tfloat t = 0., t2 = 0.;\r\n\tvec3 m1, m2, rd2, ro2, nor2;\r\n\tvec3 roold=ro1;\r\n\tvec3 rdold=rd1;\r\n\tm1.x=0.;\r\n\tfor( int i = 0; i < 140; i++ )\r\n\t{\r\n\r\n\t\tseed = fract(seed+iTime*float(i+1)+.1);\r\n\t\t//ro1=mix(roold, hashHs(ro1, seed), 0.001);\t\t\t\t// antialiasing\r\n        //rd1=mix(rdold,hashHs(rdold,seed),0.06*m1.x); \t\r\n\t\tm1 = map(ro1+rd1*t);\r\n\t\tt+=m1.z!=0. ? 0.25*abs(m1.x)+0.0008 : 0.25*m1.x;\r\n\t\tro2 = ro1 + rd1*t;\r\n\t\tnor2 = normal(ro2); \t\t\t\t\t\t\t\t\t// normal of new origin\r\n\t\tseed = fract(seed+iTime*float(i+2)+.1);\r\n        rd2 = mix(reflect(rd1, nor2), hashHs(nor2, seed), m1.y);// reflect depending on material\r\n\t\tm2 = map(ro2+rd2*t2);\r\n\t\tt2+=m2.z!=0. ? 0.25*abs(m2.x) : 0.25*m2.x;\r\n\t\tscol+=.007*(vec3(1.+m2.z, 1., 1.-m2.z)*step(1., m2.y)+vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y));\r\n\t}\r\n}\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\r\n\t// borders\r\n\tif( uv.y>.2&&uv.y<0.8)\r\n\t{\r\n\t\tfloat seed = sin(fragCoord.x + fragCoord.y)*sin(fragCoord.x - fragCoord.y);\r\n\t\tvec3 bufa= texture(iChannel0, uv).xyz;\r\n\r\n\t\t// camera\r\n\t\tvec3 ro, rd;\r\n\t\tvec2 uv2 = (2.*fragCoord.xy-iResolution.xy)/iResolution.x;\r\n\t\tro = vec3(0, 0,-5);\r\n\t\trd = normalize(vec3(uv2, 1));\r\n\t\t// rotate scene\r\n\t\tpR(rd.xz, .4*-sin(.11*iTime));\r\n\t\tpR(rd.yz, .3*sin(.13*iTime));\r\n\t\tpR(rd.xy, .1*-cos(.15*iTime));\r\n\t\t// render    \r\n\t\tmadtracer(ro, rd, seed);\r\n\r\n\t\tfragColor =clamp(vec4(0.7*scol+0.7*bufa, 0.), 0., 1.); // with blur\r\n\t}\r\n}\r\n","inputs":[],"outputs":[],"code":"//------------------------------------------------------------------------\r\n//  End of time.  A 4k intro by Virgill/Alcatraz & KK/Altair\r\n//\r\n//  Full intro: http://www.pouet.net/prod.php?which=77102\r\n//  Youtube: https://youtu.be/5lR76o9lWB0\r\n//  4klang music: https://soundcloud.com/virgill/4klang-end-of-time\r\n//  Thanks to these ppl for help + inspiration: Slerpy, LJ, Xtr1m, Gopher\r\n//------------------------------------------------------------------------\r\n\r\nvec3 scol;\r\n\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif(x<d.x) d=vec3(x,y,z);\r\n}\r\n\r\n// 3D noise function (IQ, Shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\n// hemisphere hash function based on a hash by Slerpy\r\nvec3 hashHs(vec3 n, float seed)\r\n{\r\n\tfloat a = fract(sin(seed)*43758.5)*2.-1.;\r\n\tfloat b = 6.283*fract(sin(seed)*41758.5)*2.-1.;\r\n\tfloat c=sqrt(1.-a*a);\r\n\tvec3 r=vec3(c*cos(b), a, c*sin(b));\r\n\treturn r;\r\n}\r\n\r\nfloat sdTorus(vec3 p, vec2 t)\r\n{\r\n\treturn length(vec2(length(p.yz)-t.x, p.x))-t.y;\r\n}\r\n\r\nfloat box(vec2 p)\r\n{\r\n\tp=abs(p); return max(p.x, p.y);\r\n}\r\n\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\n\r\nvec3 map(vec3 p)\r\n{\r\n    vec3 q;\r\n    vec3 d = vec2(0, 1.).yxx;\r\n\tdmin(d, length(p+vec3(cos(0.1*iTime),sin(0.1*iTime),2.5+sin(0.5*iTime)))-.3, 1., .5); \r\n\tdmin(d, length(p+vec3(cos(0.3*iTime),sin(0.3*iTime),2.5-sin(0.5*iTime)))-.3, 1.,-.5); \r\n    q=p;\r\n    q.xy = vec2( (atan(q.x,q.y)+0.*sin(0.9*sqrt(dot(q.xy,q.xy))-0.5*iTime)),1.-length(q.xy));   \r\n    dmin(d, .8-abs(q.y)-.6*noise(5.*q+0.1*iTime)-0.05*noise(40.*q-iTime), 0., 1.); \r\n\treturn d;\r\n\r\n}\r\n\r\n\r\nvec3 normal(vec3 p)\r\n{\r\n\tfloat m = map(p).x;\r\n\tvec2 e = vec2(0,.05);\r\n\treturn normalize(m-vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\r\n}\r\n\r\n\r\nvoid madtracer(in vec3 ro1, in vec3 rd1, in float seed)\r\n{\r\n\tscol = vec3(0);\t\r\n\tfloat t = 0., t2 = 0.;\r\n\tvec3 m1, m2, rd2, ro2, nor2;\r\n\tvec3 roold=ro1;\r\n\tvec3 rdold=rd1;\r\n\tm1.x=0.;\r\n\tfor( int i = 0; i < 140; i++ )\r\n\t{\r\n\r\n\t\tseed = fract(seed+iTime*float(i+1)+.1);\r\n\t\t//ro1=mix(roold, hashHs(ro1, seed), 0.001);\t\t\t\t// antialiasing\r\n        //rd1=mix(rdold,hashHs(rdold,seed),0.06*m1.x); \t\r\n\t\tm1 = map(ro1+rd1*t);\r\n\t\tt+=m1.z!=0. ? 0.25*abs(m1.x)+0.0008 : 0.25*m1.x;\r\n\t\tro2 = ro1 + rd1*t;\r\n\t\tnor2 = normal(ro2); \t\t\t\t\t\t\t\t\t// normal of new origin\r\n\t\tseed = fract(seed+iTime*float(i+2)+.1);\r\n        rd2 = mix(reflect(rd1, nor2), hashHs(nor2, seed), m1.y);// reflect depending on material\r\n\t\tm2 = map(ro2+rd2*t2);\r\n\t\tt2+=m2.z!=0. ? 0.25*abs(m2.x) : 0.25*m2.x;\r\n\t\tscol+=.007*(vec3(1.+m2.z, 1., 1.-m2.z)*step(1., m2.y)+vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y));\r\n\t}\r\n}\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\r\n\t// borders\r\n\tif( uv.y>.2&&uv.y<0.8)\r\n\t{\r\n\t\tfloat seed = sin(fragCoord.x + fragCoord.y)*sin(fragCoord.x - fragCoord.y);\r\n\t\tvec3 bufa= texture(iChannel0, uv).xyz;\r\n\r\n\t\t// camera\r\n\t\tvec3 ro, rd;\r\n\t\tvec2 uv2 = (2.*fragCoord.xy-iResolution.xy)/iResolution.x;\r\n\t\tro = vec3(0, 0,-5);\r\n\t\trd = normalize(vec3(uv2, 1));\r\n\t\t// rotate scene\r\n\t\tpR(rd.xz, .4*-sin(.11*iTime));\r\n\t\tpR(rd.yz, .3*sin(.13*iTime));\r\n\t\tpR(rd.xy, .1*-cos(.15*iTime));\r\n\t\t// render    \r\n\t\tmadtracer(ro, rd, seed);\r\n\r\n\t\tfragColor =clamp(vec4(0.7*scol+0.7*bufa, 0.), 0., 1.); // with blur\r\n\t}\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\r\n// and animate the scene. The rays are reflected off a displaced\r\n// plane  into the trees.\r\n\r\n// polynomial smooth min (k = 0.1);\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\nfloat sminCubic( float a, float b, float k )\r\n{\r\n    float h = max( k-abs(a-b), 0.0 )/k;\r\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\r\n}\r\n\r\n// the wave for each droplet is based on a simple cosine wave\r\n// the wave in attenuated by the sqared distace to the center\r\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\r\n// both the cosine wave and the rings are animated by offsets\r\n// time is looped in 25 second intervals\r\n// about the time for the rings to leave the field of view\r\nfloat waveDisplacement( vec3 p )\r\n{\r\n    // drop one\r\n    float dist = length(p.xz - vec2(-0.5, 6.0));\r\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\r\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop two\r\n    dist = length(p.xz - vec2(0.5, 5.5));\r\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop three\r\n    dist = length(p.xz - vec2(-0.0, 5.0));\r\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    return waves;\r\n}\r\n\r\n// plane with waves\r\nfloat sdPlane( vec3 p )\r\n{\r\n    float dist = p.y;\r\n    \r\n    // apply costly displacement only when close\r\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\r\n    \r\n    return dist;\r\n}\r\n\r\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\r\n{\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\n// like capsule, but with different radii at each end\r\n// https://www.shadertoy.com/view/3lsSzf\r\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\r\n{\r\n    vec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\r\n}\r\n\r\nfloat sdTree( vec3 p )\r\n{\r\n    // trunk\r\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\r\n    \r\n    // mirror x-axis\r\n    p.x = abs( p.x );\r\n    \r\n    // big branches\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\r\n    \r\n    // mirror z-axis\r\n    p.z = abs( p.z );\r\n    \r\n    // small branches\r\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\r\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\r\n    \r\n    // lang thin branches\r\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\r\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\r\n    \r\n    return dist;\r\n}\r\n\r\n// combined SDF for scene\r\n// water is handled seperately for optimization\r\nfloat map( vec3 p ) {\r\n   \t\r\n    // slight distortion of the space\r\n    // makes the trees look more organic\r\n    // this makes a big difference\r\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\r\n    \r\n    vec3 p1 = p;\r\n    \r\n\t// rotation matrix based on pythagorean tripel\r\n    p1 *= mat3( 4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, 4.0) / 5.0;\r\n    \r\n    float tree1 = sdTree(p1);\r\n    \r\n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\r\n   \t\r\n    // rotation matrix based on pythagorean tripel\r\n    p2 *= mat3(-4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, -4.0) / 5.0;\r\n    \r\n    float tree2 = sdTree(p2);\r\n    \r\n    return min(tree1, tree2);\r\n}\r\n\r\n// optimized normal for water\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcWaterNormal( in vec3 pos)\r\n{\r\n    \r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\r\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \r\n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \r\n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \r\n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=0; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*sdPlane(pos+0.001*e);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n\r\n// get distance to the water surface\r\n// the water is close, only a few iterations are needed\r\n// this helps because the displacement is costly\r\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 10; i++) {\r\n        float d = sdPlane( eye + dist * ray_dir );\r\n        if ( d < 0.001) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 10.0 ) {\r\n            break;\r\n        }    \r\n    }\r\n    return dist;\r\n}\r\n\r\n// get distance to the trees\r\n// farplane is close to speed things up\r\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 70; i++) {\r\n        float d = map( eye + dist * ray_dir );\r\n        if ( d < 0.001 * dist) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 18.0 ) {\r\n            break;\r\n        }\r\n        \r\n    }\r\n    return dist;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get uv between -1 and 1 and fix aspect ratio\r\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n    \r\n    // camera setup\r\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\r\n    \r\n    vec3 eye = vec3(3.0*sin(angle),\r\n                    1.6 + 0.2*(sin(iTime*0.23)),\r\n                    3.0*cos(angle));\r\n    \r\n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\r\n    \r\n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\r\n    vec3 view_dir = normalize( look_at - eye );\r\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\r\n    vec3 up = cross( view_dir, right );\r\n    float focal_dist = 5.0;\r\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\r\n    \r\n    // background color\r\n    vec3 col = vec3(0.5);\r\n    \r\n    // reflect ray at water surface\r\n    float dist = ray_march_water( eye, ray_dir );\r\n    vec3 p = eye + dist*ray_dir;\r\n    vec3 normal = calcWaterNormal( p );\r\n    ray_dir = reflect( ray_dir, normal );\r\n    \r\n    // raymarch the trees\r\n\tdist = ray_march( p + normal * 0.01, ray_dir );\r\n \r\n    // color trees black\r\n    if (dist < 18.0) col = vec3(0);\r\n    \r\n    // color moon white\r\n    // moon is at infinity\r\n    // render based on angle of the reflected ray\r\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\r\n\r\n\tfragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\r\n// and animate the scene. The rays are reflected off a displaced\r\n// plane  into the trees.\r\n\r\n// polynomial smooth min (k = 0.1);\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\nfloat sminCubic( float a, float b, float k )\r\n{\r\n    float h = max( k-abs(a-b), 0.0 )/k;\r\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\r\n}\r\n\r\n// the wave for each droplet is based on a simple cosine wave\r\n// the wave in attenuated by the sqared distace to the center\r\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\r\n// both the cosine wave and the rings are animated by offsets\r\n// time is looped in 25 second intervals\r\n// about the time for the rings to leave the field of view\r\nfloat waveDisplacement( vec3 p )\r\n{\r\n    // drop one\r\n    float dist = length(p.xz - vec2(-0.5, 6.0));\r\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\r\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop two\r\n    dist = length(p.xz - vec2(0.5, 5.5));\r\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop three\r\n    dist = length(p.xz - vec2(-0.0, 5.0));\r\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    return waves;\r\n}\r\n\r\n// plane with waves\r\nfloat sdPlane( vec3 p )\r\n{\r\n    float dist = p.y;\r\n    \r\n    // apply costly displacement only when close\r\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\r\n    \r\n    return dist;\r\n}\r\n\r\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\r\n{\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\n// like capsule, but with different radii at each end\r\n// https://www.shadertoy.com/view/3lsSzf\r\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\r\n{\r\n    vec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\r\n}\r\n\r\nfloat sdTree( vec3 p )\r\n{\r\n    // trunk\r\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\r\n    \r\n    // mirror x-axis\r\n    p.x = abs( p.x );\r\n    \r\n    // big branches\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\r\n    \r\n    // mirror z-axis\r\n    p.z = abs( p.z );\r\n    \r\n    // small branches\r\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\r\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\r\n    \r\n    // lang thin branches\r\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\r\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\r\n    \r\n    return dist;\r\n}\r\n\r\n// combined SDF for scene\r\n// water is handled seperately for optimization\r\nfloat map( vec3 p ) {\r\n   \t\r\n    // slight distortion of the space\r\n    // makes the trees look more organic\r\n    // this makes a big difference\r\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\r\n    \r\n    vec3 p1 = p;\r\n    \r\n\t// rotation matrix based on pythagorean tripel\r\n    p1 *= mat3( 4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, 4.0) / 5.0;\r\n    \r\n    float tree1 = sdTree(p1);\r\n    \r\n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\r\n   \t\r\n    // rotation matrix based on pythagorean tripel\r\n    p2 *= mat3(-4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, -4.0) / 5.0;\r\n    \r\n    float tree2 = sdTree(p2);\r\n    \r\n    return min(tree1, tree2);\r\n}\r\n\r\n// optimized normal for water\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcWaterNormal( in vec3 pos)\r\n{\r\n    \r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\r\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \r\n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \r\n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \r\n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=0; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*sdPlane(pos+0.001*e);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n\r\n// get distance to the water surface\r\n// the water is close, only a few iterations are needed\r\n// this helps because the displacement is costly\r\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 10; i++) {\r\n        float d = sdPlane( eye + dist * ray_dir );\r\n        if ( d < 0.001) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 10.0 ) {\r\n            break;\r\n        }    \r\n    }\r\n    return dist;\r\n}\r\n\r\n// get distance to the trees\r\n// farplane is close to speed things up\r\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 70; i++) {\r\n        float d = map( eye + dist * ray_dir );\r\n        if ( d < 0.001 * dist) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 18.0 ) {\r\n            break;\r\n        }\r\n        \r\n    }\r\n    return dist;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get uv between -1 and 1 and fix aspect ratio\r\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n    \r\n    // camera setup\r\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\r\n    \r\n    vec3 eye = vec3(3.0*sin(angle),\r\n                    1.6 + 0.2*(sin(iTime*0.23)),\r\n                    3.0*cos(angle));\r\n    \r\n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\r\n    \r\n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\r\n    vec3 view_dir = normalize( look_at - eye );\r\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\r\n    vec3 up = cross( view_dir, right );\r\n    float focal_dist = 5.0;\r\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\r\n    \r\n    // background color\r\n    vec3 col = vec3(0.5);\r\n    \r\n    // reflect ray at water surface\r\n    float dist = ray_march_water( eye, ray_dir );\r\n    vec3 p = eye + dist*ray_dir;\r\n    vec3 normal = calcWaterNormal( p );\r\n    ray_dir = reflect( ray_dir, normal );\r\n    \r\n    // raymarch the trees\r\n\tdist = ray_march( p + normal * 0.01, ray_dir );\r\n \r\n    // color trees black\r\n    if (dist < 18.0) col = vec3(0);\r\n    \r\n    // color moon white\r\n    // moon is at infinity\r\n    // render based on angle of the reflected ray\r\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\r\n\r\n\tfragColor = vec4(col, 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Escher Puddle","id":"48d0b6c517c9477ea10c38a4d67d9d57","date":null,"viewed":0,"name":"Escher Puddle","description":"This is my attempt to recreate and animate M.C. Eschers 'Rippled Surface'\r\nhttps://www.shadertoy.com/view/3tVGDh","likes":0,"published":null,"tags":["raymarching"," reflection"," waves"," escher"," reproduction"]},"ver":null,"info":{"Name":"Escher Puddle","id":"48d0b6c517c9477ea10c38a4d67d9d57","date":null,"viewed":0,"name":"Escher Puddle","description":"This is my attempt to recreate and animate M.C. Eschers 'Rippled Surface'\r\nhttps://www.shadertoy.com/view/3tVGDh","likes":0,"published":null,"tags":["raymarching"," reflection"," waves"," escher"," reproduction"]},"renderpass":[{"Code":"// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\r\n// and animate the scene. The rays are reflected off a displaced\r\n// plane  into the trees.\r\n\r\n// polynomial smooth min (k = 0.1);\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\nfloat sminCubic( float a, float b, float k )\r\n{\r\n    float h = max( k-abs(a-b), 0.0 )/k;\r\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\r\n}\r\n\r\n// the wave for each droplet is based on a simple cosine wave\r\n// the wave in attenuated by the sqared distace to the center\r\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\r\n// both the cosine wave and the rings are animated by offsets\r\n// time is looped in 25 second intervals\r\n// about the time for the rings to leave the field of view\r\nfloat waveDisplacement( vec3 p )\r\n{\r\n    // drop one\r\n    float dist = length(p.xz - vec2(-0.5, 6.0));\r\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\r\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop two\r\n    dist = length(p.xz - vec2(0.5, 5.5));\r\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop three\r\n    dist = length(p.xz - vec2(-0.0, 5.0));\r\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    return waves;\r\n}\r\n\r\n// plane with waves\r\nfloat sdPlane( vec3 p )\r\n{\r\n    float dist = p.y;\r\n    \r\n    // apply costly displacement only when close\r\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\r\n    \r\n    return dist;\r\n}\r\n\r\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\r\n{\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\n// like capsule, but with different radii at each end\r\n// https://www.shadertoy.com/view/3lsSzf\r\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\r\n{\r\n    vec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\r\n}\r\n\r\nfloat sdTree( vec3 p )\r\n{\r\n    // trunk\r\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\r\n    \r\n    // mirror x-axis\r\n    p.x = abs( p.x );\r\n    \r\n    // big branches\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\r\n    \r\n    // mirror z-axis\r\n    p.z = abs( p.z );\r\n    \r\n    // small branches\r\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\r\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\r\n    \r\n    // lang thin branches\r\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\r\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\r\n    \r\n    return dist;\r\n}\r\n\r\n// combined SDF for scene\r\n// water is handled seperately for optimization\r\nfloat map( vec3 p ) {\r\n   \t\r\n    // slight distortion of the space\r\n    // makes the trees look more organic\r\n    // this makes a big difference\r\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\r\n    \r\n    vec3 p1 = p;\r\n    \r\n\t// rotation matrix based on pythagorean tripel\r\n    p1 *= mat3( 4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, 4.0) / 5.0;\r\n    \r\n    float tree1 = sdTree(p1);\r\n    \r\n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\r\n   \t\r\n    // rotation matrix based on pythagorean tripel\r\n    p2 *= mat3(-4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, -4.0) / 5.0;\r\n    \r\n    float tree2 = sdTree(p2);\r\n    \r\n    return min(tree1, tree2);\r\n}\r\n\r\n// optimized normal for water\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcWaterNormal( in vec3 pos)\r\n{\r\n    \r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\r\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \r\n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \r\n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \r\n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=0; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*sdPlane(pos+0.001*e);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n\r\n// get distance to the water surface\r\n// the water is close, only a few iterations are needed\r\n// this helps because the displacement is costly\r\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 10; i++) {\r\n        float d = sdPlane( eye + dist * ray_dir );\r\n        if ( d < 0.001) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 10.0 ) {\r\n            break;\r\n        }    \r\n    }\r\n    return dist;\r\n}\r\n\r\n// get distance to the trees\r\n// farplane is close to speed things up\r\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 70; i++) {\r\n        float d = map( eye + dist * ray_dir );\r\n        if ( d < 0.001 * dist) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 18.0 ) {\r\n            break;\r\n        }\r\n        \r\n    }\r\n    return dist;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get uv between -1 and 1 and fix aspect ratio\r\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n    \r\n    // camera setup\r\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\r\n    \r\n    vec3 eye = vec3(3.0*sin(angle),\r\n                    1.6 + 0.2*(sin(iTime*0.23)),\r\n                    3.0*cos(angle));\r\n    \r\n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\r\n    \r\n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\r\n    vec3 view_dir = normalize( look_at - eye );\r\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\r\n    vec3 up = cross( view_dir, right );\r\n    float focal_dist = 5.0;\r\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\r\n    \r\n    // background color\r\n    vec3 col = vec3(0.5);\r\n    \r\n    // reflect ray at water surface\r\n    float dist = ray_march_water( eye, ray_dir );\r\n    vec3 p = eye + dist*ray_dir;\r\n    vec3 normal = calcWaterNormal( p );\r\n    ray_dir = reflect( ray_dir, normal );\r\n    \r\n    // raymarch the trees\r\n\tdist = ray_march( p + normal * 0.01, ray_dir );\r\n \r\n    // color trees black\r\n    if (dist < 18.0) col = vec3(0);\r\n    \r\n    // color moon white\r\n    // moon is at infinity\r\n    // render based on angle of the reflected ray\r\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\r\n\r\n\tfragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\r\n// and animate the scene. The rays are reflected off a displaced\r\n// plane  into the trees.\r\n\r\n// polynomial smooth min (k = 0.1);\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\nfloat sminCubic( float a, float b, float k )\r\n{\r\n    float h = max( k-abs(a-b), 0.0 )/k;\r\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\r\n}\r\n\r\n// the wave for each droplet is based on a simple cosine wave\r\n// the wave in attenuated by the sqared distace to the center\r\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\r\n// both the cosine wave and the rings are animated by offsets\r\n// time is looped in 25 second intervals\r\n// about the time for the rings to leave the field of view\r\nfloat waveDisplacement( vec3 p )\r\n{\r\n    // drop one\r\n    float dist = length(p.xz - vec2(-0.5, 6.0));\r\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\r\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop two\r\n    dist = length(p.xz - vec2(0.5, 5.5));\r\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop three\r\n    dist = length(p.xz - vec2(-0.0, 5.0));\r\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    return waves;\r\n}\r\n\r\n// plane with waves\r\nfloat sdPlane( vec3 p )\r\n{\r\n    float dist = p.y;\r\n    \r\n    // apply costly displacement only when close\r\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\r\n    \r\n    return dist;\r\n}\r\n\r\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\r\n{\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\n// like capsule, but with different radii at each end\r\n// https://www.shadertoy.com/view/3lsSzf\r\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\r\n{\r\n    vec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\r\n}\r\n\r\nfloat sdTree( vec3 p )\r\n{\r\n    // trunk\r\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\r\n    \r\n    // mirror x-axis\r\n    p.x = abs( p.x );\r\n    \r\n    // big branches\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\r\n    \r\n    // mirror z-axis\r\n    p.z = abs( p.z );\r\n    \r\n    // small branches\r\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\r\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\r\n    \r\n    // lang thin branches\r\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\r\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\r\n    \r\n    return dist;\r\n}\r\n\r\n// combined SDF for scene\r\n// water is handled seperately for optimization\r\nfloat map( vec3 p ) {\r\n   \t\r\n    // slight distortion of the space\r\n    // makes the trees look more organic\r\n    // this makes a big difference\r\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\r\n    \r\n    vec3 p1 = p;\r\n    \r\n\t// rotation matrix based on pythagorean tripel\r\n    p1 *= mat3( 4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, 4.0) / 5.0;\r\n    \r\n    float tree1 = sdTree(p1);\r\n    \r\n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\r\n   \t\r\n    // rotation matrix based on pythagorean tripel\r\n    p2 *= mat3(-4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, -4.0) / 5.0;\r\n    \r\n    float tree2 = sdTree(p2);\r\n    \r\n    return min(tree1, tree2);\r\n}\r\n\r\n// optimized normal for water\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcWaterNormal( in vec3 pos)\r\n{\r\n    \r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\r\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \r\n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \r\n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \r\n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=0; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*sdPlane(pos+0.001*e);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n\r\n// get distance to the water surface\r\n// the water is close, only a few iterations are needed\r\n// this helps because the displacement is costly\r\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 10; i++) {\r\n        float d = sdPlane( eye + dist * ray_dir );\r\n        if ( d < 0.001) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 10.0 ) {\r\n            break;\r\n        }    \r\n    }\r\n    return dist;\r\n}\r\n\r\n// get distance to the trees\r\n// farplane is close to speed things up\r\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 70; i++) {\r\n        float d = map( eye + dist * ray_dir );\r\n        if ( d < 0.001 * dist) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 18.0 ) {\r\n            break;\r\n        }\r\n        \r\n    }\r\n    return dist;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get uv between -1 and 1 and fix aspect ratio\r\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n    \r\n    // camera setup\r\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\r\n    \r\n    vec3 eye = vec3(3.0*sin(angle),\r\n                    1.6 + 0.2*(sin(iTime*0.23)),\r\n                    3.0*cos(angle));\r\n    \r\n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\r\n    \r\n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\r\n    vec3 view_dir = normalize( look_at - eye );\r\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\r\n    vec3 up = cross( view_dir, right );\r\n    float focal_dist = 5.0;\r\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\r\n    \r\n    // background color\r\n    vec3 col = vec3(0.5);\r\n    \r\n    // reflect ray at water surface\r\n    float dist = ray_march_water( eye, ray_dir );\r\n    vec3 p = eye + dist*ray_dir;\r\n    vec3 normal = calcWaterNormal( p );\r\n    ray_dir = reflect( ray_dir, normal );\r\n    \r\n    // raymarch the trees\r\n\tdist = ray_march( p + normal * 0.01, ray_dir );\r\n \r\n    // color trees black\r\n    if (dist < 18.0) col = vec3(0);\r\n    \r\n    // color moon white\r\n    // moon is at infinity\r\n    // render based on angle of the reflected ray\r\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\r\n\r\n\tfragColor = vec4(col, 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//afl_ext 2017-2019\r\n\r\n#define DRAG_MULT 0.048\r\n#define ITERATIONS_RAYMARCH 13\r\n#define ITERATIONS_NORMAL 48\r\n\r\n#define Mouse (iMouse.xy / iResolution.xy)\r\n#define Resolution (iResolution.xy)\r\n#define Time (iTime)\r\n\r\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\r\n    float x = dot(direction, position) * frequency + timeshift * speed;\r\n    float wave = exp(sin(x) - 1.0);\r\n    float dx = wave * cos(x);\r\n    return vec2(wave, -dx);\r\n}\r\n\r\nfloat getwaves(vec2 position, int iterations){\r\n\tfloat iter = 0.0;\r\n    float phase = 6.0;\r\n    float speed = 2.0;\r\n    float weight = 1.0;\r\n    float w = 0.0;\r\n    float ws = 0.0;\r\n    for(int i=0;i<iterations;i++){\r\n        vec2 p = vec2(sin(iter), cos(iter));\r\n        vec2 res = wavedx(position, p, speed, phase, Time);\r\n        position += normalize(p) * res.y * weight * DRAG_MULT;\r\n        w += res.x * weight;\r\n        iter += 12.0;\r\n        ws += weight;\r\n        weight = mix(weight, 0.0, 0.2);\r\n        phase *= 1.18;\r\n        speed *= 1.07;\r\n    }\r\n    return w / ws;\r\n}\r\n\r\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\r\n    vec3 pos = start;\r\n    float h = 0.0;\r\n    float hupper = depth;\r\n    float hlower = 0.0;\r\n    vec2 zer = vec2(0.0);\r\n    vec3 dir = normalize(end - start);\r\n    for(int i=0;i<318;i++){\r\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\r\n        float dist_pos = distance(pos, camera);\r\n        if(h + 0.01*dist_pos > pos.y) {\r\n            return dist_pos;\r\n        }\r\n        pos += dir * (pos.y - h);\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat H = 0.0;\r\nvec3 normal(vec2 pos, float e, float depth){\r\n    vec2 ex = vec2(e, 0);\r\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\r\n    vec3 a = vec3(pos.x, H, pos.y);\r\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \r\n                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\r\n}\r\nmat3 rotmat(vec3 axis, float angle)\r\n{\r\n\taxis = normalize(axis);\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\tfloat oc = 1.0 - c;\r\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \r\n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \r\n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n}\r\n\r\nvec3 getRay(vec2 uv){\r\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\r\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\r\n    if(Resolution.x < 400.0) return proj;\r\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\r\n    return ray;\r\n}\r\n\r\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\r\n{ \r\n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \r\n}\r\n\r\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\r\n\tsundir.y = max(sundir.y, -0.07);\r\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\r\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\r\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\r\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\r\n\tfloat mymie = sundt * special_trick * 0.2;\r\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\r\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\r\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\r\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\r\n\treturn bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\r\n} \r\nvec3 getatm(vec3 ray){\r\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\r\n    \r\n}\r\n\r\nfloat sun(vec3 ray){\r\n \tvec3 sd = normalize(vec3(1.0));   \r\n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\r\n}\r\nvec3 aces_tonemap(vec3 color){\t\r\n\tmat3 m1 = mat3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777\r\n\t);\r\n\tmat3 m2 = mat3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602\r\n\t);\r\n\tvec3 v = m1 * color;    \r\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\r\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n \t\r\n\tfloat waterdepth = 2.1;\r\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\r\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\r\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\r\n\tvec3 ray = getRay(uv);\r\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\r\n    if(ray.y >= -0.01){\r\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\r\n        //tonemapping\r\n    \tC = aces_tonemap(C);\r\n     \tfragColor = vec4( C,1.0);   \r\n        return;\r\n    }\r\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\r\n    vec3 hipos = orig + ray * hihit;\r\n    vec3 lopos = orig + ray * lohit;\r\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\r\n    vec3 pos = orig + ray * dist;\r\n\r\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\r\n    vec2 velocity = N.xz * (1.0 - N.y);\r\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\r\n    vec3 R = reflect(ray, N);\r\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\r\n\t\r\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\r\n    //tonemapping\r\n    C = aces_tonemap(C);\r\n    \r\n\tfragColor = vec4(C,1.0);\r\n}","inputs":[],"outputs":[],"code":"//afl_ext 2017-2019\r\n\r\n#define DRAG_MULT 0.048\r\n#define ITERATIONS_RAYMARCH 13\r\n#define ITERATIONS_NORMAL 48\r\n\r\n#define Mouse (iMouse.xy / iResolution.xy)\r\n#define Resolution (iResolution.xy)\r\n#define Time (iTime)\r\n\r\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\r\n    float x = dot(direction, position) * frequency + timeshift * speed;\r\n    float wave = exp(sin(x) - 1.0);\r\n    float dx = wave * cos(x);\r\n    return vec2(wave, -dx);\r\n}\r\n\r\nfloat getwaves(vec2 position, int iterations){\r\n\tfloat iter = 0.0;\r\n    float phase = 6.0;\r\n    float speed = 2.0;\r\n    float weight = 1.0;\r\n    float w = 0.0;\r\n    float ws = 0.0;\r\n    for(int i=0;i<iterations;i++){\r\n        vec2 p = vec2(sin(iter), cos(iter));\r\n        vec2 res = wavedx(position, p, speed, phase, Time);\r\n        position += normalize(p) * res.y * weight * DRAG_MULT;\r\n        w += res.x * weight;\r\n        iter += 12.0;\r\n        ws += weight;\r\n        weight = mix(weight, 0.0, 0.2);\r\n        phase *= 1.18;\r\n        speed *= 1.07;\r\n    }\r\n    return w / ws;\r\n}\r\n\r\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\r\n    vec3 pos = start;\r\n    float h = 0.0;\r\n    float hupper = depth;\r\n    float hlower = 0.0;\r\n    vec2 zer = vec2(0.0);\r\n    vec3 dir = normalize(end - start);\r\n    for(int i=0;i<318;i++){\r\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\r\n        float dist_pos = distance(pos, camera);\r\n        if(h + 0.01*dist_pos > pos.y) {\r\n            return dist_pos;\r\n        }\r\n        pos += dir * (pos.y - h);\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat H = 0.0;\r\nvec3 normal(vec2 pos, float e, float depth){\r\n    vec2 ex = vec2(e, 0);\r\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\r\n    vec3 a = vec3(pos.x, H, pos.y);\r\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \r\n                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\r\n}\r\nmat3 rotmat(vec3 axis, float angle)\r\n{\r\n\taxis = normalize(axis);\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\tfloat oc = 1.0 - c;\r\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \r\n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \r\n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n}\r\n\r\nvec3 getRay(vec2 uv){\r\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\r\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\r\n    if(Resolution.x < 400.0) return proj;\r\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\r\n    return ray;\r\n}\r\n\r\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\r\n{ \r\n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \r\n}\r\n\r\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\r\n\tsundir.y = max(sundir.y, -0.07);\r\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\r\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\r\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\r\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\r\n\tfloat mymie = sundt * special_trick * 0.2;\r\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\r\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\r\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\r\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\r\n\treturn bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\r\n} \r\nvec3 getatm(vec3 ray){\r\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\r\n    \r\n}\r\n\r\nfloat sun(vec3 ray){\r\n \tvec3 sd = normalize(vec3(1.0));   \r\n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\r\n}\r\nvec3 aces_tonemap(vec3 color){\t\r\n\tmat3 m1 = mat3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777\r\n\t);\r\n\tmat3 m2 = mat3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602\r\n\t);\r\n\tvec3 v = m1 * color;    \r\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\r\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n \t\r\n\tfloat waterdepth = 2.1;\r\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\r\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\r\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\r\n\tvec3 ray = getRay(uv);\r\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\r\n    if(ray.y >= -0.01){\r\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\r\n        //tonemapping\r\n    \tC = aces_tonemap(C);\r\n     \tfragColor = vec4( C,1.0);   \r\n        return;\r\n    }\r\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\r\n    vec3 hipos = orig + ray * hihit;\r\n    vec3 lopos = orig + ray * lohit;\r\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\r\n    vec3 pos = orig + ray * dist;\r\n\r\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\r\n    vec2 velocity = N.xz * (1.0 - N.y);\r\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\r\n    vec3 R = reflect(ray, N);\r\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\r\n\t\r\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\r\n    //tonemapping\r\n    C = aces_tonemap(C);\r\n    \r\n\tfragColor = vec4(C,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Even faster procedural ocean","id":"14d216bde4b04d118d54a6175b46fe40","date":null,"viewed":0,"name":"Even faster procedural ocean","description":"This is a slightly improved version of \"Very fast procedural ocean\". The precision of the rendering decreases as the distance from the camera increases.\nhttps://www.shadertoy.com/view/3scfD7","likes":0,"published":null,"tags":["waves"," sea"," water"," ocean"," seascape"," scape"]},"ver":null,"info":{"Name":"Even faster procedural ocean","id":"14d216bde4b04d118d54a6175b46fe40","date":null,"viewed":0,"name":"Even faster procedural ocean","description":"This is a slightly improved version of \"Very fast procedural ocean\". The precision of the rendering decreases as the distance from the camera increases.\nhttps://www.shadertoy.com/view/3scfD7","likes":0,"published":null,"tags":["waves"," sea"," water"," ocean"," seascape"," scape"]},"renderpass":[{"Code":"//afl_ext 2017-2019\r\n\r\n#define DRAG_MULT 0.048\r\n#define ITERATIONS_RAYMARCH 13\r\n#define ITERATIONS_NORMAL 48\r\n\r\n#define Mouse (iMouse.xy / iResolution.xy)\r\n#define Resolution (iResolution.xy)\r\n#define Time (iTime)\r\n\r\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\r\n    float x = dot(direction, position) * frequency + timeshift * speed;\r\n    float wave = exp(sin(x) - 1.0);\r\n    float dx = wave * cos(x);\r\n    return vec2(wave, -dx);\r\n}\r\n\r\nfloat getwaves(vec2 position, int iterations){\r\n\tfloat iter = 0.0;\r\n    float phase = 6.0;\r\n    float speed = 2.0;\r\n    float weight = 1.0;\r\n    float w = 0.0;\r\n    float ws = 0.0;\r\n    for(int i=0;i<iterations;i++){\r\n        vec2 p = vec2(sin(iter), cos(iter));\r\n        vec2 res = wavedx(position, p, speed, phase, Time);\r\n        position += normalize(p) * res.y * weight * DRAG_MULT;\r\n        w += res.x * weight;\r\n        iter += 12.0;\r\n        ws += weight;\r\n        weight = mix(weight, 0.0, 0.2);\r\n        phase *= 1.18;\r\n        speed *= 1.07;\r\n    }\r\n    return w / ws;\r\n}\r\n\r\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\r\n    vec3 pos = start;\r\n    float h = 0.0;\r\n    float hupper = depth;\r\n    float hlower = 0.0;\r\n    vec2 zer = vec2(0.0);\r\n    vec3 dir = normalize(end - start);\r\n    for(int i=0;i<318;i++){\r\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\r\n        float dist_pos = distance(pos, camera);\r\n        if(h + 0.01*dist_pos > pos.y) {\r\n            return dist_pos;\r\n        }\r\n        pos += dir * (pos.y - h);\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat H = 0.0;\r\nvec3 normal(vec2 pos, float e, float depth){\r\n    vec2 ex = vec2(e, 0);\r\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\r\n    vec3 a = vec3(pos.x, H, pos.y);\r\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \r\n                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\r\n}\r\nmat3 rotmat(vec3 axis, float angle)\r\n{\r\n\taxis = normalize(axis);\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\tfloat oc = 1.0 - c;\r\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \r\n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \r\n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n}\r\n\r\nvec3 getRay(vec2 uv){\r\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\r\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\r\n    if(Resolution.x < 400.0) return proj;\r\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\r\n    return ray;\r\n}\r\n\r\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\r\n{ \r\n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \r\n}\r\n\r\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\r\n\tsundir.y = max(sundir.y, -0.07);\r\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\r\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\r\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\r\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\r\n\tfloat mymie = sundt * special_trick * 0.2;\r\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\r\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\r\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\r\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\r\n\treturn bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\r\n} \r\nvec3 getatm(vec3 ray){\r\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\r\n    \r\n}\r\n\r\nfloat sun(vec3 ray){\r\n \tvec3 sd = normalize(vec3(1.0));   \r\n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\r\n}\r\nvec3 aces_tonemap(vec3 color){\t\r\n\tmat3 m1 = mat3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777\r\n\t);\r\n\tmat3 m2 = mat3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602\r\n\t);\r\n\tvec3 v = m1 * color;    \r\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\r\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n \t\r\n\tfloat waterdepth = 2.1;\r\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\r\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\r\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\r\n\tvec3 ray = getRay(uv);\r\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\r\n    if(ray.y >= -0.01){\r\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\r\n        //tonemapping\r\n    \tC = aces_tonemap(C);\r\n     \tfragColor = vec4( C,1.0);   \r\n        return;\r\n    }\r\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\r\n    vec3 hipos = orig + ray * hihit;\r\n    vec3 lopos = orig + ray * lohit;\r\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\r\n    vec3 pos = orig + ray * dist;\r\n\r\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\r\n    vec2 velocity = N.xz * (1.0 - N.y);\r\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\r\n    vec3 R = reflect(ray, N);\r\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\r\n\t\r\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\r\n    //tonemapping\r\n    C = aces_tonemap(C);\r\n    \r\n\tfragColor = vec4(C,1.0);\r\n}","inputs":[],"outputs":[],"code":"//afl_ext 2017-2019\r\n\r\n#define DRAG_MULT 0.048\r\n#define ITERATIONS_RAYMARCH 13\r\n#define ITERATIONS_NORMAL 48\r\n\r\n#define Mouse (iMouse.xy / iResolution.xy)\r\n#define Resolution (iResolution.xy)\r\n#define Time (iTime)\r\n\r\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\r\n    float x = dot(direction, position) * frequency + timeshift * speed;\r\n    float wave = exp(sin(x) - 1.0);\r\n    float dx = wave * cos(x);\r\n    return vec2(wave, -dx);\r\n}\r\n\r\nfloat getwaves(vec2 position, int iterations){\r\n\tfloat iter = 0.0;\r\n    float phase = 6.0;\r\n    float speed = 2.0;\r\n    float weight = 1.0;\r\n    float w = 0.0;\r\n    float ws = 0.0;\r\n    for(int i=0;i<iterations;i++){\r\n        vec2 p = vec2(sin(iter), cos(iter));\r\n        vec2 res = wavedx(position, p, speed, phase, Time);\r\n        position += normalize(p) * res.y * weight * DRAG_MULT;\r\n        w += res.x * weight;\r\n        iter += 12.0;\r\n        ws += weight;\r\n        weight = mix(weight, 0.0, 0.2);\r\n        phase *= 1.18;\r\n        speed *= 1.07;\r\n    }\r\n    return w / ws;\r\n}\r\n\r\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\r\n    vec3 pos = start;\r\n    float h = 0.0;\r\n    float hupper = depth;\r\n    float hlower = 0.0;\r\n    vec2 zer = vec2(0.0);\r\n    vec3 dir = normalize(end - start);\r\n    for(int i=0;i<318;i++){\r\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\r\n        float dist_pos = distance(pos, camera);\r\n        if(h + 0.01*dist_pos > pos.y) {\r\n            return dist_pos;\r\n        }\r\n        pos += dir * (pos.y - h);\r\n    }\r\n    return -1.0;\r\n}\r\n\r\nfloat H = 0.0;\r\nvec3 normal(vec2 pos, float e, float depth){\r\n    vec2 ex = vec2(e, 0);\r\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\r\n    vec3 a = vec3(pos.x, H, pos.y);\r\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \r\n                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\r\n}\r\nmat3 rotmat(vec3 axis, float angle)\r\n{\r\n\taxis = normalize(axis);\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\tfloat oc = 1.0 - c;\r\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \r\n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \r\n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n}\r\n\r\nvec3 getRay(vec2 uv){\r\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\r\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\r\n    if(Resolution.x < 400.0) return proj;\r\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * proj;\r\n    return ray;\r\n}\r\n\r\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\r\n{ \r\n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \r\n}\r\n\r\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\r\n\tsundir.y = max(sundir.y, -0.07);\r\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\r\n\tfloat special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\r\n\tfloat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\r\n\tfloat sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\r\n\tfloat mymie = sundt * special_trick * 0.2;\r\n\tvec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\r\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 * suncolor;\r\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));\r\n\tbluesky2 *= special_trick * (0.24 + raysundt * 0.24);\r\n\treturn bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0)) + mymie * suncolor;\r\n} \r\nvec3 getatm(vec3 ray){\r\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\r\n    \r\n}\r\n\r\nfloat sun(vec3 ray){\r\n \tvec3 sd = normalize(vec3(1.0));   \r\n    return pow(max(0.0, dot(ray, sd)), 528.0) * 110.0;\r\n}\r\nvec3 aces_tonemap(vec3 color){\t\r\n\tmat3 m1 = mat3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777\r\n\t);\r\n\tmat3 m2 = mat3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602\r\n\t);\r\n\tvec3 v = m1 * color;    \r\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\r\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n \t\r\n\tfloat waterdepth = 2.1;\r\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\r\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\r\n\tvec3 orig = vec3(0.0, 2.0, 0.0);\r\n\tvec3 ray = getRay(uv);\r\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\r\n    if(ray.y >= -0.01){\r\n        vec3 C = getatm(ray) * 2.0 + sun(ray);\r\n        //tonemapping\r\n    \tC = aces_tonemap(C);\r\n     \tfragColor = vec4( C,1.0);   \r\n        return;\r\n    }\r\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\r\n    vec3 hipos = orig + ray * hihit;\r\n    vec3 lopos = orig + ray * lohit;\r\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\r\n    vec3 pos = orig + ray * dist;\r\n\r\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\r\n    vec2 velocity = N.xz * (1.0 - N.y);\r\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\r\n    vec3 R = reflect(ray, N);\r\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\r\n\t\r\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\r\n    //tonemapping\r\n    C = aces_tonemap(C);\r\n    \r\n\tfragColor = vec4(C,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Example of 3D Noise","id":"Wtc3W7","date":"0","viewed":0,"name":"Example of 3D Noise","description":"3d\u566A\u58F0\u793A\u4F8B","likes":0,"published":"Private","tags":["3d","noise"]},"ver":"0.1","info":{"Name":"Example of 3D Noise","id":"Wtc3W7","date":"0","viewed":0,"name":"Example of 3D Noise","description":"3d\u566A\u58F0\u793A\u4F8B","likes":0,"published":"Private","tags":["3d","noise"]},"renderpass":[{"Code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Examples Of 2D Noise","id":"llKyDc","date":"1576221630","viewed":61,"name":"Examples Of 2D Noise","description":"2d\u566A\u58F0\u793A\u4F8B","likes":6,"published":"Public","tags":["2d","noise"]},"ver":"0.1","info":{"Name":"Examples Of 2D Noise","id":"llKyDc","date":"1576221630","viewed":61,"name":"Examples Of 2D Noise","description":"2d\u566A\u58F0\u793A\u4F8B","likes":6,"published":"Public","tags":["2d","noise"]},"renderpass":[{"Code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Eye-2D","id":"3dyXDt","date":"0","viewed":0,"name":"Eye-2D","description":"Eye-2D","likes":0,"published":"Private","tags":["2dmodel"]},"ver":"0.1","info":{"Name":"Eye-2D","id":"3dyXDt","date":"0","viewed":0,"name":"Eye-2D","description":"Eye-2D","likes":0,"published":"Private","tags":["2dmodel"]},"renderpass":[{"Code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"fbm test1","id":"wsyXDV","date":"0","viewed":0,"name":"fbm test1","description":"math fbm noise","likes":0,"published":"Private","tags":["mathfbmnoise"]},"ver":"0.1","info":{"Name":"fbm test1","id":"wsyXDV","date":"0","viewed":0,"name":"fbm test1","description":"math fbm noise","likes":0,"published":"Private","tags":["mathfbmnoise"]},"renderpass":[{"Code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// from star shader https://www.shadertoy.com/view/Xty3zc\r\n\r\n\r\n#define rnd(x)  fract( 4356.17 * sin( 1e4*x ) )\r\n#define srnd(x) ( 2.* rnd(x) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n    float r, t = iTime,t1,v;\r\n    vec2 R = iResolution.xy, P;\r\n    U =  (2.*U-R) / R.y;\r\n\r\n    O -= O;\r\n    \r\n  if (abs(U.x)<1.25*cos(1.2*(.5+.5*U.y))) // clamp out of the flame profile\r\n    for(float i=0.; i<3.*256.; i++) {\r\n       t1 = t + 6.28*rnd(i);\r\n        v = 2.+srnd(i+.7);\r\n        r = cos(1.4*fract(t1)) * (.2+rnd(i+.1));    \r\n        P = vec2(   cos(t1*v)*r ,          // particle location\r\n                 .2*sin (t1*v)*r + 2.*pow(fract(t1),1.5)-1.   ), \r\n        r = length(P-U),\r\n\t    O += U.x<0. \r\n             ? 1e-4 / pow(r,3.)            // pix = clamp ( Emit/dist^2 * Bessel )\r\n             : smoothstep(1.,.8, r*20.);   // pix = disk ( R/dist )\r\n    }\r\n    \r\n    O *= vec4(1,.5,.2,1);                  // color  \r\n    \r\n  //O += .3*texture(iChannel0,vec3(-U,-1));\r\n}","inputs":[],"outputs":[],"code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// from star shader https://www.shadertoy.com/view/Xty3zc\r\n\r\n\r\n#define rnd(x)  fract( 4356.17 * sin( 1e4*x ) )\r\n#define srnd(x) ( 2.* rnd(x) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n    float r, t = iTime,t1,v;\r\n    vec2 R = iResolution.xy, P;\r\n    U =  (2.*U-R) / R.y;\r\n\r\n    O -= O;\r\n    \r\n  if (abs(U.x)<1.25*cos(1.2*(.5+.5*U.y))) // clamp out of the flame profile\r\n    for(float i=0.; i<3.*256.; i++) {\r\n       t1 = t + 6.28*rnd(i);\r\n        v = 2.+srnd(i+.7);\r\n        r = cos(1.4*fract(t1)) * (.2+rnd(i+.1));    \r\n        P = vec2(   cos(t1*v)*r ,          // particle location\r\n                 .2*sin (t1*v)*r + 2.*pow(fract(t1),1.5)-1.   ), \r\n        r = length(P-U),\r\n\t    O += U.x<0. \r\n             ? 1e-4 / pow(r,3.)            // pix = clamp ( Emit/dist^2 * Bessel )\r\n             : smoothstep(1.,.8, r*20.);   // pix = disk ( R/dist )\r\n    }\r\n    \r\n    O *= vec4(1,.5,.2,1);                  // color  \r\n    \r\n  //O += .3*texture(iChannel0,vec3(-U,-1));\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"fire particles - PSF+saturation","id":"ffbf1ee3a163422982f3e5ff093660f1","date":null,"viewed":0,"name":"fire particles - PSF+saturation","description":"Accounting for blooming+saturation effect\r\nhttps://www.shadertoy.com/view/MlG3R3","likes":0,"published":null,"tags":["psf"," sensor"]},"ver":null,"info":{"Name":"fire particles - PSF+saturation","id":"ffbf1ee3a163422982f3e5ff093660f1","date":null,"viewed":0,"name":"fire particles - PSF+saturation","description":"Accounting for blooming+saturation effect\r\nhttps://www.shadertoy.com/view/MlG3R3","likes":0,"published":null,"tags":["psf"," sensor"]},"renderpass":[{"Code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// from star shader https://www.shadertoy.com/view/Xty3zc\r\n\r\n\r\n#define rnd(x)  fract( 4356.17 * sin( 1e4*x ) )\r\n#define srnd(x) ( 2.* rnd(x) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n    float r, t = iTime,t1,v;\r\n    vec2 R = iResolution.xy, P;\r\n    U =  (2.*U-R) / R.y;\r\n\r\n    O -= O;\r\n    \r\n  if (abs(U.x)<1.25*cos(1.2*(.5+.5*U.y))) // clamp out of the flame profile\r\n    for(float i=0.; i<3.*256.; i++) {\r\n       t1 = t + 6.28*rnd(i);\r\n        v = 2.+srnd(i+.7);\r\n        r = cos(1.4*fract(t1)) * (.2+rnd(i+.1));    \r\n        P = vec2(   cos(t1*v)*r ,          // particle location\r\n                 .2*sin (t1*v)*r + 2.*pow(fract(t1),1.5)-1.   ), \r\n        r = length(P-U),\r\n\t    O += U.x<0. \r\n             ? 1e-4 / pow(r,3.)            // pix = clamp ( Emit/dist^2 * Bessel )\r\n             : smoothstep(1.,.8, r*20.);   // pix = disk ( R/dist )\r\n    }\r\n    \r\n    O *= vec4(1,.5,.2,1);                  // color  \r\n    \r\n  //O += .3*texture(iChannel0,vec3(-U,-1));\r\n}","inputs":[],"outputs":[],"code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// from star shader https://www.shadertoy.com/view/Xty3zc\r\n\r\n\r\n#define rnd(x)  fract( 4356.17 * sin( 1e4*x ) )\r\n#define srnd(x) ( 2.* rnd(x) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n    float r, t = iTime,t1,v;\r\n    vec2 R = iResolution.xy, P;\r\n    U =  (2.*U-R) / R.y;\r\n\r\n    O -= O;\r\n    \r\n  if (abs(U.x)<1.25*cos(1.2*(.5+.5*U.y))) // clamp out of the flame profile\r\n    for(float i=0.; i<3.*256.; i++) {\r\n       t1 = t + 6.28*rnd(i);\r\n        v = 2.+srnd(i+.7);\r\n        r = cos(1.4*fract(t1)) * (.2+rnd(i+.1));    \r\n        P = vec2(   cos(t1*v)*r ,          // particle location\r\n                 .2*sin (t1*v)*r + 2.*pow(fract(t1),1.5)-1.   ), \r\n        r = length(P-U),\r\n\t    O += U.x<0. \r\n             ? 1e-4 / pow(r,3.)            // pix = clamp ( Emit/dist^2 * Bessel )\r\n             : smoothstep(1.,.8, r*20.);   // pix = disk ( R/dist )\r\n    }\r\n    \r\n    O *= vec4(1,.5,.2,1);                  // color  \r\n    \r\n  //O += .3*texture(iChannel0,vec3(-U,-1));\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// see \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\r\n\r\n// noise-based variant: https://www.shadertoy.com/view/Xl3Gzj\r\n\r\n#define r 1.5 // test distance      for efficiency, as small as it keep covering influencials river sides \r\n#define c 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\r\n\r\n#define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\r\n    \r\nfloat f(float d) { // interpolation function\r\n    float t = 1.-d/r;\r\n    return t<0. ? 0. :pow(d,-c)*(6.*t*t-15.*t+10.)*t*t*t;\r\n}\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.y;\r\n    \r\n    // --- interpolate stream function : add(distance to border, stream at border)\r\n    float t = iTime,wf=0.,wT=0., w; \r\n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\r\n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\r\n    add( length( U-vec2(.0+.2*sin(t) , .8)    ) -.3, 0.);   // rock1 stream=0.\r\n    add( length( U-vec2(.3+.2*sin(t) , .5)    ) -.3, 0.);\r\n    add( length( U-vec2(1.3, .8+.2*cos(2.*t)) ) -.5, .5);   // rock2 stream=.5\r\n    add( length( U-vec2(.8+.2*cos(.5*t), -.2) ) -.4, 1.);   // rock3 stream=1.\r\n    add( length( U-vec2(1.7, .15)             ) -.1,  .75); // rock4 stream=.75\r\n    w = wf / wT;                               // stream field\r\n    vec2 V = vec2(-dFdy(w), dFdx(w));          // velocity field\r\n    \r\n    // --- display\r\n    if (w!=w) { O =  vec4(.5,0,0,0); return; } // in rocks   ( w!=w = NaN )\r\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\r\n\r\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\r\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\r\n}","inputs":[],"outputs":[],"code":"// see \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\r\n\r\n// noise-based variant: https://www.shadertoy.com/view/Xl3Gzj\r\n\r\n#define r 1.5 // test distance      for efficiency, as small as it keep covering influencials river sides \r\n#define c 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\r\n\r\n#define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\r\n    \r\nfloat f(float d) { // interpolation function\r\n    float t = 1.-d/r;\r\n    return t<0. ? 0. :pow(d,-c)*(6.*t*t-15.*t+10.)*t*t*t;\r\n}\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.y;\r\n    \r\n    // --- interpolate stream function : add(distance to border, stream at border)\r\n    float t = iTime,wf=0.,wT=0., w; \r\n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\r\n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\r\n    add( length( U-vec2(.0+.2*sin(t) , .8)    ) -.3, 0.);   // rock1 stream=0.\r\n    add( length( U-vec2(.3+.2*sin(t) , .5)    ) -.3, 0.);\r\n    add( length( U-vec2(1.3, .8+.2*cos(2.*t)) ) -.5, .5);   // rock2 stream=.5\r\n    add( length( U-vec2(.8+.2*cos(.5*t), -.2) ) -.4, 1.);   // rock3 stream=1.\r\n    add( length( U-vec2(1.7, .15)             ) -.1,  .75); // rock4 stream=.75\r\n    w = wf / wT;                               // stream field\r\n    vec2 V = vec2(-dFdy(w), dFdx(w));          // velocity field\r\n    \r\n    // --- display\r\n    if (w!=w) { O =  vec4(.5,0,0,0); return; } // in rocks   ( w!=w = NaN )\r\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\r\n\r\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\r\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"flow by stream function ","id":"b21e193b17d741298a17d8b740377dc3","date":null,"viewed":0,"name":"flow by stream function ","description":"flow by stream function. see https://hal.inria.fr/inria-00345903/\nhttps://www.shadertoy.com/view/ldtSzn","likes":0,"published":null,"tags":["fluid"," flow"," short"," stream"]},"ver":null,"info":{"Name":"flow by stream function ","id":"b21e193b17d741298a17d8b740377dc3","date":null,"viewed":0,"name":"flow by stream function ","description":"flow by stream function. see https://hal.inria.fr/inria-00345903/\nhttps://www.shadertoy.com/view/ldtSzn","likes":0,"published":null,"tags":["fluid"," flow"," short"," stream"]},"renderpass":[{"Code":"// see \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\r\n\r\n// noise-based variant: https://www.shadertoy.com/view/Xl3Gzj\r\n\r\n#define r 1.5 // test distance      for efficiency, as small as it keep covering influencials river sides \r\n#define c 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\r\n\r\n#define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\r\n    \r\nfloat f(float d) { // interpolation function\r\n    float t = 1.-d/r;\r\n    return t<0. ? 0. :pow(d,-c)*(6.*t*t-15.*t+10.)*t*t*t;\r\n}\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.y;\r\n    \r\n    // --- interpolate stream function : add(distance to border, stream at border)\r\n    float t = iTime,wf=0.,wT=0., w; \r\n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\r\n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\r\n    add( length( U-vec2(.0+.2*sin(t) , .8)    ) -.3, 0.);   // rock1 stream=0.\r\n    add( length( U-vec2(.3+.2*sin(t) , .5)    ) -.3, 0.);\r\n    add( length( U-vec2(1.3, .8+.2*cos(2.*t)) ) -.5, .5);   // rock2 stream=.5\r\n    add( length( U-vec2(.8+.2*cos(.5*t), -.2) ) -.4, 1.);   // rock3 stream=1.\r\n    add( length( U-vec2(1.7, .15)             ) -.1,  .75); // rock4 stream=.75\r\n    w = wf / wT;                               // stream field\r\n    vec2 V = vec2(-dFdy(w), dFdx(w));          // velocity field\r\n    \r\n    // --- display\r\n    if (w!=w) { O =  vec4(.5,0,0,0); return; } // in rocks   ( w!=w = NaN )\r\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\r\n\r\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\r\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\r\n}","inputs":[],"outputs":[],"code":"// see \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\r\n\r\n// noise-based variant: https://www.shadertoy.com/view/Xl3Gzj\r\n\r\n#define r 1.5 // test distance      for efficiency, as small as it keep covering influencials river sides \r\n#define c 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\r\n\r\n#define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\r\n    \r\nfloat f(float d) { // interpolation function\r\n    float t = 1.-d/r;\r\n    return t<0. ? 0. :pow(d,-c)*(6.*t*t-15.*t+10.)*t*t*t;\r\n}\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.y;\r\n    \r\n    // --- interpolate stream function : add(distance to border, stream at border)\r\n    float t = iTime,wf=0.,wT=0., w; \r\n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\r\n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\r\n    add( length( U-vec2(.0+.2*sin(t) , .8)    ) -.3, 0.);   // rock1 stream=0.\r\n    add( length( U-vec2(.3+.2*sin(t) , .5)    ) -.3, 0.);\r\n    add( length( U-vec2(1.3, .8+.2*cos(2.*t)) ) -.5, .5);   // rock2 stream=.5\r\n    add( length( U-vec2(.8+.2*cos(.5*t), -.2) ) -.4, 1.);   // rock3 stream=1.\r\n    add( length( U-vec2(1.7, .15)             ) -.1,  .75); // rock4 stream=.75\r\n    w = wf / wT;                               // stream field\r\n    vec2 V = vec2(-dFdy(w), dFdx(w));          // velocity field\r\n    \r\n    // --- display\r\n    if (w!=w) { O =  vec4(.5,0,0,0); return; } // in rocks   ( w!=w = NaN )\r\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\r\n\r\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\r\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//yibojiang, 2015-8-30\r\n#define pi 3.1415926\r\n#define flyCount 40\r\n\r\nfloat pingPong(float v) {\r\n\r\n  const float amplitude = 1.;\r\n  const float t = pi * 2.0;\r\n  float k = 4.0*amplitude / t;\r\n  float r = mod( v  , t);\r\n  float d = floor(v / (0.5 * t) );\r\n  return mix(k * r - amplitude ,  amplitude * 3. - k * r , mod(d, 2.0));\r\n\r\n}\r\n\r\nfloat getRad(vec2 q) {\r\n  return atan(q.y, q.x);\r\n}\r\n\r\nvec2 hash(vec2 p)\r\n{\r\n  p = vec2( dot(p, vec2(127.1, 311.7)),\r\n            dot(p, vec2(269.5, 183.3)) );\r\n  return -1. + 2.*fract(sin(p) * 53758.5453123);\r\n}\r\n\r\nvec2 noise(vec2 tc) {\r\n  return hash(tc);\r\n}\r\n\r\nfloat firefly(vec2 p, float size) {\r\n  return smoothstep(0.0, size, length(p) );\r\n\r\n}\r\n\r\nconst float pow = 1.0;\r\nconst float flySpeed = 0.1;\r\nconst float duration = 1.0;\r\n\r\nvec3 drawFlower(vec3 col, vec2 p, vec2 flowerP, float t, float count, float ratio)\r\n{\r\n  \r\n  vec2 q = p - flowerP - vec2( pow * 0.008 * cos(3.0*iTime) , pow * 0.008 * sin(3.0*iTime) ) ;\r\n  vec2 rootP = p - flowerP - vec2( pow * 0.02 * cos(3.0*iTime) * p.y , -0.48 + pow * 0.008 * sin(3.0*iTime) );\r\n  q.y *= ratio;\r\n  //draw stem\r\n  float width = 0.01;\r\n  float h = 0.5;\r\n  float w = 0.0005;\r\n\r\n  col = mix(vec3(0.5, 0.7, 0.4), col, \r\n            1.0 - (1.0 - smoothstep(h, h + width, abs(rootP.y)))\r\n            * (1.0 - smoothstep(w, w + width, abs(rootP.x - 0.1 * sin(4.0 * rootP.y + pi * 0.35)))));\r\n\r\n  //draw flower\r\n  vec3 flowerCol = mix(vec3(0.7, 0.7, 0.2), vec3(0.7, 0.9, 0.7), smoothstep(0.0, 1.0, length(q) * 10.0));\r\n\r\n  float r = 0.1 + 0.05 * ( pingPong( getRad( q ) * count  + 2.*q.x * (t - duration)  )  );\r\n\r\n  col = mix(flowerCol, col, smoothstep(r, r + 0.02,  length(q)));\r\n\r\n  //draw buds\r\n  float r1 = 0.04;\r\n  vec3 budCol = mix (vec3(.3, .4, 0.), vec3(.9, .8, 0.), length(q) * 10.0);\r\n  col = mix(budCol, col, smoothstep(r1, r1 + 0.01,  length(q)));\r\n  return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n  \r\n  float t = duration * (1. + sin(3.0 * iTime ) );\r\n\r\n  vec2 p = fragCoord.xy / iResolution.xy;\r\n\r\n  float ratio = iResolution.y / iResolution.x;\r\n\r\n  vec2 uv = p;\r\n  uv.y *= ratio;\r\n\r\n  //vec2 flowerP = ;\r\n  \r\n  //sky\r\n  vec3 col = mix( vec3(0.1, 0.6, 0.5), vec3(0.2, 0.1, 0.2), sqrt(p.y) * .6 );\r\n  col = mix(drawFlower(col, p, vec2(0.618, 0.518), t, 7.0, ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n  col = mix(drawFlower(col, p, vec2(0.418, 0.418), t*4.0, 6.0, ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n  col = mix(drawFlower(col, p, vec2(0.818, 0.318), t*2.0, 8., ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n\r\n  for (int ii = 0; ii < flyCount; ii++) {\r\n    float i = float(ii);\r\n    float seed = i / float(flyCount);\r\n    float t1 = 1.0*(1. + sin(noise(vec2(seed) ).x * iTime));\r\n    vec2 fireflyP = uv - vec2(noise(vec2(seed) ).x + noise(vec2(seed) ).y * t1 * flySpeed, noise(vec2(seed) ).y + noise(vec2(seed) ).y * t1 * flySpeed);\r\n    float fly = firefly( fireflyP, 0.002 + 0.008 * seed );\r\n    vec3 flyCol = mix(vec3(0.1, 0.9, 0.1) * t1, vec3(0.0), fly );\r\n    col += flyCol;\r\n  }\r\n  fragColor = vec4(col, 0.);\r\n}","inputs":[],"outputs":[],"code":"//yibojiang, 2015-8-30\r\n#define pi 3.1415926\r\n#define flyCount 40\r\n\r\nfloat pingPong(float v) {\r\n\r\n  const float amplitude = 1.;\r\n  const float t = pi * 2.0;\r\n  float k = 4.0*amplitude / t;\r\n  float r = mod( v  , t);\r\n  float d = floor(v / (0.5 * t) );\r\n  return mix(k * r - amplitude ,  amplitude * 3. - k * r , mod(d, 2.0));\r\n\r\n}\r\n\r\nfloat getRad(vec2 q) {\r\n  return atan(q.y, q.x);\r\n}\r\n\r\nvec2 hash(vec2 p)\r\n{\r\n  p = vec2( dot(p, vec2(127.1, 311.7)),\r\n            dot(p, vec2(269.5, 183.3)) );\r\n  return -1. + 2.*fract(sin(p) * 53758.5453123);\r\n}\r\n\r\nvec2 noise(vec2 tc) {\r\n  return hash(tc);\r\n}\r\n\r\nfloat firefly(vec2 p, float size) {\r\n  return smoothstep(0.0, size, length(p) );\r\n\r\n}\r\n\r\nconst float pow = 1.0;\r\nconst float flySpeed = 0.1;\r\nconst float duration = 1.0;\r\n\r\nvec3 drawFlower(vec3 col, vec2 p, vec2 flowerP, float t, float count, float ratio)\r\n{\r\n  \r\n  vec2 q = p - flowerP - vec2( pow * 0.008 * cos(3.0*iTime) , pow * 0.008 * sin(3.0*iTime) ) ;\r\n  vec2 rootP = p - flowerP - vec2( pow * 0.02 * cos(3.0*iTime) * p.y , -0.48 + pow * 0.008 * sin(3.0*iTime) );\r\n  q.y *= ratio;\r\n  //draw stem\r\n  float width = 0.01;\r\n  float h = 0.5;\r\n  float w = 0.0005;\r\n\r\n  col = mix(vec3(0.5, 0.7, 0.4), col, \r\n            1.0 - (1.0 - smoothstep(h, h + width, abs(rootP.y)))\r\n            * (1.0 - smoothstep(w, w + width, abs(rootP.x - 0.1 * sin(4.0 * rootP.y + pi * 0.35)))));\r\n\r\n  //draw flower\r\n  vec3 flowerCol = mix(vec3(0.7, 0.7, 0.2), vec3(0.7, 0.9, 0.7), smoothstep(0.0, 1.0, length(q) * 10.0));\r\n\r\n  float r = 0.1 + 0.05 * ( pingPong( getRad( q ) * count  + 2.*q.x * (t - duration)  )  );\r\n\r\n  col = mix(flowerCol, col, smoothstep(r, r + 0.02,  length(q)));\r\n\r\n  //draw buds\r\n  float r1 = 0.04;\r\n  vec3 budCol = mix (vec3(.3, .4, 0.), vec3(.9, .8, 0.), length(q) * 10.0);\r\n  col = mix(budCol, col, smoothstep(r1, r1 + 0.01,  length(q)));\r\n  return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n  \r\n  float t = duration * (1. + sin(3.0 * iTime ) );\r\n\r\n  vec2 p = fragCoord.xy / iResolution.xy;\r\n\r\n  float ratio = iResolution.y / iResolution.x;\r\n\r\n  vec2 uv = p;\r\n  uv.y *= ratio;\r\n\r\n  //vec2 flowerP = ;\r\n  \r\n  //sky\r\n  vec3 col = mix( vec3(0.1, 0.6, 0.5), vec3(0.2, 0.1, 0.2), sqrt(p.y) * .6 );\r\n  col = mix(drawFlower(col, p, vec2(0.618, 0.518), t, 7.0, ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n  col = mix(drawFlower(col, p, vec2(0.418, 0.418), t*4.0, 6.0, ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n  col = mix(drawFlower(col, p, vec2(0.818, 0.318), t*2.0, 8., ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n\r\n  for (int ii = 0; ii < flyCount; ii++) {\r\n    float i = float(ii);\r\n    float seed = i / float(flyCount);\r\n    float t1 = 1.0*(1. + sin(noise(vec2(seed) ).x * iTime));\r\n    vec2 fireflyP = uv - vec2(noise(vec2(seed) ).x + noise(vec2(seed) ).y * t1 * flySpeed, noise(vec2(seed) ).y + noise(vec2(seed) ).y * t1 * flySpeed);\r\n    float fly = firefly( fireflyP, 0.002 + 0.008 * seed );\r\n    vec3 flyCol = mix(vec3(0.1, 0.9, 0.1) * t1, vec3(0.0), fly );\r\n    col += flyCol;\r\n  }\r\n  fragColor = vec4(col, 0.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Flower at night","id":"d9532161ae1845d39d0e5e323131086f","date":null,"viewed":0,"name":"Flower at night","description":"experiment math painting ","likes":0,"published":null,"tags":["flower"," pattern"]},"ver":null,"info":{"Name":"Flower at night","id":"d9532161ae1845d39d0e5e323131086f","date":null,"viewed":0,"name":"Flower at night","description":"experiment math painting ","likes":0,"published":null,"tags":["flower"," pattern"]},"renderpass":[{"Code":"//yibojiang, 2015-8-30\r\n#define pi 3.1415926\r\n#define flyCount 40\r\n\r\nfloat pingPong(float v) {\r\n\r\n  const float amplitude = 1.;\r\n  const float t = pi * 2.0;\r\n  float k = 4.0*amplitude / t;\r\n  float r = mod( v  , t);\r\n  float d = floor(v / (0.5 * t) );\r\n  return mix(k * r - amplitude ,  amplitude * 3. - k * r , mod(d, 2.0));\r\n\r\n}\r\n\r\nfloat getRad(vec2 q) {\r\n  return atan(q.y, q.x);\r\n}\r\n\r\nvec2 hash(vec2 p)\r\n{\r\n  p = vec2( dot(p, vec2(127.1, 311.7)),\r\n            dot(p, vec2(269.5, 183.3)) );\r\n  return -1. + 2.*fract(sin(p) * 53758.5453123);\r\n}\r\n\r\nvec2 noise(vec2 tc) {\r\n  return hash(tc);\r\n}\r\n\r\nfloat firefly(vec2 p, float size) {\r\n  return smoothstep(0.0, size, length(p) );\r\n\r\n}\r\n\r\nconst float pow = 1.0;\r\nconst float flySpeed = 0.1;\r\nconst float duration = 1.0;\r\n\r\nvec3 drawFlower(vec3 col, vec2 p, vec2 flowerP, float t, float count, float ratio)\r\n{\r\n  \r\n  vec2 q = p - flowerP - vec2( pow * 0.008 * cos(3.0*iTime) , pow * 0.008 * sin(3.0*iTime) ) ;\r\n  vec2 rootP = p - flowerP - vec2( pow * 0.02 * cos(3.0*iTime) * p.y , -0.48 + pow * 0.008 * sin(3.0*iTime) );\r\n  q.y *= ratio;\r\n  //draw stem\r\n  float width = 0.01;\r\n  float h = 0.5;\r\n  float w = 0.0005;\r\n\r\n  col = mix(vec3(0.5, 0.7, 0.4), col, \r\n            1.0 - (1.0 - smoothstep(h, h + width, abs(rootP.y)))\r\n            * (1.0 - smoothstep(w, w + width, abs(rootP.x - 0.1 * sin(4.0 * rootP.y + pi * 0.35)))));\r\n\r\n  //draw flower\r\n  vec3 flowerCol = mix(vec3(0.7, 0.7, 0.2), vec3(0.7, 0.9, 0.7), smoothstep(0.0, 1.0, length(q) * 10.0));\r\n\r\n  float r = 0.1 + 0.05 * ( pingPong( getRad( q ) * count  + 2.*q.x * (t - duration)  )  );\r\n\r\n  col = mix(flowerCol, col, smoothstep(r, r + 0.02,  length(q)));\r\n\r\n  //draw buds\r\n  float r1 = 0.04;\r\n  vec3 budCol = mix (vec3(.3, .4, 0.), vec3(.9, .8, 0.), length(q) * 10.0);\r\n  col = mix(budCol, col, smoothstep(r1, r1 + 0.01,  length(q)));\r\n  return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n  \r\n  float t = duration * (1. + sin(3.0 * iTime ) );\r\n\r\n  vec2 p = fragCoord.xy / iResolution.xy;\r\n\r\n  float ratio = iResolution.y / iResolution.x;\r\n\r\n  vec2 uv = p;\r\n  uv.y *= ratio;\r\n\r\n  //vec2 flowerP = ;\r\n  \r\n  //sky\r\n  vec3 col = mix( vec3(0.1, 0.6, 0.5), vec3(0.2, 0.1, 0.2), sqrt(p.y) * .6 );\r\n  col = mix(drawFlower(col, p, vec2(0.618, 0.518), t, 7.0, ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n  col = mix(drawFlower(col, p, vec2(0.418, 0.418), t*4.0, 6.0, ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n  col = mix(drawFlower(col, p, vec2(0.818, 0.318), t*2.0, 8., ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n\r\n  for (int ii = 0; ii < flyCount; ii++) {\r\n    float i = float(ii);\r\n    float seed = i / float(flyCount);\r\n    float t1 = 1.0*(1. + sin(noise(vec2(seed) ).x * iTime));\r\n    vec2 fireflyP = uv - vec2(noise(vec2(seed) ).x + noise(vec2(seed) ).y * t1 * flySpeed, noise(vec2(seed) ).y + noise(vec2(seed) ).y * t1 * flySpeed);\r\n    float fly = firefly( fireflyP, 0.002 + 0.008 * seed );\r\n    vec3 flyCol = mix(vec3(0.1, 0.9, 0.1) * t1, vec3(0.0), fly );\r\n    col += flyCol;\r\n  }\r\n  fragColor = vec4(col, 0.);\r\n}","inputs":[],"outputs":[],"code":"//yibojiang, 2015-8-30\r\n#define pi 3.1415926\r\n#define flyCount 40\r\n\r\nfloat pingPong(float v) {\r\n\r\n  const float amplitude = 1.;\r\n  const float t = pi * 2.0;\r\n  float k = 4.0*amplitude / t;\r\n  float r = mod( v  , t);\r\n  float d = floor(v / (0.5 * t) );\r\n  return mix(k * r - amplitude ,  amplitude * 3. - k * r , mod(d, 2.0));\r\n\r\n}\r\n\r\nfloat getRad(vec2 q) {\r\n  return atan(q.y, q.x);\r\n}\r\n\r\nvec2 hash(vec2 p)\r\n{\r\n  p = vec2( dot(p, vec2(127.1, 311.7)),\r\n            dot(p, vec2(269.5, 183.3)) );\r\n  return -1. + 2.*fract(sin(p) * 53758.5453123);\r\n}\r\n\r\nvec2 noise(vec2 tc) {\r\n  return hash(tc);\r\n}\r\n\r\nfloat firefly(vec2 p, float size) {\r\n  return smoothstep(0.0, size, length(p) );\r\n\r\n}\r\n\r\nconst float pow = 1.0;\r\nconst float flySpeed = 0.1;\r\nconst float duration = 1.0;\r\n\r\nvec3 drawFlower(vec3 col, vec2 p, vec2 flowerP, float t, float count, float ratio)\r\n{\r\n  \r\n  vec2 q = p - flowerP - vec2( pow * 0.008 * cos(3.0*iTime) , pow * 0.008 * sin(3.0*iTime) ) ;\r\n  vec2 rootP = p - flowerP - vec2( pow * 0.02 * cos(3.0*iTime) * p.y , -0.48 + pow * 0.008 * sin(3.0*iTime) );\r\n  q.y *= ratio;\r\n  //draw stem\r\n  float width = 0.01;\r\n  float h = 0.5;\r\n  float w = 0.0005;\r\n\r\n  col = mix(vec3(0.5, 0.7, 0.4), col, \r\n            1.0 - (1.0 - smoothstep(h, h + width, abs(rootP.y)))\r\n            * (1.0 - smoothstep(w, w + width, abs(rootP.x - 0.1 * sin(4.0 * rootP.y + pi * 0.35)))));\r\n\r\n  //draw flower\r\n  vec3 flowerCol = mix(vec3(0.7, 0.7, 0.2), vec3(0.7, 0.9, 0.7), smoothstep(0.0, 1.0, length(q) * 10.0));\r\n\r\n  float r = 0.1 + 0.05 * ( pingPong( getRad( q ) * count  + 2.*q.x * (t - duration)  )  );\r\n\r\n  col = mix(flowerCol, col, smoothstep(r, r + 0.02,  length(q)));\r\n\r\n  //draw buds\r\n  float r1 = 0.04;\r\n  vec3 budCol = mix (vec3(.3, .4, 0.), vec3(.9, .8, 0.), length(q) * 10.0);\r\n  col = mix(budCol, col, smoothstep(r1, r1 + 0.01,  length(q)));\r\n  return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n  \r\n  float t = duration * (1. + sin(3.0 * iTime ) );\r\n\r\n  vec2 p = fragCoord.xy / iResolution.xy;\r\n\r\n  float ratio = iResolution.y / iResolution.x;\r\n\r\n  vec2 uv = p;\r\n  uv.y *= ratio;\r\n\r\n  //vec2 flowerP = ;\r\n  \r\n  //sky\r\n  vec3 col = mix( vec3(0.1, 0.6, 0.5), vec3(0.2, 0.1, 0.2), sqrt(p.y) * .6 );\r\n  col = mix(drawFlower(col, p, vec2(0.618, 0.518), t, 7.0, ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n  col = mix(drawFlower(col, p, vec2(0.418, 0.418), t*4.0, 6.0, ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n  col = mix(drawFlower(col, p, vec2(0.818, 0.318), t*2.0, 8., ratio), col, 1.0 - smoothstep(0.0, 0.01, length(p)));\r\n\r\n  for (int ii = 0; ii < flyCount; ii++) {\r\n    float i = float(ii);\r\n    float seed = i / float(flyCount);\r\n    float t1 = 1.0*(1. + sin(noise(vec2(seed) ).x * iTime));\r\n    vec2 fireflyP = uv - vec2(noise(vec2(seed) ).x + noise(vec2(seed) ).y * t1 * flySpeed, noise(vec2(seed) ).y + noise(vec2(seed) ).y * t1 * flySpeed);\r\n    float fly = firefly( fireflyP, 0.002 + 0.008 * seed );\r\n    vec3 flyCol = mix(vec3(0.1, 0.9, 0.1) * t1, vec3(0.0), fly );\r\n    col += flyCol;\r\n  }\r\n  fragColor = vec4(col, 0.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define RAYMARCH_ITERATIONS 60.0\r\n#define TIME (iTime * 0.4)\r\n#define LINE_LENGTH 1.0\r\n#define LINE_SPACE 1.0\r\n#define LINE_WIDTH 0.007\r\n#define BOUNDING_CYLINDER 1.8\r\n#define INSIDE_CYLINDER 0.32\r\n#define EPS 0.0001\r\n#define FOG_DISTANCE 30.0\r\n\r\n#define FIRST_COLOR vec3(1.2, 0.5, 0.2) * 1.2\r\n#define SECOND_COLOR vec3(0.2, 0.8, 1.1)\r\n\r\nfloat hash12(vec2 x)\r\n{\r\n \treturn fract(sin(dot(x, vec2(42.2347, 43.4271))) * 342.324234);   \r\n}\r\n\r\nvec2 hash22(vec2 x)\r\n{\r\n \treturn fract(sin(x * mat2x2(23.421, 24.4217, 25.3271, 27.2412)) * 342.324234);   \r\n}\r\n\r\nvec3 hash33(vec3 x)\r\n{\r\n \treturn fract(sin(x * mat3x3(23.421, 24.4217, 25.3271, 27.2412, 32.21731, 21.27641, 20.421, 27.4217, 22.3271)) * 342.324234);   \r\n}\r\n\r\n\r\nmat3x3 rotationMatrix(vec3 angle)\r\n{\r\n \treturn \tmat3x3(cos(angle.z), sin(angle.z), 0.0,\r\n                 -sin(angle.z), cos(angle.z), 0.0,\r\n                 0.0, 0.0, 1.0)\r\n        \t* mat3x3(1.0, 0.0, 0.0,\r\n                    0.0, cos(angle.x), sin(angle.x),\r\n                    0.0, -sin(angle.x), cos(angle.x))\r\n        \t* mat3x3(cos(angle.y), 0.0, sin(angle.y),\r\n                    0.0, 1.0, 0.0,\r\n                    -sin(angle.y), 0.0, cos(angle.y));\r\n}\r\n\r\n//Shader License: CC BY 3.0\r\n//Author: Jan Mr\u00F3z (jaszunio15)\r\n\r\nvec3 castPlanePoint(vec2 fragCoord)\r\n{\r\n \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\r\n    return vec3(uv.x, uv.y, -1.0);\r\n}\r\n\r\nfloat planeSDF(vec3 point)\r\n{\r\n \treturn point.y;\r\n}\r\n\r\n//source https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat boxSDF( vec3 point, vec3 bounds )\r\n{\r\n    vec3 q = abs(point) - bounds;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\n//rgb - colors\r\n//a - sdf\r\nvec4 repeatBoxSDF(vec3 point)\r\n{\r\n    vec3 rootPoint = floor(vec3(point.x / LINE_SPACE, point.y / LINE_SPACE, point.z / LINE_LENGTH)); \r\n    rootPoint.z *= LINE_LENGTH;\r\n    rootPoint.xy *= LINE_SPACE;\r\n    float minSDF = 10000.0;\r\n    vec3 mainColor = vec3(0.0);\r\n    \r\n    for (float x = -1.0; x <= 1.1; x++)\r\n    {\r\n        for (float y = -1.0; y <= 1.1; y++)\r\n        {\r\n\t\t\tfor (float z = -1.0; z <= 1.1; z++)\r\n            {\r\n\t\t\t\tvec3 tempRootPoint = rootPoint + vec3(x * LINE_SPACE, y * LINE_SPACE, z * LINE_LENGTH);\r\n                \r\n                vec3 lineHash = hash33(tempRootPoint);\r\n                lineHash.z = pow(lineHash.z, 10.0);\r\n                \r\n                float hash = hash12(tempRootPoint.xy) - 0.5;\r\n                tempRootPoint.z += hash * LINE_LENGTH;\r\n                \r\n                vec3 boxCenter = tempRootPoint + vec3(0.5 * LINE_SPACE, 0.5 * LINE_SPACE, 0.5 * LINE_LENGTH);\r\n                boxCenter.xy += (lineHash.xy - 0.5) * LINE_SPACE;\r\n                vec3 boxSize = vec3(LINE_WIDTH, LINE_WIDTH, LINE_LENGTH * (1.0 - lineHash.z));\r\n                \r\n                vec3 color = FIRST_COLOR;\r\n                if(lineHash.x < 0.5) color = SECOND_COLOR;\r\n                \r\n                float sdf = boxSDF(point - boxCenter, boxSize);\r\n                if (sdf < minSDF)\r\n                {\r\n                    mainColor = color;\r\n                    minSDF = sdf;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    return vec4(mainColor, minSDF);\r\n}\r\n\r\nfloat cylinderSDF(vec3 point, float radius)\r\n{\r\n \treturn length(point.xy) - radius;\r\n}\r\n\r\nfloat multiplyObjects(float o1, float o2)\r\n{\r\n \treturn max(o1, o2);   \r\n}\r\n\r\nvec3 spaceBounding(vec3 point)\r\n{\r\n \treturn vec3(sin(point.z * 0.15) * 5.0, cos(point.z * 0.131) * 5.0, 0.0); \r\n}\r\n\r\n//rgb - color,\r\n//a - sdf\r\nvec4 objectSDF(vec3 point)\r\n{\r\n    point += spaceBounding(point);\r\n    \r\n    vec4 lines = repeatBoxSDF(point);\r\n    float cylinder = cylinderSDF(point, BOUNDING_CYLINDER);\r\n    float insideCylinder = -cylinderSDF(point, INSIDE_CYLINDER);\r\n    \r\n    float object = multiplyObjects(lines.a, cylinder);\r\n    object = multiplyObjects(object, insideCylinder);\r\n \treturn vec4(lines.rgb, object);\r\n}\r\n\r\n\r\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDirection, out vec3 color)\r\n{\r\n    color = vec3(0.0);\r\n    float dist = 0.0;\r\n \tfor (float i = 0.0; i < RAYMARCH_ITERATIONS; i++)\r\n    {\r\n     \tvec4 sdfData = objectSDF(rayOrigin);\r\n        color += sdfData.rgb * sqrt(smoothstep(0.8, 0.0, sdfData.a)) * pow(smoothstep(FOG_DISTANCE * 0.6, 0.0, dist), 3.0) * 0.2;\r\n        rayOrigin += rayDirection * sdfData.a * 0.7;\r\n        dist += sdfData.a;\r\n        if (length(rayOrigin.xy) > BOUNDING_CYLINDER + 10.0) break;\r\n    }\r\n\r\n\r\n    return rayOrigin;\r\n}\r\n \r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 cameraCenter = vec3(0.0, 0.0, -TIME * 10.0);\r\n    cameraCenter -= spaceBounding(cameraCenter);\r\n    vec3 cameraAngle = vec3(0.0, 0.0, 0.0);\r\n    \r\n    vec3 prevCameraCenter = vec3(0.0, 0.0, -(TIME - 0.01) * 10.0);\r\n    prevCameraCenter -= spaceBounding(prevCameraCenter);\r\n    vec3 nextCameraCenter = vec3(0.0, 0.0, -(TIME + 0.4) * 10.0);\r\n    nextCameraCenter -= spaceBounding(nextCameraCenter);\r\n    \r\n    vec3 velocityVector = -normalize(nextCameraCenter - prevCameraCenter);\r\n    vec3 cameraUp = -normalize(cross(velocityVector, vec3(1.0, 0.0, 0.0)));\r\n    vec3 cameraRight = -(cross(velocityVector, cameraUp));\r\n    \r\n    \r\n    mat3x3 cameraRotation = mat3x3(cameraRight, cameraUp, velocityVector);\r\n    \r\n    vec3 rayOrigin = cameraCenter;\r\n    vec3 rayDirection = cameraRotation * normalize(castPlanePoint(fragCoord));\r\n    \r\n    vec3 color = vec3(0.0);\r\n    vec3 hitPoint = rayMarch(rayOrigin, rayDirection, color);\r\n    vec4 sdf = objectSDF(hitPoint);\r\n    \r\n    float vision = smoothstep(0.01, 0.0, sdf.a);\r\n    \r\n    float fog = sqrt(smoothstep(FOG_DISTANCE, 0.0, distance(cameraCenter, hitPoint)));\r\n    \r\n    vec3 ambient = mix(SECOND_COLOR, FIRST_COLOR, pow(sin(TIME) * 0.5 + 0.5, 2.0) * 0.6);\r\n    ambient *= sqrt((sin(TIME) + sin(TIME * 3.0)) * 0.25 + 1.0);\r\n    vec3 bloom = smoothstep(-0.0, 15.0, color);\r\n    \r\n    color = color * vision * 0.07 * fog + bloom + ambient * 0.3;\r\n    color = smoothstep(-0.01, 1.5, color * 1.1);\r\n    \r\n    fragColor = vec4(color, 1.0);\r\n}","inputs":[],"outputs":[],"code":"#define RAYMARCH_ITERATIONS 60.0\r\n#define TIME (iTime * 0.4)\r\n#define LINE_LENGTH 1.0\r\n#define LINE_SPACE 1.0\r\n#define LINE_WIDTH 0.007\r\n#define BOUNDING_CYLINDER 1.8\r\n#define INSIDE_CYLINDER 0.32\r\n#define EPS 0.0001\r\n#define FOG_DISTANCE 30.0\r\n\r\n#define FIRST_COLOR vec3(1.2, 0.5, 0.2) * 1.2\r\n#define SECOND_COLOR vec3(0.2, 0.8, 1.1)\r\n\r\nfloat hash12(vec2 x)\r\n{\r\n \treturn fract(sin(dot(x, vec2(42.2347, 43.4271))) * 342.324234);   \r\n}\r\n\r\nvec2 hash22(vec2 x)\r\n{\r\n \treturn fract(sin(x * mat2x2(23.421, 24.4217, 25.3271, 27.2412)) * 342.324234);   \r\n}\r\n\r\nvec3 hash33(vec3 x)\r\n{\r\n \treturn fract(sin(x * mat3x3(23.421, 24.4217, 25.3271, 27.2412, 32.21731, 21.27641, 20.421, 27.4217, 22.3271)) * 342.324234);   \r\n}\r\n\r\n\r\nmat3x3 rotationMatrix(vec3 angle)\r\n{\r\n \treturn \tmat3x3(cos(angle.z), sin(angle.z), 0.0,\r\n                 -sin(angle.z), cos(angle.z), 0.0,\r\n                 0.0, 0.0, 1.0)\r\n        \t* mat3x3(1.0, 0.0, 0.0,\r\n                    0.0, cos(angle.x), sin(angle.x),\r\n                    0.0, -sin(angle.x), cos(angle.x))\r\n        \t* mat3x3(cos(angle.y), 0.0, sin(angle.y),\r\n                    0.0, 1.0, 0.0,\r\n                    -sin(angle.y), 0.0, cos(angle.y));\r\n}\r\n\r\n//Shader License: CC BY 3.0\r\n//Author: Jan Mr\u00F3z (jaszunio15)\r\n\r\nvec3 castPlanePoint(vec2 fragCoord)\r\n{\r\n \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\r\n    return vec3(uv.x, uv.y, -1.0);\r\n}\r\n\r\nfloat planeSDF(vec3 point)\r\n{\r\n \treturn point.y;\r\n}\r\n\r\n//source https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat boxSDF( vec3 point, vec3 bounds )\r\n{\r\n    vec3 q = abs(point) - bounds;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\n//rgb - colors\r\n//a - sdf\r\nvec4 repeatBoxSDF(vec3 point)\r\n{\r\n    vec3 rootPoint = floor(vec3(point.x / LINE_SPACE, point.y / LINE_SPACE, point.z / LINE_LENGTH)); \r\n    rootPoint.z *= LINE_LENGTH;\r\n    rootPoint.xy *= LINE_SPACE;\r\n    float minSDF = 10000.0;\r\n    vec3 mainColor = vec3(0.0);\r\n    \r\n    for (float x = -1.0; x <= 1.1; x++)\r\n    {\r\n        for (float y = -1.0; y <= 1.1; y++)\r\n        {\r\n\t\t\tfor (float z = -1.0; z <= 1.1; z++)\r\n            {\r\n\t\t\t\tvec3 tempRootPoint = rootPoint + vec3(x * LINE_SPACE, y * LINE_SPACE, z * LINE_LENGTH);\r\n                \r\n                vec3 lineHash = hash33(tempRootPoint);\r\n                lineHash.z = pow(lineHash.z, 10.0);\r\n                \r\n                float hash = hash12(tempRootPoint.xy) - 0.5;\r\n                tempRootPoint.z += hash * LINE_LENGTH;\r\n                \r\n                vec3 boxCenter = tempRootPoint + vec3(0.5 * LINE_SPACE, 0.5 * LINE_SPACE, 0.5 * LINE_LENGTH);\r\n                boxCenter.xy += (lineHash.xy - 0.5) * LINE_SPACE;\r\n                vec3 boxSize = vec3(LINE_WIDTH, LINE_WIDTH, LINE_LENGTH * (1.0 - lineHash.z));\r\n                \r\n                vec3 color = FIRST_COLOR;\r\n                if(lineHash.x < 0.5) color = SECOND_COLOR;\r\n                \r\n                float sdf = boxSDF(point - boxCenter, boxSize);\r\n                if (sdf < minSDF)\r\n                {\r\n                    mainColor = color;\r\n                    minSDF = sdf;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    return vec4(mainColor, minSDF);\r\n}\r\n\r\nfloat cylinderSDF(vec3 point, float radius)\r\n{\r\n \treturn length(point.xy) - radius;\r\n}\r\n\r\nfloat multiplyObjects(float o1, float o2)\r\n{\r\n \treturn max(o1, o2);   \r\n}\r\n\r\nvec3 spaceBounding(vec3 point)\r\n{\r\n \treturn vec3(sin(point.z * 0.15) * 5.0, cos(point.z * 0.131) * 5.0, 0.0); \r\n}\r\n\r\n//rgb - color,\r\n//a - sdf\r\nvec4 objectSDF(vec3 point)\r\n{\r\n    point += spaceBounding(point);\r\n    \r\n    vec4 lines = repeatBoxSDF(point);\r\n    float cylinder = cylinderSDF(point, BOUNDING_CYLINDER);\r\n    float insideCylinder = -cylinderSDF(point, INSIDE_CYLINDER);\r\n    \r\n    float object = multiplyObjects(lines.a, cylinder);\r\n    object = multiplyObjects(object, insideCylinder);\r\n \treturn vec4(lines.rgb, object);\r\n}\r\n\r\n\r\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDirection, out vec3 color)\r\n{\r\n    color = vec3(0.0);\r\n    float dist = 0.0;\r\n \tfor (float i = 0.0; i < RAYMARCH_ITERATIONS; i++)\r\n    {\r\n     \tvec4 sdfData = objectSDF(rayOrigin);\r\n        color += sdfData.rgb * sqrt(smoothstep(0.8, 0.0, sdfData.a)) * pow(smoothstep(FOG_DISTANCE * 0.6, 0.0, dist), 3.0) * 0.2;\r\n        rayOrigin += rayDirection * sdfData.a * 0.7;\r\n        dist += sdfData.a;\r\n        if (length(rayOrigin.xy) > BOUNDING_CYLINDER + 10.0) break;\r\n    }\r\n\r\n\r\n    return rayOrigin;\r\n}\r\n \r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 cameraCenter = vec3(0.0, 0.0, -TIME * 10.0);\r\n    cameraCenter -= spaceBounding(cameraCenter);\r\n    vec3 cameraAngle = vec3(0.0, 0.0, 0.0);\r\n    \r\n    vec3 prevCameraCenter = vec3(0.0, 0.0, -(TIME - 0.01) * 10.0);\r\n    prevCameraCenter -= spaceBounding(prevCameraCenter);\r\n    vec3 nextCameraCenter = vec3(0.0, 0.0, -(TIME + 0.4) * 10.0);\r\n    nextCameraCenter -= spaceBounding(nextCameraCenter);\r\n    \r\n    vec3 velocityVector = -normalize(nextCameraCenter - prevCameraCenter);\r\n    vec3 cameraUp = -normalize(cross(velocityVector, vec3(1.0, 0.0, 0.0)));\r\n    vec3 cameraRight = -(cross(velocityVector, cameraUp));\r\n    \r\n    \r\n    mat3x3 cameraRotation = mat3x3(cameraRight, cameraUp, velocityVector);\r\n    \r\n    vec3 rayOrigin = cameraCenter;\r\n    vec3 rayDirection = cameraRotation * normalize(castPlanePoint(fragCoord));\r\n    \r\n    vec3 color = vec3(0.0);\r\n    vec3 hitPoint = rayMarch(rayOrigin, rayDirection, color);\r\n    vec4 sdf = objectSDF(hitPoint);\r\n    \r\n    float vision = smoothstep(0.01, 0.0, sdf.a);\r\n    \r\n    float fog = sqrt(smoothstep(FOG_DISTANCE, 0.0, distance(cameraCenter, hitPoint)));\r\n    \r\n    vec3 ambient = mix(SECOND_COLOR, FIRST_COLOR, pow(sin(TIME) * 0.5 + 0.5, 2.0) * 0.6);\r\n    ambient *= sqrt((sin(TIME) + sin(TIME * 3.0)) * 0.25 + 1.0);\r\n    vec3 bloom = smoothstep(-0.0, 15.0, color);\r\n    \r\n    color = color * vision * 0.07 * fog + bloom + ambient * 0.3;\r\n    color = smoothstep(-0.01, 1.5, color * 1.1);\r\n    \r\n    fragColor = vec4(color, 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Flying into digital tunnel","id":"c0a8804997084b05a931c7beaf715823","date":null,"viewed":0,"name":"Flying into digital tunnel","description":"Shutterstock challenge! It has some bugs, but I'm happy with the result \nCoding timelapse: https://youtu.be/QPWSkuW53Qs\n\nStock video:\nhttps://www.shutterstock.com/pl/video/clip-1026647174-motion-graphic-4k-seamless-loop-flying-into\nhttps://www.shadertoy.com/view/wsGSRz","likes":0,"published":null,"tags":["sdf"," digital"," tunel"," stockchallenge"]},"ver":null,"info":{"Name":"Flying into digital tunnel","id":"c0a8804997084b05a931c7beaf715823","date":null,"viewed":0,"name":"Flying into digital tunnel","description":"Shutterstock challenge! It has some bugs, but I'm happy with the result \nCoding timelapse: https://youtu.be/QPWSkuW53Qs\n\nStock video:\nhttps://www.shutterstock.com/pl/video/clip-1026647174-motion-graphic-4k-seamless-loop-flying-into\nhttps://www.shadertoy.com/view/wsGSRz","likes":0,"published":null,"tags":["sdf"," digital"," tunel"," stockchallenge"]},"renderpass":[{"Code":"#define RAYMARCH_ITERATIONS 60.0\r\n#define TIME (iTime * 0.4)\r\n#define LINE_LENGTH 1.0\r\n#define LINE_SPACE 1.0\r\n#define LINE_WIDTH 0.007\r\n#define BOUNDING_CYLINDER 1.8\r\n#define INSIDE_CYLINDER 0.32\r\n#define EPS 0.0001\r\n#define FOG_DISTANCE 30.0\r\n\r\n#define FIRST_COLOR vec3(1.2, 0.5, 0.2) * 1.2\r\n#define SECOND_COLOR vec3(0.2, 0.8, 1.1)\r\n\r\nfloat hash12(vec2 x)\r\n{\r\n \treturn fract(sin(dot(x, vec2(42.2347, 43.4271))) * 342.324234);   \r\n}\r\n\r\nvec2 hash22(vec2 x)\r\n{\r\n \treturn fract(sin(x * mat2x2(23.421, 24.4217, 25.3271, 27.2412)) * 342.324234);   \r\n}\r\n\r\nvec3 hash33(vec3 x)\r\n{\r\n \treturn fract(sin(x * mat3x3(23.421, 24.4217, 25.3271, 27.2412, 32.21731, 21.27641, 20.421, 27.4217, 22.3271)) * 342.324234);   \r\n}\r\n\r\n\r\nmat3x3 rotationMatrix(vec3 angle)\r\n{\r\n \treturn \tmat3x3(cos(angle.z), sin(angle.z), 0.0,\r\n                 -sin(angle.z), cos(angle.z), 0.0,\r\n                 0.0, 0.0, 1.0)\r\n        \t* mat3x3(1.0, 0.0, 0.0,\r\n                    0.0, cos(angle.x), sin(angle.x),\r\n                    0.0, -sin(angle.x), cos(angle.x))\r\n        \t* mat3x3(cos(angle.y), 0.0, sin(angle.y),\r\n                    0.0, 1.0, 0.0,\r\n                    -sin(angle.y), 0.0, cos(angle.y));\r\n}\r\n\r\n//Shader License: CC BY 3.0\r\n//Author: Jan Mr\u00F3z (jaszunio15)\r\n\r\nvec3 castPlanePoint(vec2 fragCoord)\r\n{\r\n \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\r\n    return vec3(uv.x, uv.y, -1.0);\r\n}\r\n\r\nfloat planeSDF(vec3 point)\r\n{\r\n \treturn point.y;\r\n}\r\n\r\n//source https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat boxSDF( vec3 point, vec3 bounds )\r\n{\r\n    vec3 q = abs(point) - bounds;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\n//rgb - colors\r\n//a - sdf\r\nvec4 repeatBoxSDF(vec3 point)\r\n{\r\n    vec3 rootPoint = floor(vec3(point.x / LINE_SPACE, point.y / LINE_SPACE, point.z / LINE_LENGTH)); \r\n    rootPoint.z *= LINE_LENGTH;\r\n    rootPoint.xy *= LINE_SPACE;\r\n    float minSDF = 10000.0;\r\n    vec3 mainColor = vec3(0.0);\r\n    \r\n    for (float x = -1.0; x <= 1.1; x++)\r\n    {\r\n        for (float y = -1.0; y <= 1.1; y++)\r\n        {\r\n\t\t\tfor (float z = -1.0; z <= 1.1; z++)\r\n            {\r\n\t\t\t\tvec3 tempRootPoint = rootPoint + vec3(x * LINE_SPACE, y * LINE_SPACE, z * LINE_LENGTH);\r\n                \r\n                vec3 lineHash = hash33(tempRootPoint);\r\n                lineHash.z = pow(lineHash.z, 10.0);\r\n                \r\n                float hash = hash12(tempRootPoint.xy) - 0.5;\r\n                tempRootPoint.z += hash * LINE_LENGTH;\r\n                \r\n                vec3 boxCenter = tempRootPoint + vec3(0.5 * LINE_SPACE, 0.5 * LINE_SPACE, 0.5 * LINE_LENGTH);\r\n                boxCenter.xy += (lineHash.xy - 0.5) * LINE_SPACE;\r\n                vec3 boxSize = vec3(LINE_WIDTH, LINE_WIDTH, LINE_LENGTH * (1.0 - lineHash.z));\r\n                \r\n                vec3 color = FIRST_COLOR;\r\n                if(lineHash.x < 0.5) color = SECOND_COLOR;\r\n                \r\n                float sdf = boxSDF(point - boxCenter, boxSize);\r\n                if (sdf < minSDF)\r\n                {\r\n                    mainColor = color;\r\n                    minSDF = sdf;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    return vec4(mainColor, minSDF);\r\n}\r\n\r\nfloat cylinderSDF(vec3 point, float radius)\r\n{\r\n \treturn length(point.xy) - radius;\r\n}\r\n\r\nfloat multiplyObjects(float o1, float o2)\r\n{\r\n \treturn max(o1, o2);   \r\n}\r\n\r\nvec3 spaceBounding(vec3 point)\r\n{\r\n \treturn vec3(sin(point.z * 0.15) * 5.0, cos(point.z * 0.131) * 5.0, 0.0); \r\n}\r\n\r\n//rgb - color,\r\n//a - sdf\r\nvec4 objectSDF(vec3 point)\r\n{\r\n    point += spaceBounding(point);\r\n    \r\n    vec4 lines = repeatBoxSDF(point);\r\n    float cylinder = cylinderSDF(point, BOUNDING_CYLINDER);\r\n    float insideCylinder = -cylinderSDF(point, INSIDE_CYLINDER);\r\n    \r\n    float object = multiplyObjects(lines.a, cylinder);\r\n    object = multiplyObjects(object, insideCylinder);\r\n \treturn vec4(lines.rgb, object);\r\n}\r\n\r\n\r\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDirection, out vec3 color)\r\n{\r\n    color = vec3(0.0);\r\n    float dist = 0.0;\r\n \tfor (float i = 0.0; i < RAYMARCH_ITERATIONS; i++)\r\n    {\r\n     \tvec4 sdfData = objectSDF(rayOrigin);\r\n        color += sdfData.rgb * sqrt(smoothstep(0.8, 0.0, sdfData.a)) * pow(smoothstep(FOG_DISTANCE * 0.6, 0.0, dist), 3.0) * 0.2;\r\n        rayOrigin += rayDirection * sdfData.a * 0.7;\r\n        dist += sdfData.a;\r\n        if (length(rayOrigin.xy) > BOUNDING_CYLINDER + 10.0) break;\r\n    }\r\n\r\n\r\n    return rayOrigin;\r\n}\r\n \r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 cameraCenter = vec3(0.0, 0.0, -TIME * 10.0);\r\n    cameraCenter -= spaceBounding(cameraCenter);\r\n    vec3 cameraAngle = vec3(0.0, 0.0, 0.0);\r\n    \r\n    vec3 prevCameraCenter = vec3(0.0, 0.0, -(TIME - 0.01) * 10.0);\r\n    prevCameraCenter -= spaceBounding(prevCameraCenter);\r\n    vec3 nextCameraCenter = vec3(0.0, 0.0, -(TIME + 0.4) * 10.0);\r\n    nextCameraCenter -= spaceBounding(nextCameraCenter);\r\n    \r\n    vec3 velocityVector = -normalize(nextCameraCenter - prevCameraCenter);\r\n    vec3 cameraUp = -normalize(cross(velocityVector, vec3(1.0, 0.0, 0.0)));\r\n    vec3 cameraRight = -(cross(velocityVector, cameraUp));\r\n    \r\n    \r\n    mat3x3 cameraRotation = mat3x3(cameraRight, cameraUp, velocityVector);\r\n    \r\n    vec3 rayOrigin = cameraCenter;\r\n    vec3 rayDirection = cameraRotation * normalize(castPlanePoint(fragCoord));\r\n    \r\n    vec3 color = vec3(0.0);\r\n    vec3 hitPoint = rayMarch(rayOrigin, rayDirection, color);\r\n    vec4 sdf = objectSDF(hitPoint);\r\n    \r\n    float vision = smoothstep(0.01, 0.0, sdf.a);\r\n    \r\n    float fog = sqrt(smoothstep(FOG_DISTANCE, 0.0, distance(cameraCenter, hitPoint)));\r\n    \r\n    vec3 ambient = mix(SECOND_COLOR, FIRST_COLOR, pow(sin(TIME) * 0.5 + 0.5, 2.0) * 0.6);\r\n    ambient *= sqrt((sin(TIME) + sin(TIME * 3.0)) * 0.25 + 1.0);\r\n    vec3 bloom = smoothstep(-0.0, 15.0, color);\r\n    \r\n    color = color * vision * 0.07 * fog + bloom + ambient * 0.3;\r\n    color = smoothstep(-0.01, 1.5, color * 1.1);\r\n    \r\n    fragColor = vec4(color, 1.0);\r\n}","inputs":[],"outputs":[],"code":"#define RAYMARCH_ITERATIONS 60.0\r\n#define TIME (iTime * 0.4)\r\n#define LINE_LENGTH 1.0\r\n#define LINE_SPACE 1.0\r\n#define LINE_WIDTH 0.007\r\n#define BOUNDING_CYLINDER 1.8\r\n#define INSIDE_CYLINDER 0.32\r\n#define EPS 0.0001\r\n#define FOG_DISTANCE 30.0\r\n\r\n#define FIRST_COLOR vec3(1.2, 0.5, 0.2) * 1.2\r\n#define SECOND_COLOR vec3(0.2, 0.8, 1.1)\r\n\r\nfloat hash12(vec2 x)\r\n{\r\n \treturn fract(sin(dot(x, vec2(42.2347, 43.4271))) * 342.324234);   \r\n}\r\n\r\nvec2 hash22(vec2 x)\r\n{\r\n \treturn fract(sin(x * mat2x2(23.421, 24.4217, 25.3271, 27.2412)) * 342.324234);   \r\n}\r\n\r\nvec3 hash33(vec3 x)\r\n{\r\n \treturn fract(sin(x * mat3x3(23.421, 24.4217, 25.3271, 27.2412, 32.21731, 21.27641, 20.421, 27.4217, 22.3271)) * 342.324234);   \r\n}\r\n\r\n\r\nmat3x3 rotationMatrix(vec3 angle)\r\n{\r\n \treturn \tmat3x3(cos(angle.z), sin(angle.z), 0.0,\r\n                 -sin(angle.z), cos(angle.z), 0.0,\r\n                 0.0, 0.0, 1.0)\r\n        \t* mat3x3(1.0, 0.0, 0.0,\r\n                    0.0, cos(angle.x), sin(angle.x),\r\n                    0.0, -sin(angle.x), cos(angle.x))\r\n        \t* mat3x3(cos(angle.y), 0.0, sin(angle.y),\r\n                    0.0, 1.0, 0.0,\r\n                    -sin(angle.y), 0.0, cos(angle.y));\r\n}\r\n\r\n//Shader License: CC BY 3.0\r\n//Author: Jan Mr\u00F3z (jaszunio15)\r\n\r\nvec3 castPlanePoint(vec2 fragCoord)\r\n{\r\n \tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\r\n    return vec3(uv.x, uv.y, -1.0);\r\n}\r\n\r\nfloat planeSDF(vec3 point)\r\n{\r\n \treturn point.y;\r\n}\r\n\r\n//source https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat boxSDF( vec3 point, vec3 bounds )\r\n{\r\n    vec3 q = abs(point) - bounds;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\n//rgb - colors\r\n//a - sdf\r\nvec4 repeatBoxSDF(vec3 point)\r\n{\r\n    vec3 rootPoint = floor(vec3(point.x / LINE_SPACE, point.y / LINE_SPACE, point.z / LINE_LENGTH)); \r\n    rootPoint.z *= LINE_LENGTH;\r\n    rootPoint.xy *= LINE_SPACE;\r\n    float minSDF = 10000.0;\r\n    vec3 mainColor = vec3(0.0);\r\n    \r\n    for (float x = -1.0; x <= 1.1; x++)\r\n    {\r\n        for (float y = -1.0; y <= 1.1; y++)\r\n        {\r\n\t\t\tfor (float z = -1.0; z <= 1.1; z++)\r\n            {\r\n\t\t\t\tvec3 tempRootPoint = rootPoint + vec3(x * LINE_SPACE, y * LINE_SPACE, z * LINE_LENGTH);\r\n                \r\n                vec3 lineHash = hash33(tempRootPoint);\r\n                lineHash.z = pow(lineHash.z, 10.0);\r\n                \r\n                float hash = hash12(tempRootPoint.xy) - 0.5;\r\n                tempRootPoint.z += hash * LINE_LENGTH;\r\n                \r\n                vec3 boxCenter = tempRootPoint + vec3(0.5 * LINE_SPACE, 0.5 * LINE_SPACE, 0.5 * LINE_LENGTH);\r\n                boxCenter.xy += (lineHash.xy - 0.5) * LINE_SPACE;\r\n                vec3 boxSize = vec3(LINE_WIDTH, LINE_WIDTH, LINE_LENGTH * (1.0 - lineHash.z));\r\n                \r\n                vec3 color = FIRST_COLOR;\r\n                if(lineHash.x < 0.5) color = SECOND_COLOR;\r\n                \r\n                float sdf = boxSDF(point - boxCenter, boxSize);\r\n                if (sdf < minSDF)\r\n                {\r\n                    mainColor = color;\r\n                    minSDF = sdf;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    return vec4(mainColor, minSDF);\r\n}\r\n\r\nfloat cylinderSDF(vec3 point, float radius)\r\n{\r\n \treturn length(point.xy) - radius;\r\n}\r\n\r\nfloat multiplyObjects(float o1, float o2)\r\n{\r\n \treturn max(o1, o2);   \r\n}\r\n\r\nvec3 spaceBounding(vec3 point)\r\n{\r\n \treturn vec3(sin(point.z * 0.15) * 5.0, cos(point.z * 0.131) * 5.0, 0.0); \r\n}\r\n\r\n//rgb - color,\r\n//a - sdf\r\nvec4 objectSDF(vec3 point)\r\n{\r\n    point += spaceBounding(point);\r\n    \r\n    vec4 lines = repeatBoxSDF(point);\r\n    float cylinder = cylinderSDF(point, BOUNDING_CYLINDER);\r\n    float insideCylinder = -cylinderSDF(point, INSIDE_CYLINDER);\r\n    \r\n    float object = multiplyObjects(lines.a, cylinder);\r\n    object = multiplyObjects(object, insideCylinder);\r\n \treturn vec4(lines.rgb, object);\r\n}\r\n\r\n\r\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDirection, out vec3 color)\r\n{\r\n    color = vec3(0.0);\r\n    float dist = 0.0;\r\n \tfor (float i = 0.0; i < RAYMARCH_ITERATIONS; i++)\r\n    {\r\n     \tvec4 sdfData = objectSDF(rayOrigin);\r\n        color += sdfData.rgb * sqrt(smoothstep(0.8, 0.0, sdfData.a)) * pow(smoothstep(FOG_DISTANCE * 0.6, 0.0, dist), 3.0) * 0.2;\r\n        rayOrigin += rayDirection * sdfData.a * 0.7;\r\n        dist += sdfData.a;\r\n        if (length(rayOrigin.xy) > BOUNDING_CYLINDER + 10.0) break;\r\n    }\r\n\r\n\r\n    return rayOrigin;\r\n}\r\n \r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 cameraCenter = vec3(0.0, 0.0, -TIME * 10.0);\r\n    cameraCenter -= spaceBounding(cameraCenter);\r\n    vec3 cameraAngle = vec3(0.0, 0.0, 0.0);\r\n    \r\n    vec3 prevCameraCenter = vec3(0.0, 0.0, -(TIME - 0.01) * 10.0);\r\n    prevCameraCenter -= spaceBounding(prevCameraCenter);\r\n    vec3 nextCameraCenter = vec3(0.0, 0.0, -(TIME + 0.4) * 10.0);\r\n    nextCameraCenter -= spaceBounding(nextCameraCenter);\r\n    \r\n    vec3 velocityVector = -normalize(nextCameraCenter - prevCameraCenter);\r\n    vec3 cameraUp = -normalize(cross(velocityVector, vec3(1.0, 0.0, 0.0)));\r\n    vec3 cameraRight = -(cross(velocityVector, cameraUp));\r\n    \r\n    \r\n    mat3x3 cameraRotation = mat3x3(cameraRight, cameraUp, velocityVector);\r\n    \r\n    vec3 rayOrigin = cameraCenter;\r\n    vec3 rayDirection = cameraRotation * normalize(castPlanePoint(fragCoord));\r\n    \r\n    vec3 color = vec3(0.0);\r\n    vec3 hitPoint = rayMarch(rayOrigin, rayDirection, color);\r\n    vec4 sdf = objectSDF(hitPoint);\r\n    \r\n    float vision = smoothstep(0.01, 0.0, sdf.a);\r\n    \r\n    float fog = sqrt(smoothstep(FOG_DISTANCE, 0.0, distance(cameraCenter, hitPoint)));\r\n    \r\n    vec3 ambient = mix(SECOND_COLOR, FIRST_COLOR, pow(sin(TIME) * 0.5 + 0.5, 2.0) * 0.6);\r\n    ambient *= sqrt((sin(TIME) + sin(TIME * 3.0)) * 0.25 + 1.0);\r\n    vec3 bloom = smoothstep(-0.0, 15.0, color);\r\n    \r\n    color = color * vision * 0.07 * fog + bloom + ambient * 0.3;\r\n    color = smoothstep(-0.01, 1.5, color * 1.1);\r\n    \r\n    fragColor = vec4(color, 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"vec3 palette(float d){\r\n\treturn mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\r\n}\r\n\r\nvec2 rotate(vec2 p,float a){\r\n\tfloat c = cos(a);\r\n    float s = sin(a);\r\n    return p*mat2(c,s,-s,c);\r\n}\r\n\r\nfloat map(vec3 p){\r\n    for( int i = 0; i<8; ++i){\r\n        float t = iTime*0.2;\r\n        p.xz =rotate(p.xz,t);\r\n        p.xy =rotate(p.xy,t*1.89);\r\n        p.xz = abs(p.xz);\r\n        p.xz-=.5;\r\n\t}\r\n\treturn dot(sign(p),p)/5.;\r\n}\r\n\r\nvec4 rm (vec3 ro, vec3 rd){\r\n    float t = 0.;\r\n    vec3 col = vec3(0.);\r\n    float d;\r\n    for(float i =0.; i<64.; i++){\r\n\t\tvec3 p = ro + rd*t;\r\n        d = map(p)*.5;\r\n        if(d<0.02){\r\n            break;\r\n        }\r\n        if(d>100.){\r\n        \tbreak;\r\n        }\r\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\r\n        col+=palette(length(p)*.1)/(400.*(d));\r\n        t+=d;\r\n    }\r\n    return vec4(col,1./(d*100.));\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\r\n\tvec3 ro = vec3(0.,0.,-50.);\r\n    ro.xz = rotate(ro.xz,iTime);\r\n    vec3 cf = normalize(-ro);\r\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\r\n    vec3 cu = normalize(cross(cf,cs));\r\n    \r\n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\r\n    \r\n    vec3 rd = normalize(uuv-ro);\r\n    \r\n    vec4 col = rm(ro,rd);\r\n    \r\n    \r\n    fragColor = col;\r\n}\r\n\r\n/** SHADERDATA\r\n{\r\n\t\"title\": \"fractal pyramid\",\r\n\t\"description\": \"coding my new screensaver\",\r\n\t\"model\": \"car\"\r\n}\r\n*/","inputs":[],"outputs":[],"code":"vec3 palette(float d){\r\n\treturn mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\r\n}\r\n\r\nvec2 rotate(vec2 p,float a){\r\n\tfloat c = cos(a);\r\n    float s = sin(a);\r\n    return p*mat2(c,s,-s,c);\r\n}\r\n\r\nfloat map(vec3 p){\r\n    for( int i = 0; i<8; ++i){\r\n        float t = iTime*0.2;\r\n        p.xz =rotate(p.xz,t);\r\n        p.xy =rotate(p.xy,t*1.89);\r\n        p.xz = abs(p.xz);\r\n        p.xz-=.5;\r\n\t}\r\n\treturn dot(sign(p),p)/5.;\r\n}\r\n\r\nvec4 rm (vec3 ro, vec3 rd){\r\n    float t = 0.;\r\n    vec3 col = vec3(0.);\r\n    float d;\r\n    for(float i =0.; i<64.; i++){\r\n\t\tvec3 p = ro + rd*t;\r\n        d = map(p)*.5;\r\n        if(d<0.02){\r\n            break;\r\n        }\r\n        if(d>100.){\r\n        \tbreak;\r\n        }\r\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\r\n        col+=palette(length(p)*.1)/(400.*(d));\r\n        t+=d;\r\n    }\r\n    return vec4(col,1./(d*100.));\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\r\n\tvec3 ro = vec3(0.,0.,-50.);\r\n    ro.xz = rotate(ro.xz,iTime);\r\n    vec3 cf = normalize(-ro);\r\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\r\n    vec3 cu = normalize(cross(cf,cs));\r\n    \r\n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\r\n    \r\n    vec3 rd = normalize(uuv-ro);\r\n    \r\n    vec4 col = rm(ro,rd);\r\n    \r\n    \r\n    fragColor = col;\r\n}\r\n\r\n/** SHADERDATA\r\n{\r\n\t\"title\": \"fractal pyramid\",\r\n\t\"description\": \"coding my new screensaver\",\r\n\t\"model\": \"car\"\r\n}\r\n*/","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"fractal pyramid","id":"777dbb171bb94ca5aa8ce8872a78199d","date":null,"viewed":0,"name":"fractal pyramid","description":"coding my new screensaver\nhttps://www.shadertoy.com/view/tsXBzS","likes":0,"published":null,"tags":["fractalcineshader"]},"ver":null,"info":{"Name":"fractal pyramid","id":"777dbb171bb94ca5aa8ce8872a78199d","date":null,"viewed":0,"name":"fractal pyramid","description":"coding my new screensaver\nhttps://www.shadertoy.com/view/tsXBzS","likes":0,"published":null,"tags":["fractalcineshader"]},"renderpass":[{"Code":"vec3 palette(float d){\r\n\treturn mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\r\n}\r\n\r\nvec2 rotate(vec2 p,float a){\r\n\tfloat c = cos(a);\r\n    float s = sin(a);\r\n    return p*mat2(c,s,-s,c);\r\n}\r\n\r\nfloat map(vec3 p){\r\n    for( int i = 0; i<8; ++i){\r\n        float t = iTime*0.2;\r\n        p.xz =rotate(p.xz,t);\r\n        p.xy =rotate(p.xy,t*1.89);\r\n        p.xz = abs(p.xz);\r\n        p.xz-=.5;\r\n\t}\r\n\treturn dot(sign(p),p)/5.;\r\n}\r\n\r\nvec4 rm (vec3 ro, vec3 rd){\r\n    float t = 0.;\r\n    vec3 col = vec3(0.);\r\n    float d;\r\n    for(float i =0.; i<64.; i++){\r\n\t\tvec3 p = ro + rd*t;\r\n        d = map(p)*.5;\r\n        if(d<0.02){\r\n            break;\r\n        }\r\n        if(d>100.){\r\n        \tbreak;\r\n        }\r\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\r\n        col+=palette(length(p)*.1)/(400.*(d));\r\n        t+=d;\r\n    }\r\n    return vec4(col,1./(d*100.));\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\r\n\tvec3 ro = vec3(0.,0.,-50.);\r\n    ro.xz = rotate(ro.xz,iTime);\r\n    vec3 cf = normalize(-ro);\r\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\r\n    vec3 cu = normalize(cross(cf,cs));\r\n    \r\n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\r\n    \r\n    vec3 rd = normalize(uuv-ro);\r\n    \r\n    vec4 col = rm(ro,rd);\r\n    \r\n    \r\n    fragColor = col;\r\n}\r\n\r\n/** SHADERDATA\r\n{\r\n\t\"title\": \"fractal pyramid\",\r\n\t\"description\": \"coding my new screensaver\",\r\n\t\"model\": \"car\"\r\n}\r\n*/","inputs":[],"outputs":[],"code":"vec3 palette(float d){\r\n\treturn mix(vec3(0.2,0.7,0.9),vec3(1.,0.,1.),d);\r\n}\r\n\r\nvec2 rotate(vec2 p,float a){\r\n\tfloat c = cos(a);\r\n    float s = sin(a);\r\n    return p*mat2(c,s,-s,c);\r\n}\r\n\r\nfloat map(vec3 p){\r\n    for( int i = 0; i<8; ++i){\r\n        float t = iTime*0.2;\r\n        p.xz =rotate(p.xz,t);\r\n        p.xy =rotate(p.xy,t*1.89);\r\n        p.xz = abs(p.xz);\r\n        p.xz-=.5;\r\n\t}\r\n\treturn dot(sign(p),p)/5.;\r\n}\r\n\r\nvec4 rm (vec3 ro, vec3 rd){\r\n    float t = 0.;\r\n    vec3 col = vec3(0.);\r\n    float d;\r\n    for(float i =0.; i<64.; i++){\r\n\t\tvec3 p = ro + rd*t;\r\n        d = map(p)*.5;\r\n        if(d<0.02){\r\n            break;\r\n        }\r\n        if(d>100.){\r\n        \tbreak;\r\n        }\r\n        //col+=vec3(0.6,0.8,0.8)/(400.*(d));\r\n        col+=palette(length(p)*.1)/(400.*(d));\r\n        t+=d;\r\n    }\r\n    return vec4(col,1./(d*100.));\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\r\n\tvec3 ro = vec3(0.,0.,-50.);\r\n    ro.xz = rotate(ro.xz,iTime);\r\n    vec3 cf = normalize(-ro);\r\n    vec3 cs = normalize(cross(cf,vec3(0.,1.,0.)));\r\n    vec3 cu = normalize(cross(cf,cs));\r\n    \r\n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\r\n    \r\n    vec3 rd = normalize(uuv-ro);\r\n    \r\n    vec4 col = rm(ro,rd);\r\n    \r\n    \r\n    fragColor = col;\r\n}\r\n\r\n/** SHADERDATA\r\n{\r\n\t\"title\": \"fractal pyramid\",\r\n\t\"description\": \"coding my new screensaver\",\r\n\t\"model\": \"car\"\r\n}\r\n*/","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(vec2 p)\r\n{\r\n    return vec3(value_noise(p),value_noise(p+123.456),value_noise(p+94577.340));\r\n}\r\n\r\n// fur ball\r\n// (c) simon green 2013\r\n// @simesgreen\r\n// v1.1\r\n\r\nconst float uvScale = 1.0;\r\nconst float colorUvScale = 0.1;\r\nconst float furDepth = 0.2;\r\nconst int furLayers = 64;\r\nconst float rayStep = furDepth*2.0 / float(furLayers);\r\nconst float furThreshold = 0.4;\r\nconst float shininess = 50.0;\r\n\r\nbool intersectSphere(vec3 ro, vec3 rd, float r, out float t)\r\n{\r\n\tfloat b = dot(-ro, rd);\r\n\tfloat det = b*b - dot(ro, ro) + r*r;\r\n\tif (det < 0.0) return false;\r\n\tdet = sqrt(det);\r\n\tt = b - det;\r\n\treturn t > 0.0;\r\n}\r\n\r\nvec3 rotateX(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\r\n}\r\n\r\nvec2 cartesianToSpherical(vec3 p)\r\n{\t\t\r\n\tfloat r = length(p);\r\n\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\t\r\n\tp = rotateX(p.zyx, -cos(iTime*1.5)*t*t*0.4).zyx;\t// curl\r\n\r\n\tp /= r;\t\r\n\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\r\n\r\n\t//uv.x += cos(iTime*1.5)*t*t*0.4;\t// curl\r\n\t//uv.y += sin(iTime*1.7)*t*t*0.2;\r\n\tuv.y -= t*t*0.1;\t// curl down\r\n\treturn uv;\r\n}\r\n\r\n// returns fur density at given position\r\nfloat furDensity(vec3 pos, out vec2 uv)\r\n{\r\n\tuv = cartesianToSpherical(pos.xzy);\t\r\n\tvec4 tex = vec4(noise23(uv*uvScale*100.0),1.0);// textureLod(iChannel0, uv*uvScale, 0.0);\r\n\r\n\t// thin out hair\r\n\tfloat density = smoothstep(furThreshold, 1.0, tex.x);\r\n\t\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\t\r\n\t// fade out along length\r\n\tfloat len = tex.y;\r\n\tdensity *= smoothstep(len, len-0.2, t);\r\n\r\n\treturn density;\t\r\n}\r\n\r\n// calculate normal from density\r\nvec3 furNormal(vec3 pos, float density)\r\n{\r\n    float eps = 0.01;\r\n    vec3 n;\r\n\tvec2 uv;\r\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), uv ) - density;\r\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), uv ) - density;\r\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), uv ) - density;\r\n    return normalize(n);\r\n}\r\n\r\nvec3 furShade(vec3 pos, vec2 uv, vec3 ro, float density)\r\n{\r\n\t// lighting\r\n\tconst vec3 L = vec3(0, 1, 0);\r\n\tvec3 V = normalize(ro - pos);\r\n\tvec3 H = normalize(V + L);\r\n\r\n\tvec3 N = -furNormal(pos, density);\r\n\t//float diff = max(0.0, dot(N, L));\r\n\tfloat diff = max(0.0, dot(N, L)*0.5+0.5);\r\n\tfloat spec = pow(max(0.0, dot(N, H)), shininess);\r\n\t\r\n\t// base color\r\n\tvec3 color = noise23(uv*colorUvScale*100.0);// textureLod(iChannel1, uv*colorUvScale, 0.0).xyz;\r\n\r\n\t// darken with depth\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\tt = clamp(t, 0.0, 1.0);\r\n\tfloat i = t*0.5+0.5;\r\n\t\t\r\n\treturn color*diff*i + vec3(spec*i);\r\n}\t\t\r\n\r\nvec4 scene(vec3 ro,vec3 rd)\r\n{\r\n\tvec3 p = vec3(0.0);\r\n\tconst float r = 1.0;\r\n\tfloat t;\t\t\t\t  \r\n\tbool hit = intersectSphere(ro - p, rd, r, t);\r\n\t\r\n\tvec4 c = vec4(0.0);\r\n\tif (hit) {\r\n\t\tvec3 pos = ro + rd*t;\r\n\r\n\t\t// ray-march into volume\r\n\t\tfor(int i=0; i<furLayers; i++) {\r\n\t\t\tvec4 sampleCol;\r\n\t\t\tvec2 uv;\r\n\t\t\tsampleCol.a = furDensity(pos, uv);\r\n\t\t\tif (sampleCol.a > 0.0) {\r\n\t\t\t\tsampleCol.rgb = furShade(pos, uv, ro, sampleCol.a);\r\n\r\n\t\t\t\t// pre-multiply alpha\r\n\t\t\t\tsampleCol.rgb *= sampleCol.a;\r\n\t\t\t\tc = c + sampleCol*(1.0 - c.a);\r\n\t\t\t\tif (c.a > 0.95) break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpos += rd*rayStep;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv = uv*2.0-1.0;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\r\n\tvec3 rd = normalize(vec3(uv, -2.0));\r\n\t\r\n\tvec2 mouse = iMouse.xy / iResolution.xy;\r\n\tfloat roty = 0.0;\r\n\tfloat rotx = 0.0;\r\n\tif (iMouse.z > 0.0) {\r\n\t\trotx = (mouse.y-0.5)*3.0;\r\n\t\troty = -(mouse.x-0.5)*6.0;\r\n\t} else {\r\n\t\troty = sin(iTime*1.5);\r\n\t}\r\n\t\r\n    ro = rotateX(ro, rotx);\t\r\n    ro = rotateY(ro, roty);\t\r\n    rd = rotateX(rd, rotx);\r\n    rd = rotateY(rd, roty);\r\n\t\r\n\tfragColor = scene(ro, rd);\r\n}","inputs":[],"outputs":[],"code":"//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(vec2 p)\r\n{\r\n    return vec3(value_noise(p),value_noise(p+123.456),value_noise(p+94577.340));\r\n}\r\n\r\n// fur ball\r\n// (c) simon green 2013\r\n// @simesgreen\r\n// v1.1\r\n\r\nconst float uvScale = 1.0;\r\nconst float colorUvScale = 0.1;\r\nconst float furDepth = 0.2;\r\nconst int furLayers = 64;\r\nconst float rayStep = furDepth*2.0 / float(furLayers);\r\nconst float furThreshold = 0.4;\r\nconst float shininess = 50.0;\r\n\r\nbool intersectSphere(vec3 ro, vec3 rd, float r, out float t)\r\n{\r\n\tfloat b = dot(-ro, rd);\r\n\tfloat det = b*b - dot(ro, ro) + r*r;\r\n\tif (det < 0.0) return false;\r\n\tdet = sqrt(det);\r\n\tt = b - det;\r\n\treturn t > 0.0;\r\n}\r\n\r\nvec3 rotateX(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\r\n}\r\n\r\nvec2 cartesianToSpherical(vec3 p)\r\n{\t\t\r\n\tfloat r = length(p);\r\n\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\t\r\n\tp = rotateX(p.zyx, -cos(iTime*1.5)*t*t*0.4).zyx;\t// curl\r\n\r\n\tp /= r;\t\r\n\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\r\n\r\n\t//uv.x += cos(iTime*1.5)*t*t*0.4;\t// curl\r\n\t//uv.y += sin(iTime*1.7)*t*t*0.2;\r\n\tuv.y -= t*t*0.1;\t// curl down\r\n\treturn uv;\r\n}\r\n\r\n// returns fur density at given position\r\nfloat furDensity(vec3 pos, out vec2 uv)\r\n{\r\n\tuv = cartesianToSpherical(pos.xzy);\t\r\n\tvec4 tex = vec4(noise23(uv*uvScale*100.0),1.0);// textureLod(iChannel0, uv*uvScale, 0.0);\r\n\r\n\t// thin out hair\r\n\tfloat density = smoothstep(furThreshold, 1.0, tex.x);\r\n\t\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\t\r\n\t// fade out along length\r\n\tfloat len = tex.y;\r\n\tdensity *= smoothstep(len, len-0.2, t);\r\n\r\n\treturn density;\t\r\n}\r\n\r\n// calculate normal from density\r\nvec3 furNormal(vec3 pos, float density)\r\n{\r\n    float eps = 0.01;\r\n    vec3 n;\r\n\tvec2 uv;\r\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), uv ) - density;\r\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), uv ) - density;\r\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), uv ) - density;\r\n    return normalize(n);\r\n}\r\n\r\nvec3 furShade(vec3 pos, vec2 uv, vec3 ro, float density)\r\n{\r\n\t// lighting\r\n\tconst vec3 L = vec3(0, 1, 0);\r\n\tvec3 V = normalize(ro - pos);\r\n\tvec3 H = normalize(V + L);\r\n\r\n\tvec3 N = -furNormal(pos, density);\r\n\t//float diff = max(0.0, dot(N, L));\r\n\tfloat diff = max(0.0, dot(N, L)*0.5+0.5);\r\n\tfloat spec = pow(max(0.0, dot(N, H)), shininess);\r\n\t\r\n\t// base color\r\n\tvec3 color = noise23(uv*colorUvScale*100.0);// textureLod(iChannel1, uv*colorUvScale, 0.0).xyz;\r\n\r\n\t// darken with depth\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\tt = clamp(t, 0.0, 1.0);\r\n\tfloat i = t*0.5+0.5;\r\n\t\t\r\n\treturn color*diff*i + vec3(spec*i);\r\n}\t\t\r\n\r\nvec4 scene(vec3 ro,vec3 rd)\r\n{\r\n\tvec3 p = vec3(0.0);\r\n\tconst float r = 1.0;\r\n\tfloat t;\t\t\t\t  \r\n\tbool hit = intersectSphere(ro - p, rd, r, t);\r\n\t\r\n\tvec4 c = vec4(0.0);\r\n\tif (hit) {\r\n\t\tvec3 pos = ro + rd*t;\r\n\r\n\t\t// ray-march into volume\r\n\t\tfor(int i=0; i<furLayers; i++) {\r\n\t\t\tvec4 sampleCol;\r\n\t\t\tvec2 uv;\r\n\t\t\tsampleCol.a = furDensity(pos, uv);\r\n\t\t\tif (sampleCol.a > 0.0) {\r\n\t\t\t\tsampleCol.rgb = furShade(pos, uv, ro, sampleCol.a);\r\n\r\n\t\t\t\t// pre-multiply alpha\r\n\t\t\t\tsampleCol.rgb *= sampleCol.a;\r\n\t\t\t\tc = c + sampleCol*(1.0 - c.a);\r\n\t\t\t\tif (c.a > 0.95) break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpos += rd*rayStep;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv = uv*2.0-1.0;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\r\n\tvec3 rd = normalize(vec3(uv, -2.0));\r\n\t\r\n\tvec2 mouse = iMouse.xy / iResolution.xy;\r\n\tfloat roty = 0.0;\r\n\tfloat rotx = 0.0;\r\n\tif (iMouse.z > 0.0) {\r\n\t\trotx = (mouse.y-0.5)*3.0;\r\n\t\troty = -(mouse.x-0.5)*6.0;\r\n\t} else {\r\n\t\troty = sin(iTime*1.5);\r\n\t}\r\n\t\r\n    ro = rotateX(ro, rotx);\t\r\n    ro = rotateY(ro, roty);\t\r\n    rd = rotateX(rd, rotx);\r\n    rd = rotateY(rd, roty);\r\n\t\r\n\tfragColor = scene(ro, rd);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"furball","id":"6e88ad8811bf4064bed761a0e7bc252c","date":null,"viewed":0,"name":"furball","description":"Kajiya & Kay style ray-marched fur.\n\nhttp://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.127.5564\nhttps://www.shadertoy.com/view/XsfGWN","likes":0,"published":null,"tags":["raymarch"," hair"," fur"," fluffy"]},"ver":null,"info":{"Name":"furball","id":"6e88ad8811bf4064bed761a0e7bc252c","date":null,"viewed":0,"name":"furball","description":"Kajiya & Kay style ray-marched fur.\n\nhttp://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.127.5564\nhttps://www.shadertoy.com/view/XsfGWN","likes":0,"published":null,"tags":["raymarch"," hair"," fur"," fluffy"]},"renderpass":[{"Code":"//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(vec2 p)\r\n{\r\n    return vec3(value_noise(p),value_noise(p+123.456),value_noise(p+94577.340));\r\n}\r\n\r\n// fur ball\r\n// (c) simon green 2013\r\n// @simesgreen\r\n// v1.1\r\n\r\nconst float uvScale = 1.0;\r\nconst float colorUvScale = 0.1;\r\nconst float furDepth = 0.2;\r\nconst int furLayers = 64;\r\nconst float rayStep = furDepth*2.0 / float(furLayers);\r\nconst float furThreshold = 0.4;\r\nconst float shininess = 50.0;\r\n\r\nbool intersectSphere(vec3 ro, vec3 rd, float r, out float t)\r\n{\r\n\tfloat b = dot(-ro, rd);\r\n\tfloat det = b*b - dot(ro, ro) + r*r;\r\n\tif (det < 0.0) return false;\r\n\tdet = sqrt(det);\r\n\tt = b - det;\r\n\treturn t > 0.0;\r\n}\r\n\r\nvec3 rotateX(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\r\n}\r\n\r\nvec2 cartesianToSpherical(vec3 p)\r\n{\t\t\r\n\tfloat r = length(p);\r\n\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\t\r\n\tp = rotateX(p.zyx, -cos(iTime*1.5)*t*t*0.4).zyx;\t// curl\r\n\r\n\tp /= r;\t\r\n\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\r\n\r\n\t//uv.x += cos(iTime*1.5)*t*t*0.4;\t// curl\r\n\t//uv.y += sin(iTime*1.7)*t*t*0.2;\r\n\tuv.y -= t*t*0.1;\t// curl down\r\n\treturn uv;\r\n}\r\n\r\n// returns fur density at given position\r\nfloat furDensity(vec3 pos, out vec2 uv)\r\n{\r\n\tuv = cartesianToSpherical(pos.xzy);\t\r\n\tvec4 tex = vec4(noise23(uv*uvScale*100.0),1.0);// textureLod(iChannel0, uv*uvScale, 0.0);\r\n\r\n\t// thin out hair\r\n\tfloat density = smoothstep(furThreshold, 1.0, tex.x);\r\n\t\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\t\r\n\t// fade out along length\r\n\tfloat len = tex.y;\r\n\tdensity *= smoothstep(len, len-0.2, t);\r\n\r\n\treturn density;\t\r\n}\r\n\r\n// calculate normal from density\r\nvec3 furNormal(vec3 pos, float density)\r\n{\r\n    float eps = 0.01;\r\n    vec3 n;\r\n\tvec2 uv;\r\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), uv ) - density;\r\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), uv ) - density;\r\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), uv ) - density;\r\n    return normalize(n);\r\n}\r\n\r\nvec3 furShade(vec3 pos, vec2 uv, vec3 ro, float density)\r\n{\r\n\t// lighting\r\n\tconst vec3 L = vec3(0, 1, 0);\r\n\tvec3 V = normalize(ro - pos);\r\n\tvec3 H = normalize(V + L);\r\n\r\n\tvec3 N = -furNormal(pos, density);\r\n\t//float diff = max(0.0, dot(N, L));\r\n\tfloat diff = max(0.0, dot(N, L)*0.5+0.5);\r\n\tfloat spec = pow(max(0.0, dot(N, H)), shininess);\r\n\t\r\n\t// base color\r\n\tvec3 color = noise23(uv*colorUvScale*100.0);// textureLod(iChannel1, uv*colorUvScale, 0.0).xyz;\r\n\r\n\t// darken with depth\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\tt = clamp(t, 0.0, 1.0);\r\n\tfloat i = t*0.5+0.5;\r\n\t\t\r\n\treturn color*diff*i + vec3(spec*i);\r\n}\t\t\r\n\r\nvec4 scene(vec3 ro,vec3 rd)\r\n{\r\n\tvec3 p = vec3(0.0);\r\n\tconst float r = 1.0;\r\n\tfloat t;\t\t\t\t  \r\n\tbool hit = intersectSphere(ro - p, rd, r, t);\r\n\t\r\n\tvec4 c = vec4(0.0);\r\n\tif (hit) {\r\n\t\tvec3 pos = ro + rd*t;\r\n\r\n\t\t// ray-march into volume\r\n\t\tfor(int i=0; i<furLayers; i++) {\r\n\t\t\tvec4 sampleCol;\r\n\t\t\tvec2 uv;\r\n\t\t\tsampleCol.a = furDensity(pos, uv);\r\n\t\t\tif (sampleCol.a > 0.0) {\r\n\t\t\t\tsampleCol.rgb = furShade(pos, uv, ro, sampleCol.a);\r\n\r\n\t\t\t\t// pre-multiply alpha\r\n\t\t\t\tsampleCol.rgb *= sampleCol.a;\r\n\t\t\t\tc = c + sampleCol*(1.0 - c.a);\r\n\t\t\t\tif (c.a > 0.95) break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpos += rd*rayStep;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv = uv*2.0-1.0;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\r\n\tvec3 rd = normalize(vec3(uv, -2.0));\r\n\t\r\n\tvec2 mouse = iMouse.xy / iResolution.xy;\r\n\tfloat roty = 0.0;\r\n\tfloat rotx = 0.0;\r\n\tif (iMouse.z > 0.0) {\r\n\t\trotx = (mouse.y-0.5)*3.0;\r\n\t\troty = -(mouse.x-0.5)*6.0;\r\n\t} else {\r\n\t\troty = sin(iTime*1.5);\r\n\t}\r\n\t\r\n    ro = rotateX(ro, rotx);\t\r\n    ro = rotateY(ro, roty);\t\r\n    rd = rotateX(rd, rotx);\r\n    rd = rotateY(rd, roty);\r\n\t\r\n\tfragColor = scene(ro, rd);\r\n}","inputs":[],"outputs":[],"code":"//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(vec2 p)\r\n{\r\n    return vec3(value_noise(p),value_noise(p+123.456),value_noise(p+94577.340));\r\n}\r\n\r\n// fur ball\r\n// (c) simon green 2013\r\n// @simesgreen\r\n// v1.1\r\n\r\nconst float uvScale = 1.0;\r\nconst float colorUvScale = 0.1;\r\nconst float furDepth = 0.2;\r\nconst int furLayers = 64;\r\nconst float rayStep = furDepth*2.0 / float(furLayers);\r\nconst float furThreshold = 0.4;\r\nconst float shininess = 50.0;\r\n\r\nbool intersectSphere(vec3 ro, vec3 rd, float r, out float t)\r\n{\r\n\tfloat b = dot(-ro, rd);\r\n\tfloat det = b*b - dot(ro, ro) + r*r;\r\n\tif (det < 0.0) return false;\r\n\tdet = sqrt(det);\r\n\tt = b - det;\r\n\treturn t > 0.0;\r\n}\r\n\r\nvec3 rotateX(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\r\n}\r\n\r\nvec3 rotateY(vec3 p, float a)\r\n{\r\n    float sa = sin(a);\r\n    float ca = cos(a);\r\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\r\n}\r\n\r\nvec2 cartesianToSpherical(vec3 p)\r\n{\t\t\r\n\tfloat r = length(p);\r\n\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\t\r\n\tp = rotateX(p.zyx, -cos(iTime*1.5)*t*t*0.4).zyx;\t// curl\r\n\r\n\tp /= r;\t\r\n\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\r\n\r\n\t//uv.x += cos(iTime*1.5)*t*t*0.4;\t// curl\r\n\t//uv.y += sin(iTime*1.7)*t*t*0.2;\r\n\tuv.y -= t*t*0.1;\t// curl down\r\n\treturn uv;\r\n}\r\n\r\n// returns fur density at given position\r\nfloat furDensity(vec3 pos, out vec2 uv)\r\n{\r\n\tuv = cartesianToSpherical(pos.xzy);\t\r\n\tvec4 tex = vec4(noise23(uv*uvScale*100.0),1.0);// textureLod(iChannel0, uv*uvScale, 0.0);\r\n\r\n\t// thin out hair\r\n\tfloat density = smoothstep(furThreshold, 1.0, tex.x);\r\n\t\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\t\r\n\t// fade out along length\r\n\tfloat len = tex.y;\r\n\tdensity *= smoothstep(len, len-0.2, t);\r\n\r\n\treturn density;\t\r\n}\r\n\r\n// calculate normal from density\r\nvec3 furNormal(vec3 pos, float density)\r\n{\r\n    float eps = 0.01;\r\n    vec3 n;\r\n\tvec2 uv;\r\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), uv ) - density;\r\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), uv ) - density;\r\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), uv ) - density;\r\n    return normalize(n);\r\n}\r\n\r\nvec3 furShade(vec3 pos, vec2 uv, vec3 ro, float density)\r\n{\r\n\t// lighting\r\n\tconst vec3 L = vec3(0, 1, 0);\r\n\tvec3 V = normalize(ro - pos);\r\n\tvec3 H = normalize(V + L);\r\n\r\n\tvec3 N = -furNormal(pos, density);\r\n\t//float diff = max(0.0, dot(N, L));\r\n\tfloat diff = max(0.0, dot(N, L)*0.5+0.5);\r\n\tfloat spec = pow(max(0.0, dot(N, H)), shininess);\r\n\t\r\n\t// base color\r\n\tvec3 color = noise23(uv*colorUvScale*100.0);// textureLod(iChannel1, uv*colorUvScale, 0.0).xyz;\r\n\r\n\t// darken with depth\r\n\tfloat r = length(pos);\r\n\tfloat t = (r - (1.0 - furDepth)) / furDepth;\r\n\tt = clamp(t, 0.0, 1.0);\r\n\tfloat i = t*0.5+0.5;\r\n\t\t\r\n\treturn color*diff*i + vec3(spec*i);\r\n}\t\t\r\n\r\nvec4 scene(vec3 ro,vec3 rd)\r\n{\r\n\tvec3 p = vec3(0.0);\r\n\tconst float r = 1.0;\r\n\tfloat t;\t\t\t\t  \r\n\tbool hit = intersectSphere(ro - p, rd, r, t);\r\n\t\r\n\tvec4 c = vec4(0.0);\r\n\tif (hit) {\r\n\t\tvec3 pos = ro + rd*t;\r\n\r\n\t\t// ray-march into volume\r\n\t\tfor(int i=0; i<furLayers; i++) {\r\n\t\t\tvec4 sampleCol;\r\n\t\t\tvec2 uv;\r\n\t\t\tsampleCol.a = furDensity(pos, uv);\r\n\t\t\tif (sampleCol.a > 0.0) {\r\n\t\t\t\tsampleCol.rgb = furShade(pos, uv, ro, sampleCol.a);\r\n\r\n\t\t\t\t// pre-multiply alpha\r\n\t\t\t\tsampleCol.rgb *= sampleCol.a;\r\n\t\t\t\tc = c + sampleCol*(1.0 - c.a);\r\n\t\t\t\tif (c.a > 0.95) break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tpos += rd*rayStep;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv = uv*2.0-1.0;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\r\n\tvec3 rd = normalize(vec3(uv, -2.0));\r\n\t\r\n\tvec2 mouse = iMouse.xy / iResolution.xy;\r\n\tfloat roty = 0.0;\r\n\tfloat rotx = 0.0;\r\n\tif (iMouse.z > 0.0) {\r\n\t\trotx = (mouse.y-0.5)*3.0;\r\n\t\troty = -(mouse.x-0.5)*6.0;\r\n\t} else {\r\n\t\troty = sin(iTime*1.5);\r\n\t}\r\n\t\r\n    ro = rotateX(ro, rotx);\t\r\n    ro = rotateY(ro, roty);\t\r\n    rd = rotateX(rd, rotx);\r\n    rd = rotateY(rd, roty);\r\n\t\r\n\tfragColor = scene(ro, rd);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// https://www.shadertoy.com/view/MdXSzS\r\n// The Big Bang - just a small explosion somewhere in a massive Galaxy of Universes.\r\n// Outside of this there's a massive galaxy of 'Galaxy of Universes'... etc etc. :D\r\n\r\n// To fake a perspective it takes advantage of the screen being wider than it is tall.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\r\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\r\n\tfloat si = sin(t);\r\n\tfloat co = cos(t);\r\n\tmat2 ma = mat2(co, si, -si, co);\r\n\r\n\tfloat v1, v2, v3;\r\n\tv1 = v2 = v3 = 0.0;\r\n\t\r\n\tfloat s = 0.0;\r\n\tfor (int i = 0; i < 90; i++)\r\n\t{\r\n\t\tvec3 p = s * vec3(uv, 0.0);\r\n\t\tp.xy *= ma;\r\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\r\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\r\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\r\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\r\n\t\tv3 += length(p.xy*10.) * .0003;\r\n\t\ts  += .035;\r\n\t}\r\n\t\r\n\tfloat len = length(uv);\r\n\tv1 *= smoothstep(.7, .0, len);\r\n\tv2 *= smoothstep(.5, .0, len);\r\n\tv3 *= smoothstep(.9, .0, len);\r\n\t\r\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\r\n\t\t\t\t\t(v1 + v3) * .3,\r\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\r\n\r\n\tfragColor=vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0);\r\n}","inputs":[],"outputs":[],"code":"// https://www.shadertoy.com/view/MdXSzS\r\n// The Big Bang - just a small explosion somewhere in a massive Galaxy of Universes.\r\n// Outside of this there's a massive galaxy of 'Galaxy of Universes'... etc etc. :D\r\n\r\n// To fake a perspective it takes advantage of the screen being wider than it is tall.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\r\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\r\n\tfloat si = sin(t);\r\n\tfloat co = cos(t);\r\n\tmat2 ma = mat2(co, si, -si, co);\r\n\r\n\tfloat v1, v2, v3;\r\n\tv1 = v2 = v3 = 0.0;\r\n\t\r\n\tfloat s = 0.0;\r\n\tfor (int i = 0; i < 90; i++)\r\n\t{\r\n\t\tvec3 p = s * vec3(uv, 0.0);\r\n\t\tp.xy *= ma;\r\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\r\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\r\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\r\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\r\n\t\tv3 += length(p.xy*10.) * .0003;\r\n\t\ts  += .035;\r\n\t}\r\n\t\r\n\tfloat len = length(uv);\r\n\tv1 *= smoothstep(.7, .0, len);\r\n\tv2 *= smoothstep(.5, .0, len);\r\n\tv3 *= smoothstep(.9, .0, len);\r\n\t\r\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\r\n\t\t\t\t\t(v1 + v3) * .3,\r\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\r\n\r\n\tfragColor=vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Galaxy of Universes","id":"a94afe13a5cb4b7e83f71eff1f11c361","date":null,"viewed":0,"name":"Galaxy of Universes","description":"Big Bang? *pfft* It's just a small explosion somewhere in a rotating Galaxy of Universes!\nThanks to Kali for his fractal formula.\nhttps://www.shadertoy.com/view/MdXSzS","likes":0,"published":null,"tags":["galaxy"," universes"]},"ver":null,"info":{"Name":"Galaxy of Universes","id":"a94afe13a5cb4b7e83f71eff1f11c361","date":null,"viewed":0,"name":"Galaxy of Universes","description":"Big Bang? *pfft* It's just a small explosion somewhere in a rotating Galaxy of Universes!\nThanks to Kali for his fractal formula.\nhttps://www.shadertoy.com/view/MdXSzS","likes":0,"published":null,"tags":["galaxy"," universes"]},"renderpass":[{"Code":"// https://www.shadertoy.com/view/MdXSzS\r\n// The Big Bang - just a small explosion somewhere in a massive Galaxy of Universes.\r\n// Outside of this there's a massive galaxy of 'Galaxy of Universes'... etc etc. :D\r\n\r\n// To fake a perspective it takes advantage of the screen being wider than it is tall.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\r\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\r\n\tfloat si = sin(t);\r\n\tfloat co = cos(t);\r\n\tmat2 ma = mat2(co, si, -si, co);\r\n\r\n\tfloat v1, v2, v3;\r\n\tv1 = v2 = v3 = 0.0;\r\n\t\r\n\tfloat s = 0.0;\r\n\tfor (int i = 0; i < 90; i++)\r\n\t{\r\n\t\tvec3 p = s * vec3(uv, 0.0);\r\n\t\tp.xy *= ma;\r\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\r\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\r\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\r\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\r\n\t\tv3 += length(p.xy*10.) * .0003;\r\n\t\ts  += .035;\r\n\t}\r\n\t\r\n\tfloat len = length(uv);\r\n\tv1 *= smoothstep(.7, .0, len);\r\n\tv2 *= smoothstep(.5, .0, len);\r\n\tv3 *= smoothstep(.9, .0, len);\r\n\t\r\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\r\n\t\t\t\t\t(v1 + v3) * .3,\r\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\r\n\r\n\tfragColor=vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0);\r\n}","inputs":[],"outputs":[],"code":"// https://www.shadertoy.com/view/MdXSzS\r\n// The Big Bang - just a small explosion somewhere in a massive Galaxy of Universes.\r\n// Outside of this there's a massive galaxy of 'Galaxy of Universes'... etc etc. :D\r\n\r\n// To fake a perspective it takes advantage of the screen being wider than it is tall.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\r\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\r\n\tfloat si = sin(t);\r\n\tfloat co = cos(t);\r\n\tmat2 ma = mat2(co, si, -si, co);\r\n\r\n\tfloat v1, v2, v3;\r\n\tv1 = v2 = v3 = 0.0;\r\n\t\r\n\tfloat s = 0.0;\r\n\tfor (int i = 0; i < 90; i++)\r\n\t{\r\n\t\tvec3 p = s * vec3(uv, 0.0);\r\n\t\tp.xy *= ma;\r\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\r\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\r\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\r\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\r\n\t\tv3 += length(p.xy*10.) * .0003;\r\n\t\ts  += .035;\r\n\t}\r\n\t\r\n\tfloat len = length(uv);\r\n\tv1 *= smoothstep(.7, .0, len);\r\n\tv2 *= smoothstep(.5, .0, len);\r\n\tv3 *= smoothstep(.9, .0, len);\r\n\t\r\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\r\n\t\t\t\t\t(v1 + v3) * .3,\r\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\r\n\r\n\tfragColor=vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"float M = 10.;\r\n\r\nfloat rnd(vec2 uv, float n) {\r\n#if 1\r\n\tuv -= .5*n;\r\n\treturn mod(sin(34556.456*uv.x-457523.345*uv.y)*345674.54,1.);\r\n#else\r\n\tuv *= 4.*iResolution.y/256.;\r\n\treturn (n==0.) ? texture(iChannel0,uv).r : texture(iChannel0,uv).g;\r\n#endif\r\n}\r\n\r\nfloat gauss(float m, float s, vec2 uv) {\r\n\tfloat x = rnd(uv,0.), y=rnd(uv,1.);\r\n\treturn m + s* sqrt(-2.*log(x+1e-6))*cos(2.*3.14159*y); // http://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\r\n}\r\n\r\nfloat poisson(float m, vec2 uv) { // good approx for m >= 10 \r\n\treturn gauss(m-.5,sqrt(m),uv);  // http://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\r\n}\r\n\r\n#define SCALES 8.\r\nfloat poisson_rec(float m, vec2 uv) {\r\n\tfloat s = pow(4.,SCALES);\r\n\tm *= s;\r\n\tfor (float i=0.; i<SCALES; i++) {\r\n\t\tm = poisson(m/4.,(uv+i)/s);  // +i)/s for decorrelation\r\n\t\ts /= 4.;\r\n\t}\r\n\t\r\n\treturn m;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat c;\r\n\tvec2 uv = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy/iResolution.xy;\r\n\tif (iMouse.x+iMouse.y>0.)\r\n\t\tM = pow(2., 20.* (mouse.y-.5));\r\n\t\r\n\tif (abs(uv.x-.5*iResolution.x/iResolution.y)<2e-3) {\r\n\t\tfragColor = vec4(1.,0.,0.,0.);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t//uv *= 2.*mouse.x;\r\n\tif (uv.x<0.)\r\n\t\tc = poisson(M,uv)/(2.*M);\r\n\telse\r\n\t\tc = poisson_rec(M,uv)/(2.*M);\r\n\t\r\n\tfragColor = vec4(c);\r\n}","inputs":[],"outputs":[],"code":"float M = 10.;\r\n\r\nfloat rnd(vec2 uv, float n) {\r\n#if 1\r\n\tuv -= .5*n;\r\n\treturn mod(sin(34556.456*uv.x-457523.345*uv.y)*345674.54,1.);\r\n#else\r\n\tuv *= 4.*iResolution.y/256.;\r\n\treturn (n==0.) ? texture(iChannel0,uv).r : texture(iChannel0,uv).g;\r\n#endif\r\n}\r\n\r\nfloat gauss(float m, float s, vec2 uv) {\r\n\tfloat x = rnd(uv,0.), y=rnd(uv,1.);\r\n\treturn m + s* sqrt(-2.*log(x+1e-6))*cos(2.*3.14159*y); // http://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\r\n}\r\n\r\nfloat poisson(float m, vec2 uv) { // good approx for m >= 10 \r\n\treturn gauss(m-.5,sqrt(m),uv);  // http://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\r\n}\r\n\r\n#define SCALES 8.\r\nfloat poisson_rec(float m, vec2 uv) {\r\n\tfloat s = pow(4.,SCALES);\r\n\tm *= s;\r\n\tfor (float i=0.; i<SCALES; i++) {\r\n\t\tm = poisson(m/4.,(uv+i)/s);  // +i)/s for decorrelation\r\n\t\ts /= 4.;\r\n\t}\r\n\t\r\n\treturn m;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat c;\r\n\tvec2 uv = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy/iResolution.xy;\r\n\tif (iMouse.x+iMouse.y>0.)\r\n\t\tM = pow(2., 20.* (mouse.y-.5));\r\n\t\r\n\tif (abs(uv.x-.5*iResolution.x/iResolution.y)<2e-3) {\r\n\t\tfragColor = vec4(1.,0.,0.,0.);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t//uv *= 2.*mouse.x;\r\n\tif (uv.x<0.)\r\n\t\tc = poisson(M,uv)/(2.*M);\r\n\telse\r\n\t\tc = poisson_rec(M,uv)/(2.*M);\r\n\t\r\n\tfragColor = vec4(c);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"gauss / poisson process","id":"05a777fdac004d6bb55bbf73349f0513","date":null,"viewed":0,"name":"gauss / poisson process","description":"Poisson process = uniform points distribution (e.g, stars) with average M per pixel.\npixel-average law = Poisson(M) ~ gauss(M-.5,sqrt(M))\ndensity = 2^(10*Mouse.y) , mouse in -1..1\nLeft: pixel-based Poisson.   Right: recursive Poisson.  \nhttps://www.shadertoy.com/view/4dsSR2","likes":0,"published":null,"tags":["random"," stars"]},"ver":null,"info":{"Name":"gauss / poisson process","id":"05a777fdac004d6bb55bbf73349f0513","date":null,"viewed":0,"name":"gauss / poisson process","description":"Poisson process = uniform points distribution (e.g, stars) with average M per pixel.\npixel-average law = Poisson(M) ~ gauss(M-.5,sqrt(M))\ndensity = 2^(10*Mouse.y) , mouse in -1..1\nLeft: pixel-based Poisson.   Right: recursive Poisson.  \nhttps://www.shadertoy.com/view/4dsSR2","likes":0,"published":null,"tags":["random"," stars"]},"renderpass":[{"Code":"float M = 10.;\r\n\r\nfloat rnd(vec2 uv, float n) {\r\n#if 1\r\n\tuv -= .5*n;\r\n\treturn mod(sin(34556.456*uv.x-457523.345*uv.y)*345674.54,1.);\r\n#else\r\n\tuv *= 4.*iResolution.y/256.;\r\n\treturn (n==0.) ? texture(iChannel0,uv).r : texture(iChannel0,uv).g;\r\n#endif\r\n}\r\n\r\nfloat gauss(float m, float s, vec2 uv) {\r\n\tfloat x = rnd(uv,0.), y=rnd(uv,1.);\r\n\treturn m + s* sqrt(-2.*log(x+1e-6))*cos(2.*3.14159*y); // http://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\r\n}\r\n\r\nfloat poisson(float m, vec2 uv) { // good approx for m >= 10 \r\n\treturn gauss(m-.5,sqrt(m),uv);  // http://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\r\n}\r\n\r\n#define SCALES 8.\r\nfloat poisson_rec(float m, vec2 uv) {\r\n\tfloat s = pow(4.,SCALES);\r\n\tm *= s;\r\n\tfor (float i=0.; i<SCALES; i++) {\r\n\t\tm = poisson(m/4.,(uv+i)/s);  // +i)/s for decorrelation\r\n\t\ts /= 4.;\r\n\t}\r\n\t\r\n\treturn m;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat c;\r\n\tvec2 uv = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy/iResolution.xy;\r\n\tif (iMouse.x+iMouse.y>0.)\r\n\t\tM = pow(2., 20.* (mouse.y-.5));\r\n\t\r\n\tif (abs(uv.x-.5*iResolution.x/iResolution.y)<2e-3) {\r\n\t\tfragColor = vec4(1.,0.,0.,0.);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t//uv *= 2.*mouse.x;\r\n\tif (uv.x<0.)\r\n\t\tc = poisson(M,uv)/(2.*M);\r\n\telse\r\n\t\tc = poisson_rec(M,uv)/(2.*M);\r\n\t\r\n\tfragColor = vec4(c);\r\n}","inputs":[],"outputs":[],"code":"float M = 10.;\r\n\r\nfloat rnd(vec2 uv, float n) {\r\n#if 1\r\n\tuv -= .5*n;\r\n\treturn mod(sin(34556.456*uv.x-457523.345*uv.y)*345674.54,1.);\r\n#else\r\n\tuv *= 4.*iResolution.y/256.;\r\n\treturn (n==0.) ? texture(iChannel0,uv).r : texture(iChannel0,uv).g;\r\n#endif\r\n}\r\n\r\nfloat gauss(float m, float s, vec2 uv) {\r\n\tfloat x = rnd(uv,0.), y=rnd(uv,1.);\r\n\treturn m + s* sqrt(-2.*log(x+1e-6))*cos(2.*3.14159*y); // http://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\r\n}\r\n\r\nfloat poisson(float m, vec2 uv) { // good approx for m >= 10 \r\n\treturn gauss(m-.5,sqrt(m),uv);  // http://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\r\n}\r\n\r\n#define SCALES 8.\r\nfloat poisson_rec(float m, vec2 uv) {\r\n\tfloat s = pow(4.,SCALES);\r\n\tm *= s;\r\n\tfor (float i=0.; i<SCALES; i++) {\r\n\t\tm = poisson(m/4.,(uv+i)/s);  // +i)/s for decorrelation\r\n\t\ts /= 4.;\r\n\t}\r\n\t\r\n\treturn m;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat c;\r\n\tvec2 uv = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy/iResolution.xy;\r\n\tif (iMouse.x+iMouse.y>0.)\r\n\t\tM = pow(2., 20.* (mouse.y-.5));\r\n\t\r\n\tif (abs(uv.x-.5*iResolution.x/iResolution.y)<2e-3) {\r\n\t\tfragColor = vec4(1.,0.,0.,0.);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t//uv *= 2.*mouse.x;\r\n\tif (uv.x<0.)\r\n\t\tc = poisson(M,uv)/(2.*M);\r\n\telse\r\n\t\tc = poisson_rec(M,uv)/(2.*M);\r\n\t\r\n\tfragColor = vec4(c);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Generations (4K)\r\n//\r\n// The result of an ultra-quick coding session.\r\n//\r\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\r\n// and a bunch of others for sharing their knowledge!\r\n\r\n#define MIN_DIST         0.0015\r\n#define MAX_DIST         64.0\r\n#define MAX_STEPS        45.0\r\n#define SHADOW_STEPS     32.0\r\n#define MAX_SHADOW_DIST  20.0\r\n\r\nstruct MarchData {\r\n    float d;\r\n    vec3 mat;        // RGB\r\n    float specPower; // 0: None, 30.0: Shiny\r\n};\r\n\r\nfloat smin(float a, float b, float k) {\r\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n    return mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nMarchData minResult(MarchData a, MarchData b) {\r\n    if (a.d < b.d) return a;\r\n    return b;\r\n}\r\n\r\nmat2 rot(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\nfloat sdCappedCylinder(vec3 p, float h, float r) {\r\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\r\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat sdTorus(vec3 p, vec2 t) {\r\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\r\n  return length(q) - t.y;\r\n}\r\n\r\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\r\n    vec3 forward = normalize(lookAt - ro);\r\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\r\n    vec3 up = cross(forward, right);\r\n    return normalize(forward + right * uv.x + up * uv.y);\r\n}\r\n\r\nfloat sdPawn(vec3 p) {\r\n    p.y -= 3.2;\r\n    float d = max(length(p.xz) - 0.3, p.y);\r\n    d = smin(d, length(p) - 0.8, 0.1);\r\n    p.y += 1.05;\r\n    d = smin(d, sdCappedCylinder(p, 0.75, 0.07), 0.5);\r\n    p.y += 1.5;\r\n    d = smin(d, sdCappedCylinder(p, 0.75, 0.12), 0.5);\r\n    p.y += 0.4;\r\n    return smin(d, sdCappedCylinder(p, 0.9, 0.2), 0.4);\r\n}\r\n\r\nfloat sdKing(vec3 p) {\r\n    p.y -= 1.85;\r\n    float d = sdCappedCylinder(p, 0.4 - 0.14 * cos(p.y * 1.4 - 0.8), 2.0);\r\n    \r\n    p.y -= 1.0;\r\n    d = smin(d, sdCappedCylinder(p, 0.7, 0.1), 0.2);\r\n    \r\n    p.y += 2.0;\r\n    d = smin(d, sdCappedCylinder(p, 0.7, 0.1), 0.2);\r\n    p.y += 0.5;\r\n    d = smin(d, sdCappedCylinder(p, 1.0, 0.3), 0.1);\r\n    \r\n    vec3 c = vec3(0.5, 0.2, 0.1);\r\n    p.xz *= rot(-0.7);\r\n    d = min(d, sdBox(p - vec3(0.0, 4.0, 0.0), c));\r\n    \r\n    return min(d, sdBox(p - vec3(0.0, 4.0, 0.0), c.yxz));\r\n}\r\n\r\n// Map the scene using SDF functions.\r\nMarchData map(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(0.8);\r\n    result.specPower = 20.0;\r\n    \r\n    result.d = sdPawn(p * 1.2);\r\n    \r\n    float gnd = length(p.y);\r\n    if (gnd < result.d) {\r\n        result.d = gnd;\r\n        result.mat = vec3(0.2);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nvec3 calcNormal(vec3 p, float t) {\r\n    vec2 e = vec2(0.5773, -0.5773) * t * 0.003;\r\n    return normalize(e.xyy * map(p + e.xyy).d + \r\n\t\t\t\t\t   e.yyx * map(p + e.yyx).d + \r\n\t\t\t\t\t   e.yxy * map(p + e.yxy).d + \r\n\t\t\t\t\t   e.xxx * map(p + e.xxx).d);\r\n}\r\n\r\nfloat calcShadow(vec3 p, vec3 lightPos) {\r\n    // Thanks iq.\r\n    vec3 rd = normalize(lightPos - p);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = 0.5;\r\n    for (float i = 0.0; i < SHADOW_STEPS; i++)\r\n    {\r\n\t\tfloat h = sdKing(p + rd * t);\r\n        res = min(res, 150.0 * h / t);\r\n        t += h;\r\n        if (res < 0.01 || t > MAX_SHADOW_DIST) break;\r\n    }\r\n    \r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n// Quick ambient occlusion.\r\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\r\n\r\n/**********************************************************************************/\r\n\r\nvec3 vignette(vec3 col, vec2 fragCoord) {\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\r\n    return col;\r\n}\r\n\r\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\r\n    const vec3 sunCol = vec3(2.0, 1.6, 1.4);\r\n    const vec3 sunPos = vec2(-8.0, 8.0).xyx;\r\n    vec3 sunDir = normalize(sunPos - p);\r\n    vec3 n = calcNormal(p, d);\r\n    float ao = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\r\n    \r\n    // Primary light.\r\n    float primary = max(0.0, dot(sunDir, n));\r\n    \r\n    // Secondary(/bounce) light.\r\n    float bounce = max(0.0, dot(sunDir * vec3(-1.0, 0.0, -1.0), n)) * 0.1;\r\n\r\n    // Specular.\r\n    float spe = smoothstep(0.0, 1.0, pow(max(0.0, dot(rd, reflect(sunDir, n))), data.specPower));\r\n    \r\n    // Combine.\r\n    primary *= mix(0.4, 1.0, calcShadow(p, sunPos));\r\n    vec3 lig = ((primary + bounce) * ao + spe) * sunCol;\r\n    \r\n    return data.mat * lig * exp(-length(p) * 0.1);\r\n}\r\n\r\nvec3 getSceneColor(vec3 ro, vec3 rd) {\r\n    // Raymarch.\r\n    vec3 p;\r\n    \r\n    float d = 0.01;\r\n    MarchData h;\r\n    for (float steps = 0.0; steps < MAX_STEPS; steps++) {\r\n        p = ro + rd * d;\r\n        h = map(p);\r\n        \r\n        if (abs(h.d) < MIN_DIST)\r\n            break;\r\n        \r\n        if (d > MAX_DIST)\r\n            return vec3(0.0); // Distance limit reached - Stop.\r\n        \r\n        d += h.d; // No hit, so keep marching.\r\n    }\r\n    \r\n    // Lighting.\r\n    return applyLighting(p, rd, d, h);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    // Camera.\r\n    vec3 lookAt = vec3(2.0, 2.0 + 2.0, 0.0);\r\n    vec3 ro = vec3(2.0, 5.0, -10.0);\r\n    ro.yz *= rot(-0.2);\r\n    \r\n    vec3 col = vec3(0.0);\r\n\r\n    for (float dx = 0.0; dx <= 1.0; dx++) {\r\n        for (float dy = 0.0; dy <= 1.0; dy++) {\r\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\r\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\r\n\r\n            col += getSceneColor(ro, getRayDir(ro, lookAt, uv));\r\n        }\r\n    }\r\n    col /= 4.0;\r\n    \r\n    // Output to screen.\r\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Generations (4K)\r\n//\r\n// The result of an ultra-quick coding session.\r\n//\r\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\r\n// and a bunch of others for sharing their knowledge!\r\n\r\n#define MIN_DIST         0.0015\r\n#define MAX_DIST         64.0\r\n#define MAX_STEPS        45.0\r\n#define SHADOW_STEPS     32.0\r\n#define MAX_SHADOW_DIST  20.0\r\n\r\nstruct MarchData {\r\n    float d;\r\n    vec3 mat;        // RGB\r\n    float specPower; // 0: None, 30.0: Shiny\r\n};\r\n\r\nfloat smin(float a, float b, float k) {\r\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n    return mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nMarchData minResult(MarchData a, MarchData b) {\r\n    if (a.d < b.d) return a;\r\n    return b;\r\n}\r\n\r\nmat2 rot(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\nfloat sdCappedCylinder(vec3 p, float h, float r) {\r\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\r\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat sdTorus(vec3 p, vec2 t) {\r\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\r\n  return length(q) - t.y;\r\n}\r\n\r\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\r\n    vec3 forward = normalize(lookAt - ro);\r\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\r\n    vec3 up = cross(forward, right);\r\n    return normalize(forward + right * uv.x + up * uv.y);\r\n}\r\n\r\nfloat sdPawn(vec3 p) {\r\n    p.y -= 3.2;\r\n    float d = max(length(p.xz) - 0.3, p.y);\r\n    d = smin(d, length(p) - 0.8, 0.1);\r\n    p.y += 1.05;\r\n    d = smin(d, sdCappedCylinder(p, 0.75, 0.07), 0.5);\r\n    p.y += 1.5;\r\n    d = smin(d, sdCappedCylinder(p, 0.75, 0.12), 0.5);\r\n    p.y += 0.4;\r\n    return smin(d, sdCappedCylinder(p, 0.9, 0.2), 0.4);\r\n}\r\n\r\nfloat sdKing(vec3 p) {\r\n    p.y -= 1.85;\r\n    float d = sdCappedCylinder(p, 0.4 - 0.14 * cos(p.y * 1.4 - 0.8), 2.0);\r\n    \r\n    p.y -= 1.0;\r\n    d = smin(d, sdCappedCylinder(p, 0.7, 0.1), 0.2);\r\n    \r\n    p.y += 2.0;\r\n    d = smin(d, sdCappedCylinder(p, 0.7, 0.1), 0.2);\r\n    p.y += 0.5;\r\n    d = smin(d, sdCappedCylinder(p, 1.0, 0.3), 0.1);\r\n    \r\n    vec3 c = vec3(0.5, 0.2, 0.1);\r\n    p.xz *= rot(-0.7);\r\n    d = min(d, sdBox(p - vec3(0.0, 4.0, 0.0), c));\r\n    \r\n    return min(d, sdBox(p - vec3(0.0, 4.0, 0.0), c.yxz));\r\n}\r\n\r\n// Map the scene using SDF functions.\r\nMarchData map(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(0.8);\r\n    result.specPower = 20.0;\r\n    \r\n    result.d = sdPawn(p * 1.2);\r\n    \r\n    float gnd = length(p.y);\r\n    if (gnd < result.d) {\r\n        result.d = gnd;\r\n        result.mat = vec3(0.2);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nvec3 calcNormal(vec3 p, float t) {\r\n    vec2 e = vec2(0.5773, -0.5773) * t * 0.003;\r\n    return normalize(e.xyy * map(p + e.xyy).d + \r\n\t\t\t\t\t   e.yyx * map(p + e.yyx).d + \r\n\t\t\t\t\t   e.yxy * map(p + e.yxy).d + \r\n\t\t\t\t\t   e.xxx * map(p + e.xxx).d);\r\n}\r\n\r\nfloat calcShadow(vec3 p, vec3 lightPos) {\r\n    // Thanks iq.\r\n    vec3 rd = normalize(lightPos - p);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = 0.5;\r\n    for (float i = 0.0; i < SHADOW_STEPS; i++)\r\n    {\r\n\t\tfloat h = sdKing(p + rd * t);\r\n        res = min(res, 150.0 * h / t);\r\n        t += h;\r\n        if (res < 0.01 || t > MAX_SHADOW_DIST) break;\r\n    }\r\n    \r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n// Quick ambient occlusion.\r\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\r\n\r\n/**********************************************************************************/\r\n\r\nvec3 vignette(vec3 col, vec2 fragCoord) {\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\r\n    return col;\r\n}\r\n\r\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\r\n    const vec3 sunCol = vec3(2.0, 1.6, 1.4);\r\n    const vec3 sunPos = vec2(-8.0, 8.0).xyx;\r\n    vec3 sunDir = normalize(sunPos - p);\r\n    vec3 n = calcNormal(p, d);\r\n    float ao = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\r\n    \r\n    // Primary light.\r\n    float primary = max(0.0, dot(sunDir, n));\r\n    \r\n    // Secondary(/bounce) light.\r\n    float bounce = max(0.0, dot(sunDir * vec3(-1.0, 0.0, -1.0), n)) * 0.1;\r\n\r\n    // Specular.\r\n    float spe = smoothstep(0.0, 1.0, pow(max(0.0, dot(rd, reflect(sunDir, n))), data.specPower));\r\n    \r\n    // Combine.\r\n    primary *= mix(0.4, 1.0, calcShadow(p, sunPos));\r\n    vec3 lig = ((primary + bounce) * ao + spe) * sunCol;\r\n    \r\n    return data.mat * lig * exp(-length(p) * 0.1);\r\n}\r\n\r\nvec3 getSceneColor(vec3 ro, vec3 rd) {\r\n    // Raymarch.\r\n    vec3 p;\r\n    \r\n    float d = 0.01;\r\n    MarchData h;\r\n    for (float steps = 0.0; steps < MAX_STEPS; steps++) {\r\n        p = ro + rd * d;\r\n        h = map(p);\r\n        \r\n        if (abs(h.d) < MIN_DIST)\r\n            break;\r\n        \r\n        if (d > MAX_DIST)\r\n            return vec3(0.0); // Distance limit reached - Stop.\r\n        \r\n        d += h.d; // No hit, so keep marching.\r\n    }\r\n    \r\n    // Lighting.\r\n    return applyLighting(p, rd, d, h);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    // Camera.\r\n    vec3 lookAt = vec3(2.0, 2.0 + 2.0, 0.0);\r\n    vec3 ro = vec3(2.0, 5.0, -10.0);\r\n    ro.yz *= rot(-0.2);\r\n    \r\n    vec3 col = vec3(0.0);\r\n\r\n    for (float dx = 0.0; dx <= 1.0; dx++) {\r\n        for (float dy = 0.0; dy <= 1.0; dy++) {\r\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\r\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\r\n\r\n            col += getSceneColor(ro, getRayDir(ro, lookAt, uv));\r\n        }\r\n    }\r\n    col /= 4.0;\r\n    \r\n    // Output to screen.\r\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Generations (4K)","id":"5318650883654c41b1aedd4dfc9896d1","date":null,"viewed":0,"name":"Generations (4K)","description":"The result of an ultra-quick coding session.\nA reproduction of a common image.\nhttps://www.shadertoy.com/view/WscBzB","likes":0,"published":null,"tags":["3d"," raymarching"," chess"," reproduction"," cineshader"]},"ver":null,"info":{"Name":"Generations (4K)","id":"5318650883654c41b1aedd4dfc9896d1","date":null,"viewed":0,"name":"Generations (4K)","description":"The result of an ultra-quick coding session.\nA reproduction of a common image.\nhttps://www.shadertoy.com/view/WscBzB","likes":0,"published":null,"tags":["3d"," raymarching"," chess"," reproduction"," cineshader"]},"renderpass":[{"Code":"// Generations (4K)\r\n//\r\n// The result of an ultra-quick coding session.\r\n//\r\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\r\n// and a bunch of others for sharing their knowledge!\r\n\r\n#define MIN_DIST         0.0015\r\n#define MAX_DIST         64.0\r\n#define MAX_STEPS        45.0\r\n#define SHADOW_STEPS     32.0\r\n#define MAX_SHADOW_DIST  20.0\r\n\r\nstruct MarchData {\r\n    float d;\r\n    vec3 mat;        // RGB\r\n    float specPower; // 0: None, 30.0: Shiny\r\n};\r\n\r\nfloat smin(float a, float b, float k) {\r\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n    return mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nMarchData minResult(MarchData a, MarchData b) {\r\n    if (a.d < b.d) return a;\r\n    return b;\r\n}\r\n\r\nmat2 rot(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\nfloat sdCappedCylinder(vec3 p, float h, float r) {\r\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\r\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat sdTorus(vec3 p, vec2 t) {\r\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\r\n  return length(q) - t.y;\r\n}\r\n\r\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\r\n    vec3 forward = normalize(lookAt - ro);\r\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\r\n    vec3 up = cross(forward, right);\r\n    return normalize(forward + right * uv.x + up * uv.y);\r\n}\r\n\r\nfloat sdPawn(vec3 p) {\r\n    p.y -= 3.2;\r\n    float d = max(length(p.xz) - 0.3, p.y);\r\n    d = smin(d, length(p) - 0.8, 0.1);\r\n    p.y += 1.05;\r\n    d = smin(d, sdCappedCylinder(p, 0.75, 0.07), 0.5);\r\n    p.y += 1.5;\r\n    d = smin(d, sdCappedCylinder(p, 0.75, 0.12), 0.5);\r\n    p.y += 0.4;\r\n    return smin(d, sdCappedCylinder(p, 0.9, 0.2), 0.4);\r\n}\r\n\r\nfloat sdKing(vec3 p) {\r\n    p.y -= 1.85;\r\n    float d = sdCappedCylinder(p, 0.4 - 0.14 * cos(p.y * 1.4 - 0.8), 2.0);\r\n    \r\n    p.y -= 1.0;\r\n    d = smin(d, sdCappedCylinder(p, 0.7, 0.1), 0.2);\r\n    \r\n    p.y += 2.0;\r\n    d = smin(d, sdCappedCylinder(p, 0.7, 0.1), 0.2);\r\n    p.y += 0.5;\r\n    d = smin(d, sdCappedCylinder(p, 1.0, 0.3), 0.1);\r\n    \r\n    vec3 c = vec3(0.5, 0.2, 0.1);\r\n    p.xz *= rot(-0.7);\r\n    d = min(d, sdBox(p - vec3(0.0, 4.0, 0.0), c));\r\n    \r\n    return min(d, sdBox(p - vec3(0.0, 4.0, 0.0), c.yxz));\r\n}\r\n\r\n// Map the scene using SDF functions.\r\nMarchData map(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(0.8);\r\n    result.specPower = 20.0;\r\n    \r\n    result.d = sdPawn(p * 1.2);\r\n    \r\n    float gnd = length(p.y);\r\n    if (gnd < result.d) {\r\n        result.d = gnd;\r\n        result.mat = vec3(0.2);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nvec3 calcNormal(vec3 p, float t) {\r\n    vec2 e = vec2(0.5773, -0.5773) * t * 0.003;\r\n    return normalize(e.xyy * map(p + e.xyy).d + \r\n\t\t\t\t\t   e.yyx * map(p + e.yyx).d + \r\n\t\t\t\t\t   e.yxy * map(p + e.yxy).d + \r\n\t\t\t\t\t   e.xxx * map(p + e.xxx).d);\r\n}\r\n\r\nfloat calcShadow(vec3 p, vec3 lightPos) {\r\n    // Thanks iq.\r\n    vec3 rd = normalize(lightPos - p);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = 0.5;\r\n    for (float i = 0.0; i < SHADOW_STEPS; i++)\r\n    {\r\n\t\tfloat h = sdKing(p + rd * t);\r\n        res = min(res, 150.0 * h / t);\r\n        t += h;\r\n        if (res < 0.01 || t > MAX_SHADOW_DIST) break;\r\n    }\r\n    \r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n// Quick ambient occlusion.\r\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\r\n\r\n/**********************************************************************************/\r\n\r\nvec3 vignette(vec3 col, vec2 fragCoord) {\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\r\n    return col;\r\n}\r\n\r\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\r\n    const vec3 sunCol = vec3(2.0, 1.6, 1.4);\r\n    const vec3 sunPos = vec2(-8.0, 8.0).xyx;\r\n    vec3 sunDir = normalize(sunPos - p);\r\n    vec3 n = calcNormal(p, d);\r\n    float ao = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\r\n    \r\n    // Primary light.\r\n    float primary = max(0.0, dot(sunDir, n));\r\n    \r\n    // Secondary(/bounce) light.\r\n    float bounce = max(0.0, dot(sunDir * vec3(-1.0, 0.0, -1.0), n)) * 0.1;\r\n\r\n    // Specular.\r\n    float spe = smoothstep(0.0, 1.0, pow(max(0.0, dot(rd, reflect(sunDir, n))), data.specPower));\r\n    \r\n    // Combine.\r\n    primary *= mix(0.4, 1.0, calcShadow(p, sunPos));\r\n    vec3 lig = ((primary + bounce) * ao + spe) * sunCol;\r\n    \r\n    return data.mat * lig * exp(-length(p) * 0.1);\r\n}\r\n\r\nvec3 getSceneColor(vec3 ro, vec3 rd) {\r\n    // Raymarch.\r\n    vec3 p;\r\n    \r\n    float d = 0.01;\r\n    MarchData h;\r\n    for (float steps = 0.0; steps < MAX_STEPS; steps++) {\r\n        p = ro + rd * d;\r\n        h = map(p);\r\n        \r\n        if (abs(h.d) < MIN_DIST)\r\n            break;\r\n        \r\n        if (d > MAX_DIST)\r\n            return vec3(0.0); // Distance limit reached - Stop.\r\n        \r\n        d += h.d; // No hit, so keep marching.\r\n    }\r\n    \r\n    // Lighting.\r\n    return applyLighting(p, rd, d, h);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    // Camera.\r\n    vec3 lookAt = vec3(2.0, 2.0 + 2.0, 0.0);\r\n    vec3 ro = vec3(2.0, 5.0, -10.0);\r\n    ro.yz *= rot(-0.2);\r\n    \r\n    vec3 col = vec3(0.0);\r\n\r\n    for (float dx = 0.0; dx <= 1.0; dx++) {\r\n        for (float dy = 0.0; dy <= 1.0; dy++) {\r\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\r\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\r\n\r\n            col += getSceneColor(ro, getRayDir(ro, lookAt, uv));\r\n        }\r\n    }\r\n    col /= 4.0;\r\n    \r\n    // Output to screen.\r\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Generations (4K)\r\n//\r\n// The result of an ultra-quick coding session.\r\n//\r\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\r\n// and a bunch of others for sharing their knowledge!\r\n\r\n#define MIN_DIST         0.0015\r\n#define MAX_DIST         64.0\r\n#define MAX_STEPS        45.0\r\n#define SHADOW_STEPS     32.0\r\n#define MAX_SHADOW_DIST  20.0\r\n\r\nstruct MarchData {\r\n    float d;\r\n    vec3 mat;        // RGB\r\n    float specPower; // 0: None, 30.0: Shiny\r\n};\r\n\r\nfloat smin(float a, float b, float k) {\r\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n    return mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nMarchData minResult(MarchData a, MarchData b) {\r\n    if (a.d < b.d) return a;\r\n    return b;\r\n}\r\n\r\nmat2 rot(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\nfloat sdCappedCylinder(vec3 p, float h, float r) {\r\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\r\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nfloat sdTorus(vec3 p, vec2 t) {\r\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\r\n  return length(q) - t.y;\r\n}\r\n\r\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\r\n    vec3 forward = normalize(lookAt - ro);\r\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\r\n    vec3 up = cross(forward, right);\r\n    return normalize(forward + right * uv.x + up * uv.y);\r\n}\r\n\r\nfloat sdPawn(vec3 p) {\r\n    p.y -= 3.2;\r\n    float d = max(length(p.xz) - 0.3, p.y);\r\n    d = smin(d, length(p) - 0.8, 0.1);\r\n    p.y += 1.05;\r\n    d = smin(d, sdCappedCylinder(p, 0.75, 0.07), 0.5);\r\n    p.y += 1.5;\r\n    d = smin(d, sdCappedCylinder(p, 0.75, 0.12), 0.5);\r\n    p.y += 0.4;\r\n    return smin(d, sdCappedCylinder(p, 0.9, 0.2), 0.4);\r\n}\r\n\r\nfloat sdKing(vec3 p) {\r\n    p.y -= 1.85;\r\n    float d = sdCappedCylinder(p, 0.4 - 0.14 * cos(p.y * 1.4 - 0.8), 2.0);\r\n    \r\n    p.y -= 1.0;\r\n    d = smin(d, sdCappedCylinder(p, 0.7, 0.1), 0.2);\r\n    \r\n    p.y += 2.0;\r\n    d = smin(d, sdCappedCylinder(p, 0.7, 0.1), 0.2);\r\n    p.y += 0.5;\r\n    d = smin(d, sdCappedCylinder(p, 1.0, 0.3), 0.1);\r\n    \r\n    vec3 c = vec3(0.5, 0.2, 0.1);\r\n    p.xz *= rot(-0.7);\r\n    d = min(d, sdBox(p - vec3(0.0, 4.0, 0.0), c));\r\n    \r\n    return min(d, sdBox(p - vec3(0.0, 4.0, 0.0), c.yxz));\r\n}\r\n\r\n// Map the scene using SDF functions.\r\nMarchData map(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(0.8);\r\n    result.specPower = 20.0;\r\n    \r\n    result.d = sdPawn(p * 1.2);\r\n    \r\n    float gnd = length(p.y);\r\n    if (gnd < result.d) {\r\n        result.d = gnd;\r\n        result.mat = vec3(0.2);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nvec3 calcNormal(vec3 p, float t) {\r\n    vec2 e = vec2(0.5773, -0.5773) * t * 0.003;\r\n    return normalize(e.xyy * map(p + e.xyy).d + \r\n\t\t\t\t\t   e.yyx * map(p + e.yyx).d + \r\n\t\t\t\t\t   e.yxy * map(p + e.yxy).d + \r\n\t\t\t\t\t   e.xxx * map(p + e.xxx).d);\r\n}\r\n\r\nfloat calcShadow(vec3 p, vec3 lightPos) {\r\n    // Thanks iq.\r\n    vec3 rd = normalize(lightPos - p);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = 0.5;\r\n    for (float i = 0.0; i < SHADOW_STEPS; i++)\r\n    {\r\n\t\tfloat h = sdKing(p + rd * t);\r\n        res = min(res, 150.0 * h / t);\r\n        t += h;\r\n        if (res < 0.01 || t > MAX_SHADOW_DIST) break;\r\n    }\r\n    \r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n// Quick ambient occlusion.\r\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\r\n\r\n/**********************************************************************************/\r\n\r\nvec3 vignette(vec3 col, vec2 fragCoord) {\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\r\n    return col;\r\n}\r\n\r\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\r\n    const vec3 sunCol = vec3(2.0, 1.6, 1.4);\r\n    const vec3 sunPos = vec2(-8.0, 8.0).xyx;\r\n    vec3 sunDir = normalize(sunPos - p);\r\n    vec3 n = calcNormal(p, d);\r\n    float ao = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\r\n    \r\n    // Primary light.\r\n    float primary = max(0.0, dot(sunDir, n));\r\n    \r\n    // Secondary(/bounce) light.\r\n    float bounce = max(0.0, dot(sunDir * vec3(-1.0, 0.0, -1.0), n)) * 0.1;\r\n\r\n    // Specular.\r\n    float spe = smoothstep(0.0, 1.0, pow(max(0.0, dot(rd, reflect(sunDir, n))), data.specPower));\r\n    \r\n    // Combine.\r\n    primary *= mix(0.4, 1.0, calcShadow(p, sunPos));\r\n    vec3 lig = ((primary + bounce) * ao + spe) * sunCol;\r\n    \r\n    return data.mat * lig * exp(-length(p) * 0.1);\r\n}\r\n\r\nvec3 getSceneColor(vec3 ro, vec3 rd) {\r\n    // Raymarch.\r\n    vec3 p;\r\n    \r\n    float d = 0.01;\r\n    MarchData h;\r\n    for (float steps = 0.0; steps < MAX_STEPS; steps++) {\r\n        p = ro + rd * d;\r\n        h = map(p);\r\n        \r\n        if (abs(h.d) < MIN_DIST)\r\n            break;\r\n        \r\n        if (d > MAX_DIST)\r\n            return vec3(0.0); // Distance limit reached - Stop.\r\n        \r\n        d += h.d; // No hit, so keep marching.\r\n    }\r\n    \r\n    // Lighting.\r\n    return applyLighting(p, rd, d, h);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    // Camera.\r\n    vec3 lookAt = vec3(2.0, 2.0 + 2.0, 0.0);\r\n    vec3 ro = vec3(2.0, 5.0, -10.0);\r\n    ro.yz *= rot(-0.2);\r\n    \r\n    vec3 col = vec3(0.0);\r\n\r\n    for (float dx = 0.0; dx <= 1.0; dx++) {\r\n        for (float dy = 0.0; dy <= 1.0; dy++) {\r\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\r\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\r\n\r\n            col += getSceneColor(ro, getRayDir(ro, lookAt, uv));\r\n        }\r\n    }\r\n    col /= 4.0;\r\n    \r\n    // Output to screen.\r\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//1. Go fullscreen\r\n//2. Take drugs now\r\n\r\n//iq noise fn\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n\r\n//x3\r\nvec3 noise3( in vec3 x)\r\n{\r\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\r\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\r\n\t\t\t\tnoise(x) );\r\n}\r\n\r\n//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz\r\nfloat bias(float x, float b) {\r\n\treturn  x/((1./b-2.)*(1.-x)+1.);\r\n}\r\n\r\nfloat gain(float x, float g) {\r\n\tfloat t = (1./g-2.)*(1.-(2.*x));\t\r\n\treturn x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);\r\n}\r\n\r\n\r\nmat3 rotation(float angle, vec3 axis)\r\n{\r\n    float s = sin(-angle);\r\n    float c = cos(-angle);\r\n    float oc = 1.0 - c;\r\n\tvec3 sa = axis * s;\r\n\tvec3 oca = axis * oc;\r\n    return mat3(\t\r\n\t\toca.x * axis + vec3(\tc,\t-sa.z,\tsa.y),\r\n\t\toca.y * axis + vec3( sa.z,\tc,\t\t-sa.x),\t\t\r\n\t\toca.z * axis + vec3(-sa.y,\tsa.x,\tc));\t\r\n}\r\n\r\nvec3 fbm(vec3 x, float H, float L, int oc)\r\n{\r\n\tvec3 v = vec3(0);\r\n\tfloat f = 1.;\r\n\tfor (int i=0; i<10; i++)\r\n\t{\r\n\t\tif (i >= oc) break;\r\n\t\tfloat w = pow(f,-H);\r\n\t\tv += noise3(x)*w;\r\n\t\tx *= L;\r\n\t\tf *= L;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nvec3 smf(vec3 x, float H, float L, int oc, float off)\r\n{\r\n\tvec3 v = vec3(1);\r\n\tfloat f = 1.;\r\n\tfor (int i=0; i<10; i++)\r\n\t{\r\n\t\tif (i >= oc) break;\r\n\t\tv *= off + f*(noise3(x)*2.-1.);\r\n\t\tf *= H;\r\n\t\tx *= L;\r\n\t}\r\n\treturn v;\t\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tfloat time = iTime * 1.276;\r\n\t\r\n\tfloat slow = time*0.002;\r\n\tuv *= 1. + .5*slow*sin(slow*10.);\r\n\t\r\n\tfloat ts = time*0.37;\r\n\tfloat change = gain(fract(ts),0.0008)+floor(ts);\t//flick to a different view \r\n\t\t\t\t\t\t\r\n\tvec3 p = vec3(uv*.2,slow+change);\t\t\t\t\t//coordinate + slight change over time\r\n\t\r\n\tvec3 axis = 4. * fbm(p, 0.5, 2., 8);\t\t\t\t//random fbm axis of rotation\r\n\t\r\n\tvec3 colorVec = 0.5 * 5. * fbm(p*0.3,0.5,2.,7);\t\t//random base color\r\n\tp += colorVec;\r\n\t\r\n//\tfloat mag = 4e5;\t//published, rather garish?\r\n\tfloat mag = 0.75e5; //still clips a bit\r\n//\tmag = mag * (1.+sin(2.*3.1415927*ts)*0.75);\r\n\tvec3 colorMod = mag * smf(p,0.7,2.,8,.2);\t\t\t//multifractal saturation\r\n\tcolorVec += colorMod;\r\n\t\r\n\tcolorVec = rotation(3.*length(axis)+slow*10.,normalize(axis))*colorVec;\r\n\t\r\n\tcolorVec *= 0.05;\r\n\t\t\t\r\n//\tcolorVec = colorVec / (1. + length(colorVec));\t//tone it all down a bit\r\n\t\r\n\tcolorVec = pow(colorVec,vec3(1./2.2));\t\t//gamma\r\n\tfragColor = vec4(colorVec,1.0);\r\n}","inputs":[],"outputs":[],"code":"//1. Go fullscreen\r\n//2. Take drugs now\r\n\r\n//iq noise fn\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n\r\n//x3\r\nvec3 noise3( in vec3 x)\r\n{\r\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\r\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\r\n\t\t\t\tnoise(x) );\r\n}\r\n\r\n//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz\r\nfloat bias(float x, float b) {\r\n\treturn  x/((1./b-2.)*(1.-x)+1.);\r\n}\r\n\r\nfloat gain(float x, float g) {\r\n\tfloat t = (1./g-2.)*(1.-(2.*x));\t\r\n\treturn x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);\r\n}\r\n\r\n\r\nmat3 rotation(float angle, vec3 axis)\r\n{\r\n    float s = sin(-angle);\r\n    float c = cos(-angle);\r\n    float oc = 1.0 - c;\r\n\tvec3 sa = axis * s;\r\n\tvec3 oca = axis * oc;\r\n    return mat3(\t\r\n\t\toca.x * axis + vec3(\tc,\t-sa.z,\tsa.y),\r\n\t\toca.y * axis + vec3( sa.z,\tc,\t\t-sa.x),\t\t\r\n\t\toca.z * axis + vec3(-sa.y,\tsa.x,\tc));\t\r\n}\r\n\r\nvec3 fbm(vec3 x, float H, float L, int oc)\r\n{\r\n\tvec3 v = vec3(0);\r\n\tfloat f = 1.;\r\n\tfor (int i=0; i<10; i++)\r\n\t{\r\n\t\tif (i >= oc) break;\r\n\t\tfloat w = pow(f,-H);\r\n\t\tv += noise3(x)*w;\r\n\t\tx *= L;\r\n\t\tf *= L;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nvec3 smf(vec3 x, float H, float L, int oc, float off)\r\n{\r\n\tvec3 v = vec3(1);\r\n\tfloat f = 1.;\r\n\tfor (int i=0; i<10; i++)\r\n\t{\r\n\t\tif (i >= oc) break;\r\n\t\tv *= off + f*(noise3(x)*2.-1.);\r\n\t\tf *= H;\r\n\t\tx *= L;\r\n\t}\r\n\treturn v;\t\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tfloat time = iTime * 1.276;\r\n\t\r\n\tfloat slow = time*0.002;\r\n\tuv *= 1. + .5*slow*sin(slow*10.);\r\n\t\r\n\tfloat ts = time*0.37;\r\n\tfloat change = gain(fract(ts),0.0008)+floor(ts);\t//flick to a different view \r\n\t\t\t\t\t\t\r\n\tvec3 p = vec3(uv*.2,slow+change);\t\t\t\t\t//coordinate + slight change over time\r\n\t\r\n\tvec3 axis = 4. * fbm(p, 0.5, 2., 8);\t\t\t\t//random fbm axis of rotation\r\n\t\r\n\tvec3 colorVec = 0.5 * 5. * fbm(p*0.3,0.5,2.,7);\t\t//random base color\r\n\tp += colorVec;\r\n\t\r\n//\tfloat mag = 4e5;\t//published, rather garish?\r\n\tfloat mag = 0.75e5; //still clips a bit\r\n//\tmag = mag * (1.+sin(2.*3.1415927*ts)*0.75);\r\n\tvec3 colorMod = mag * smf(p,0.7,2.,8,.2);\t\t\t//multifractal saturation\r\n\tcolorVec += colorMod;\r\n\t\r\n\tcolorVec = rotation(3.*length(axis)+slow*10.,normalize(axis))*colorVec;\r\n\t\r\n\tcolorVec *= 0.05;\r\n\t\t\t\r\n//\tcolorVec = colorVec / (1. + length(colorVec));\t//tone it all down a bit\r\n\t\r\n\tcolorVec = pow(colorVec,vec3(1./2.2));\t\t//gamma\r\n\tfragColor = vec4(colorVec,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"GIT","id":"5aa95de9d6bb4e28b6507ac80e68c620","date":null,"viewed":0,"name":"GIT","description":"\"Generalized Impressionistic Texture\" ala Ken Musgrave: p 322 of Texturing And Modelling: A Procedural Approach.\nA painterly plasma.\nhttps://www.shadertoy.com/view/Mdj3RV","likes":0,"published":null,"tags":["noise"," fbm"," multifractal"]},"ver":null,"info":{"Name":"GIT","id":"5aa95de9d6bb4e28b6507ac80e68c620","date":null,"viewed":0,"name":"GIT","description":"\"Generalized Impressionistic Texture\" ala Ken Musgrave: p 322 of Texturing And Modelling: A Procedural Approach.\nA painterly plasma.\nhttps://www.shadertoy.com/view/Mdj3RV","likes":0,"published":null,"tags":["noise"," fbm"," multifractal"]},"renderpass":[{"Code":"//1. Go fullscreen\r\n//2. Take drugs now\r\n\r\n//iq noise fn\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n\r\n//x3\r\nvec3 noise3( in vec3 x)\r\n{\r\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\r\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\r\n\t\t\t\tnoise(x) );\r\n}\r\n\r\n//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz\r\nfloat bias(float x, float b) {\r\n\treturn  x/((1./b-2.)*(1.-x)+1.);\r\n}\r\n\r\nfloat gain(float x, float g) {\r\n\tfloat t = (1./g-2.)*(1.-(2.*x));\t\r\n\treturn x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);\r\n}\r\n\r\n\r\nmat3 rotation(float angle, vec3 axis)\r\n{\r\n    float s = sin(-angle);\r\n    float c = cos(-angle);\r\n    float oc = 1.0 - c;\r\n\tvec3 sa = axis * s;\r\n\tvec3 oca = axis * oc;\r\n    return mat3(\t\r\n\t\toca.x * axis + vec3(\tc,\t-sa.z,\tsa.y),\r\n\t\toca.y * axis + vec3( sa.z,\tc,\t\t-sa.x),\t\t\r\n\t\toca.z * axis + vec3(-sa.y,\tsa.x,\tc));\t\r\n}\r\n\r\nvec3 fbm(vec3 x, float H, float L, int oc)\r\n{\r\n\tvec3 v = vec3(0);\r\n\tfloat f = 1.;\r\n\tfor (int i=0; i<10; i++)\r\n\t{\r\n\t\tif (i >= oc) break;\r\n\t\tfloat w = pow(f,-H);\r\n\t\tv += noise3(x)*w;\r\n\t\tx *= L;\r\n\t\tf *= L;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nvec3 smf(vec3 x, float H, float L, int oc, float off)\r\n{\r\n\tvec3 v = vec3(1);\r\n\tfloat f = 1.;\r\n\tfor (int i=0; i<10; i++)\r\n\t{\r\n\t\tif (i >= oc) break;\r\n\t\tv *= off + f*(noise3(x)*2.-1.);\r\n\t\tf *= H;\r\n\t\tx *= L;\r\n\t}\r\n\treturn v;\t\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tfloat time = iTime * 1.276;\r\n\t\r\n\tfloat slow = time*0.002;\r\n\tuv *= 1. + .5*slow*sin(slow*10.);\r\n\t\r\n\tfloat ts = time*0.37;\r\n\tfloat change = gain(fract(ts),0.0008)+floor(ts);\t//flick to a different view \r\n\t\t\t\t\t\t\r\n\tvec3 p = vec3(uv*.2,slow+change);\t\t\t\t\t//coordinate + slight change over time\r\n\t\r\n\tvec3 axis = 4. * fbm(p, 0.5, 2., 8);\t\t\t\t//random fbm axis of rotation\r\n\t\r\n\tvec3 colorVec = 0.5 * 5. * fbm(p*0.3,0.5,2.,7);\t\t//random base color\r\n\tp += colorVec;\r\n\t\r\n//\tfloat mag = 4e5;\t//published, rather garish?\r\n\tfloat mag = 0.75e5; //still clips a bit\r\n//\tmag = mag * (1.+sin(2.*3.1415927*ts)*0.75);\r\n\tvec3 colorMod = mag * smf(p,0.7,2.,8,.2);\t\t\t//multifractal saturation\r\n\tcolorVec += colorMod;\r\n\t\r\n\tcolorVec = rotation(3.*length(axis)+slow*10.,normalize(axis))*colorVec;\r\n\t\r\n\tcolorVec *= 0.05;\r\n\t\t\t\r\n//\tcolorVec = colorVec / (1. + length(colorVec));\t//tone it all down a bit\r\n\t\r\n\tcolorVec = pow(colorVec,vec3(1./2.2));\t\t//gamma\r\n\tfragColor = vec4(colorVec,1.0);\r\n}","inputs":[],"outputs":[],"code":"//1. Go fullscreen\r\n//2. Take drugs now\r\n\r\n//iq noise fn\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n\r\n//x3\r\nvec3 noise3( in vec3 x)\r\n{\r\n\treturn vec3( noise(x+vec3(123.456,.567,.37)),\r\n\t\t\t\tnoise(x+vec3(.11,47.43,19.17)),\r\n\t\t\t\tnoise(x) );\r\n}\r\n\r\n//http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz\r\nfloat bias(float x, float b) {\r\n\treturn  x/((1./b-2.)*(1.-x)+1.);\r\n}\r\n\r\nfloat gain(float x, float g) {\r\n\tfloat t = (1./g-2.)*(1.-(2.*x));\t\r\n\treturn x<0.5 ? (x/(t+1.)) : (t-x)/(t-1.);\r\n}\r\n\r\n\r\nmat3 rotation(float angle, vec3 axis)\r\n{\r\n    float s = sin(-angle);\r\n    float c = cos(-angle);\r\n    float oc = 1.0 - c;\r\n\tvec3 sa = axis * s;\r\n\tvec3 oca = axis * oc;\r\n    return mat3(\t\r\n\t\toca.x * axis + vec3(\tc,\t-sa.z,\tsa.y),\r\n\t\toca.y * axis + vec3( sa.z,\tc,\t\t-sa.x),\t\t\r\n\t\toca.z * axis + vec3(-sa.y,\tsa.x,\tc));\t\r\n}\r\n\r\nvec3 fbm(vec3 x, float H, float L, int oc)\r\n{\r\n\tvec3 v = vec3(0);\r\n\tfloat f = 1.;\r\n\tfor (int i=0; i<10; i++)\r\n\t{\r\n\t\tif (i >= oc) break;\r\n\t\tfloat w = pow(f,-H);\r\n\t\tv += noise3(x)*w;\r\n\t\tx *= L;\r\n\t\tf *= L;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nvec3 smf(vec3 x, float H, float L, int oc, float off)\r\n{\r\n\tvec3 v = vec3(1);\r\n\tfloat f = 1.;\r\n\tfor (int i=0; i<10; i++)\r\n\t{\r\n\t\tif (i >= oc) break;\r\n\t\tv *= off + f*(noise3(x)*2.-1.);\r\n\t\tf *= H;\r\n\t\tx *= L;\r\n\t}\r\n\treturn v;\t\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n\t\r\n\tfloat time = iTime * 1.276;\r\n\t\r\n\tfloat slow = time*0.002;\r\n\tuv *= 1. + .5*slow*sin(slow*10.);\r\n\t\r\n\tfloat ts = time*0.37;\r\n\tfloat change = gain(fract(ts),0.0008)+floor(ts);\t//flick to a different view \r\n\t\t\t\t\t\t\r\n\tvec3 p = vec3(uv*.2,slow+change);\t\t\t\t\t//coordinate + slight change over time\r\n\t\r\n\tvec3 axis = 4. * fbm(p, 0.5, 2., 8);\t\t\t\t//random fbm axis of rotation\r\n\t\r\n\tvec3 colorVec = 0.5 * 5. * fbm(p*0.3,0.5,2.,7);\t\t//random base color\r\n\tp += colorVec;\r\n\t\r\n//\tfloat mag = 4e5;\t//published, rather garish?\r\n\tfloat mag = 0.75e5; //still clips a bit\r\n//\tmag = mag * (1.+sin(2.*3.1415927*ts)*0.75);\r\n\tvec3 colorMod = mag * smf(p,0.7,2.,8,.2);\t\t\t//multifractal saturation\r\n\tcolorVec += colorMod;\r\n\t\r\n\tcolorVec = rotation(3.*length(axis)+slow*10.,normalize(axis))*colorVec;\r\n\t\r\n\tcolorVec *= 0.05;\r\n\t\t\t\r\n//\tcolorVec = colorVec / (1. + length(colorVec));\t//tone it all down a bit\r\n\t\r\n\tcolorVec = pow(colorVec,vec3(1./2.2));\t\t//gamma\r\n\tfragColor = vec4(colorVec,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by evilryu\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\r\n\r\n#define GRASS_ENV 0.2\r\n#define FREQ 340.\r\n#define PI 3.1415926535\r\n\r\nfloat hash11(float p)\r\n{\r\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\r\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\r\n    return fract(p2.x * p2.y * 95.4337)*0.5+0.5;\r\n}\r\n\r\nvec3 hash33(float n) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\r\nvec3 noise(float x)\r\n{\r\n    float p=floor(x);\r\n    float f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    return mix(hash33(p+0.0), hash33(p+1.0), f);\r\n}\r\n\r\nfloat noise(vec2 x)\r\n{\r\n    vec2 p=floor(x);\r\n    vec2 f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    float n=p.x + p.y*57.0;\r\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\r\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n    float f=0.0;\r\n    f+=.5*noise(p); p=p*2.01;\r\n    f+=.25*noise(p); p=p*2.1;\r\n    f+=.125*noise(p); p=p*2.03;\r\n    return f;\r\n}\r\n\r\nfloat terrain(vec2 p) \r\n{\r\n    float w=0.;\r\n    float s=1.;\r\n    p.x*=20.;\r\n    w+=sin(p.x*.3521)*4.;\r\n    for (int i=0; i<5; i++) \r\n    {\r\n        p.x*=1.53562;\r\n        p.x+=7.56248;\r\n        w+=sin(p.x)*s;      \r\n        s*=.5;\r\n    }\r\n    w=w*.5+.5;\r\n    return smoothstep(0.,0.05,p.y-w*.01-0.02);\r\n}\r\n\r\nvec3 renderTerrian(vec3 ro, vec3 rd, vec3 col)\r\n{\r\n    col=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.-terrain(rd.xy));\r\n\t\r\n    return col;\r\n}\r\n\r\nfloat mapTerrian(vec3 p)\r\n{\r\n    vec2 q=p.xz*1.1-vec2(2.3,0.);\r\n    float f=0.0;\r\n    f+=.56*noise(q); q=q*2.01;\r\n    f+=.25*noise(q); q=q*2.1;\r\n    //f+=.125*noise(q); q=q*2.03;\r\n    return f-0.3;\r\n}\r\n\r\nfloat traceTerrian(vec3 ro, vec3 rd)\r\n{\r\n    float t=0.01,d,h;\r\n    float tPrev=t;\r\n    vec3 p;\r\n    float grassMint=100.;\r\n    for(int i=0;i<200;++i)\r\n    {\r\n        p=ro+t*rd;\r\n        h=mapTerrian(p);    \r\n        d=p.y-h;\r\n        \r\n        if(p.y-h-GRASS_ENV < 0.001 && grassMint>99.)\r\n        {\r\n\t\t\tgrassMint=tPrev;   \r\n            break;\r\n        }\r\n       \r\n        if(t>=100.0) { break;}\r\n        \r\n        tPrev=t;\r\n        t+=d;\r\n    }\r\n \r\n    return grassMint;\r\n}\r\n\r\nfloat blades[8];\r\n    \r\nvoid rotate(float v)\r\n{\r\n    blades[7]=blades[6]; blades[6]=blades[5]; blades[5]=blades[4];\r\n    blades[4]=blades[3]; blades[3]=blades[2]; blades[2]=blades[1];\r\n    blades[1]=blades[0]; blades[0]=v;\r\n}\r\n\r\nbool useAA=false;\r\nfloat oldD=0.;\r\n\r\nfloat shear(vec3 p, float t)\r\n{\r\n    return sin(t+p.x*3.+p.z*(2.))*.3*(p.y)*(1.-smoothstep(-1.5, 2., p.z));\r\n}\r\n\r\nfloat grassNoise(vec2 p)\r\n{\r\n    vec2 l=floor(p);\r\n    vec2 f=fract(p);\r\n    f=f*f*(3.-2.*f);\r\n    float n=l.x+l.y*57.;\r\n    float d=mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n    return d;\r\n}\r\n\r\nfloat mapGrass(vec3 p)\r\n{\r\n    vec3 q=p;\r\n    // Shear\r\n    p.xy=vec2(p.x+shear(p,0.)+.02*shear(p,iTime*2.), p.y);\r\n    float d=grassNoise(p.xz*FREQ);\r\n    d*=mix(1.,grassNoise(p.xz*30.),0.6);\r\n    \r\n    #if 1\r\n    if(useAA)\r\n    {\r\n        rotate(d);\r\n        d = (blades[0]+blades[1]+blades[2]+blades[3]\r\n            +blades[4]+blades[5]+blades[6]+blades[7])*0.125;\r\n    }\r\n    #else\r\n    if(useAA&&oldD>0.)\r\n    {\r\n        d=(oldD+d)*.5;\r\n    }\r\n    oldD=d;\r\n    #endif\r\n    \r\n    d*=GRASS_ENV;\r\n    return d;\r\n}\r\n\r\nfloat occlusion(vec3 p)\r\n{\r\n    // 1 cell backwards\r\n \tfloat w=1./FREQ;\r\n    // check the difference of height\r\n    float d=p.y-mapGrass(p-vec3(0,0,w))-mapTerrian(p);\r\n    // normalize\r\n    return clamp(d/GRASS_ENV, 0.0, 1.0);\r\n}\r\n\r\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\r\n{\r\n    float mid=0.;\r\n    vec3 p=ro+near*rd;\r\n    float sgn=sign(p.y-mapGrass(p)-mapTerrian(p));\r\n    for (int i=0; i<6; i++)\r\n    { \r\n        mid=(near+far)*.5;\r\n        p=ro+mid*rd;\r\n        float d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if(abs(d)<0.001)break;\r\n        if(d*sgn<0.)  far=mid; else near=mid;\r\n    }\r\n    return (near+far)*.5;\r\n}\r\n\r\nvec4 renderGrass(vec3 ro, vec3 rd, float mint)\r\n{\r\n\tfloat t=mint;//((ro.y-GRASS_ENV)/abs(rd.y));\r\n\r\n    vec3 p=ro+t*rd;\r\n    float d=p.y-mapGrass(p)-mapTerrian(p);\r\n\tfloat sgn=sign(d);\r\n    float told=0.;\r\n\tbool doBisect=false;\r\n\r\n    useAA=true;\r\n    \r\n    for(int i=0;i<500;++i)\r\n    {\r\n        d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if (sign(d)!=sgn)\r\n        {\r\n            doBisect=true;\r\n            break;\r\n        }\r\n        \r\n        if(d<0.003||t>=50.0)\r\n        {\r\n            break;\r\n        }\r\n        \r\n        told=t;\r\n        \r\n\t    d=max(1e-4, 0.04*d*exp(t*.2));\r\n        p+=d*rd;\r\n        t+=d;\r\n    }\r\n    if (doBisect)t=bisect(ro,rd,told,t);\r\n    \r\n    useAA=false;\r\n    vec3 col=vec3(0.1,0.5,1.)*3.5;\r\n    col=renderTerrian(ro,rd,col);\r\n\r\n    if(t<50.)\r\n    {\r\n        vec3 ld0=normalize(vec3(5., 5.0, 0.));\r\n        col=vec3(0.1,0.2,0.05)*10.;\r\n        col=mix(col,vec3(0.12,0.1,0.05)*10.,fbm(p.xz*2.));       \r\n        col*=smoothstep(GRASS_ENV*0.45,GRASS_ENV*2.,p.y-mapTerrian(p));\r\n        col*=pow(smoothstep(0.,1.,fbm(p.xz)),2.);\r\n \r\n        col*=.7*smoothstep(0.3,0.5,p.y)+.3;\r\n \r\n        col*=.8*occlusion(p)+.2;\r\n        \r\n        col*=20.;\r\n    \tcol=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.0-exp(-0.01*t*t));\r\n    }\r\n    \r\n    return vec4(col,t);\r\n}\r\n\r\nvec3 tonemap(vec3 x) \r\n{\r\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\r\n    return (x*(a*x+b))/(x*(c*x+d)+e);\r\n}\r\n\r\nvec3 firecolor(float f)\r\n{\r\n\tf=f*f*(3.-2.*f);\r\n    return min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n\tif(abs(p.y)-0.85>0.) { fragColor.xyz=vec3(0); return; }\r\n    \r\n    vec3 lookat=vec3(0.0, 0., 0.0);\r\n\tvec3 ro=vec3(0., .8,-2.5);\r\n    ro.xy+=vec2(0.04,0.01)*noise(iTime*0.5).xy;\r\n    \r\n    vec3 forward=normalize(lookat-ro);\r\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\r\n    vec3 up=normalize(cross(right, forward));\r\n    \r\n    vec3 rd=normalize(p.x*right + p.y*up + 1.6*forward);\r\n    \r\n    vec3 col=vec3(0.1,0.5,1.)*0.1;\r\n\t\r\n    float grassMint=traceTerrian(ro,rd);\r\n\tvec4 res=renderGrass(ro,rd,grassMint);\r\n    col=res.xyz;\r\n    col+=firecolor(0.5)*pow(clamp(dot(normalize(vec3(.0, 1., 2.)),rd), 0.0, 1.0),10.);\r\n    col=tonemap(col);\r\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\r\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\r\n    //col=pow(col,vec3(0.85,0.9,1.));\r\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\r\n    fragColor.xyz=col;\r\n}","inputs":[],"outputs":[],"code":"// Created by evilryu\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\r\n\r\n#define GRASS_ENV 0.2\r\n#define FREQ 340.\r\n#define PI 3.1415926535\r\n\r\nfloat hash11(float p)\r\n{\r\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\r\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\r\n    return fract(p2.x * p2.y * 95.4337)*0.5+0.5;\r\n}\r\n\r\nvec3 hash33(float n) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\r\nvec3 noise(float x)\r\n{\r\n    float p=floor(x);\r\n    float f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    return mix(hash33(p+0.0), hash33(p+1.0), f);\r\n}\r\n\r\nfloat noise(vec2 x)\r\n{\r\n    vec2 p=floor(x);\r\n    vec2 f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    float n=p.x + p.y*57.0;\r\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\r\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n    float f=0.0;\r\n    f+=.5*noise(p); p=p*2.01;\r\n    f+=.25*noise(p); p=p*2.1;\r\n    f+=.125*noise(p); p=p*2.03;\r\n    return f;\r\n}\r\n\r\nfloat terrain(vec2 p) \r\n{\r\n    float w=0.;\r\n    float s=1.;\r\n    p.x*=20.;\r\n    w+=sin(p.x*.3521)*4.;\r\n    for (int i=0; i<5; i++) \r\n    {\r\n        p.x*=1.53562;\r\n        p.x+=7.56248;\r\n        w+=sin(p.x)*s;      \r\n        s*=.5;\r\n    }\r\n    w=w*.5+.5;\r\n    return smoothstep(0.,0.05,p.y-w*.01-0.02);\r\n}\r\n\r\nvec3 renderTerrian(vec3 ro, vec3 rd, vec3 col)\r\n{\r\n    col=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.-terrain(rd.xy));\r\n\t\r\n    return col;\r\n}\r\n\r\nfloat mapTerrian(vec3 p)\r\n{\r\n    vec2 q=p.xz*1.1-vec2(2.3,0.);\r\n    float f=0.0;\r\n    f+=.56*noise(q); q=q*2.01;\r\n    f+=.25*noise(q); q=q*2.1;\r\n    //f+=.125*noise(q); q=q*2.03;\r\n    return f-0.3;\r\n}\r\n\r\nfloat traceTerrian(vec3 ro, vec3 rd)\r\n{\r\n    float t=0.01,d,h;\r\n    float tPrev=t;\r\n    vec3 p;\r\n    float grassMint=100.;\r\n    for(int i=0;i<200;++i)\r\n    {\r\n        p=ro+t*rd;\r\n        h=mapTerrian(p);    \r\n        d=p.y-h;\r\n        \r\n        if(p.y-h-GRASS_ENV < 0.001 && grassMint>99.)\r\n        {\r\n\t\t\tgrassMint=tPrev;   \r\n            break;\r\n        }\r\n       \r\n        if(t>=100.0) { break;}\r\n        \r\n        tPrev=t;\r\n        t+=d;\r\n    }\r\n \r\n    return grassMint;\r\n}\r\n\r\nfloat blades[8];\r\n    \r\nvoid rotate(float v)\r\n{\r\n    blades[7]=blades[6]; blades[6]=blades[5]; blades[5]=blades[4];\r\n    blades[4]=blades[3]; blades[3]=blades[2]; blades[2]=blades[1];\r\n    blades[1]=blades[0]; blades[0]=v;\r\n}\r\n\r\nbool useAA=false;\r\nfloat oldD=0.;\r\n\r\nfloat shear(vec3 p, float t)\r\n{\r\n    return sin(t+p.x*3.+p.z*(2.))*.3*(p.y)*(1.-smoothstep(-1.5, 2., p.z));\r\n}\r\n\r\nfloat grassNoise(vec2 p)\r\n{\r\n    vec2 l=floor(p);\r\n    vec2 f=fract(p);\r\n    f=f*f*(3.-2.*f);\r\n    float n=l.x+l.y*57.;\r\n    float d=mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n    return d;\r\n}\r\n\r\nfloat mapGrass(vec3 p)\r\n{\r\n    vec3 q=p;\r\n    // Shear\r\n    p.xy=vec2(p.x+shear(p,0.)+.02*shear(p,iTime*2.), p.y);\r\n    float d=grassNoise(p.xz*FREQ);\r\n    d*=mix(1.,grassNoise(p.xz*30.),0.6);\r\n    \r\n    #if 1\r\n    if(useAA)\r\n    {\r\n        rotate(d);\r\n        d = (blades[0]+blades[1]+blades[2]+blades[3]\r\n            +blades[4]+blades[5]+blades[6]+blades[7])*0.125;\r\n    }\r\n    #else\r\n    if(useAA&&oldD>0.)\r\n    {\r\n        d=(oldD+d)*.5;\r\n    }\r\n    oldD=d;\r\n    #endif\r\n    \r\n    d*=GRASS_ENV;\r\n    return d;\r\n}\r\n\r\nfloat occlusion(vec3 p)\r\n{\r\n    // 1 cell backwards\r\n \tfloat w=1./FREQ;\r\n    // check the difference of height\r\n    float d=p.y-mapGrass(p-vec3(0,0,w))-mapTerrian(p);\r\n    // normalize\r\n    return clamp(d/GRASS_ENV, 0.0, 1.0);\r\n}\r\n\r\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\r\n{\r\n    float mid=0.;\r\n    vec3 p=ro+near*rd;\r\n    float sgn=sign(p.y-mapGrass(p)-mapTerrian(p));\r\n    for (int i=0; i<6; i++)\r\n    { \r\n        mid=(near+far)*.5;\r\n        p=ro+mid*rd;\r\n        float d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if(abs(d)<0.001)break;\r\n        if(d*sgn<0.)  far=mid; else near=mid;\r\n    }\r\n    return (near+far)*.5;\r\n}\r\n\r\nvec4 renderGrass(vec3 ro, vec3 rd, float mint)\r\n{\r\n\tfloat t=mint;//((ro.y-GRASS_ENV)/abs(rd.y));\r\n\r\n    vec3 p=ro+t*rd;\r\n    float d=p.y-mapGrass(p)-mapTerrian(p);\r\n\tfloat sgn=sign(d);\r\n    float told=0.;\r\n\tbool doBisect=false;\r\n\r\n    useAA=true;\r\n    \r\n    for(int i=0;i<500;++i)\r\n    {\r\n        d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if (sign(d)!=sgn)\r\n        {\r\n            doBisect=true;\r\n            break;\r\n        }\r\n        \r\n        if(d<0.003||t>=50.0)\r\n        {\r\n            break;\r\n        }\r\n        \r\n        told=t;\r\n        \r\n\t    d=max(1e-4, 0.04*d*exp(t*.2));\r\n        p+=d*rd;\r\n        t+=d;\r\n    }\r\n    if (doBisect)t=bisect(ro,rd,told,t);\r\n    \r\n    useAA=false;\r\n    vec3 col=vec3(0.1,0.5,1.)*3.5;\r\n    col=renderTerrian(ro,rd,col);\r\n\r\n    if(t<50.)\r\n    {\r\n        vec3 ld0=normalize(vec3(5., 5.0, 0.));\r\n        col=vec3(0.1,0.2,0.05)*10.;\r\n        col=mix(col,vec3(0.12,0.1,0.05)*10.,fbm(p.xz*2.));       \r\n        col*=smoothstep(GRASS_ENV*0.45,GRASS_ENV*2.,p.y-mapTerrian(p));\r\n        col*=pow(smoothstep(0.,1.,fbm(p.xz)),2.);\r\n \r\n        col*=.7*smoothstep(0.3,0.5,p.y)+.3;\r\n \r\n        col*=.8*occlusion(p)+.2;\r\n        \r\n        col*=20.;\r\n    \tcol=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.0-exp(-0.01*t*t));\r\n    }\r\n    \r\n    return vec4(col,t);\r\n}\r\n\r\nvec3 tonemap(vec3 x) \r\n{\r\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\r\n    return (x*(a*x+b))/(x*(c*x+d)+e);\r\n}\r\n\r\nvec3 firecolor(float f)\r\n{\r\n\tf=f*f*(3.-2.*f);\r\n    return min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n\tif(abs(p.y)-0.85>0.) { fragColor.xyz=vec3(0); return; }\r\n    \r\n    vec3 lookat=vec3(0.0, 0., 0.0);\r\n\tvec3 ro=vec3(0., .8,-2.5);\r\n    ro.xy+=vec2(0.04,0.01)*noise(iTime*0.5).xy;\r\n    \r\n    vec3 forward=normalize(lookat-ro);\r\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\r\n    vec3 up=normalize(cross(right, forward));\r\n    \r\n    vec3 rd=normalize(p.x*right + p.y*up + 1.6*forward);\r\n    \r\n    vec3 col=vec3(0.1,0.5,1.)*0.1;\r\n\t\r\n    float grassMint=traceTerrian(ro,rd);\r\n\tvec4 res=renderGrass(ro,rd,grassMint);\r\n    col=res.xyz;\r\n    col+=firecolor(0.5)*pow(clamp(dot(normalize(vec3(.0, 1., 2.)),rd), 0.0, 1.0),10.);\r\n    col=tonemap(col);\r\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\r\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\r\n    //col=pow(col,vec3(0.85,0.9,1.));\r\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\r\n    fragColor.xyz=col;\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"GrassTest","id":"e8e4be3d603c4bc694921a00eb75e6f7","date":null,"viewed":0,"name":"GrassTest","description":"Grass test, fullscreen doesn't look good.","likes":0,"published":null,"tags":["noise"," fbm"," grass"," terrian"]},"ver":null,"info":{"Name":"GrassTest","id":"e8e4be3d603c4bc694921a00eb75e6f7","date":null,"viewed":0,"name":"GrassTest","description":"Grass test, fullscreen doesn't look good.","likes":0,"published":null,"tags":["noise"," fbm"," grass"," terrian"]},"renderpass":[{"Code":"// Created by evilryu\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\r\n\r\n#define GRASS_ENV 0.2\r\n#define FREQ 340.\r\n#define PI 3.1415926535\r\n\r\nfloat hash11(float p)\r\n{\r\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\r\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\r\n    return fract(p2.x * p2.y * 95.4337)*0.5+0.5;\r\n}\r\n\r\nvec3 hash33(float n) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\r\nvec3 noise(float x)\r\n{\r\n    float p=floor(x);\r\n    float f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    return mix(hash33(p+0.0), hash33(p+1.0), f);\r\n}\r\n\r\nfloat noise(vec2 x)\r\n{\r\n    vec2 p=floor(x);\r\n    vec2 f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    float n=p.x + p.y*57.0;\r\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\r\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n    float f=0.0;\r\n    f+=.5*noise(p); p=p*2.01;\r\n    f+=.25*noise(p); p=p*2.1;\r\n    f+=.125*noise(p); p=p*2.03;\r\n    return f;\r\n}\r\n\r\nfloat terrain(vec2 p) \r\n{\r\n    float w=0.;\r\n    float s=1.;\r\n    p.x*=20.;\r\n    w+=sin(p.x*.3521)*4.;\r\n    for (int i=0; i<5; i++) \r\n    {\r\n        p.x*=1.53562;\r\n        p.x+=7.56248;\r\n        w+=sin(p.x)*s;      \r\n        s*=.5;\r\n    }\r\n    w=w*.5+.5;\r\n    return smoothstep(0.,0.05,p.y-w*.01-0.02);\r\n}\r\n\r\nvec3 renderTerrian(vec3 ro, vec3 rd, vec3 col)\r\n{\r\n    col=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.-terrain(rd.xy));\r\n\t\r\n    return col;\r\n}\r\n\r\nfloat mapTerrian(vec3 p)\r\n{\r\n    vec2 q=p.xz*1.1-vec2(2.3,0.);\r\n    float f=0.0;\r\n    f+=.56*noise(q); q=q*2.01;\r\n    f+=.25*noise(q); q=q*2.1;\r\n    //f+=.125*noise(q); q=q*2.03;\r\n    return f-0.3;\r\n}\r\n\r\nfloat traceTerrian(vec3 ro, vec3 rd)\r\n{\r\n    float t=0.01,d,h;\r\n    float tPrev=t;\r\n    vec3 p;\r\n    float grassMint=100.;\r\n    for(int i=0;i<200;++i)\r\n    {\r\n        p=ro+t*rd;\r\n        h=mapTerrian(p);    \r\n        d=p.y-h;\r\n        \r\n        if(p.y-h-GRASS_ENV < 0.001 && grassMint>99.)\r\n        {\r\n\t\t\tgrassMint=tPrev;   \r\n            break;\r\n        }\r\n       \r\n        if(t>=100.0) { break;}\r\n        \r\n        tPrev=t;\r\n        t+=d;\r\n    }\r\n \r\n    return grassMint;\r\n}\r\n\r\nfloat blades[8];\r\n    \r\nvoid rotate(float v)\r\n{\r\n    blades[7]=blades[6]; blades[6]=blades[5]; blades[5]=blades[4];\r\n    blades[4]=blades[3]; blades[3]=blades[2]; blades[2]=blades[1];\r\n    blades[1]=blades[0]; blades[0]=v;\r\n}\r\n\r\nbool useAA=false;\r\nfloat oldD=0.;\r\n\r\nfloat shear(vec3 p, float t)\r\n{\r\n    return sin(t+p.x*3.+p.z*(2.))*.3*(p.y)*(1.-smoothstep(-1.5, 2., p.z));\r\n}\r\n\r\nfloat grassNoise(vec2 p)\r\n{\r\n    vec2 l=floor(p);\r\n    vec2 f=fract(p);\r\n    f=f*f*(3.-2.*f);\r\n    float n=l.x+l.y*57.;\r\n    float d=mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n    return d;\r\n}\r\n\r\nfloat mapGrass(vec3 p)\r\n{\r\n    vec3 q=p;\r\n    // Shear\r\n    p.xy=vec2(p.x+shear(p,0.)+.02*shear(p,iTime*2.), p.y);\r\n    float d=grassNoise(p.xz*FREQ);\r\n    d*=mix(1.,grassNoise(p.xz*30.),0.6);\r\n    \r\n    #if 1\r\n    if(useAA)\r\n    {\r\n        rotate(d);\r\n        d = (blades[0]+blades[1]+blades[2]+blades[3]\r\n            +blades[4]+blades[5]+blades[6]+blades[7])*0.125;\r\n    }\r\n    #else\r\n    if(useAA&&oldD>0.)\r\n    {\r\n        d=(oldD+d)*.5;\r\n    }\r\n    oldD=d;\r\n    #endif\r\n    \r\n    d*=GRASS_ENV;\r\n    return d;\r\n}\r\n\r\nfloat occlusion(vec3 p)\r\n{\r\n    // 1 cell backwards\r\n \tfloat w=1./FREQ;\r\n    // check the difference of height\r\n    float d=p.y-mapGrass(p-vec3(0,0,w))-mapTerrian(p);\r\n    // normalize\r\n    return clamp(d/GRASS_ENV, 0.0, 1.0);\r\n}\r\n\r\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\r\n{\r\n    float mid=0.;\r\n    vec3 p=ro+near*rd;\r\n    float sgn=sign(p.y-mapGrass(p)-mapTerrian(p));\r\n    for (int i=0; i<6; i++)\r\n    { \r\n        mid=(near+far)*.5;\r\n        p=ro+mid*rd;\r\n        float d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if(abs(d)<0.001)break;\r\n        if(d*sgn<0.)  far=mid; else near=mid;\r\n    }\r\n    return (near+far)*.5;\r\n}\r\n\r\nvec4 renderGrass(vec3 ro, vec3 rd, float mint)\r\n{\r\n\tfloat t=mint;//((ro.y-GRASS_ENV)/abs(rd.y));\r\n\r\n    vec3 p=ro+t*rd;\r\n    float d=p.y-mapGrass(p)-mapTerrian(p);\r\n\tfloat sgn=sign(d);\r\n    float told=0.;\r\n\tbool doBisect=false;\r\n\r\n    useAA=true;\r\n    \r\n    for(int i=0;i<500;++i)\r\n    {\r\n        d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if (sign(d)!=sgn)\r\n        {\r\n            doBisect=true;\r\n            break;\r\n        }\r\n        \r\n        if(d<0.003||t>=50.0)\r\n        {\r\n            break;\r\n        }\r\n        \r\n        told=t;\r\n        \r\n\t    d=max(1e-4, 0.04*d*exp(t*.2));\r\n        p+=d*rd;\r\n        t+=d;\r\n    }\r\n    if (doBisect)t=bisect(ro,rd,told,t);\r\n    \r\n    useAA=false;\r\n    vec3 col=vec3(0.1,0.5,1.)*3.5;\r\n    col=renderTerrian(ro,rd,col);\r\n\r\n    if(t<50.)\r\n    {\r\n        vec3 ld0=normalize(vec3(5., 5.0, 0.));\r\n        col=vec3(0.1,0.2,0.05)*10.;\r\n        col=mix(col,vec3(0.12,0.1,0.05)*10.,fbm(p.xz*2.));       \r\n        col*=smoothstep(GRASS_ENV*0.45,GRASS_ENV*2.,p.y-mapTerrian(p));\r\n        col*=pow(smoothstep(0.,1.,fbm(p.xz)),2.);\r\n \r\n        col*=.7*smoothstep(0.3,0.5,p.y)+.3;\r\n \r\n        col*=.8*occlusion(p)+.2;\r\n        \r\n        col*=20.;\r\n    \tcol=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.0-exp(-0.01*t*t));\r\n    }\r\n    \r\n    return vec4(col,t);\r\n}\r\n\r\nvec3 tonemap(vec3 x) \r\n{\r\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\r\n    return (x*(a*x+b))/(x*(c*x+d)+e);\r\n}\r\n\r\nvec3 firecolor(float f)\r\n{\r\n\tf=f*f*(3.-2.*f);\r\n    return min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n\tif(abs(p.y)-0.85>0.) { fragColor.xyz=vec3(0); return; }\r\n    \r\n    vec3 lookat=vec3(0.0, 0., 0.0);\r\n\tvec3 ro=vec3(0., .8,-2.5);\r\n    ro.xy+=vec2(0.04,0.01)*noise(iTime*0.5).xy;\r\n    \r\n    vec3 forward=normalize(lookat-ro);\r\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\r\n    vec3 up=normalize(cross(right, forward));\r\n    \r\n    vec3 rd=normalize(p.x*right + p.y*up + 1.6*forward);\r\n    \r\n    vec3 col=vec3(0.1,0.5,1.)*0.1;\r\n\t\r\n    float grassMint=traceTerrian(ro,rd);\r\n\tvec4 res=renderGrass(ro,rd,grassMint);\r\n    col=res.xyz;\r\n    col+=firecolor(0.5)*pow(clamp(dot(normalize(vec3(.0, 1., 2.)),rd), 0.0, 1.0),10.);\r\n    col=tonemap(col);\r\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\r\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\r\n    //col=pow(col,vec3(0.85,0.9,1.));\r\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\r\n    fragColor.xyz=col;\r\n}","inputs":[],"outputs":[],"code":"// Created by evilryu\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\r\n\r\n#define GRASS_ENV 0.2\r\n#define FREQ 340.\r\n#define PI 3.1415926535\r\n\r\nfloat hash11(float p)\r\n{\r\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\r\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\r\n    return fract(p2.x * p2.y * 95.4337)*0.5+0.5;\r\n}\r\n\r\nvec3 hash33(float n) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\r\nvec3 noise(float x)\r\n{\r\n    float p=floor(x);\r\n    float f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    return mix(hash33(p+0.0), hash33(p+1.0), f);\r\n}\r\n\r\nfloat noise(vec2 x)\r\n{\r\n    vec2 p=floor(x);\r\n    vec2 f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    float n=p.x + p.y*57.0;\r\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\r\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n    float f=0.0;\r\n    f+=.5*noise(p); p=p*2.01;\r\n    f+=.25*noise(p); p=p*2.1;\r\n    f+=.125*noise(p); p=p*2.03;\r\n    return f;\r\n}\r\n\r\nfloat terrain(vec2 p) \r\n{\r\n    float w=0.;\r\n    float s=1.;\r\n    p.x*=20.;\r\n    w+=sin(p.x*.3521)*4.;\r\n    for (int i=0; i<5; i++) \r\n    {\r\n        p.x*=1.53562;\r\n        p.x+=7.56248;\r\n        w+=sin(p.x)*s;      \r\n        s*=.5;\r\n    }\r\n    w=w*.5+.5;\r\n    return smoothstep(0.,0.05,p.y-w*.01-0.02);\r\n}\r\n\r\nvec3 renderTerrian(vec3 ro, vec3 rd, vec3 col)\r\n{\r\n    col=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.-terrain(rd.xy));\r\n\t\r\n    return col;\r\n}\r\n\r\nfloat mapTerrian(vec3 p)\r\n{\r\n    vec2 q=p.xz*1.1-vec2(2.3,0.);\r\n    float f=0.0;\r\n    f+=.56*noise(q); q=q*2.01;\r\n    f+=.25*noise(q); q=q*2.1;\r\n    //f+=.125*noise(q); q=q*2.03;\r\n    return f-0.3;\r\n}\r\n\r\nfloat traceTerrian(vec3 ro, vec3 rd)\r\n{\r\n    float t=0.01,d,h;\r\n    float tPrev=t;\r\n    vec3 p;\r\n    float grassMint=100.;\r\n    for(int i=0;i<200;++i)\r\n    {\r\n        p=ro+t*rd;\r\n        h=mapTerrian(p);    \r\n        d=p.y-h;\r\n        \r\n        if(p.y-h-GRASS_ENV < 0.001 && grassMint>99.)\r\n        {\r\n\t\t\tgrassMint=tPrev;   \r\n            break;\r\n        }\r\n       \r\n        if(t>=100.0) { break;}\r\n        \r\n        tPrev=t;\r\n        t+=d;\r\n    }\r\n \r\n    return grassMint;\r\n}\r\n\r\nfloat blades[8];\r\n    \r\nvoid rotate(float v)\r\n{\r\n    blades[7]=blades[6]; blades[6]=blades[5]; blades[5]=blades[4];\r\n    blades[4]=blades[3]; blades[3]=blades[2]; blades[2]=blades[1];\r\n    blades[1]=blades[0]; blades[0]=v;\r\n}\r\n\r\nbool useAA=false;\r\nfloat oldD=0.;\r\n\r\nfloat shear(vec3 p, float t)\r\n{\r\n    return sin(t+p.x*3.+p.z*(2.))*.3*(p.y)*(1.-smoothstep(-1.5, 2., p.z));\r\n}\r\n\r\nfloat grassNoise(vec2 p)\r\n{\r\n    vec2 l=floor(p);\r\n    vec2 f=fract(p);\r\n    f=f*f*(3.-2.*f);\r\n    float n=l.x+l.y*57.;\r\n    float d=mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n    return d;\r\n}\r\n\r\nfloat mapGrass(vec3 p)\r\n{\r\n    vec3 q=p;\r\n    // Shear\r\n    p.xy=vec2(p.x+shear(p,0.)+.02*shear(p,iTime*2.), p.y);\r\n    float d=grassNoise(p.xz*FREQ);\r\n    d*=mix(1.,grassNoise(p.xz*30.),0.6);\r\n    \r\n    #if 1\r\n    if(useAA)\r\n    {\r\n        rotate(d);\r\n        d = (blades[0]+blades[1]+blades[2]+blades[3]\r\n            +blades[4]+blades[5]+blades[6]+blades[7])*0.125;\r\n    }\r\n    #else\r\n    if(useAA&&oldD>0.)\r\n    {\r\n        d=(oldD+d)*.5;\r\n    }\r\n    oldD=d;\r\n    #endif\r\n    \r\n    d*=GRASS_ENV;\r\n    return d;\r\n}\r\n\r\nfloat occlusion(vec3 p)\r\n{\r\n    // 1 cell backwards\r\n \tfloat w=1./FREQ;\r\n    // check the difference of height\r\n    float d=p.y-mapGrass(p-vec3(0,0,w))-mapTerrian(p);\r\n    // normalize\r\n    return clamp(d/GRASS_ENV, 0.0, 1.0);\r\n}\r\n\r\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\r\n{\r\n    float mid=0.;\r\n    vec3 p=ro+near*rd;\r\n    float sgn=sign(p.y-mapGrass(p)-mapTerrian(p));\r\n    for (int i=0; i<6; i++)\r\n    { \r\n        mid=(near+far)*.5;\r\n        p=ro+mid*rd;\r\n        float d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if(abs(d)<0.001)break;\r\n        if(d*sgn<0.)  far=mid; else near=mid;\r\n    }\r\n    return (near+far)*.5;\r\n}\r\n\r\nvec4 renderGrass(vec3 ro, vec3 rd, float mint)\r\n{\r\n\tfloat t=mint;//((ro.y-GRASS_ENV)/abs(rd.y));\r\n\r\n    vec3 p=ro+t*rd;\r\n    float d=p.y-mapGrass(p)-mapTerrian(p);\r\n\tfloat sgn=sign(d);\r\n    float told=0.;\r\n\tbool doBisect=false;\r\n\r\n    useAA=true;\r\n    \r\n    for(int i=0;i<500;++i)\r\n    {\r\n        d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if (sign(d)!=sgn)\r\n        {\r\n            doBisect=true;\r\n            break;\r\n        }\r\n        \r\n        if(d<0.003||t>=50.0)\r\n        {\r\n            break;\r\n        }\r\n        \r\n        told=t;\r\n        \r\n\t    d=max(1e-4, 0.04*d*exp(t*.2));\r\n        p+=d*rd;\r\n        t+=d;\r\n    }\r\n    if (doBisect)t=bisect(ro,rd,told,t);\r\n    \r\n    useAA=false;\r\n    vec3 col=vec3(0.1,0.5,1.)*3.5;\r\n    col=renderTerrian(ro,rd,col);\r\n\r\n    if(t<50.)\r\n    {\r\n        vec3 ld0=normalize(vec3(5., 5.0, 0.));\r\n        col=vec3(0.1,0.2,0.05)*10.;\r\n        col=mix(col,vec3(0.12,0.1,0.05)*10.,fbm(p.xz*2.));       \r\n        col*=smoothstep(GRASS_ENV*0.45,GRASS_ENV*2.,p.y-mapTerrian(p));\r\n        col*=pow(smoothstep(0.,1.,fbm(p.xz)),2.);\r\n \r\n        col*=.7*smoothstep(0.3,0.5,p.y)+.3;\r\n \r\n        col*=.8*occlusion(p)+.2;\r\n        \r\n        col*=20.;\r\n    \tcol=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.0-exp(-0.01*t*t));\r\n    }\r\n    \r\n    return vec4(col,t);\r\n}\r\n\r\nvec3 tonemap(vec3 x) \r\n{\r\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\r\n    return (x*(a*x+b))/(x*(c*x+d)+e);\r\n}\r\n\r\nvec3 firecolor(float f)\r\n{\r\n\tf=f*f*(3.-2.*f);\r\n    return min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n\tif(abs(p.y)-0.85>0.) { fragColor.xyz=vec3(0); return; }\r\n    \r\n    vec3 lookat=vec3(0.0, 0., 0.0);\r\n\tvec3 ro=vec3(0., .8,-2.5);\r\n    ro.xy+=vec2(0.04,0.01)*noise(iTime*0.5).xy;\r\n    \r\n    vec3 forward=normalize(lookat-ro);\r\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\r\n    vec3 up=normalize(cross(right, forward));\r\n    \r\n    vec3 rd=normalize(p.x*right + p.y*up + 1.6*forward);\r\n    \r\n    vec3 col=vec3(0.1,0.5,1.)*0.1;\r\n\t\r\n    float grassMint=traceTerrian(ro,rd);\r\n\tvec4 res=renderGrass(ro,rd,grassMint);\r\n    col=res.xyz;\r\n    col+=firecolor(0.5)*pow(clamp(dot(normalize(vec3(.0, 1., 2.)),rd), 0.0, 1.0),10.);\r\n    col=tonemap(col);\r\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\r\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\r\n    //col=pow(col,vec3(0.85,0.9,1.));\r\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\r\n    fragColor.xyz=col;\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define POINTS 100  \t\t // number of stars\r\n\r\n// --- GUI utils\r\n\r\nfloat t;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- flag and values buton display ---\r\n\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\n\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of stars\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    t = iTime;\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : 4.*iMouse.x/iResolution.x;\r\n\tint MODE = int(mod(m,4.)); \r\n\tfloat fMODE = (1.-cos(6.283*m))/2.;\r\n\r\n\t\r\n\tfloat v=0.; vec2 V=vec2(0.);\r\n\tfor (int i=1; i<POINTS; i++) { // sum stars\r\n\t\tvec2 p = P(float(i));\r\n\t\tfor (int y=-1; y<=1; y++)  // ghost echos in cycling universe\r\n\t\t\tfor (int x=-1; x<=1; x++) {\r\n\t\t\t\tvec2 d = p+vec2(float(x),float(y)) -uv; // pixel to star\r\n\t\t\t\tif      (MODE==0) v +=  1./length(d);\r\n\t\t\t\telse if (MODE==1) v +=  1./dot(d,d);\r\n\t\t\t    else if (MODE==2) V +=  d /dot(d,d);\r\n\t\t\t\telse\t\t\t  V +=  d /pow(length(d),3.);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\tif (MODE>1) v = length(V);\r\n\tv *= 1./(9.*float(POINTS));\r\n\t\r\n\tv *= 10.*fMODE;\r\n\tfragColor = vec4(sin(v),sin(v/2.),sin(v/4.),1.);\r\n\t\r\n\tv =   showFlag(vec2(-1.5+.1*float(MODE),.9),uv,fMODE)\r\n\t\t+ showFlag(vec2(-1.5,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.4,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.3,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.2,.9),uv,false);\r\n\tfragColor = mix(fragColor,vec4(0,0,1,0),v);\r\n\r\n}","inputs":[],"outputs":[],"code":"#define POINTS 100  \t\t // number of stars\r\n\r\n// --- GUI utils\r\n\r\nfloat t;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- flag and values buton display ---\r\n\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\n\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of stars\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    t = iTime;\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : 4.*iMouse.x/iResolution.x;\r\n\tint MODE = int(mod(m,4.)); \r\n\tfloat fMODE = (1.-cos(6.283*m))/2.;\r\n\r\n\t\r\n\tfloat v=0.; vec2 V=vec2(0.);\r\n\tfor (int i=1; i<POINTS; i++) { // sum stars\r\n\t\tvec2 p = P(float(i));\r\n\t\tfor (int y=-1; y<=1; y++)  // ghost echos in cycling universe\r\n\t\t\tfor (int x=-1; x<=1; x++) {\r\n\t\t\t\tvec2 d = p+vec2(float(x),float(y)) -uv; // pixel to star\r\n\t\t\t\tif      (MODE==0) v +=  1./length(d);\r\n\t\t\t\telse if (MODE==1) v +=  1./dot(d,d);\r\n\t\t\t    else if (MODE==2) V +=  d /dot(d,d);\r\n\t\t\t\telse\t\t\t  V +=  d /pow(length(d),3.);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\tif (MODE>1) v = length(V);\r\n\tv *= 1./(9.*float(POINTS));\r\n\t\r\n\tv *= 10.*fMODE;\r\n\tfragColor = vec4(sin(v),sin(v/2.),sin(v/4.),1.);\r\n\t\r\n\tv =   showFlag(vec2(-1.5+.1*float(MODE),.9),uv,fMODE)\r\n\t\t+ showFlag(vec2(-1.5,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.4,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.3,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.2,.9),uv,false);\r\n\tfragColor = mix(fragColor,vec4(0,0,1,0),v);\r\n\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"gravity field","id":"8631eb555eb84d3c8785663602e11498","date":null,"viewed":0,"name":"gravity field","description":"gravity field generated by a schoolfish of stars\r\nCycles between sum(pot2D), sum(pot3D), sum(gravity2D), sum(gravity3D)\r\nMouse.x to force cycling.\r\nhttps://www.shadertoy.com/view/XdlXW4","likes":0,"published":null,"tags":["gravity"]},"ver":null,"info":{"Name":"gravity field","id":"8631eb555eb84d3c8785663602e11498","date":null,"viewed":0,"name":"gravity field","description":"gravity field generated by a schoolfish of stars\r\nCycles between sum(pot2D), sum(pot3D), sum(gravity2D), sum(gravity3D)\r\nMouse.x to force cycling.\r\nhttps://www.shadertoy.com/view/XdlXW4","likes":0,"published":null,"tags":["gravity"]},"renderpass":[{"Code":"#define POINTS 100  \t\t // number of stars\r\n\r\n// --- GUI utils\r\n\r\nfloat t;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- flag and values buton display ---\r\n\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\n\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of stars\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    t = iTime;\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : 4.*iMouse.x/iResolution.x;\r\n\tint MODE = int(mod(m,4.)); \r\n\tfloat fMODE = (1.-cos(6.283*m))/2.;\r\n\r\n\t\r\n\tfloat v=0.; vec2 V=vec2(0.);\r\n\tfor (int i=1; i<POINTS; i++) { // sum stars\r\n\t\tvec2 p = P(float(i));\r\n\t\tfor (int y=-1; y<=1; y++)  // ghost echos in cycling universe\r\n\t\t\tfor (int x=-1; x<=1; x++) {\r\n\t\t\t\tvec2 d = p+vec2(float(x),float(y)) -uv; // pixel to star\r\n\t\t\t\tif      (MODE==0) v +=  1./length(d);\r\n\t\t\t\telse if (MODE==1) v +=  1./dot(d,d);\r\n\t\t\t    else if (MODE==2) V +=  d /dot(d,d);\r\n\t\t\t\telse\t\t\t  V +=  d /pow(length(d),3.);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\tif (MODE>1) v = length(V);\r\n\tv *= 1./(9.*float(POINTS));\r\n\t\r\n\tv *= 10.*fMODE;\r\n\tfragColor = vec4(sin(v),sin(v/2.),sin(v/4.),1.);\r\n\t\r\n\tv =   showFlag(vec2(-1.5+.1*float(MODE),.9),uv,fMODE)\r\n\t\t+ showFlag(vec2(-1.5,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.4,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.3,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.2,.9),uv,false);\r\n\tfragColor = mix(fragColor,vec4(0,0,1,0),v);\r\n\r\n}","inputs":[],"outputs":[],"code":"#define POINTS 100  \t\t // number of stars\r\n\r\n// --- GUI utils\r\n\r\nfloat t;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- flag and values buton display ---\r\n\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\n\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of stars\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    t = iTime;\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : 4.*iMouse.x/iResolution.x;\r\n\tint MODE = int(mod(m,4.)); \r\n\tfloat fMODE = (1.-cos(6.283*m))/2.;\r\n\r\n\t\r\n\tfloat v=0.; vec2 V=vec2(0.);\r\n\tfor (int i=1; i<POINTS; i++) { // sum stars\r\n\t\tvec2 p = P(float(i));\r\n\t\tfor (int y=-1; y<=1; y++)  // ghost echos in cycling universe\r\n\t\t\tfor (int x=-1; x<=1; x++) {\r\n\t\t\t\tvec2 d = p+vec2(float(x),float(y)) -uv; // pixel to star\r\n\t\t\t\tif      (MODE==0) v +=  1./length(d);\r\n\t\t\t\telse if (MODE==1) v +=  1./dot(d,d);\r\n\t\t\t    else if (MODE==2) V +=  d /dot(d,d);\r\n\t\t\t\telse\t\t\t  V +=  d /pow(length(d),3.);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\tif (MODE>1) v = length(V);\r\n\tv *= 1./(9.*float(POINTS));\r\n\t\r\n\tv *= 10.*fMODE;\r\n\tfragColor = vec4(sin(v),sin(v/2.),sin(v/4.),1.);\r\n\t\r\n\tv =   showFlag(vec2(-1.5+.1*float(MODE),.9),uv,fMODE)\r\n\t\t+ showFlag(vec2(-1.5,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.4,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.3,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.2,.9),uv,false);\r\n\tfragColor = mix(fragColor,vec4(0,0,1,0),v);\r\n\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define PI 3.1415926\r\n#define HAIR_LEN 4.\r\n#define SKIN_COL vec3(226,204,190)/255.\r\n#define HAIR_COL vec3(35,33,28)/255.\r\n\r\n// Simplex noise from https://www.shadertoy.com/view/4sdGD8\r\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\r\nlowp float snoise(in lowp vec2 v) {\r\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\r\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\r\n  lowp float s = step(x0.x,x0.y);\r\n  lowp vec2 j = vec2(1.0-s,s),\r\n      x1 = x0 - j + .211324865405187, \r\n      x3 = x0 - .577350269189626; \r\n  i = mod(i,289.);\r\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\r\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\r\n       x = fract(p * .024390243902439) * 2. - 1.,\r\n       h = abs(x) - .5,\r\n      a0 = x - floor(x + .5);\r\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\r\n}\r\n\r\nfloat rand(vec2 co) { \r\n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\r\n} \r\n\r\nfloat hairLine(vec2 p, float len, float thickness, float blur, float bendFactor){    \r\n        \r\n    p.x += sin(p.y*3. + iTime*10. + bendFactor)*.025;\r\n    float result = smoothstep(thickness, thickness - blur, abs(p.x));    \r\n    result *= (1. - step(.0, p.y));\r\n    \r\n    // Limit length\r\n    float d = length(p);\r\n    result*= (1. - step(len, d));\r\n    return result;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{    \r\n    vec2 uv = fragCoord/iResolution.x;\r\n    vec2 ouv = uv;\r\n    \r\n    float SIZE = floor(iResolution.x/15.);\r\n    \r\n    float sm = 1./iResolution.y * SIZE*0.80;\r\n       \r\n    \r\n    uv *= SIZE;\r\n    vec2 id = floor(uv);\r\n    uv = fract(uv);           \r\n          \r\n    float mask = 0.;\r\n    vec3 col = vec3(0.);\r\n    for(float y=-3.; y<=3.; y+=1.){\r\n        for(float x=-3.; x<=3.; x+=1.){\r\n            \r\n            vec2 rid = id;\r\n            rid.x-=x;\r\n            rid.y-=y;\r\n            \r\n            vec2 orid = rid;\r\n            \r\n            // Random thickness for realistic\r\n            float thickness = rand(rid)*0.015 + 0.05;\r\n            float ra = rand(rid);\r\n            float ra2 = rand(rid+1.);\r\n            \r\n            rid/=SIZE;\r\n            rid.x+=iTime*0.2;\r\n                                    \r\n            float a = snoise(rid*2.)*PI; // not 2*PI for one side rotation only            \r\n            a+=ra*0.40;                       \r\n            \r\n            vec2 ruv = uv;            \r\n            ruv.x+=x + (ra - .5)*.5; //+some randomness\r\n            ruv.y+=y + (ra2 - .5)*.5;             \r\n            \r\n            float rotaDir = (floor(mod(orid.x+orid.y, 2.))*2.-1.);\r\n            float rotaForce = rand(orid)*1.0;\r\n            float rota = a+(length(ruv*0.1)*0.8)*rotaDir*rotaForce;\r\n            \r\n            float ca = cos(rota);\r\n            float sa = sin(rota);\r\n            mat2 rot = mat2(ca, -sa, sa, ca);                       \r\n                                   \r\n            ruv *= rot;\r\n                        \r\n            float hairLen = HAIR_LEN + ((ra + ra2)*0.5 - 0.5); //+some randomness\r\n            float bendFactor = id.x+id.y;\r\n    \t\tmask += hairLine(ruv, hairLen, thickness, sm, bendFactor);\r\n            \r\n            col = mix(SKIN_COL, HAIR_COL, mask);\r\n            \r\n            // Make light depending angle\r\n            col += a*0.03;\r\n        }\r\n    }\r\n                         \r\n    \r\n    fragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"#define PI 3.1415926\r\n#define HAIR_LEN 4.\r\n#define SKIN_COL vec3(226,204,190)/255.\r\n#define HAIR_COL vec3(35,33,28)/255.\r\n\r\n// Simplex noise from https://www.shadertoy.com/view/4sdGD8\r\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\r\nlowp float snoise(in lowp vec2 v) {\r\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\r\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\r\n  lowp float s = step(x0.x,x0.y);\r\n  lowp vec2 j = vec2(1.0-s,s),\r\n      x1 = x0 - j + .211324865405187, \r\n      x3 = x0 - .577350269189626; \r\n  i = mod(i,289.);\r\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\r\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\r\n       x = fract(p * .024390243902439) * 2. - 1.,\r\n       h = abs(x) - .5,\r\n      a0 = x - floor(x + .5);\r\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\r\n}\r\n\r\nfloat rand(vec2 co) { \r\n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\r\n} \r\n\r\nfloat hairLine(vec2 p, float len, float thickness, float blur, float bendFactor){    \r\n        \r\n    p.x += sin(p.y*3. + iTime*10. + bendFactor)*.025;\r\n    float result = smoothstep(thickness, thickness - blur, abs(p.x));    \r\n    result *= (1. - step(.0, p.y));\r\n    \r\n    // Limit length\r\n    float d = length(p);\r\n    result*= (1. - step(len, d));\r\n    return result;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{    \r\n    vec2 uv = fragCoord/iResolution.x;\r\n    vec2 ouv = uv;\r\n    \r\n    float SIZE = floor(iResolution.x/15.);\r\n    \r\n    float sm = 1./iResolution.y * SIZE*0.80;\r\n       \r\n    \r\n    uv *= SIZE;\r\n    vec2 id = floor(uv);\r\n    uv = fract(uv);           \r\n          \r\n    float mask = 0.;\r\n    vec3 col = vec3(0.);\r\n    for(float y=-3.; y<=3.; y+=1.){\r\n        for(float x=-3.; x<=3.; x+=1.){\r\n            \r\n            vec2 rid = id;\r\n            rid.x-=x;\r\n            rid.y-=y;\r\n            \r\n            vec2 orid = rid;\r\n            \r\n            // Random thickness for realistic\r\n            float thickness = rand(rid)*0.015 + 0.05;\r\n            float ra = rand(rid);\r\n            float ra2 = rand(rid+1.);\r\n            \r\n            rid/=SIZE;\r\n            rid.x+=iTime*0.2;\r\n                                    \r\n            float a = snoise(rid*2.)*PI; // not 2*PI for one side rotation only            \r\n            a+=ra*0.40;                       \r\n            \r\n            vec2 ruv = uv;            \r\n            ruv.x+=x + (ra - .5)*.5; //+some randomness\r\n            ruv.y+=y + (ra2 - .5)*.5;             \r\n            \r\n            float rotaDir = (floor(mod(orid.x+orid.y, 2.))*2.-1.);\r\n            float rotaForce = rand(orid)*1.0;\r\n            float rota = a+(length(ruv*0.1)*0.8)*rotaDir*rotaForce;\r\n            \r\n            float ca = cos(rota);\r\n            float sa = sin(rota);\r\n            mat2 rot = mat2(ca, -sa, sa, ca);                       \r\n                                   \r\n            ruv *= rot;\r\n                        \r\n            float hairLen = HAIR_LEN + ((ra + ra2)*0.5 - 0.5); //+some randomness\r\n            float bendFactor = id.x+id.y;\r\n    \t\tmask += hairLine(ruv, hairLen, thickness, sm, bendFactor);\r\n            \r\n            col = mix(SKIN_COL, HAIR_COL, mask);\r\n            \r\n            // Make light depending angle\r\n            col += a*0.03;\r\n        }\r\n    }\r\n                         \r\n    \r\n    fragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Hairs on your body ;)","id":"2f92a45989e340aeb1eca734e230d11d","date":null,"viewed":0,"name":"Hairs on your body ;)","description":"Made hairs before in JS canvas with lines https://avin.github.io/sketches/018_hair.html\nNow it's time to make something like that in GLSL \nhttps://www.shadertoy.com/view/tsBSDd","likes":0,"published":null,"tags":["lines"," hairs"," stubble"," beard"]},"ver":null,"info":{"Name":"Hairs on your body ;)","id":"2f92a45989e340aeb1eca734e230d11d","date":null,"viewed":0,"name":"Hairs on your body ;)","description":"Made hairs before in JS canvas with lines https://avin.github.io/sketches/018_hair.html\nNow it's time to make something like that in GLSL \nhttps://www.shadertoy.com/view/tsBSDd","likes":0,"published":null,"tags":["lines"," hairs"," stubble"," beard"]},"renderpass":[{"Code":"#define PI 3.1415926\r\n#define HAIR_LEN 4.\r\n#define SKIN_COL vec3(226,204,190)/255.\r\n#define HAIR_COL vec3(35,33,28)/255.\r\n\r\n// Simplex noise from https://www.shadertoy.com/view/4sdGD8\r\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\r\nlowp float snoise(in lowp vec2 v) {\r\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\r\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\r\n  lowp float s = step(x0.x,x0.y);\r\n  lowp vec2 j = vec2(1.0-s,s),\r\n      x1 = x0 - j + .211324865405187, \r\n      x3 = x0 - .577350269189626; \r\n  i = mod(i,289.);\r\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\r\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\r\n       x = fract(p * .024390243902439) * 2. - 1.,\r\n       h = abs(x) - .5,\r\n      a0 = x - floor(x + .5);\r\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\r\n}\r\n\r\nfloat rand(vec2 co) { \r\n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\r\n} \r\n\r\nfloat hairLine(vec2 p, float len, float thickness, float blur, float bendFactor){    \r\n        \r\n    p.x += sin(p.y*3. + iTime*10. + bendFactor)*.025;\r\n    float result = smoothstep(thickness, thickness - blur, abs(p.x));    \r\n    result *= (1. - step(.0, p.y));\r\n    \r\n    // Limit length\r\n    float d = length(p);\r\n    result*= (1. - step(len, d));\r\n    return result;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{    \r\n    vec2 uv = fragCoord/iResolution.x;\r\n    vec2 ouv = uv;\r\n    \r\n    float SIZE = floor(iResolution.x/15.);\r\n    \r\n    float sm = 1./iResolution.y * SIZE*0.80;\r\n       \r\n    \r\n    uv *= SIZE;\r\n    vec2 id = floor(uv);\r\n    uv = fract(uv);           \r\n          \r\n    float mask = 0.;\r\n    vec3 col = vec3(0.);\r\n    for(float y=-3.; y<=3.; y+=1.){\r\n        for(float x=-3.; x<=3.; x+=1.){\r\n            \r\n            vec2 rid = id;\r\n            rid.x-=x;\r\n            rid.y-=y;\r\n            \r\n            vec2 orid = rid;\r\n            \r\n            // Random thickness for realistic\r\n            float thickness = rand(rid)*0.015 + 0.05;\r\n            float ra = rand(rid);\r\n            float ra2 = rand(rid+1.);\r\n            \r\n            rid/=SIZE;\r\n            rid.x+=iTime*0.2;\r\n                                    \r\n            float a = snoise(rid*2.)*PI; // not 2*PI for one side rotation only            \r\n            a+=ra*0.40;                       \r\n            \r\n            vec2 ruv = uv;            \r\n            ruv.x+=x + (ra - .5)*.5; //+some randomness\r\n            ruv.y+=y + (ra2 - .5)*.5;             \r\n            \r\n            float rotaDir = (floor(mod(orid.x+orid.y, 2.))*2.-1.);\r\n            float rotaForce = rand(orid)*1.0;\r\n            float rota = a+(length(ruv*0.1)*0.8)*rotaDir*rotaForce;\r\n            \r\n            float ca = cos(rota);\r\n            float sa = sin(rota);\r\n            mat2 rot = mat2(ca, -sa, sa, ca);                       \r\n                                   \r\n            ruv *= rot;\r\n                        \r\n            float hairLen = HAIR_LEN + ((ra + ra2)*0.5 - 0.5); //+some randomness\r\n            float bendFactor = id.x+id.y;\r\n    \t\tmask += hairLine(ruv, hairLen, thickness, sm, bendFactor);\r\n            \r\n            col = mix(SKIN_COL, HAIR_COL, mask);\r\n            \r\n            // Make light depending angle\r\n            col += a*0.03;\r\n        }\r\n    }\r\n                         \r\n    \r\n    fragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"#define PI 3.1415926\r\n#define HAIR_LEN 4.\r\n#define SKIN_COL vec3(226,204,190)/255.\r\n#define HAIR_COL vec3(35,33,28)/255.\r\n\r\n// Simplex noise from https://www.shadertoy.com/view/4sdGD8\r\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\r\nlowp float snoise(in lowp vec2 v) {\r\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\r\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\r\n  lowp float s = step(x0.x,x0.y);\r\n  lowp vec2 j = vec2(1.0-s,s),\r\n      x1 = x0 - j + .211324865405187, \r\n      x3 = x0 - .577350269189626; \r\n  i = mod(i,289.);\r\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\r\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\r\n       x = fract(p * .024390243902439) * 2. - 1.,\r\n       h = abs(x) - .5,\r\n      a0 = x - floor(x + .5);\r\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\r\n}\r\n\r\nfloat rand(vec2 co) { \r\n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\r\n} \r\n\r\nfloat hairLine(vec2 p, float len, float thickness, float blur, float bendFactor){    \r\n        \r\n    p.x += sin(p.y*3. + iTime*10. + bendFactor)*.025;\r\n    float result = smoothstep(thickness, thickness - blur, abs(p.x));    \r\n    result *= (1. - step(.0, p.y));\r\n    \r\n    // Limit length\r\n    float d = length(p);\r\n    result*= (1. - step(len, d));\r\n    return result;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{    \r\n    vec2 uv = fragCoord/iResolution.x;\r\n    vec2 ouv = uv;\r\n    \r\n    float SIZE = floor(iResolution.x/15.);\r\n    \r\n    float sm = 1./iResolution.y * SIZE*0.80;\r\n       \r\n    \r\n    uv *= SIZE;\r\n    vec2 id = floor(uv);\r\n    uv = fract(uv);           \r\n          \r\n    float mask = 0.;\r\n    vec3 col = vec3(0.);\r\n    for(float y=-3.; y<=3.; y+=1.){\r\n        for(float x=-3.; x<=3.; x+=1.){\r\n            \r\n            vec2 rid = id;\r\n            rid.x-=x;\r\n            rid.y-=y;\r\n            \r\n            vec2 orid = rid;\r\n            \r\n            // Random thickness for realistic\r\n            float thickness = rand(rid)*0.015 + 0.05;\r\n            float ra = rand(rid);\r\n            float ra2 = rand(rid+1.);\r\n            \r\n            rid/=SIZE;\r\n            rid.x+=iTime*0.2;\r\n                                    \r\n            float a = snoise(rid*2.)*PI; // not 2*PI for one side rotation only            \r\n            a+=ra*0.40;                       \r\n            \r\n            vec2 ruv = uv;            \r\n            ruv.x+=x + (ra - .5)*.5; //+some randomness\r\n            ruv.y+=y + (ra2 - .5)*.5;             \r\n            \r\n            float rotaDir = (floor(mod(orid.x+orid.y, 2.))*2.-1.);\r\n            float rotaForce = rand(orid)*1.0;\r\n            float rota = a+(length(ruv*0.1)*0.8)*rotaDir*rotaForce;\r\n            \r\n            float ca = cos(rota);\r\n            float sa = sin(rota);\r\n            mat2 rot = mat2(ca, -sa, sa, ca);                       \r\n                                   \r\n            ruv *= rot;\r\n                        \r\n            float hairLen = HAIR_LEN + ((ra + ra2)*0.5 - 0.5); //+some randomness\r\n            float bendFactor = id.x+id.y;\r\n    \t\tmask += hairLine(ruv, hairLen, thickness, sm, bendFactor);\r\n            \r\n            col = mix(SKIN_COL, HAIR_COL, mask);\r\n            \r\n            // Make light depending angle\r\n            col += a*0.03;\r\n        }\r\n    }\r\n                         \r\n    \r\n    fragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/**\r\n This shader is basically an improvement upon a previous fireworks shader I did a while\r\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\r\n instead of the just following the same pattern in a loop, so the fireworks show can be\r\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\r\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\r\n\r\n I wish a very happy and a prosperous new year to everyone!\r\n*/\r\n\r\n#define PI  3.141592653589793\r\n#define TAU 6.283185307179586\r\n\r\n// Helper macros \r\n#define C(x) clamp(x, 0., 1.)\r\n#define S(a, b, x) smoothstep(a, b, x)\r\n#define F(x, f) (floor(x * f) / f)\r\n\r\n// Fireworks control variables\r\n#define FIREWORK_COUNT 8\r\n#define FIREWORK_DURATION 8.\r\n#define FIREWORK_LOW .75\r\n#define FIREWORK_HIGH 1.05\r\n#define ROCKET_PARTICES 32\r\n#define ROCKET_DURATION 1.5\r\n#define FLASH_DURATION ROCKET_DURATION + .2 \r\n#define THRUSTER_SPEED .25\r\n#define EXPLOSION_STRENGTH .03;\r\n#define EXPLOSION_PARTICLES 100\r\n\r\n// Hash functions by Dave_Hoskins\r\nvec2 hash21(float p)\r\n{\r\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n\tp3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n\r\n}\r\n\r\nvec3 hash31(float p)\r\n{\r\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\treturn vec3(n) * (1. / float(0xffffffffU));\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\r\n\tuint q = (n.x ^ n.y) * 1597334673U;\r\n\treturn float(q) * (1. / float(0xffffffffU));\r\n}\r\n\r\n// Function to remap a value from [a, b] to [c, d]\r\nfloat remap(float x, float a, float b, float c, float d)\r\n{\r\n    return (((x - a) / (b - a)) * (d - c)) + c;\r\n}\r\n\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// Tiny fbm\r\nfloat fbm (in vec3 p) {\r\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\r\n}\r\n\r\n// Building window lights from www.shadertoy.com/view/wtt3WB\r\nfloat windows (vec2 uv, float offset)\r\n{\r\n    vec2 grid = vec2(20., 1.);\r\n    uv.x += offset;\r\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\r\n    uv.x *= n1 * 6.;\r\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\r\n    float n = fbm(id.xxx);\r\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\r\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\r\n    vec2 lPos = fract(uv * lightGrid);\r\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\r\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\r\n    n2 = smoothstep(.225, .5, n2);\r\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\r\n}\r\n\r\n// Building skyline \r\nfloat buildings(vec2 st)\r\n{\r\n    // An fbm style amalgamation of various cos functions\r\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\r\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\r\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\r\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\r\n    return C((st.y + b - .1) * 100.);\r\n}\r\n\r\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\r\nfloat stars(vec2 st, vec2 fragCoord)\r\n{\r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\r\n    uv.y += .3;\r\n    uv.y = abs(uv.y);\r\n    float t = iTime * .1;\r\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\r\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\r\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\r\n    twinkle = twinkle * .5 + .5;\r\n    return h.x * h.y * twinkle * 1.5;\r\n}\r\n\r\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\r\nvec3 fireworks(vec2 st)\r\n{\r\n\tvec2 fireworkPos, particlePos;\r\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\r\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\r\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\r\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\r\n    {\r\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\r\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\r\n        // This hash changes after each firework cycle (rocket + explosion)\r\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\r\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\r\n        fireworkCol = fireworkHash * .5 + .5;\r\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\r\n        // Random firework x coordinate but confined to a certain column based on j\r\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\r\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\r\n        \r\n        // Duration of each firework with a random start time\r\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\r\n        if (time > ROCKET_DURATION)\r\n        {\r\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\r\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\r\n            {\r\n                // Unique hash that yeilds a separate spread pattern for each explosion\r\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \r\n\t\t\t\t\t* 1619.8196 + 469.7119);\r\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\r\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\r\n                // Radius expands exponentially over time, i.e. explosion effect\r\n                radius = radiusScale * time * time;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                particlePos.y -= 8. * pow(particlePos.x, 4.); // fake-ish gravity\r\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\r\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\r\n                // Shimmering effect for explosion particles\r\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \r\n                    * (sin((iTime + particleHash.y * TAU) * 18.)));\r\n                shimmerThreshold = FIREWORK_DURATION * .6;\r\n                // Fade after a certain time threshold\r\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\r\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\r\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\r\n                    * fade * fireworkCol;\r\n            }\r\n            \r\n            // Initial instant flash for the explosion\r\n            if(time < FLASH_DURATION)\r\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\r\n        }\r\n        else\r\n        {\r\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\r\n            // ease out sine\r\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\r\n            fireworkPos = vec2(fireworkHash.x, \r\n                    rocketPath * fireworkHash.y);\r\n            // Slight random wiggle for the rocket's path\r\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\r\n            \r\n            // Rockets flying before the explosion\r\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\r\n            {\r\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\r\n                // rocket trail size\r\n                float t = time * (2. - time);\r\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\r\n\t\t\t\t\t* particleHash.z * .1;\r\n                // Confine theta to a small value for a vertical thrust effect\r\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\r\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\r\n            }\r\n        }\r\n    }  \r\n    return finalCol;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\r\n    uv.y += .3; // shift the horizon a bit lower\r\n    float reflection = 0.;\r\n    \r\n    if (uv.y < 0.)\r\n    {\r\n        reflection = 1.;\r\n        // watery distortion in the lake (improved)\r\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\r\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\r\n    }\r\n\r\n    // Our special uv coord that gives us reflection effect for pratically free\r\n    vec2 st = vec2(uv.x, abs(uv.y));\r\n    vec3 col = vec3(0.);\r\n    \r\n    // Background mountain\r\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\r\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\r\n    mountain = C(S(-.005, .005, mountain));\r\n    \r\n    float building = buildings(st);\r\n    \r\n    // Finally blend everything together\r\n    \r\n    // Sky color\r\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\r\n    // Blend the mountain and the sky\r\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\r\n    // Occlude the mountain with the building skyline\r\n    col *= building;\r\n    \r\n    // Yellow-ish window color tint\r\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \r\n    \r\n    // Moon white circle\r\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\r\n    \r\n    //Twinkly stars, masked by the buildings, mountain, and the moon\r\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\r\n    \r\n    // Cut the main moon circle with an offset inverted one to make a crescent\r\n    moon *= smoothstep(.3, .4, length(st-vec2(.92, .88)));\r\n    \r\n    // Add the moon to the scene\r\n    col += moon * vec3(1.2, 1.18, 1.);\r\n    \r\n    // Fireworks launch from behind the buildings, but in front of the mountains\r\n    col += C(fireworks(st)) * (building + moon);\r\n    \r\n    // Slightly change of the reflections to watery blueish-green\r\n    col.r -= reflection * .05;\r\n    col.gb += reflection * .01;\r\n    \r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"/**\r\n This shader is basically an improvement upon a previous fireworks shader I did a while\r\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\r\n instead of the just following the same pattern in a loop, so the fireworks show can be\r\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\r\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\r\n\r\n I wish a very happy and a prosperous new year to everyone!\r\n*/\r\n\r\n#define PI  3.141592653589793\r\n#define TAU 6.283185307179586\r\n\r\n// Helper macros \r\n#define C(x) clamp(x, 0., 1.)\r\n#define S(a, b, x) smoothstep(a, b, x)\r\n#define F(x, f) (floor(x * f) / f)\r\n\r\n// Fireworks control variables\r\n#define FIREWORK_COUNT 8\r\n#define FIREWORK_DURATION 8.\r\n#define FIREWORK_LOW .75\r\n#define FIREWORK_HIGH 1.05\r\n#define ROCKET_PARTICES 32\r\n#define ROCKET_DURATION 1.5\r\n#define FLASH_DURATION ROCKET_DURATION + .2 \r\n#define THRUSTER_SPEED .25\r\n#define EXPLOSION_STRENGTH .03;\r\n#define EXPLOSION_PARTICLES 100\r\n\r\n// Hash functions by Dave_Hoskins\r\nvec2 hash21(float p)\r\n{\r\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n\tp3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n\r\n}\r\n\r\nvec3 hash31(float p)\r\n{\r\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\treturn vec3(n) * (1. / float(0xffffffffU));\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\r\n\tuint q = (n.x ^ n.y) * 1597334673U;\r\n\treturn float(q) * (1. / float(0xffffffffU));\r\n}\r\n\r\n// Function to remap a value from [a, b] to [c, d]\r\nfloat remap(float x, float a, float b, float c, float d)\r\n{\r\n    return (((x - a) / (b - a)) * (d - c)) + c;\r\n}\r\n\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// Tiny fbm\r\nfloat fbm (in vec3 p) {\r\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\r\n}\r\n\r\n// Building window lights from www.shadertoy.com/view/wtt3WB\r\nfloat windows (vec2 uv, float offset)\r\n{\r\n    vec2 grid = vec2(20., 1.);\r\n    uv.x += offset;\r\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\r\n    uv.x *= n1 * 6.;\r\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\r\n    float n = fbm(id.xxx);\r\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\r\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\r\n    vec2 lPos = fract(uv * lightGrid);\r\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\r\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\r\n    n2 = smoothstep(.225, .5, n2);\r\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\r\n}\r\n\r\n// Building skyline \r\nfloat buildings(vec2 st)\r\n{\r\n    // An fbm style amalgamation of various cos functions\r\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\r\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\r\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\r\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\r\n    return C((st.y + b - .1) * 100.);\r\n}\r\n\r\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\r\nfloat stars(vec2 st, vec2 fragCoord)\r\n{\r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\r\n    uv.y += .3;\r\n    uv.y = abs(uv.y);\r\n    float t = iTime * .1;\r\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\r\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\r\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\r\n    twinkle = twinkle * .5 + .5;\r\n    return h.x * h.y * twinkle * 1.5;\r\n}\r\n\r\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\r\nvec3 fireworks(vec2 st)\r\n{\r\n\tvec2 fireworkPos, particlePos;\r\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\r\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\r\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\r\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\r\n    {\r\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\r\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\r\n        // This hash changes after each firework cycle (rocket + explosion)\r\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\r\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\r\n        fireworkCol = fireworkHash * .5 + .5;\r\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\r\n        // Random firework x coordinate but confined to a certain column based on j\r\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\r\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\r\n        \r\n        // Duration of each firework with a random start time\r\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\r\n        if (time > ROCKET_DURATION)\r\n        {\r\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\r\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\r\n            {\r\n                // Unique hash that yeilds a separate spread pattern for each explosion\r\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \r\n\t\t\t\t\t* 1619.8196 + 469.7119);\r\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\r\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\r\n                // Radius expands exponentially over time, i.e. explosion effect\r\n                radius = radiusScale * time * time;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                particlePos.y -= 8. * pow(particlePos.x, 4.); // fake-ish gravity\r\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\r\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\r\n                // Shimmering effect for explosion particles\r\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \r\n                    * (sin((iTime + particleHash.y * TAU) * 18.)));\r\n                shimmerThreshold = FIREWORK_DURATION * .6;\r\n                // Fade after a certain time threshold\r\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\r\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\r\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\r\n                    * fade * fireworkCol;\r\n            }\r\n            \r\n            // Initial instant flash for the explosion\r\n            if(time < FLASH_DURATION)\r\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\r\n        }\r\n        else\r\n        {\r\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\r\n            // ease out sine\r\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\r\n            fireworkPos = vec2(fireworkHash.x, \r\n                    rocketPath * fireworkHash.y);\r\n            // Slight random wiggle for the rocket's path\r\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\r\n            \r\n            // Rockets flying before the explosion\r\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\r\n            {\r\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\r\n                // rocket trail size\r\n                float t = time * (2. - time);\r\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\r\n\t\t\t\t\t* particleHash.z * .1;\r\n                // Confine theta to a small value for a vertical thrust effect\r\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\r\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\r\n            }\r\n        }\r\n    }  \r\n    return finalCol;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\r\n    uv.y += .3; // shift the horizon a bit lower\r\n    float reflection = 0.;\r\n    \r\n    if (uv.y < 0.)\r\n    {\r\n        reflection = 1.;\r\n        // watery distortion in the lake (improved)\r\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\r\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\r\n    }\r\n\r\n    // Our special uv coord that gives us reflection effect for pratically free\r\n    vec2 st = vec2(uv.x, abs(uv.y));\r\n    vec3 col = vec3(0.);\r\n    \r\n    // Background mountain\r\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\r\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\r\n    mountain = C(S(-.005, .005, mountain));\r\n    \r\n    float building = buildings(st);\r\n    \r\n    // Finally blend everything together\r\n    \r\n    // Sky color\r\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\r\n    // Blend the mountain and the sky\r\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\r\n    // Occlude the mountain with the building skyline\r\n    col *= building;\r\n    \r\n    // Yellow-ish window color tint\r\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \r\n    \r\n    // Moon white circle\r\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\r\n    \r\n    //Twinkly stars, masked by the buildings, mountain, and the moon\r\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\r\n    \r\n    // Cut the main moon circle with an offset inverted one to make a crescent\r\n    moon *= smoothstep(.3, .4, length(st-vec2(.92, .88)));\r\n    \r\n    // Add the moon to the scene\r\n    col += moon * vec3(1.2, 1.18, 1.);\r\n    \r\n    // Fireworks launch from behind the buildings, but in front of the mountains\r\n    col += C(fireworks(st)) * (building + moon);\r\n    \r\n    // Slightly change of the reflections to watery blueish-green\r\n    col.r -= reflection * .05;\r\n    col.gb += reflection * .01;\r\n    \r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Happy 2020!","id":"0f147e1acfd44a91a25a4f581fcfe9b0","date":null,"viewed":0,"name":"Happy 2020!","description":"Happy new year everyone!\r\n\r\nv1.1 Added an initial bright flash at the starting of each explosion. (Thanks bigwings)\r\nv1.2 Improved water reflections.\r\nv1.3 Added a crescent moon.\r\nv1.4 Rockets slow down nearing apex.\r\nhttps://www.shadertoy.com/view/tt3GRN","likes":0,"published":null,"tags":["noise"," reflection"," fbm"," water"," particles"," city"," lights"," fireworks"]},"ver":null,"info":{"Name":"Happy 2020!","id":"0f147e1acfd44a91a25a4f581fcfe9b0","date":null,"viewed":0,"name":"Happy 2020!","description":"Happy new year everyone!\r\n\r\nv1.1 Added an initial bright flash at the starting of each explosion. (Thanks bigwings)\r\nv1.2 Improved water reflections.\r\nv1.3 Added a crescent moon.\r\nv1.4 Rockets slow down nearing apex.\r\nhttps://www.shadertoy.com/view/tt3GRN","likes":0,"published":null,"tags":["noise"," reflection"," fbm"," water"," particles"," city"," lights"," fireworks"]},"renderpass":[{"Code":"/**\r\n This shader is basically an improvement upon a previous fireworks shader I did a while\r\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\r\n instead of the just following the same pattern in a loop, so the fireworks show can be\r\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\r\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\r\n\r\n I wish a very happy and a prosperous new year to everyone!\r\n*/\r\n\r\n#define PI  3.141592653589793\r\n#define TAU 6.283185307179586\r\n\r\n// Helper macros \r\n#define C(x) clamp(x, 0., 1.)\r\n#define S(a, b, x) smoothstep(a, b, x)\r\n#define F(x, f) (floor(x * f) / f)\r\n\r\n// Fireworks control variables\r\n#define FIREWORK_COUNT 8\r\n#define FIREWORK_DURATION 8.\r\n#define FIREWORK_LOW .75\r\n#define FIREWORK_HIGH 1.05\r\n#define ROCKET_PARTICES 32\r\n#define ROCKET_DURATION 1.5\r\n#define FLASH_DURATION ROCKET_DURATION + .2 \r\n#define THRUSTER_SPEED .25\r\n#define EXPLOSION_STRENGTH .03;\r\n#define EXPLOSION_PARTICLES 100\r\n\r\n// Hash functions by Dave_Hoskins\r\nvec2 hash21(float p)\r\n{\r\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n\tp3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n\r\n}\r\n\r\nvec3 hash31(float p)\r\n{\r\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\treturn vec3(n) * (1. / float(0xffffffffU));\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\r\n\tuint q = (n.x ^ n.y) * 1597334673U;\r\n\treturn float(q) * (1. / float(0xffffffffU));\r\n}\r\n\r\n// Function to remap a value from [a, b] to [c, d]\r\nfloat remap(float x, float a, float b, float c, float d)\r\n{\r\n    return (((x - a) / (b - a)) * (d - c)) + c;\r\n}\r\n\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// Tiny fbm\r\nfloat fbm (in vec3 p) {\r\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\r\n}\r\n\r\n// Building window lights from www.shadertoy.com/view/wtt3WB\r\nfloat windows (vec2 uv, float offset)\r\n{\r\n    vec2 grid = vec2(20., 1.);\r\n    uv.x += offset;\r\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\r\n    uv.x *= n1 * 6.;\r\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\r\n    float n = fbm(id.xxx);\r\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\r\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\r\n    vec2 lPos = fract(uv * lightGrid);\r\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\r\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\r\n    n2 = smoothstep(.225, .5, n2);\r\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\r\n}\r\n\r\n// Building skyline \r\nfloat buildings(vec2 st)\r\n{\r\n    // An fbm style amalgamation of various cos functions\r\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\r\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\r\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\r\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\r\n    return C((st.y + b - .1) * 100.);\r\n}\r\n\r\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\r\nfloat stars(vec2 st, vec2 fragCoord)\r\n{\r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\r\n    uv.y += .3;\r\n    uv.y = abs(uv.y);\r\n    float t = iTime * .1;\r\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\r\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\r\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\r\n    twinkle = twinkle * .5 + .5;\r\n    return h.x * h.y * twinkle * 1.5;\r\n}\r\n\r\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\r\nvec3 fireworks(vec2 st)\r\n{\r\n\tvec2 fireworkPos, particlePos;\r\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\r\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\r\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\r\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\r\n    {\r\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\r\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\r\n        // This hash changes after each firework cycle (rocket + explosion)\r\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\r\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\r\n        fireworkCol = fireworkHash * .5 + .5;\r\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\r\n        // Random firework x coordinate but confined to a certain column based on j\r\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\r\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\r\n        \r\n        // Duration of each firework with a random start time\r\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\r\n        if (time > ROCKET_DURATION)\r\n        {\r\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\r\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\r\n            {\r\n                // Unique hash that yeilds a separate spread pattern for each explosion\r\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \r\n\t\t\t\t\t* 1619.8196 + 469.7119);\r\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\r\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\r\n                // Radius expands exponentially over time, i.e. explosion effect\r\n                radius = radiusScale * time * time;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                particlePos.y -= 8. * pow(particlePos.x, 4.); // fake-ish gravity\r\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\r\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\r\n                // Shimmering effect for explosion particles\r\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \r\n                    * (sin((iTime + particleHash.y * TAU) * 18.)));\r\n                shimmerThreshold = FIREWORK_DURATION * .6;\r\n                // Fade after a certain time threshold\r\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\r\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\r\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\r\n                    * fade * fireworkCol;\r\n            }\r\n            \r\n            // Initial instant flash for the explosion\r\n            if(time < FLASH_DURATION)\r\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\r\n        }\r\n        else\r\n        {\r\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\r\n            // ease out sine\r\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\r\n            fireworkPos = vec2(fireworkHash.x, \r\n                    rocketPath * fireworkHash.y);\r\n            // Slight random wiggle for the rocket's path\r\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\r\n            \r\n            // Rockets flying before the explosion\r\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\r\n            {\r\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\r\n                // rocket trail size\r\n                float t = time * (2. - time);\r\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\r\n\t\t\t\t\t* particleHash.z * .1;\r\n                // Confine theta to a small value for a vertical thrust effect\r\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\r\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\r\n            }\r\n        }\r\n    }  \r\n    return finalCol;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\r\n    uv.y += .3; // shift the horizon a bit lower\r\n    float reflection = 0.;\r\n    \r\n    if (uv.y < 0.)\r\n    {\r\n        reflection = 1.;\r\n        // watery distortion in the lake (improved)\r\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\r\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\r\n    }\r\n\r\n    // Our special uv coord that gives us reflection effect for pratically free\r\n    vec2 st = vec2(uv.x, abs(uv.y));\r\n    vec3 col = vec3(0.);\r\n    \r\n    // Background mountain\r\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\r\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\r\n    mountain = C(S(-.005, .005, mountain));\r\n    \r\n    float building = buildings(st);\r\n    \r\n    // Finally blend everything together\r\n    \r\n    // Sky color\r\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\r\n    // Blend the mountain and the sky\r\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\r\n    // Occlude the mountain with the building skyline\r\n    col *= building;\r\n    \r\n    // Yellow-ish window color tint\r\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \r\n    \r\n    // Moon white circle\r\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\r\n    \r\n    //Twinkly stars, masked by the buildings, mountain, and the moon\r\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\r\n    \r\n    // Cut the main moon circle with an offset inverted one to make a crescent\r\n    moon *= smoothstep(.3, .4, length(st-vec2(.92, .88)));\r\n    \r\n    // Add the moon to the scene\r\n    col += moon * vec3(1.2, 1.18, 1.);\r\n    \r\n    // Fireworks launch from behind the buildings, but in front of the mountains\r\n    col += C(fireworks(st)) * (building + moon);\r\n    \r\n    // Slightly change of the reflections to watery blueish-green\r\n    col.r -= reflection * .05;\r\n    col.gb += reflection * .01;\r\n    \r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"/**\r\n This shader is basically an improvement upon a previous fireworks shader I did a while\r\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\r\n instead of the just following the same pattern in a loop, so the fireworks show can be\r\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\r\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\r\n\r\n I wish a very happy and a prosperous new year to everyone!\r\n*/\r\n\r\n#define PI  3.141592653589793\r\n#define TAU 6.283185307179586\r\n\r\n// Helper macros \r\n#define C(x) clamp(x, 0., 1.)\r\n#define S(a, b, x) smoothstep(a, b, x)\r\n#define F(x, f) (floor(x * f) / f)\r\n\r\n// Fireworks control variables\r\n#define FIREWORK_COUNT 8\r\n#define FIREWORK_DURATION 8.\r\n#define FIREWORK_LOW .75\r\n#define FIREWORK_HIGH 1.05\r\n#define ROCKET_PARTICES 32\r\n#define ROCKET_DURATION 1.5\r\n#define FLASH_DURATION ROCKET_DURATION + .2 \r\n#define THRUSTER_SPEED .25\r\n#define EXPLOSION_STRENGTH .03;\r\n#define EXPLOSION_PARTICLES 100\r\n\r\n// Hash functions by Dave_Hoskins\r\nvec2 hash21(float p)\r\n{\r\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n\tp3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n\r\n}\r\n\r\nvec3 hash31(float p)\r\n{\r\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\treturn vec3(n) * (1. / float(0xffffffffU));\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\r\n\tuint q = (n.x ^ n.y) * 1597334673U;\r\n\treturn float(q) * (1. / float(0xffffffffU));\r\n}\r\n\r\n// Function to remap a value from [a, b] to [c, d]\r\nfloat remap(float x, float a, float b, float c, float d)\r\n{\r\n    return (((x - a) / (b - a)) * (d - c)) + c;\r\n}\r\n\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// Tiny fbm\r\nfloat fbm (in vec3 p) {\r\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\r\n}\r\n\r\n// Building window lights from www.shadertoy.com/view/wtt3WB\r\nfloat windows (vec2 uv, float offset)\r\n{\r\n    vec2 grid = vec2(20., 1.);\r\n    uv.x += offset;\r\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\r\n    uv.x *= n1 * 6.;\r\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\r\n    float n = fbm(id.xxx);\r\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\r\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\r\n    vec2 lPos = fract(uv * lightGrid);\r\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\r\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\r\n    n2 = smoothstep(.225, .5, n2);\r\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\r\n}\r\n\r\n// Building skyline \r\nfloat buildings(vec2 st)\r\n{\r\n    // An fbm style amalgamation of various cos functions\r\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\r\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\r\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\r\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\r\n    return C((st.y + b - .1) * 100.);\r\n}\r\n\r\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\r\nfloat stars(vec2 st, vec2 fragCoord)\r\n{\r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\r\n    uv.y += .3;\r\n    uv.y = abs(uv.y);\r\n    float t = iTime * .1;\r\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\r\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\r\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\r\n    twinkle = twinkle * .5 + .5;\r\n    return h.x * h.y * twinkle * 1.5;\r\n}\r\n\r\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\r\nvec3 fireworks(vec2 st)\r\n{\r\n\tvec2 fireworkPos, particlePos;\r\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\r\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\r\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\r\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\r\n    {\r\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\r\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\r\n        // This hash changes after each firework cycle (rocket + explosion)\r\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\r\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\r\n        fireworkCol = fireworkHash * .5 + .5;\r\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\r\n        // Random firework x coordinate but confined to a certain column based on j\r\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\r\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\r\n        \r\n        // Duration of each firework with a random start time\r\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\r\n        if (time > ROCKET_DURATION)\r\n        {\r\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\r\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\r\n            {\r\n                // Unique hash that yeilds a separate spread pattern for each explosion\r\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \r\n\t\t\t\t\t* 1619.8196 + 469.7119);\r\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\r\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\r\n                // Radius expands exponentially over time, i.e. explosion effect\r\n                radius = radiusScale * time * time;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                particlePos.y -= 8. * pow(particlePos.x, 4.); // fake-ish gravity\r\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\r\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\r\n                // Shimmering effect for explosion particles\r\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \r\n                    * (sin((iTime + particleHash.y * TAU) * 18.)));\r\n                shimmerThreshold = FIREWORK_DURATION * .6;\r\n                // Fade after a certain time threshold\r\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\r\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\r\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\r\n                    * fade * fireworkCol;\r\n            }\r\n            \r\n            // Initial instant flash for the explosion\r\n            if(time < FLASH_DURATION)\r\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\r\n        }\r\n        else\r\n        {\r\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\r\n            // ease out sine\r\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\r\n            fireworkPos = vec2(fireworkHash.x, \r\n                    rocketPath * fireworkHash.y);\r\n            // Slight random wiggle for the rocket's path\r\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\r\n            \r\n            // Rockets flying before the explosion\r\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\r\n            {\r\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\r\n                // rocket trail size\r\n                float t = time * (2. - time);\r\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\r\n\t\t\t\t\t* particleHash.z * .1;\r\n                // Confine theta to a small value for a vertical thrust effect\r\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\r\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\r\n            }\r\n        }\r\n    }  \r\n    return finalCol;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\r\n    uv.y += .3; // shift the horizon a bit lower\r\n    float reflection = 0.;\r\n    \r\n    if (uv.y < 0.)\r\n    {\r\n        reflection = 1.;\r\n        // watery distortion in the lake (improved)\r\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\r\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\r\n    }\r\n\r\n    // Our special uv coord that gives us reflection effect for pratically free\r\n    vec2 st = vec2(uv.x, abs(uv.y));\r\n    vec3 col = vec3(0.);\r\n    \r\n    // Background mountain\r\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\r\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\r\n    mountain = C(S(-.005, .005, mountain));\r\n    \r\n    float building = buildings(st);\r\n    \r\n    // Finally blend everything together\r\n    \r\n    // Sky color\r\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\r\n    // Blend the mountain and the sky\r\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\r\n    // Occlude the mountain with the building skyline\r\n    col *= building;\r\n    \r\n    // Yellow-ish window color tint\r\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \r\n    \r\n    // Moon white circle\r\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\r\n    \r\n    //Twinkly stars, masked by the buildings, mountain, and the moon\r\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\r\n    \r\n    // Cut the main moon circle with an offset inverted one to make a crescent\r\n    moon *= smoothstep(.3, .4, length(st-vec2(.92, .88)));\r\n    \r\n    // Add the moon to the scene\r\n    col += moon * vec3(1.2, 1.18, 1.);\r\n    \r\n    // Fireworks launch from behind the buildings, but in front of the mountains\r\n    col += C(fireworks(st)) * (building + moon);\r\n    \r\n    // Slightly change of the reflections to watery blueish-green\r\n    col.r -= reflection * .05;\r\n    col.gb += reflection * .01;\r\n    \r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/**\r\n **   __ __|_  ___________________________________________________________________________  ___|__ __\r\n **  //    /\\                                           _                                  /\\    \\\\  \r\n ** //____/  \\__     __ _____ _____ _____ _____ _____  | |     __ _____ _____ __        __/  \\____\\\\ \r\n **  \\    \\  / /  __|  |     |   __|  _  |     |  _  | | |  __|  |     |   __|  |      /\\ \\  /    /  \r\n **   \\____\\/_/  |  |  |  |  |  |  |     | | | |   __| | | |  |  |  |  |  |  |  |__   \"  \\_\\/____/   \r\n **  /\\    \\     |_____|_____|_____|__|__|_|_|_|__|    | | |_____|_____|_____|_____|  _  /    /\\     \r\n ** /  \\____\\                       http://jogamp.org  |_|                              /____/  \\    \r\n ** \\  /   \"' _________________________________________________________________________ `\"   \\  /    \r\n **  \\/____.                                                                             .____\\/     \r\n **\r\n ** JOGL2 port of my PC 4k intro competition entry for Revision 2012. This is the raymarching fragment\r\n ** shader that is rendered to a fullscreen billboard. The shader basically encapsulates a \r\n ** sphere-tracing based raymarcher for a single fractal formula with camera handling. The different \r\n ** intro parts are all parameter and camera position variations of the same fractal.\r\n **\r\n ** This is the 'normal', unminified version I used during development.\r\n **\r\n ** Papers and articles you should be familiar with before trying to understand the code:\r\n **\r\n ** Distance rendering for fractals: http://www.iquilezles.org/www/articles/distancefractals/distancefractals.htm\r\n ** Ambient occlusion techniques: http://www.iquilezles.org/www/articles/ao/ao.htm\r\n ** Sphere tracing: A geometric method for the antialiased ray tracing of implicit surfaces: http://graphics.cs.uiuc.edu/~jch/papers/zeno.pdf\r\n ** Rendering fractals with distance estimation function: http://www.iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\r\n **\r\n ** For an impression how this routine looks like see here: http://www.youtube.com/watch?v=UjgRGDhgehA\r\n ** Original release from the Revision 2012 can be found here: http://www.pouet.net/prod.php?which=59086\r\n **/\r\n\r\n//base\r\n//uniform vec2 rs;  //resolution\r\n\r\n//scene timing\r\nint sn = 1;   //scene number\r\n\r\nfloat lt = 23.0; //previous/last scene time\r\n\r\n//camera\r\nvec3  cp; //camera position\r\nmat3  cr; //camera rotation\r\n\r\n//coloring\r\nfloat ff; //fog falloff\r\n\r\n//ifs\r\nfloat fu; //fractal_spheresubstract\r\nfloat fd; //fractal_distancemult\r\nvec3 cs;  //fractal_csize\r\nfloat fs; //fractal_size\r\nvec3 fc;  //fractal_c\r\n\r\nfloat dE(vec3 p) {\r\n   float dEfactor=1.;\r\n   //int fractal_iterations = 12;\r\n   for(int i=0;i<12;i++){\r\n      //box folding\r\n      p=2.*clamp(p, -cs, cs)-p;\r\n      //inversion\r\n      float k=max(fs/dot(p,p),1.);\r\n      p*=k;\r\n      dEfactor*=k;\r\n      //julia seed\r\n      p+=fc;\r\n   }\r\n   //call basic shape and scale its DE\r\n   //need to adjust fractal_distancemult with non zero julia seed\r\n   float rxy=length(p.xy)-fu;\r\n   //distance from pos to the pseudo kleinian basic shape ...\r\n   return (fd*max(rxy,abs(length(p.xy)*p.z)/sqrt(dot(p,p)))/abs(dEfactor));\r\n}\r\n\r\nvec4 rd(vec2 fragment_coordinates) {   \r\n   //calculate ray direction from fragment coordinates ...\r\n   vec2 ray_position = (0.5*iResolution.xy-fragment_coordinates)/vec2(iResolution.x,iResolution.y);   \r\n   ray_position.x *= (iResolution.x/iResolution.y); //aspect_ratio\r\n   vec3 ray_direction = normalize(cr * vec3(ray_position.x * vec3(1, 0, 0) + ray_position.y * vec3(0, 1, 0) - .9 * vec3(0, 0, 1)));\r\n   //sphere tracing initialization ...\r\n   float ray_length = 0.0;\r\n   vec3  ray = cp+ray_length*ray_direction;\r\n   float epsilon = 0.0000006;\r\n   float  calculated_distance;\r\n   int   tracingsteps = 0;\r\n   bool  hit = false;\r\n   ray = cp+ray_length*ray_direction;\r\n   //magic :) DO NOT TOUCH!\r\n   float eps_factor = 2.0*.294*(1.0/iResolution.y)*.6;\r\n   //actual sphere tracing ...\r\n   //#define tracingsteps_max 200\r\n   for (int i=0; i<100; i++) {\r\n      tracingsteps = i;\r\n      calculated_distance = dE(ray);     \r\n      //small stepback to remove 'fuzzel'-structures near inside shooting range\r\n      //#define raylength_max 10000.0\r\n       if (hit && calculated_distance<epsilon || ray_length>1000.0){\r\n         tracingsteps--;\r\n         break;\r\n      }\r\n      hit = false;\r\n      ray_length += calculated_distance;\r\n      ray = cp+ray_length*ray_direction;\r\n      epsilon = ray_length * eps_factor;\r\n      if (calculated_distance<epsilon) {\r\n         hit = true;\r\n      }\r\n   }\r\n   //---   \r\n   //intersects ?\r\n   //#define tracingsteps_max 200\r\n   float glow_amount = float(tracingsteps)/float(200);\r\n   vec4 color_primary = vec4(1.0,1.0,1.0,0.45);             //alpha-channel represents intensity\r\n   vec4 color_background_primary = vec4(1.0,1.0,0.0,1.0);\r\n   vec4 color_background_secondary = vec4(0.0,0.0,0.0,1.0);\r\n   vec4 color_glow_inside = vec4(0.0,1.0,1.0,0.55);         //alpha-channel represents intensity \r\n   float aof = 1.0;\r\n   //asin(1.0)=pi/2\r\n   vec4  bg_color = vec4(clamp(mix(color_background_secondary.rgb, color_background_primary.rgb, (sin(ray_direction.y * asin(1.0)) + 1.0) * 0.5), 0.0, 1.0), 1.0);\r\n   vec4 color = color_primary;\r\n   if (hit) {\r\n      float glow = clamp(glow_amount * color_glow_inside.a * 3.0, 0.0, 1.0);\r\n      //---      \r\n      //calculate_normal: gradient calculation in x,y and z from intersection position\r\n      //#define normal_min 1.5e-7\r\n      float epsilon_normal = max(epsilon*0.5,1.5e-7);\r\n      vec3 normal = normalize(vec3(\r\n         dE(ray+vec3(epsilon_normal, 0, 0))-dE(ray-vec3(epsilon_normal, 0, 0)),\r\n         dE(ray+vec3(0, epsilon_normal, 0))-dE(ray-vec3(0, epsilon_normal, 0)),\r\n         dE(ray+vec3(0, 0, epsilon_normal))-dE(ray-vec3(0, 0, epsilon_normal)))\r\n      );\r\n      //---\r\n      //AO approximation: http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\r\n      float occlusion_factor = 1.0;\r\n      //float ambientocclusion_spread = 9.00000;\r\n      //float ambientocclusion_intensity = 0.15000;   \r\n      //float surface_offset = epsilon;\r\n      //surface_offset *= 9.;\r\n      float surface_offset = epsilon*9.;\r\n      float ao_contribution = .15/surface_offset;\r\n      //start with small offset from surface ...\r\n      float surface_distance = 2.0*surface_offset;\r\n      //#define ambientocclusion_iterations 4\r\n      for (int i=0; i<8; ++i) {\r\n         occlusion_factor -= (surface_distance-dE(ray+normal*surface_distance))*ao_contribution;\r\n         surface_distance += surface_offset;\r\n         //contribution lowers with distance to surface\r\n         ao_contribution *= 0.5; \r\n      }\r\n      aof = clamp(occlusion_factor, 0.0, 1.0);\r\n      //--- \r\n      //blinn phong shading model\r\n      //base color, incident, point of intersection, normal\r\n      //ambient colour based on background gradient\r\n      //asin(1.0)=pi/2  \r\n      vec3 ambColor = clamp(mix(color_background_secondary.rgb, color_background_primary.rgb, (sin(normal.y * asin(1.0)) + 1.0) * 0.5), 0.0, 1.0);\r\n      ambColor = mix(vec3(.5), ambColor, .3);\r\n      //vec3 light_position = vec3(-16.00000,100.00000,-60.00000);\r\n      float diffuse = max(dot(normal, normalize(vec3(-16.,100.,-60.)-ray)), 0.0);       \r\n      //vec3 clamped_ambientcolor = clamp(color.rgb * color_primary.a, 0.0, 1.0);\r\n      vec3 clamped_ambientcolor = color.rgb * color_primary.a;\r\n      //float light_specular = 0.80000;\r\n      //float light_specular_exponent = 4.00000;\r\n      //float temp_specular = pow(diffuse, 4.);\r\n      color.rgb = (ambColor * clamped_ambientcolor + clamped_ambientcolor * diffuse + pow(diffuse, 4.) * .8)*aof;\r\n      color.rgb = mix(color.rgb, color_glow_inside.rgb, glow);\r\n    } else {\r\n        //Zzzzz ... no intersection ...\r\n    } \r\n    //float color_fog_intensity = 0.01;   \r\n    color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(ray_length * exp(ff), 2.0) * .01));\r\n    return vec4(color.rgb,1.0);\r\n}\r\n\r\n//return rotation matrix for rotating around vector v by angle\r\nmat3 mr(vec3 v, float angle) {\r\n    float c = cos(radians(angle));\r\n    float s = sin(radians(angle));\r\n    return mat3(c+(1.0-c)*v.x*v.x   , (1.0-c)*v.x*v.y-s*v.z  , (1.0-c)*v.x*v.z+s*v.y,\r\n               (1.0-c)*v.x*v.y+s*v.z, c+(1.0-c)*v.y*v.y      , (1.0-c)*v.y*v.z-s*v.x,\r\n               (1.0-c)*v.x*v.z-s*v.y, (1.0 - c)*v.y*v.z+s*v.x, c+(1.0-c)*v.z*v.z);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    //camera\r\n    float camera_roll = 0.;\r\n    float camera_pitch = 90.;\r\n    float camera_yaw = 0.;\r\n    fd = 0.763;\r\n    fu = 10.0;\r\n    fs = 1.0;\r\n    fc = vec3(0);\r\n    ff = -0.50000;\r\n    cs = vec3(0.80800,0.80800,1.16700);\r\n    float gamma_correction = 1.00000;    \r\n    //float temp_scenetimer = clamp(current_scene_timer,0.0,100.0);\r\n    float temp_scenetimer = iTime;\r\n    int temp_scene_number = int(iTime / 10.0) + 1;\r\n    vec2 custom_glFragCoord = fragCoord.xy;    \r\n    float noise = 1.0;//fract(sin(dot(custom_glFragCoord.xy ,vec2(12.9898,78.233))) * 43758.5453+(temp_scenetimer*0.25))*(sin(temp_scenetimer+custom_glFragCoord.y)*2.0+4.0); \r\n    if (temp_scene_number>=1) {\r\n       if (noise>temp_scenetimer) {\r\n          temp_scenetimer = 0.0;\r\n          temp_scene_number = temp_scene_number-1;\r\n       }\r\n    }  \r\n    //#define scene_fadein 0 \r\n    if (temp_scene_number==0) {\r\n       gamma_correction = clamp(temp_scenetimer*0.055,0.0,1.0);\r\n       camera_pitch = 23.9;\r\n       cp = vec3(0.8,-1.16339+16.0-temp_scenetimer*0.095,-1.80153);\r\n       cs.y = 0.58000;\r\n    }\r\n    //#define scene_wires_sidescroller 1\r\n    if (temp_scene_number==1) {\r\n       cp = vec3(0.7212+temp_scenetimer*0.00068,0.10000,-2.35000);\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_wires_insidescroller 2\r\n    if (temp_scene_number==2) {\r\n       cp = vec3(0.7+(-0.0092+temp_scenetimer*0.000180),0.1,-2.3495);\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_grid_hallofharad 3\r\n    if (temp_scene_number==3) {\r\n       fu = 1.01000;\r\n       cp = vec3(temp_scenetimer*0.05,0.02000,2.00000-100.0*0.1);\r\n       cs.x = 0.90000;\r\n    }\r\n    //#define scene_grid_sideoverview 4\r\n    if (temp_scene_number==4) {\r\n       fu = 1.01000;\r\n       cp = vec3(0.0007,0.02000,0.10000-temp_scenetimer*0.00028);\r\n       camera_pitch = 0.0;\r\n       camera_yaw = temp_scenetimer*0.009*180.0;\r\n       cs.x = 0.90000;\r\n    }\r\n    //#define scene_spike_verticalcore 5    \r\n    if (temp_scene_number==5) {\r\n       fu = 0.9;\r\n       cp = vec3(0.0+temp_scenetimer*0.00025,1.40000+0.004,-2.38200+(-0.05+temp_scenetimer*0.002));\r\n    }\r\n    //#define scene_spike_introduction 6  \r\n    if (temp_scene_number==6) {  \r\n       cp = vec3(1.18000,0.08000+temp_scenetimer*0.000055,-0.24000);\r\n       camera_pitch = 120.0;\r\n       cs = vec3(0.50000,0.50000,1.04000);\r\n    }\r\n    //#define scene_spike_wiredballsvertical 7   \r\n    if (temp_scene_number==7) {\r\n       fd = 0.70000;\r\n       fs = 1.34000;\r\n       cp = vec3(0.69+(-0.0092+temp_scenetimer*0.0008),0.1,-2.3495);\r\n       camera_pitch = 130.0+sin(temp_scenetimer*0.075)*50.0;\r\n       camera_roll = 90.0;\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_alien_backbone 8\r\n    if (temp_scene_number==8) {\r\n       cp = vec3(0.0,-0.86000+temp_scenetimer*0.0003,0.30000);\r\n       camera_pitch = 80.0+(temp_scenetimer*0.65);     \r\n       fc.z = -0.38000;\r\n    }    \r\n    float brightness = 0.0;\r\n    //#define scene_alien_reactorcore 9\r\n    if (temp_scene_number==9) {\r\n       gamma_correction = clamp(temp_scenetimer*0.025,1.0,100.0);\r\n       fu = 1.20000;\r\n       cp = vec3(0.00,1.40000+(-0.020+temp_scenetimer*0.0018),-2.34100);\r\n       fc.z = 0.25840;\r\n       ff =  clamp(temp_scenetimer*0.05,3.6,100.0);\r\n       brightness = clamp((temp_scenetimer-35.0)*0.005,0.0,1.0);       \r\n    }\r\n    cr = mr(vec3(0, 1, 0), 180.0 - camera_yaw) * mr(vec3(1, 0, 0), -camera_pitch) * mr(vec3(0, 0, 1), camera_roll);    \r\n    //super sampling support\r\n    vec4 color = vec4(0.0);\r\n#define antialiasing 0.5       \r\n#ifdef antialiasing\r\n    float n = 0.0;\r\n    for (float x = 0.0; x < 1.0; x += float(antialiasing)) {\r\n        for (float y = 0.0; y < 1.0; y += float(antialiasing)) {\r\n            color += rd(custom_glFragCoord.xy + vec2(x, y));\r\n            n += 1.0;\r\n        }\r\n    }\r\n    color /= n;\r\n#else\r\n    color = rd(custom_glFragCoord.xy);\r\n#endif    \r\n    //output\r\n    fragColor = vec4(pow(color.rgb+brightness, vec3(1.0 / gamma_correction)), color.a);\r\n} ","inputs":[],"outputs":[],"code":"/**\r\n **   __ __|_  ___________________________________________________________________________  ___|__ __\r\n **  //    /\\                                           _                                  /\\    \\\\  \r\n ** //____/  \\__     __ _____ _____ _____ _____ _____  | |     __ _____ _____ __        __/  \\____\\\\ \r\n **  \\    \\  / /  __|  |     |   __|  _  |     |  _  | | |  __|  |     |   __|  |      /\\ \\  /    /  \r\n **   \\____\\/_/  |  |  |  |  |  |  |     | | | |   __| | | |  |  |  |  |  |  |  |__   \"  \\_\\/____/   \r\n **  /\\    \\     |_____|_____|_____|__|__|_|_|_|__|    | | |_____|_____|_____|_____|  _  /    /\\     \r\n ** /  \\____\\                       http://jogamp.org  |_|                              /____/  \\    \r\n ** \\  /   \"' _________________________________________________________________________ `\"   \\  /    \r\n **  \\/____.                                                                             .____\\/     \r\n **\r\n ** JOGL2 port of my PC 4k intro competition entry for Revision 2012. This is the raymarching fragment\r\n ** shader that is rendered to a fullscreen billboard. The shader basically encapsulates a \r\n ** sphere-tracing based raymarcher for a single fractal formula with camera handling. The different \r\n ** intro parts are all parameter and camera position variations of the same fractal.\r\n **\r\n ** This is the 'normal', unminified version I used during development.\r\n **\r\n ** Papers and articles you should be familiar with before trying to understand the code:\r\n **\r\n ** Distance rendering for fractals: http://www.iquilezles.org/www/articles/distancefractals/distancefractals.htm\r\n ** Ambient occlusion techniques: http://www.iquilezles.org/www/articles/ao/ao.htm\r\n ** Sphere tracing: A geometric method for the antialiased ray tracing of implicit surfaces: http://graphics.cs.uiuc.edu/~jch/papers/zeno.pdf\r\n ** Rendering fractals with distance estimation function: http://www.iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\r\n **\r\n ** For an impression how this routine looks like see here: http://www.youtube.com/watch?v=UjgRGDhgehA\r\n ** Original release from the Revision 2012 can be found here: http://www.pouet.net/prod.php?which=59086\r\n **/\r\n\r\n//base\r\n//uniform vec2 rs;  //resolution\r\n\r\n//scene timing\r\nint sn = 1;   //scene number\r\n\r\nfloat lt = 23.0; //previous/last scene time\r\n\r\n//camera\r\nvec3  cp; //camera position\r\nmat3  cr; //camera rotation\r\n\r\n//coloring\r\nfloat ff; //fog falloff\r\n\r\n//ifs\r\nfloat fu; //fractal_spheresubstract\r\nfloat fd; //fractal_distancemult\r\nvec3 cs;  //fractal_csize\r\nfloat fs; //fractal_size\r\nvec3 fc;  //fractal_c\r\n\r\nfloat dE(vec3 p) {\r\n   float dEfactor=1.;\r\n   //int fractal_iterations = 12;\r\n   for(int i=0;i<12;i++){\r\n      //box folding\r\n      p=2.*clamp(p, -cs, cs)-p;\r\n      //inversion\r\n      float k=max(fs/dot(p,p),1.);\r\n      p*=k;\r\n      dEfactor*=k;\r\n      //julia seed\r\n      p+=fc;\r\n   }\r\n   //call basic shape and scale its DE\r\n   //need to adjust fractal_distancemult with non zero julia seed\r\n   float rxy=length(p.xy)-fu;\r\n   //distance from pos to the pseudo kleinian basic shape ...\r\n   return (fd*max(rxy,abs(length(p.xy)*p.z)/sqrt(dot(p,p)))/abs(dEfactor));\r\n}\r\n\r\nvec4 rd(vec2 fragment_coordinates) {   \r\n   //calculate ray direction from fragment coordinates ...\r\n   vec2 ray_position = (0.5*iResolution.xy-fragment_coordinates)/vec2(iResolution.x,iResolution.y);   \r\n   ray_position.x *= (iResolution.x/iResolution.y); //aspect_ratio\r\n   vec3 ray_direction = normalize(cr * vec3(ray_position.x * vec3(1, 0, 0) + ray_position.y * vec3(0, 1, 0) - .9 * vec3(0, 0, 1)));\r\n   //sphere tracing initialization ...\r\n   float ray_length = 0.0;\r\n   vec3  ray = cp+ray_length*ray_direction;\r\n   float epsilon = 0.0000006;\r\n   float  calculated_distance;\r\n   int   tracingsteps = 0;\r\n   bool  hit = false;\r\n   ray = cp+ray_length*ray_direction;\r\n   //magic :) DO NOT TOUCH!\r\n   float eps_factor = 2.0*.294*(1.0/iResolution.y)*.6;\r\n   //actual sphere tracing ...\r\n   //#define tracingsteps_max 200\r\n   for (int i=0; i<100; i++) {\r\n      tracingsteps = i;\r\n      calculated_distance = dE(ray);     \r\n      //small stepback to remove 'fuzzel'-structures near inside shooting range\r\n      //#define raylength_max 10000.0\r\n       if (hit && calculated_distance<epsilon || ray_length>1000.0){\r\n         tracingsteps--;\r\n         break;\r\n      }\r\n      hit = false;\r\n      ray_length += calculated_distance;\r\n      ray = cp+ray_length*ray_direction;\r\n      epsilon = ray_length * eps_factor;\r\n      if (calculated_distance<epsilon) {\r\n         hit = true;\r\n      }\r\n   }\r\n   //---   \r\n   //intersects ?\r\n   //#define tracingsteps_max 200\r\n   float glow_amount = float(tracingsteps)/float(200);\r\n   vec4 color_primary = vec4(1.0,1.0,1.0,0.45);             //alpha-channel represents intensity\r\n   vec4 color_background_primary = vec4(1.0,1.0,0.0,1.0);\r\n   vec4 color_background_secondary = vec4(0.0,0.0,0.0,1.0);\r\n   vec4 color_glow_inside = vec4(0.0,1.0,1.0,0.55);         //alpha-channel represents intensity \r\n   float aof = 1.0;\r\n   //asin(1.0)=pi/2\r\n   vec4  bg_color = vec4(clamp(mix(color_background_secondary.rgb, color_background_primary.rgb, (sin(ray_direction.y * asin(1.0)) + 1.0) * 0.5), 0.0, 1.0), 1.0);\r\n   vec4 color = color_primary;\r\n   if (hit) {\r\n      float glow = clamp(glow_amount * color_glow_inside.a * 3.0, 0.0, 1.0);\r\n      //---      \r\n      //calculate_normal: gradient calculation in x,y and z from intersection position\r\n      //#define normal_min 1.5e-7\r\n      float epsilon_normal = max(epsilon*0.5,1.5e-7);\r\n      vec3 normal = normalize(vec3(\r\n         dE(ray+vec3(epsilon_normal, 0, 0))-dE(ray-vec3(epsilon_normal, 0, 0)),\r\n         dE(ray+vec3(0, epsilon_normal, 0))-dE(ray-vec3(0, epsilon_normal, 0)),\r\n         dE(ray+vec3(0, 0, epsilon_normal))-dE(ray-vec3(0, 0, epsilon_normal)))\r\n      );\r\n      //---\r\n      //AO approximation: http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\r\n      float occlusion_factor = 1.0;\r\n      //float ambientocclusion_spread = 9.00000;\r\n      //float ambientocclusion_intensity = 0.15000;   \r\n      //float surface_offset = epsilon;\r\n      //surface_offset *= 9.;\r\n      float surface_offset = epsilon*9.;\r\n      float ao_contribution = .15/surface_offset;\r\n      //start with small offset from surface ...\r\n      float surface_distance = 2.0*surface_offset;\r\n      //#define ambientocclusion_iterations 4\r\n      for (int i=0; i<8; ++i) {\r\n         occlusion_factor -= (surface_distance-dE(ray+normal*surface_distance))*ao_contribution;\r\n         surface_distance += surface_offset;\r\n         //contribution lowers with distance to surface\r\n         ao_contribution *= 0.5; \r\n      }\r\n      aof = clamp(occlusion_factor, 0.0, 1.0);\r\n      //--- \r\n      //blinn phong shading model\r\n      //base color, incident, point of intersection, normal\r\n      //ambient colour based on background gradient\r\n      //asin(1.0)=pi/2  \r\n      vec3 ambColor = clamp(mix(color_background_secondary.rgb, color_background_primary.rgb, (sin(normal.y * asin(1.0)) + 1.0) * 0.5), 0.0, 1.0);\r\n      ambColor = mix(vec3(.5), ambColor, .3);\r\n      //vec3 light_position = vec3(-16.00000,100.00000,-60.00000);\r\n      float diffuse = max(dot(normal, normalize(vec3(-16.,100.,-60.)-ray)), 0.0);       \r\n      //vec3 clamped_ambientcolor = clamp(color.rgb * color_primary.a, 0.0, 1.0);\r\n      vec3 clamped_ambientcolor = color.rgb * color_primary.a;\r\n      //float light_specular = 0.80000;\r\n      //float light_specular_exponent = 4.00000;\r\n      //float temp_specular = pow(diffuse, 4.);\r\n      color.rgb = (ambColor * clamped_ambientcolor + clamped_ambientcolor * diffuse + pow(diffuse, 4.) * .8)*aof;\r\n      color.rgb = mix(color.rgb, color_glow_inside.rgb, glow);\r\n    } else {\r\n        //Zzzzz ... no intersection ...\r\n    } \r\n    //float color_fog_intensity = 0.01;   \r\n    color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(ray_length * exp(ff), 2.0) * .01));\r\n    return vec4(color.rgb,1.0);\r\n}\r\n\r\n//return rotation matrix for rotating around vector v by angle\r\nmat3 mr(vec3 v, float angle) {\r\n    float c = cos(radians(angle));\r\n    float s = sin(radians(angle));\r\n    return mat3(c+(1.0-c)*v.x*v.x   , (1.0-c)*v.x*v.y-s*v.z  , (1.0-c)*v.x*v.z+s*v.y,\r\n               (1.0-c)*v.x*v.y+s*v.z, c+(1.0-c)*v.y*v.y      , (1.0-c)*v.y*v.z-s*v.x,\r\n               (1.0-c)*v.x*v.z-s*v.y, (1.0 - c)*v.y*v.z+s*v.x, c+(1.0-c)*v.z*v.z);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    //camera\r\n    float camera_roll = 0.;\r\n    float camera_pitch = 90.;\r\n    float camera_yaw = 0.;\r\n    fd = 0.763;\r\n    fu = 10.0;\r\n    fs = 1.0;\r\n    fc = vec3(0);\r\n    ff = -0.50000;\r\n    cs = vec3(0.80800,0.80800,1.16700);\r\n    float gamma_correction = 1.00000;    \r\n    //float temp_scenetimer = clamp(current_scene_timer,0.0,100.0);\r\n    float temp_scenetimer = iTime;\r\n    int temp_scene_number = int(iTime / 10.0) + 1;\r\n    vec2 custom_glFragCoord = fragCoord.xy;    \r\n    float noise = 1.0;//fract(sin(dot(custom_glFragCoord.xy ,vec2(12.9898,78.233))) * 43758.5453+(temp_scenetimer*0.25))*(sin(temp_scenetimer+custom_glFragCoord.y)*2.0+4.0); \r\n    if (temp_scene_number>=1) {\r\n       if (noise>temp_scenetimer) {\r\n          temp_scenetimer = 0.0;\r\n          temp_scene_number = temp_scene_number-1;\r\n       }\r\n    }  \r\n    //#define scene_fadein 0 \r\n    if (temp_scene_number==0) {\r\n       gamma_correction = clamp(temp_scenetimer*0.055,0.0,1.0);\r\n       camera_pitch = 23.9;\r\n       cp = vec3(0.8,-1.16339+16.0-temp_scenetimer*0.095,-1.80153);\r\n       cs.y = 0.58000;\r\n    }\r\n    //#define scene_wires_sidescroller 1\r\n    if (temp_scene_number==1) {\r\n       cp = vec3(0.7212+temp_scenetimer*0.00068,0.10000,-2.35000);\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_wires_insidescroller 2\r\n    if (temp_scene_number==2) {\r\n       cp = vec3(0.7+(-0.0092+temp_scenetimer*0.000180),0.1,-2.3495);\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_grid_hallofharad 3\r\n    if (temp_scene_number==3) {\r\n       fu = 1.01000;\r\n       cp = vec3(temp_scenetimer*0.05,0.02000,2.00000-100.0*0.1);\r\n       cs.x = 0.90000;\r\n    }\r\n    //#define scene_grid_sideoverview 4\r\n    if (temp_scene_number==4) {\r\n       fu = 1.01000;\r\n       cp = vec3(0.0007,0.02000,0.10000-temp_scenetimer*0.00028);\r\n       camera_pitch = 0.0;\r\n       camera_yaw = temp_scenetimer*0.009*180.0;\r\n       cs.x = 0.90000;\r\n    }\r\n    //#define scene_spike_verticalcore 5    \r\n    if (temp_scene_number==5) {\r\n       fu = 0.9;\r\n       cp = vec3(0.0+temp_scenetimer*0.00025,1.40000+0.004,-2.38200+(-0.05+temp_scenetimer*0.002));\r\n    }\r\n    //#define scene_spike_introduction 6  \r\n    if (temp_scene_number==6) {  \r\n       cp = vec3(1.18000,0.08000+temp_scenetimer*0.000055,-0.24000);\r\n       camera_pitch = 120.0;\r\n       cs = vec3(0.50000,0.50000,1.04000);\r\n    }\r\n    //#define scene_spike_wiredballsvertical 7   \r\n    if (temp_scene_number==7) {\r\n       fd = 0.70000;\r\n       fs = 1.34000;\r\n       cp = vec3(0.69+(-0.0092+temp_scenetimer*0.0008),0.1,-2.3495);\r\n       camera_pitch = 130.0+sin(temp_scenetimer*0.075)*50.0;\r\n       camera_roll = 90.0;\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_alien_backbone 8\r\n    if (temp_scene_number==8) {\r\n       cp = vec3(0.0,-0.86000+temp_scenetimer*0.0003,0.30000);\r\n       camera_pitch = 80.0+(temp_scenetimer*0.65);     \r\n       fc.z = -0.38000;\r\n    }    \r\n    float brightness = 0.0;\r\n    //#define scene_alien_reactorcore 9\r\n    if (temp_scene_number==9) {\r\n       gamma_correction = clamp(temp_scenetimer*0.025,1.0,100.0);\r\n       fu = 1.20000;\r\n       cp = vec3(0.00,1.40000+(-0.020+temp_scenetimer*0.0018),-2.34100);\r\n       fc.z = 0.25840;\r\n       ff =  clamp(temp_scenetimer*0.05,3.6,100.0);\r\n       brightness = clamp((temp_scenetimer-35.0)*0.005,0.0,1.0);       \r\n    }\r\n    cr = mr(vec3(0, 1, 0), 180.0 - camera_yaw) * mr(vec3(1, 0, 0), -camera_pitch) * mr(vec3(0, 0, 1), camera_roll);    \r\n    //super sampling support\r\n    vec4 color = vec4(0.0);\r\n#define antialiasing 0.5       \r\n#ifdef antialiasing\r\n    float n = 0.0;\r\n    for (float x = 0.0; x < 1.0; x += float(antialiasing)) {\r\n        for (float y = 0.0; y < 1.0; y += float(antialiasing)) {\r\n            color += rd(custom_glFragCoord.xy + vec2(x, y));\r\n            n += 1.0;\r\n        }\r\n    }\r\n    color /= n;\r\n#else\r\n    color = rd(custom_glFragCoord.xy);\r\n#endif    \r\n    //output\r\n    fragColor = vec4(pow(color.rgb+brightness, vec3(1.0 / gamma_correction)), color.a);\r\n} ","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Hartverdrahtet","id":"312280d6a9c14471a60fad2aec8672cc","date":null,"viewed":0,"name":"Hartverdrahtet","description":"Quick port of hartverdrahtet shader from 4k intro. Skips intro. To be perfectly clear, this is a complete port of the original intro and in no way, shape or form my own work. See comment for details. Slow due to enabled AA. Disable at line 274\nhttps://www.shadertoy.com/view/4t23Ww","likes":0,"published":null,"tags":["raymarching"," port"," hartverdrahtet"]},"ver":null,"info":{"Name":"Hartverdrahtet","id":"312280d6a9c14471a60fad2aec8672cc","date":null,"viewed":0,"name":"Hartverdrahtet","description":"Quick port of hartverdrahtet shader from 4k intro. Skips intro. To be perfectly clear, this is a complete port of the original intro and in no way, shape or form my own work. See comment for details. Slow due to enabled AA. Disable at line 274\nhttps://www.shadertoy.com/view/4t23Ww","likes":0,"published":null,"tags":["raymarching"," port"," hartverdrahtet"]},"renderpass":[{"Code":"/**\r\n **   __ __|_  ___________________________________________________________________________  ___|__ __\r\n **  //    /\\                                           _                                  /\\    \\\\  \r\n ** //____/  \\__     __ _____ _____ _____ _____ _____  | |     __ _____ _____ __        __/  \\____\\\\ \r\n **  \\    \\  / /  __|  |     |   __|  _  |     |  _  | | |  __|  |     |   __|  |      /\\ \\  /    /  \r\n **   \\____\\/_/  |  |  |  |  |  |  |     | | | |   __| | | |  |  |  |  |  |  |  |__   \"  \\_\\/____/   \r\n **  /\\    \\     |_____|_____|_____|__|__|_|_|_|__|    | | |_____|_____|_____|_____|  _  /    /\\     \r\n ** /  \\____\\                       http://jogamp.org  |_|                              /____/  \\    \r\n ** \\  /   \"' _________________________________________________________________________ `\"   \\  /    \r\n **  \\/____.                                                                             .____\\/     \r\n **\r\n ** JOGL2 port of my PC 4k intro competition entry for Revision 2012. This is the raymarching fragment\r\n ** shader that is rendered to a fullscreen billboard. The shader basically encapsulates a \r\n ** sphere-tracing based raymarcher for a single fractal formula with camera handling. The different \r\n ** intro parts are all parameter and camera position variations of the same fractal.\r\n **\r\n ** This is the 'normal', unminified version I used during development.\r\n **\r\n ** Papers and articles you should be familiar with before trying to understand the code:\r\n **\r\n ** Distance rendering for fractals: http://www.iquilezles.org/www/articles/distancefractals/distancefractals.htm\r\n ** Ambient occlusion techniques: http://www.iquilezles.org/www/articles/ao/ao.htm\r\n ** Sphere tracing: A geometric method for the antialiased ray tracing of implicit surfaces: http://graphics.cs.uiuc.edu/~jch/papers/zeno.pdf\r\n ** Rendering fractals with distance estimation function: http://www.iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\r\n **\r\n ** For an impression how this routine looks like see here: http://www.youtube.com/watch?v=UjgRGDhgehA\r\n ** Original release from the Revision 2012 can be found here: http://www.pouet.net/prod.php?which=59086\r\n **/\r\n\r\n//base\r\n//uniform vec2 rs;  //resolution\r\n\r\n//scene timing\r\nint sn = 1;   //scene number\r\n\r\nfloat lt = 23.0; //previous/last scene time\r\n\r\n//camera\r\nvec3  cp; //camera position\r\nmat3  cr; //camera rotation\r\n\r\n//coloring\r\nfloat ff; //fog falloff\r\n\r\n//ifs\r\nfloat fu; //fractal_spheresubstract\r\nfloat fd; //fractal_distancemult\r\nvec3 cs;  //fractal_csize\r\nfloat fs; //fractal_size\r\nvec3 fc;  //fractal_c\r\n\r\nfloat dE(vec3 p) {\r\n   float dEfactor=1.;\r\n   //int fractal_iterations = 12;\r\n   for(int i=0;i<12;i++){\r\n      //box folding\r\n      p=2.*clamp(p, -cs, cs)-p;\r\n      //inversion\r\n      float k=max(fs/dot(p,p),1.);\r\n      p*=k;\r\n      dEfactor*=k;\r\n      //julia seed\r\n      p+=fc;\r\n   }\r\n   //call basic shape and scale its DE\r\n   //need to adjust fractal_distancemult with non zero julia seed\r\n   float rxy=length(p.xy)-fu;\r\n   //distance from pos to the pseudo kleinian basic shape ...\r\n   return (fd*max(rxy,abs(length(p.xy)*p.z)/sqrt(dot(p,p)))/abs(dEfactor));\r\n}\r\n\r\nvec4 rd(vec2 fragment_coordinates) {   \r\n   //calculate ray direction from fragment coordinates ...\r\n   vec2 ray_position = (0.5*iResolution.xy-fragment_coordinates)/vec2(iResolution.x,iResolution.y);   \r\n   ray_position.x *= (iResolution.x/iResolution.y); //aspect_ratio\r\n   vec3 ray_direction = normalize(cr * vec3(ray_position.x * vec3(1, 0, 0) + ray_position.y * vec3(0, 1, 0) - .9 * vec3(0, 0, 1)));\r\n   //sphere tracing initialization ...\r\n   float ray_length = 0.0;\r\n   vec3  ray = cp+ray_length*ray_direction;\r\n   float epsilon = 0.0000006;\r\n   float  calculated_distance;\r\n   int   tracingsteps = 0;\r\n   bool  hit = false;\r\n   ray = cp+ray_length*ray_direction;\r\n   //magic :) DO NOT TOUCH!\r\n   float eps_factor = 2.0*.294*(1.0/iResolution.y)*.6;\r\n   //actual sphere tracing ...\r\n   //#define tracingsteps_max 200\r\n   for (int i=0; i<100; i++) {\r\n      tracingsteps = i;\r\n      calculated_distance = dE(ray);     \r\n      //small stepback to remove 'fuzzel'-structures near inside shooting range\r\n      //#define raylength_max 10000.0\r\n       if (hit && calculated_distance<epsilon || ray_length>1000.0){\r\n         tracingsteps--;\r\n         break;\r\n      }\r\n      hit = false;\r\n      ray_length += calculated_distance;\r\n      ray = cp+ray_length*ray_direction;\r\n      epsilon = ray_length * eps_factor;\r\n      if (calculated_distance<epsilon) {\r\n         hit = true;\r\n      }\r\n   }\r\n   //---   \r\n   //intersects ?\r\n   //#define tracingsteps_max 200\r\n   float glow_amount = float(tracingsteps)/float(200);\r\n   vec4 color_primary = vec4(1.0,1.0,1.0,0.45);             //alpha-channel represents intensity\r\n   vec4 color_background_primary = vec4(1.0,1.0,0.0,1.0);\r\n   vec4 color_background_secondary = vec4(0.0,0.0,0.0,1.0);\r\n   vec4 color_glow_inside = vec4(0.0,1.0,1.0,0.55);         //alpha-channel represents intensity \r\n   float aof = 1.0;\r\n   //asin(1.0)=pi/2\r\n   vec4  bg_color = vec4(clamp(mix(color_background_secondary.rgb, color_background_primary.rgb, (sin(ray_direction.y * asin(1.0)) + 1.0) * 0.5), 0.0, 1.0), 1.0);\r\n   vec4 color = color_primary;\r\n   if (hit) {\r\n      float glow = clamp(glow_amount * color_glow_inside.a * 3.0, 0.0, 1.0);\r\n      //---      \r\n      //calculate_normal: gradient calculation in x,y and z from intersection position\r\n      //#define normal_min 1.5e-7\r\n      float epsilon_normal = max(epsilon*0.5,1.5e-7);\r\n      vec3 normal = normalize(vec3(\r\n         dE(ray+vec3(epsilon_normal, 0, 0))-dE(ray-vec3(epsilon_normal, 0, 0)),\r\n         dE(ray+vec3(0, epsilon_normal, 0))-dE(ray-vec3(0, epsilon_normal, 0)),\r\n         dE(ray+vec3(0, 0, epsilon_normal))-dE(ray-vec3(0, 0, epsilon_normal)))\r\n      );\r\n      //---\r\n      //AO approximation: http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\r\n      float occlusion_factor = 1.0;\r\n      //float ambientocclusion_spread = 9.00000;\r\n      //float ambientocclusion_intensity = 0.15000;   \r\n      //float surface_offset = epsilon;\r\n      //surface_offset *= 9.;\r\n      float surface_offset = epsilon*9.;\r\n      float ao_contribution = .15/surface_offset;\r\n      //start with small offset from surface ...\r\n      float surface_distance = 2.0*surface_offset;\r\n      //#define ambientocclusion_iterations 4\r\n      for (int i=0; i<8; ++i) {\r\n         occlusion_factor -= (surface_distance-dE(ray+normal*surface_distance))*ao_contribution;\r\n         surface_distance += surface_offset;\r\n         //contribution lowers with distance to surface\r\n         ao_contribution *= 0.5; \r\n      }\r\n      aof = clamp(occlusion_factor, 0.0, 1.0);\r\n      //--- \r\n      //blinn phong shading model\r\n      //base color, incident, point of intersection, normal\r\n      //ambient colour based on background gradient\r\n      //asin(1.0)=pi/2  \r\n      vec3 ambColor = clamp(mix(color_background_secondary.rgb, color_background_primary.rgb, (sin(normal.y * asin(1.0)) + 1.0) * 0.5), 0.0, 1.0);\r\n      ambColor = mix(vec3(.5), ambColor, .3);\r\n      //vec3 light_position = vec3(-16.00000,100.00000,-60.00000);\r\n      float diffuse = max(dot(normal, normalize(vec3(-16.,100.,-60.)-ray)), 0.0);       \r\n      //vec3 clamped_ambientcolor = clamp(color.rgb * color_primary.a, 0.0, 1.0);\r\n      vec3 clamped_ambientcolor = color.rgb * color_primary.a;\r\n      //float light_specular = 0.80000;\r\n      //float light_specular_exponent = 4.00000;\r\n      //float temp_specular = pow(diffuse, 4.);\r\n      color.rgb = (ambColor * clamped_ambientcolor + clamped_ambientcolor * diffuse + pow(diffuse, 4.) * .8)*aof;\r\n      color.rgb = mix(color.rgb, color_glow_inside.rgb, glow);\r\n    } else {\r\n        //Zzzzz ... no intersection ...\r\n    } \r\n    //float color_fog_intensity = 0.01;   \r\n    color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(ray_length * exp(ff), 2.0) * .01));\r\n    return vec4(color.rgb,1.0);\r\n}\r\n\r\n//return rotation matrix for rotating around vector v by angle\r\nmat3 mr(vec3 v, float angle) {\r\n    float c = cos(radians(angle));\r\n    float s = sin(radians(angle));\r\n    return mat3(c+(1.0-c)*v.x*v.x   , (1.0-c)*v.x*v.y-s*v.z  , (1.0-c)*v.x*v.z+s*v.y,\r\n               (1.0-c)*v.x*v.y+s*v.z, c+(1.0-c)*v.y*v.y      , (1.0-c)*v.y*v.z-s*v.x,\r\n               (1.0-c)*v.x*v.z-s*v.y, (1.0 - c)*v.y*v.z+s*v.x, c+(1.0-c)*v.z*v.z);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    //camera\r\n    float camera_roll = 0.;\r\n    float camera_pitch = 90.;\r\n    float camera_yaw = 0.;\r\n    fd = 0.763;\r\n    fu = 10.0;\r\n    fs = 1.0;\r\n    fc = vec3(0);\r\n    ff = -0.50000;\r\n    cs = vec3(0.80800,0.80800,1.16700);\r\n    float gamma_correction = 1.00000;    \r\n    //float temp_scenetimer = clamp(current_scene_timer,0.0,100.0);\r\n    float temp_scenetimer = iTime;\r\n    int temp_scene_number = int(iTime / 10.0) + 1;\r\n    vec2 custom_glFragCoord = fragCoord.xy;    \r\n    float noise = 1.0;//fract(sin(dot(custom_glFragCoord.xy ,vec2(12.9898,78.233))) * 43758.5453+(temp_scenetimer*0.25))*(sin(temp_scenetimer+custom_glFragCoord.y)*2.0+4.0); \r\n    if (temp_scene_number>=1) {\r\n       if (noise>temp_scenetimer) {\r\n          temp_scenetimer = 0.0;\r\n          temp_scene_number = temp_scene_number-1;\r\n       }\r\n    }  \r\n    //#define scene_fadein 0 \r\n    if (temp_scene_number==0) {\r\n       gamma_correction = clamp(temp_scenetimer*0.055,0.0,1.0);\r\n       camera_pitch = 23.9;\r\n       cp = vec3(0.8,-1.16339+16.0-temp_scenetimer*0.095,-1.80153);\r\n       cs.y = 0.58000;\r\n    }\r\n    //#define scene_wires_sidescroller 1\r\n    if (temp_scene_number==1) {\r\n       cp = vec3(0.7212+temp_scenetimer*0.00068,0.10000,-2.35000);\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_wires_insidescroller 2\r\n    if (temp_scene_number==2) {\r\n       cp = vec3(0.7+(-0.0092+temp_scenetimer*0.000180),0.1,-2.3495);\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_grid_hallofharad 3\r\n    if (temp_scene_number==3) {\r\n       fu = 1.01000;\r\n       cp = vec3(temp_scenetimer*0.05,0.02000,2.00000-100.0*0.1);\r\n       cs.x = 0.90000;\r\n    }\r\n    //#define scene_grid_sideoverview 4\r\n    if (temp_scene_number==4) {\r\n       fu = 1.01000;\r\n       cp = vec3(0.0007,0.02000,0.10000-temp_scenetimer*0.00028);\r\n       camera_pitch = 0.0;\r\n       camera_yaw = temp_scenetimer*0.009*180.0;\r\n       cs.x = 0.90000;\r\n    }\r\n    //#define scene_spike_verticalcore 5    \r\n    if (temp_scene_number==5) {\r\n       fu = 0.9;\r\n       cp = vec3(0.0+temp_scenetimer*0.00025,1.40000+0.004,-2.38200+(-0.05+temp_scenetimer*0.002));\r\n    }\r\n    //#define scene_spike_introduction 6  \r\n    if (temp_scene_number==6) {  \r\n       cp = vec3(1.18000,0.08000+temp_scenetimer*0.000055,-0.24000);\r\n       camera_pitch = 120.0;\r\n       cs = vec3(0.50000,0.50000,1.04000);\r\n    }\r\n    //#define scene_spike_wiredballsvertical 7   \r\n    if (temp_scene_number==7) {\r\n       fd = 0.70000;\r\n       fs = 1.34000;\r\n       cp = vec3(0.69+(-0.0092+temp_scenetimer*0.0008),0.1,-2.3495);\r\n       camera_pitch = 130.0+sin(temp_scenetimer*0.075)*50.0;\r\n       camera_roll = 90.0;\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_alien_backbone 8\r\n    if (temp_scene_number==8) {\r\n       cp = vec3(0.0,-0.86000+temp_scenetimer*0.0003,0.30000);\r\n       camera_pitch = 80.0+(temp_scenetimer*0.65);     \r\n       fc.z = -0.38000;\r\n    }    \r\n    float brightness = 0.0;\r\n    //#define scene_alien_reactorcore 9\r\n    if (temp_scene_number==9) {\r\n       gamma_correction = clamp(temp_scenetimer*0.025,1.0,100.0);\r\n       fu = 1.20000;\r\n       cp = vec3(0.00,1.40000+(-0.020+temp_scenetimer*0.0018),-2.34100);\r\n       fc.z = 0.25840;\r\n       ff =  clamp(temp_scenetimer*0.05,3.6,100.0);\r\n       brightness = clamp((temp_scenetimer-35.0)*0.005,0.0,1.0);       \r\n    }\r\n    cr = mr(vec3(0, 1, 0), 180.0 - camera_yaw) * mr(vec3(1, 0, 0), -camera_pitch) * mr(vec3(0, 0, 1), camera_roll);    \r\n    //super sampling support\r\n    vec4 color = vec4(0.0);\r\n#define antialiasing 0.5       \r\n#ifdef antialiasing\r\n    float n = 0.0;\r\n    for (float x = 0.0; x < 1.0; x += float(antialiasing)) {\r\n        for (float y = 0.0; y < 1.0; y += float(antialiasing)) {\r\n            color += rd(custom_glFragCoord.xy + vec2(x, y));\r\n            n += 1.0;\r\n        }\r\n    }\r\n    color /= n;\r\n#else\r\n    color = rd(custom_glFragCoord.xy);\r\n#endif    \r\n    //output\r\n    fragColor = vec4(pow(color.rgb+brightness, vec3(1.0 / gamma_correction)), color.a);\r\n} ","inputs":[],"outputs":[],"code":"/**\r\n **   __ __|_  ___________________________________________________________________________  ___|__ __\r\n **  //    /\\                                           _                                  /\\    \\\\  \r\n ** //____/  \\__     __ _____ _____ _____ _____ _____  | |     __ _____ _____ __        __/  \\____\\\\ \r\n **  \\    \\  / /  __|  |     |   __|  _  |     |  _  | | |  __|  |     |   __|  |      /\\ \\  /    /  \r\n **   \\____\\/_/  |  |  |  |  |  |  |     | | | |   __| | | |  |  |  |  |  |  |  |__   \"  \\_\\/____/   \r\n **  /\\    \\     |_____|_____|_____|__|__|_|_|_|__|    | | |_____|_____|_____|_____|  _  /    /\\     \r\n ** /  \\____\\                       http://jogamp.org  |_|                              /____/  \\    \r\n ** \\  /   \"' _________________________________________________________________________ `\"   \\  /    \r\n **  \\/____.                                                                             .____\\/     \r\n **\r\n ** JOGL2 port of my PC 4k intro competition entry for Revision 2012. This is the raymarching fragment\r\n ** shader that is rendered to a fullscreen billboard. The shader basically encapsulates a \r\n ** sphere-tracing based raymarcher for a single fractal formula with camera handling. The different \r\n ** intro parts are all parameter and camera position variations of the same fractal.\r\n **\r\n ** This is the 'normal', unminified version I used during development.\r\n **\r\n ** Papers and articles you should be familiar with before trying to understand the code:\r\n **\r\n ** Distance rendering for fractals: http://www.iquilezles.org/www/articles/distancefractals/distancefractals.htm\r\n ** Ambient occlusion techniques: http://www.iquilezles.org/www/articles/ao/ao.htm\r\n ** Sphere tracing: A geometric method for the antialiased ray tracing of implicit surfaces: http://graphics.cs.uiuc.edu/~jch/papers/zeno.pdf\r\n ** Rendering fractals with distance estimation function: http://www.iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\r\n **\r\n ** For an impression how this routine looks like see here: http://www.youtube.com/watch?v=UjgRGDhgehA\r\n ** Original release from the Revision 2012 can be found here: http://www.pouet.net/prod.php?which=59086\r\n **/\r\n\r\n//base\r\n//uniform vec2 rs;  //resolution\r\n\r\n//scene timing\r\nint sn = 1;   //scene number\r\n\r\nfloat lt = 23.0; //previous/last scene time\r\n\r\n//camera\r\nvec3  cp; //camera position\r\nmat3  cr; //camera rotation\r\n\r\n//coloring\r\nfloat ff; //fog falloff\r\n\r\n//ifs\r\nfloat fu; //fractal_spheresubstract\r\nfloat fd; //fractal_distancemult\r\nvec3 cs;  //fractal_csize\r\nfloat fs; //fractal_size\r\nvec3 fc;  //fractal_c\r\n\r\nfloat dE(vec3 p) {\r\n   float dEfactor=1.;\r\n   //int fractal_iterations = 12;\r\n   for(int i=0;i<12;i++){\r\n      //box folding\r\n      p=2.*clamp(p, -cs, cs)-p;\r\n      //inversion\r\n      float k=max(fs/dot(p,p),1.);\r\n      p*=k;\r\n      dEfactor*=k;\r\n      //julia seed\r\n      p+=fc;\r\n   }\r\n   //call basic shape and scale its DE\r\n   //need to adjust fractal_distancemult with non zero julia seed\r\n   float rxy=length(p.xy)-fu;\r\n   //distance from pos to the pseudo kleinian basic shape ...\r\n   return (fd*max(rxy,abs(length(p.xy)*p.z)/sqrt(dot(p,p)))/abs(dEfactor));\r\n}\r\n\r\nvec4 rd(vec2 fragment_coordinates) {   \r\n   //calculate ray direction from fragment coordinates ...\r\n   vec2 ray_position = (0.5*iResolution.xy-fragment_coordinates)/vec2(iResolution.x,iResolution.y);   \r\n   ray_position.x *= (iResolution.x/iResolution.y); //aspect_ratio\r\n   vec3 ray_direction = normalize(cr * vec3(ray_position.x * vec3(1, 0, 0) + ray_position.y * vec3(0, 1, 0) - .9 * vec3(0, 0, 1)));\r\n   //sphere tracing initialization ...\r\n   float ray_length = 0.0;\r\n   vec3  ray = cp+ray_length*ray_direction;\r\n   float epsilon = 0.0000006;\r\n   float  calculated_distance;\r\n   int   tracingsteps = 0;\r\n   bool  hit = false;\r\n   ray = cp+ray_length*ray_direction;\r\n   //magic :) DO NOT TOUCH!\r\n   float eps_factor = 2.0*.294*(1.0/iResolution.y)*.6;\r\n   //actual sphere tracing ...\r\n   //#define tracingsteps_max 200\r\n   for (int i=0; i<100; i++) {\r\n      tracingsteps = i;\r\n      calculated_distance = dE(ray);     \r\n      //small stepback to remove 'fuzzel'-structures near inside shooting range\r\n      //#define raylength_max 10000.0\r\n       if (hit && calculated_distance<epsilon || ray_length>1000.0){\r\n         tracingsteps--;\r\n         break;\r\n      }\r\n      hit = false;\r\n      ray_length += calculated_distance;\r\n      ray = cp+ray_length*ray_direction;\r\n      epsilon = ray_length * eps_factor;\r\n      if (calculated_distance<epsilon) {\r\n         hit = true;\r\n      }\r\n   }\r\n   //---   \r\n   //intersects ?\r\n   //#define tracingsteps_max 200\r\n   float glow_amount = float(tracingsteps)/float(200);\r\n   vec4 color_primary = vec4(1.0,1.0,1.0,0.45);             //alpha-channel represents intensity\r\n   vec4 color_background_primary = vec4(1.0,1.0,0.0,1.0);\r\n   vec4 color_background_secondary = vec4(0.0,0.0,0.0,1.0);\r\n   vec4 color_glow_inside = vec4(0.0,1.0,1.0,0.55);         //alpha-channel represents intensity \r\n   float aof = 1.0;\r\n   //asin(1.0)=pi/2\r\n   vec4  bg_color = vec4(clamp(mix(color_background_secondary.rgb, color_background_primary.rgb, (sin(ray_direction.y * asin(1.0)) + 1.0) * 0.5), 0.0, 1.0), 1.0);\r\n   vec4 color = color_primary;\r\n   if (hit) {\r\n      float glow = clamp(glow_amount * color_glow_inside.a * 3.0, 0.0, 1.0);\r\n      //---      \r\n      //calculate_normal: gradient calculation in x,y and z from intersection position\r\n      //#define normal_min 1.5e-7\r\n      float epsilon_normal = max(epsilon*0.5,1.5e-7);\r\n      vec3 normal = normalize(vec3(\r\n         dE(ray+vec3(epsilon_normal, 0, 0))-dE(ray-vec3(epsilon_normal, 0, 0)),\r\n         dE(ray+vec3(0, epsilon_normal, 0))-dE(ray-vec3(0, epsilon_normal, 0)),\r\n         dE(ray+vec3(0, 0, epsilon_normal))-dE(ray-vec3(0, 0, epsilon_normal)))\r\n      );\r\n      //---\r\n      //AO approximation: http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf\r\n      float occlusion_factor = 1.0;\r\n      //float ambientocclusion_spread = 9.00000;\r\n      //float ambientocclusion_intensity = 0.15000;   \r\n      //float surface_offset = epsilon;\r\n      //surface_offset *= 9.;\r\n      float surface_offset = epsilon*9.;\r\n      float ao_contribution = .15/surface_offset;\r\n      //start with small offset from surface ...\r\n      float surface_distance = 2.0*surface_offset;\r\n      //#define ambientocclusion_iterations 4\r\n      for (int i=0; i<8; ++i) {\r\n         occlusion_factor -= (surface_distance-dE(ray+normal*surface_distance))*ao_contribution;\r\n         surface_distance += surface_offset;\r\n         //contribution lowers with distance to surface\r\n         ao_contribution *= 0.5; \r\n      }\r\n      aof = clamp(occlusion_factor, 0.0, 1.0);\r\n      //--- \r\n      //blinn phong shading model\r\n      //base color, incident, point of intersection, normal\r\n      //ambient colour based on background gradient\r\n      //asin(1.0)=pi/2  \r\n      vec3 ambColor = clamp(mix(color_background_secondary.rgb, color_background_primary.rgb, (sin(normal.y * asin(1.0)) + 1.0) * 0.5), 0.0, 1.0);\r\n      ambColor = mix(vec3(.5), ambColor, .3);\r\n      //vec3 light_position = vec3(-16.00000,100.00000,-60.00000);\r\n      float diffuse = max(dot(normal, normalize(vec3(-16.,100.,-60.)-ray)), 0.0);       \r\n      //vec3 clamped_ambientcolor = clamp(color.rgb * color_primary.a, 0.0, 1.0);\r\n      vec3 clamped_ambientcolor = color.rgb * color_primary.a;\r\n      //float light_specular = 0.80000;\r\n      //float light_specular_exponent = 4.00000;\r\n      //float temp_specular = pow(diffuse, 4.);\r\n      color.rgb = (ambColor * clamped_ambientcolor + clamped_ambientcolor * diffuse + pow(diffuse, 4.) * .8)*aof;\r\n      color.rgb = mix(color.rgb, color_glow_inside.rgb, glow);\r\n    } else {\r\n        //Zzzzz ... no intersection ...\r\n    } \r\n    //float color_fog_intensity = 0.01;   \r\n    color.rgb = mix(bg_color.rgb, color.rgb, exp(-pow(ray_length * exp(ff), 2.0) * .01));\r\n    return vec4(color.rgb,1.0);\r\n}\r\n\r\n//return rotation matrix for rotating around vector v by angle\r\nmat3 mr(vec3 v, float angle) {\r\n    float c = cos(radians(angle));\r\n    float s = sin(radians(angle));\r\n    return mat3(c+(1.0-c)*v.x*v.x   , (1.0-c)*v.x*v.y-s*v.z  , (1.0-c)*v.x*v.z+s*v.y,\r\n               (1.0-c)*v.x*v.y+s*v.z, c+(1.0-c)*v.y*v.y      , (1.0-c)*v.y*v.z-s*v.x,\r\n               (1.0-c)*v.x*v.z-s*v.y, (1.0 - c)*v.y*v.z+s*v.x, c+(1.0-c)*v.z*v.z);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    //camera\r\n    float camera_roll = 0.;\r\n    float camera_pitch = 90.;\r\n    float camera_yaw = 0.;\r\n    fd = 0.763;\r\n    fu = 10.0;\r\n    fs = 1.0;\r\n    fc = vec3(0);\r\n    ff = -0.50000;\r\n    cs = vec3(0.80800,0.80800,1.16700);\r\n    float gamma_correction = 1.00000;    \r\n    //float temp_scenetimer = clamp(current_scene_timer,0.0,100.0);\r\n    float temp_scenetimer = iTime;\r\n    int temp_scene_number = int(iTime / 10.0) + 1;\r\n    vec2 custom_glFragCoord = fragCoord.xy;    \r\n    float noise = 1.0;//fract(sin(dot(custom_glFragCoord.xy ,vec2(12.9898,78.233))) * 43758.5453+(temp_scenetimer*0.25))*(sin(temp_scenetimer+custom_glFragCoord.y)*2.0+4.0); \r\n    if (temp_scene_number>=1) {\r\n       if (noise>temp_scenetimer) {\r\n          temp_scenetimer = 0.0;\r\n          temp_scene_number = temp_scene_number-1;\r\n       }\r\n    }  \r\n    //#define scene_fadein 0 \r\n    if (temp_scene_number==0) {\r\n       gamma_correction = clamp(temp_scenetimer*0.055,0.0,1.0);\r\n       camera_pitch = 23.9;\r\n       cp = vec3(0.8,-1.16339+16.0-temp_scenetimer*0.095,-1.80153);\r\n       cs.y = 0.58000;\r\n    }\r\n    //#define scene_wires_sidescroller 1\r\n    if (temp_scene_number==1) {\r\n       cp = vec3(0.7212+temp_scenetimer*0.00068,0.10000,-2.35000);\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_wires_insidescroller 2\r\n    if (temp_scene_number==2) {\r\n       cp = vec3(0.7+(-0.0092+temp_scenetimer*0.000180),0.1,-2.3495);\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_grid_hallofharad 3\r\n    if (temp_scene_number==3) {\r\n       fu = 1.01000;\r\n       cp = vec3(temp_scenetimer*0.05,0.02000,2.00000-100.0*0.1);\r\n       cs.x = 0.90000;\r\n    }\r\n    //#define scene_grid_sideoverview 4\r\n    if (temp_scene_number==4) {\r\n       fu = 1.01000;\r\n       cp = vec3(0.0007,0.02000,0.10000-temp_scenetimer*0.00028);\r\n       camera_pitch = 0.0;\r\n       camera_yaw = temp_scenetimer*0.009*180.0;\r\n       cs.x = 0.90000;\r\n    }\r\n    //#define scene_spike_verticalcore 5    \r\n    if (temp_scene_number==5) {\r\n       fu = 0.9;\r\n       cp = vec3(0.0+temp_scenetimer*0.00025,1.40000+0.004,-2.38200+(-0.05+temp_scenetimer*0.002));\r\n    }\r\n    //#define scene_spike_introduction 6  \r\n    if (temp_scene_number==6) {  \r\n       cp = vec3(1.18000,0.08000+temp_scenetimer*0.000055,-0.24000);\r\n       camera_pitch = 120.0;\r\n       cs = vec3(0.50000,0.50000,1.04000);\r\n    }\r\n    //#define scene_spike_wiredballsvertical 7   \r\n    if (temp_scene_number==7) {\r\n       fd = 0.70000;\r\n       fs = 1.34000;\r\n       cp = vec3(0.69+(-0.0092+temp_scenetimer*0.0008),0.1,-2.3495);\r\n       camera_pitch = 130.0+sin(temp_scenetimer*0.075)*50.0;\r\n       camera_roll = 90.0;\r\n       cs.xy = vec2(0.50000);\r\n    }\r\n    //#define scene_alien_backbone 8\r\n    if (temp_scene_number==8) {\r\n       cp = vec3(0.0,-0.86000+temp_scenetimer*0.0003,0.30000);\r\n       camera_pitch = 80.0+(temp_scenetimer*0.65);     \r\n       fc.z = -0.38000;\r\n    }    \r\n    float brightness = 0.0;\r\n    //#define scene_alien_reactorcore 9\r\n    if (temp_scene_number==9) {\r\n       gamma_correction = clamp(temp_scenetimer*0.025,1.0,100.0);\r\n       fu = 1.20000;\r\n       cp = vec3(0.00,1.40000+(-0.020+temp_scenetimer*0.0018),-2.34100);\r\n       fc.z = 0.25840;\r\n       ff =  clamp(temp_scenetimer*0.05,3.6,100.0);\r\n       brightness = clamp((temp_scenetimer-35.0)*0.005,0.0,1.0);       \r\n    }\r\n    cr = mr(vec3(0, 1, 0), 180.0 - camera_yaw) * mr(vec3(1, 0, 0), -camera_pitch) * mr(vec3(0, 0, 1), camera_roll);    \r\n    //super sampling support\r\n    vec4 color = vec4(0.0);\r\n#define antialiasing 0.5       \r\n#ifdef antialiasing\r\n    float n = 0.0;\r\n    for (float x = 0.0; x < 1.0; x += float(antialiasing)) {\r\n        for (float y = 0.0; y < 1.0; y += float(antialiasing)) {\r\n            color += rd(custom_glFragCoord.xy + vec2(x, y));\r\n            n += 1.0;\r\n        }\r\n    }\r\n    color /= n;\r\n#else\r\n    color = rd(custom_glFragCoord.xy);\r\n#endif    \r\n    //output\r\n    fragColor = vec4(pow(color.rgb+brightness, vec3(1.0 / gamma_correction)), color.a);\r\n} ","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n\r\nHead\r\n----\r\n\r\nThis was painstakingly hand modeled by 'tracing' a polygonal model\r\nexported from Daz 3D.\r\n\r\nThe initial approach is to smooth blend small ellipses with a large\r\nblend radius, a technique I took from Ink Drawing by lnae\r\n(https://www.shadertoy.com/view/MltcDB)\r\n\r\nThe brow and jawline are formed by blending planes and spheres.\r\nThe nose is, of course, a few capsules.\r\nThe ears are various extruded and warped 2D layers, they were by\r\nfar the hardest part.\r\n\r\nI encourage you to comment parts out and see how it all adds up.\r\n\r\nUses a few primitives and tools from HG_SDF and IQ.\r\n\r\nApologies for the boring shading, you can see some more interesting\r\napplications in the GIF and 4K that this was created for:\r\n\r\n* Fractal Polycephaly https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/giphy.gif\r\n* \u1D07 s \u1D04 \u029C \u1D07 \u0280 \u1D21 \u1D00 \u1D20 \u1D07 https://www.shadertoy.com/view/wtf3RM\r\n\r\n\r\nLicense: Creative Commons Attribution-NonCommercial\r\nhttps://creativecommons.org/licenses/by-nc/4.0/\r\n\r\n*/\r\n\r\n#define PI 3.14159265359\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pRi(vec2 p, float a) {\r\n    pR(p, a);\r\n    return p;\r\n}\r\n\r\n#define saturate(x) clamp(x, 0., 1.)\r\n\r\nfloat vmax(vec2 v) {\r\n    return max(v.x, v.y);\r\n}\r\n\r\nfloat vmax(vec3 v) {\r\n    return max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec3 v) {\r\n    return min(min(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec2 v) {\r\n    return min(v.x, v.y);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nfloat fCorner2(vec2 p) {\r\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\r\n}\r\n\r\nfloat fDisc(vec3 p, float r) {\r\n    float l = length(p.xz) - r;\r\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\r\n}\r\n\r\n\r\nfloat fHalfCapsule(vec3 p, float r) {\r\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\r\n}\r\n\r\n\r\n// IQ https://www.shadertoy.com/view/Xds3zN\r\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\r\n{\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    \r\n    float b = (r1-r2)/h;\r\n    float a = sqrt(1.0-b*b);\r\n    float k = dot(q,vec2(-b,a));\r\n    \r\n    if( k < 0.0 ) return length(q) - r1;\r\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\r\n        \r\n    return dot(q, vec2(a,b) ) - r1;\r\n}\r\n\r\nfloat smin2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\r\n    return max(r, min (a, b)) - length(u);\r\n}\r\n\r\nfloat smax2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\r\n    return min(-r, max (a, b)) + length(u);\r\n}\r\n\r\nfloat smin(float a, float b, float k){\r\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\r\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\r\n}\r\n\r\nfloat smax(float a, float b, float k) {\r\n    return -smin(-a, -b, k);\r\n}\r\n\r\nfloat smin3(float a, float b, float k){\r\n    return min(\r\n        smin(a, b, k),\r\n        smin2(a, b, k)\r\n    );\r\n}\r\n\r\nfloat smax3(float a, float b, float k){\r\n    return max(\r\n        smax(a, b, k),\r\n        smax2(a, b, k)\r\n    );\r\n}\r\n\r\n\r\nfloat ellip(vec3 p, vec3 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ellip(vec2 p, vec2 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nbool isEye = false;\r\n\r\n\r\nfloat mHead(vec3 p) {\r\n\r\n    pR(p.yz, -.1);\r\n    p.y -= .11;\r\n\r\n    vec3 pa = p;\r\n    p.x = abs(p.x);\r\n    vec3 pp = p;\r\n\r\n    float d = 1e12;\r\n\r\n    // skull back\r\n    p += vec3(0,-.135,.09);\r\n    d = ellip(p, vec3(.395, .385, .395));\r\n\r\n    // skull base\r\n    p = pp;\r\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\r\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\r\n\r\n    // forehead\r\n    p = pp;\r\n    p += vec3(0,-.145,-.175);\r\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\r\n\r\n    p = pp;\r\n    pR(p.yz, -.5);\r\n    float bb = fBox(p, vec3(.5,.67,.7));\r\n    d = smax(d, bb, .2);\r\n\r\n    // face base\r\n    p = pp;\r\n    p += vec3(0,.25,-.13);\r\n    d = smin(d, length(p) - .28, .1);\r\n\r\n    // behind ear\r\n    p = pp;\r\n    p += vec3(-.15,.13,.06);\r\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\r\n\r\n    p = pp;\r\n    p += vec3(-.07,.18,.1);\r\n    d = smin(d, length(p) - .2, .18);\r\n\r\n    // cheek base\r\n    p = pp;\r\n    p += vec3(-.2,.12,-.14);\r\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\r\n\r\n    // jaw base\r\n    p = pp;\r\n    p += vec3(0,.475,-.16);\r\n    pR(p.yz, .8);\r\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\r\n    \r\n    // brow\r\n    p = pp;\r\n    p += vec3(0,-.0,-.18);\r\n    vec3 bp = p;\r\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\r\n    brow = length(p) - .36;\r\n    p.x -= .37;\r\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\r\n    p = bp;\r\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\r\n    p = bp;\r\n    pR(p.yz, -.5);\r\n    float peak = -p.y - .165;\r\n    peak += smoothstep(.0, .2, p.x) * .01;\r\n    peak -= smoothstep(.12, .29, p.x) * .025;\r\n    brow = smax(brow, peak, .07);\r\n    p = bp;\r\n    pR(p.yz, .5);\r\n    brow = smax(brow, -p.y - .06, .15);\r\n    d = smin(d, brow, .06);\r\n\r\n    // nose\r\n    p = pp;\r\n    p += vec3(0,.03,-.45);\r\n    pR(p.yz, 3.);\r\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\r\n\r\n    p = pp;\r\n    p += vec3(0,.06,-.47);\r\n    pR(p.yz, 2.77);\r\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\r\n\r\n    // jaw\r\n\r\n    p = pp;\r\n    vec3 jo = vec3(-.25,.4,-.07);\r\n    p = pp + jo;\r\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\r\n\r\n    p = pp;\r\n    p += vec3(0,.63,-.2);\r\n    pR(p.yz, .15);\r\n    float cr = .5;\r\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\r\n\r\n    p = pp + jo;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\r\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\r\n\r\n    p = pa;\r\n    p += vec3(.2,.5,-.1);\r\n    float jb = length(p);\r\n    jb = smoothstep(.0, .4, jb);\r\n    float js = mix(0., -.005, jb);\r\n    jb = mix(.01, .04, jb);\r\n\r\n    d = smin(d, jaw - js, jb);\r\n\r\n    // chin\r\n    p = pp;\r\n    p += vec3(0,.585,-.395);\r\n    p.x *= .7;\r\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\r\n\r\n    // cheek\r\n\r\n    p = pp;\r\n    p += vec3(-.2,.2,-.28);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, .4);\r\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.26,.02,-.1);\r\n    pR(p.xz, .13);\r\n    pR(p.yz, .5);\r\n    float temple = ellip(p, vec3(.1,.1,.15));\r\n    temple = smax(temple, p.x - .07, .1);\r\n    d = smin(d, temple, .1);\r\n\r\n    p = pp;\r\n    p += vec3(.0,.2,-.32);\r\n    ch = ellip(p, vec3(.1,.08,.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.17,.31,-.17);\r\n    ch = ellip(p, vec3(.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    // mouth base\r\n    p = pp;\r\n    p += vec3(-.0,.29,-.29);\r\n    pR(p.yz, -.3);\r\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\r\n\r\n    p = pp;\r\n    p += vec3(0,.37,-.4);\r\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.09,.37,-.31);\r\n    d = smin(d, ellip(p, vec3(.04)), .18);\r\n\r\n    // bottom lip\r\n    p = pp;\r\n    p += vec3(0,.455,-.455);\r\n    p.z += smoothstep(.0, .2, p.x) * .05;\r\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\r\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\r\n    float w = .192;\r\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\r\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\r\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\r\n    d = smin(d, bottomlip, lb);\r\n    \r\n    // top lip\r\n    p = pp;\r\n    p += vec3(0,.38,-.45);\r\n    pR(p.xz, -.3);\r\n    ls = vec3(.065,.03,.05);\r\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\r\n    vec3 pl = p * vec3(.78,1,1);\r\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\r\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\r\n    p = pp;\r\n    p += vec3(0,.33,-.45);\r\n    pR(p.yz, .7);\r\n    float cut;\r\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\r\n    float dip = smin(\r\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\r\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\r\n        .025\r\n    );\r\n    cut = smax(cut, dip, .04);\r\n    cut = smax(cut, p.x - .1, .05);\r\n    toplip = smax(toplip, cut, .02);\r\n\r\n    d = smin(d, toplip, .07);\r\n\r\n    // seam\r\n    p = pp;\r\n    p += vec3(0,.425,-.44);\r\n    lb = length(p);\r\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\r\n    pR(p.yz, .1);\r\n    p.y -= smoothstep(0., .03, p.x) * .002;\r\n    p.y += smoothstep(.03, .1, p.x) * .007;\r\n    p.z -= .133;\r\n    float seam = fDisc(p, .2);\r\n    seam = smax(seam, -d - .015, .01); // fix inside shape\r\n    d = mix(d, smax(d, -seam, lr), .65);\r\n\r\n    // nostrils base\r\n    p = pp;\r\n    p += vec3(0,.3,-.43);\r\n    d = smin(d, length(p) - .05, .07);\r\n\r\n    // nostrils\r\n    p = pp;\r\n    p += vec3(0,.27,-.52);\r\n    pR(p.yz, .2);\r\n    float nostrils = ellip(p, vec3(.055,.05,.06));\r\n\r\n    p = pp;\r\n    p += vec3(-.043,.28,-.48);\r\n    pR(p.xy, .15);\r\n    p.z *= .8;\r\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\r\n\r\n    d = smin(d, nostrils, .02);\r\n\r\n    p = pp;\r\n    p += vec3(-.033,.3,-.515);\r\n    pR(p.xz, .5);\r\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\r\n\r\n    // return d;\r\n\r\n    // eyelids\r\n    p = pp;\r\n    p += vec3(-.16,.07,-.34);\r\n    float eyelids = ellip(p, vec3(.08,.1,.1));\r\n\r\n    p = pp;\r\n    p += vec3(-.16,.09,-.35);\r\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\r\n\r\n    // edge top\r\n    p = pp;\r\n    p += vec3(-.173,.148,-.43);\r\n    p.x *= .97;\r\n    float et = length(p.xy) - .09;\r\n\r\n    // edge bottom\r\n    p = pp;\r\n    p += vec3(-.168,.105,-.43);\r\n    p.x *= .9;\r\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\r\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\r\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\r\n\r\n    float edge = max(max(eb, et), -d);\r\n\r\n    d = smin(d, eyelids, .01);\r\n    d = smin(d, eyelids2, .03);\r\n    d = smax(d, -edge, .005);\r\n\r\n    // eyeball\r\n    p = pp;\r\n    p += vec3(-.165,.0715,-.346);\r\n    float eyeball = length(p) - .088;\r\n\tisEye = eyeball < d;\r\n    d = min(d, eyeball);\r\n\r\n    // tear duct\r\n    p = pp;\r\n    p += vec3(-.075,.1,-.37);\r\n    d = min(d, length(p) - .05);\r\n\r\n    \r\n \t// ear\r\n    p = pp;\r\n    p += vec3(-.405,.12,.10);\r\n    pR(p.xy, -.12);\r\n    pR(p.xz, .35);\r\n    pR(p.yz, -.3);\r\n    vec3 pe = p;\r\n\r\n    // base\r\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\r\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\r\n\r\n    // inner\r\n    pR(p.xz, -.5);\r\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\r\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\r\n    float ridge = iear;\r\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\r\n    ear = smax2(ear, -iear, .04);\r\n    earback = smin(earback, iear - .04, .02);\r\n\r\n    // ridge\r\n    p = pe;\r\n    pR(p.xz, .2);\r\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\r\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\r\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\r\n\r\n    float ridger = .01;\r\n\r\n    ridge = max(-ridge, ridge - ridger);\r\n\r\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\r\n\r\n    ear = smin(ear, ridge, .045);\r\n\r\n    p = pe;\r\n\r\n    // outline\r\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\r\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\r\n\r\n    // edge\r\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\r\n\r\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\r\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\r\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\r\n    edgeo = smax(edgeo, -edgeoin, .05);\r\n\r\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\r\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\r\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\r\n    eedent = min(eedent, 1.);\r\n\r\n    eedge += eedent * .06;\r\n\r\n    eedge = smax(eedge, -edgeo, .01);\r\n    ear = smin(ear, eedge, .01);\r\n    ear = max(ear, earback);\r\n\r\n    ear = smax2(ear, outline, .015);\r\n\r\n    d = smin(d, ear, .015);\r\n\r\n    // targus\r\n    p = pp;\r\n    p += vec3(-.34,.2,.02);\r\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\r\n    p = pp;\r\n    p += vec3(-.37,.18,.03);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, -.4);\r\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\r\n    \r\n    return d;\r\n}\r\n\r\nfloat sstep(float t) {\r\n\treturn sin(t * PI - PI / 2.) * .5 + .5;\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    \r\n    float scale = 1.;\r\n    float s = .2;\r\n    float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.;\r\n    float rx = sin(iTime * .33) * .2;\r\n\r\n    if (iMouse.z > 0. && iMouse.w > 0.) {\r\n        ry = (.5 - iMouse.x / iResolution.x) * PI * 2.;\r\n    \trx = (.5 - iMouse.y / iResolution.y) * PI / 2.;\r\n        scale = 2.;\r\n    }\r\n    \r\n    pR(p.yz, rx);\r\n    pR(p.xz, ry);\r\n    \r\n    p /= scale;\r\n   \treturn mHead(p) * scale;\r\n}\r\n\r\nconst int NORMAL_STEPS = 6;\r\nvec3 calcNormal(vec3 pos){\r\n    vec3 eps = vec3(.0005,0,0);\r\n    vec3 nor = vec3(0);\r\n    float invert = 1.;\r\n    for (int i = 0; i < NORMAL_STEPS; i++){\r\n        nor += map(pos + eps * invert) * eps * invert;\r\n        eps = eps.zxy;\r\n        invert *= -1.;\r\n    }\r\n    return normalize(nor);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\r\n    \r\n    vec3 camPos = vec3(0,0,3.2);\r\n    vec3 rayDirection = normalize(vec3(p,-4));\r\n    \r\n    vec3 rayPosition = camPos;\r\n    float rayLength = 0.;\r\n    float dist = 0.;\r\n    bool bg = false;\r\n    vec3 col = vec3(.1);\r\n\r\n    for (int i = 0; i < 150; i++) {\r\n        rayLength += dist;\r\n        rayPosition = camPos + rayDirection * rayLength;\r\n        dist = map(rayPosition);\r\n\r\n        if (abs(dist) < .001) {\r\n        \tbreak;\r\n        }\r\n        \r\n        if (rayLength > 5.) {\r\n            bg = true;\r\n            break;\r\n        }\r\n    }\r\n    \r\n    if ( ! bg) {\r\n        vec3 albedo = isEye ? vec3(2) : vec3(1);\r\n        vec3 n = calcNormal(rayPosition);\r\n        vec3 lp = vec3(-.5,.5,.5);\r\n        float l = max(dot(lp, n), 0.);\r\n        vec3 ld = normalize(lp - rayPosition);\r\n        l += .02;\r\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\r\n        col = albedo * l;\r\n        col = pow(col, vec3(1./2.2));\r\n    }\r\n\r\n    fragColor = vec4(col,1);\r\n}\r\n","inputs":[],"outputs":[],"code":"/*\r\n\r\nHead\r\n----\r\n\r\nThis was painstakingly hand modeled by 'tracing' a polygonal model\r\nexported from Daz 3D.\r\n\r\nThe initial approach is to smooth blend small ellipses with a large\r\nblend radius, a technique I took from Ink Drawing by lnae\r\n(https://www.shadertoy.com/view/MltcDB)\r\n\r\nThe brow and jawline are formed by blending planes and spheres.\r\nThe nose is, of course, a few capsules.\r\nThe ears are various extruded and warped 2D layers, they were by\r\nfar the hardest part.\r\n\r\nI encourage you to comment parts out and see how it all adds up.\r\n\r\nUses a few primitives and tools from HG_SDF and IQ.\r\n\r\nApologies for the boring shading, you can see some more interesting\r\napplications in the GIF and 4K that this was created for:\r\n\r\n* Fractal Polycephaly https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/giphy.gif\r\n* \u1D07 s \u1D04 \u029C \u1D07 \u0280 \u1D21 \u1D00 \u1D20 \u1D07 https://www.shadertoy.com/view/wtf3RM\r\n\r\n\r\nLicense: Creative Commons Attribution-NonCommercial\r\nhttps://creativecommons.org/licenses/by-nc/4.0/\r\n\r\n*/\r\n\r\n#define PI 3.14159265359\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pRi(vec2 p, float a) {\r\n    pR(p, a);\r\n    return p;\r\n}\r\n\r\n#define saturate(x) clamp(x, 0., 1.)\r\n\r\nfloat vmax(vec2 v) {\r\n    return max(v.x, v.y);\r\n}\r\n\r\nfloat vmax(vec3 v) {\r\n    return max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec3 v) {\r\n    return min(min(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec2 v) {\r\n    return min(v.x, v.y);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nfloat fCorner2(vec2 p) {\r\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\r\n}\r\n\r\nfloat fDisc(vec3 p, float r) {\r\n    float l = length(p.xz) - r;\r\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\r\n}\r\n\r\n\r\nfloat fHalfCapsule(vec3 p, float r) {\r\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\r\n}\r\n\r\n\r\n// IQ https://www.shadertoy.com/view/Xds3zN\r\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\r\n{\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    \r\n    float b = (r1-r2)/h;\r\n    float a = sqrt(1.0-b*b);\r\n    float k = dot(q,vec2(-b,a));\r\n    \r\n    if( k < 0.0 ) return length(q) - r1;\r\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\r\n        \r\n    return dot(q, vec2(a,b) ) - r1;\r\n}\r\n\r\nfloat smin2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\r\n    return max(r, min (a, b)) - length(u);\r\n}\r\n\r\nfloat smax2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\r\n    return min(-r, max (a, b)) + length(u);\r\n}\r\n\r\nfloat smin(float a, float b, float k){\r\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\r\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\r\n}\r\n\r\nfloat smax(float a, float b, float k) {\r\n    return -smin(-a, -b, k);\r\n}\r\n\r\nfloat smin3(float a, float b, float k){\r\n    return min(\r\n        smin(a, b, k),\r\n        smin2(a, b, k)\r\n    );\r\n}\r\n\r\nfloat smax3(float a, float b, float k){\r\n    return max(\r\n        smax(a, b, k),\r\n        smax2(a, b, k)\r\n    );\r\n}\r\n\r\n\r\nfloat ellip(vec3 p, vec3 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ellip(vec2 p, vec2 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nbool isEye = false;\r\n\r\n\r\nfloat mHead(vec3 p) {\r\n\r\n    pR(p.yz, -.1);\r\n    p.y -= .11;\r\n\r\n    vec3 pa = p;\r\n    p.x = abs(p.x);\r\n    vec3 pp = p;\r\n\r\n    float d = 1e12;\r\n\r\n    // skull back\r\n    p += vec3(0,-.135,.09);\r\n    d = ellip(p, vec3(.395, .385, .395));\r\n\r\n    // skull base\r\n    p = pp;\r\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\r\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\r\n\r\n    // forehead\r\n    p = pp;\r\n    p += vec3(0,-.145,-.175);\r\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\r\n\r\n    p = pp;\r\n    pR(p.yz, -.5);\r\n    float bb = fBox(p, vec3(.5,.67,.7));\r\n    d = smax(d, bb, .2);\r\n\r\n    // face base\r\n    p = pp;\r\n    p += vec3(0,.25,-.13);\r\n    d = smin(d, length(p) - .28, .1);\r\n\r\n    // behind ear\r\n    p = pp;\r\n    p += vec3(-.15,.13,.06);\r\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\r\n\r\n    p = pp;\r\n    p += vec3(-.07,.18,.1);\r\n    d = smin(d, length(p) - .2, .18);\r\n\r\n    // cheek base\r\n    p = pp;\r\n    p += vec3(-.2,.12,-.14);\r\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\r\n\r\n    // jaw base\r\n    p = pp;\r\n    p += vec3(0,.475,-.16);\r\n    pR(p.yz, .8);\r\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\r\n    \r\n    // brow\r\n    p = pp;\r\n    p += vec3(0,-.0,-.18);\r\n    vec3 bp = p;\r\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\r\n    brow = length(p) - .36;\r\n    p.x -= .37;\r\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\r\n    p = bp;\r\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\r\n    p = bp;\r\n    pR(p.yz, -.5);\r\n    float peak = -p.y - .165;\r\n    peak += smoothstep(.0, .2, p.x) * .01;\r\n    peak -= smoothstep(.12, .29, p.x) * .025;\r\n    brow = smax(brow, peak, .07);\r\n    p = bp;\r\n    pR(p.yz, .5);\r\n    brow = smax(brow, -p.y - .06, .15);\r\n    d = smin(d, brow, .06);\r\n\r\n    // nose\r\n    p = pp;\r\n    p += vec3(0,.03,-.45);\r\n    pR(p.yz, 3.);\r\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\r\n\r\n    p = pp;\r\n    p += vec3(0,.06,-.47);\r\n    pR(p.yz, 2.77);\r\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\r\n\r\n    // jaw\r\n\r\n    p = pp;\r\n    vec3 jo = vec3(-.25,.4,-.07);\r\n    p = pp + jo;\r\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\r\n\r\n    p = pp;\r\n    p += vec3(0,.63,-.2);\r\n    pR(p.yz, .15);\r\n    float cr = .5;\r\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\r\n\r\n    p = pp + jo;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\r\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\r\n\r\n    p = pa;\r\n    p += vec3(.2,.5,-.1);\r\n    float jb = length(p);\r\n    jb = smoothstep(.0, .4, jb);\r\n    float js = mix(0., -.005, jb);\r\n    jb = mix(.01, .04, jb);\r\n\r\n    d = smin(d, jaw - js, jb);\r\n\r\n    // chin\r\n    p = pp;\r\n    p += vec3(0,.585,-.395);\r\n    p.x *= .7;\r\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\r\n\r\n    // cheek\r\n\r\n    p = pp;\r\n    p += vec3(-.2,.2,-.28);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, .4);\r\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.26,.02,-.1);\r\n    pR(p.xz, .13);\r\n    pR(p.yz, .5);\r\n    float temple = ellip(p, vec3(.1,.1,.15));\r\n    temple = smax(temple, p.x - .07, .1);\r\n    d = smin(d, temple, .1);\r\n\r\n    p = pp;\r\n    p += vec3(.0,.2,-.32);\r\n    ch = ellip(p, vec3(.1,.08,.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.17,.31,-.17);\r\n    ch = ellip(p, vec3(.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    // mouth base\r\n    p = pp;\r\n    p += vec3(-.0,.29,-.29);\r\n    pR(p.yz, -.3);\r\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\r\n\r\n    p = pp;\r\n    p += vec3(0,.37,-.4);\r\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.09,.37,-.31);\r\n    d = smin(d, ellip(p, vec3(.04)), .18);\r\n\r\n    // bottom lip\r\n    p = pp;\r\n    p += vec3(0,.455,-.455);\r\n    p.z += smoothstep(.0, .2, p.x) * .05;\r\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\r\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\r\n    float w = .192;\r\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\r\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\r\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\r\n    d = smin(d, bottomlip, lb);\r\n    \r\n    // top lip\r\n    p = pp;\r\n    p += vec3(0,.38,-.45);\r\n    pR(p.xz, -.3);\r\n    ls = vec3(.065,.03,.05);\r\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\r\n    vec3 pl = p * vec3(.78,1,1);\r\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\r\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\r\n    p = pp;\r\n    p += vec3(0,.33,-.45);\r\n    pR(p.yz, .7);\r\n    float cut;\r\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\r\n    float dip = smin(\r\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\r\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\r\n        .025\r\n    );\r\n    cut = smax(cut, dip, .04);\r\n    cut = smax(cut, p.x - .1, .05);\r\n    toplip = smax(toplip, cut, .02);\r\n\r\n    d = smin(d, toplip, .07);\r\n\r\n    // seam\r\n    p = pp;\r\n    p += vec3(0,.425,-.44);\r\n    lb = length(p);\r\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\r\n    pR(p.yz, .1);\r\n    p.y -= smoothstep(0., .03, p.x) * .002;\r\n    p.y += smoothstep(.03, .1, p.x) * .007;\r\n    p.z -= .133;\r\n    float seam = fDisc(p, .2);\r\n    seam = smax(seam, -d - .015, .01); // fix inside shape\r\n    d = mix(d, smax(d, -seam, lr), .65);\r\n\r\n    // nostrils base\r\n    p = pp;\r\n    p += vec3(0,.3,-.43);\r\n    d = smin(d, length(p) - .05, .07);\r\n\r\n    // nostrils\r\n    p = pp;\r\n    p += vec3(0,.27,-.52);\r\n    pR(p.yz, .2);\r\n    float nostrils = ellip(p, vec3(.055,.05,.06));\r\n\r\n    p = pp;\r\n    p += vec3(-.043,.28,-.48);\r\n    pR(p.xy, .15);\r\n    p.z *= .8;\r\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\r\n\r\n    d = smin(d, nostrils, .02);\r\n\r\n    p = pp;\r\n    p += vec3(-.033,.3,-.515);\r\n    pR(p.xz, .5);\r\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\r\n\r\n    // return d;\r\n\r\n    // eyelids\r\n    p = pp;\r\n    p += vec3(-.16,.07,-.34);\r\n    float eyelids = ellip(p, vec3(.08,.1,.1));\r\n\r\n    p = pp;\r\n    p += vec3(-.16,.09,-.35);\r\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\r\n\r\n    // edge top\r\n    p = pp;\r\n    p += vec3(-.173,.148,-.43);\r\n    p.x *= .97;\r\n    float et = length(p.xy) - .09;\r\n\r\n    // edge bottom\r\n    p = pp;\r\n    p += vec3(-.168,.105,-.43);\r\n    p.x *= .9;\r\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\r\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\r\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\r\n\r\n    float edge = max(max(eb, et), -d);\r\n\r\n    d = smin(d, eyelids, .01);\r\n    d = smin(d, eyelids2, .03);\r\n    d = smax(d, -edge, .005);\r\n\r\n    // eyeball\r\n    p = pp;\r\n    p += vec3(-.165,.0715,-.346);\r\n    float eyeball = length(p) - .088;\r\n\tisEye = eyeball < d;\r\n    d = min(d, eyeball);\r\n\r\n    // tear duct\r\n    p = pp;\r\n    p += vec3(-.075,.1,-.37);\r\n    d = min(d, length(p) - .05);\r\n\r\n    \r\n \t// ear\r\n    p = pp;\r\n    p += vec3(-.405,.12,.10);\r\n    pR(p.xy, -.12);\r\n    pR(p.xz, .35);\r\n    pR(p.yz, -.3);\r\n    vec3 pe = p;\r\n\r\n    // base\r\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\r\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\r\n\r\n    // inner\r\n    pR(p.xz, -.5);\r\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\r\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\r\n    float ridge = iear;\r\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\r\n    ear = smax2(ear, -iear, .04);\r\n    earback = smin(earback, iear - .04, .02);\r\n\r\n    // ridge\r\n    p = pe;\r\n    pR(p.xz, .2);\r\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\r\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\r\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\r\n\r\n    float ridger = .01;\r\n\r\n    ridge = max(-ridge, ridge - ridger);\r\n\r\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\r\n\r\n    ear = smin(ear, ridge, .045);\r\n\r\n    p = pe;\r\n\r\n    // outline\r\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\r\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\r\n\r\n    // edge\r\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\r\n\r\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\r\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\r\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\r\n    edgeo = smax(edgeo, -edgeoin, .05);\r\n\r\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\r\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\r\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\r\n    eedent = min(eedent, 1.);\r\n\r\n    eedge += eedent * .06;\r\n\r\n    eedge = smax(eedge, -edgeo, .01);\r\n    ear = smin(ear, eedge, .01);\r\n    ear = max(ear, earback);\r\n\r\n    ear = smax2(ear, outline, .015);\r\n\r\n    d = smin(d, ear, .015);\r\n\r\n    // targus\r\n    p = pp;\r\n    p += vec3(-.34,.2,.02);\r\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\r\n    p = pp;\r\n    p += vec3(-.37,.18,.03);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, -.4);\r\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\r\n    \r\n    return d;\r\n}\r\n\r\nfloat sstep(float t) {\r\n\treturn sin(t * PI - PI / 2.) * .5 + .5;\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    \r\n    float scale = 1.;\r\n    float s = .2;\r\n    float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.;\r\n    float rx = sin(iTime * .33) * .2;\r\n\r\n    if (iMouse.z > 0. && iMouse.w > 0.) {\r\n        ry = (.5 - iMouse.x / iResolution.x) * PI * 2.;\r\n    \trx = (.5 - iMouse.y / iResolution.y) * PI / 2.;\r\n        scale = 2.;\r\n    }\r\n    \r\n    pR(p.yz, rx);\r\n    pR(p.xz, ry);\r\n    \r\n    p /= scale;\r\n   \treturn mHead(p) * scale;\r\n}\r\n\r\nconst int NORMAL_STEPS = 6;\r\nvec3 calcNormal(vec3 pos){\r\n    vec3 eps = vec3(.0005,0,0);\r\n    vec3 nor = vec3(0);\r\n    float invert = 1.;\r\n    for (int i = 0; i < NORMAL_STEPS; i++){\r\n        nor += map(pos + eps * invert) * eps * invert;\r\n        eps = eps.zxy;\r\n        invert *= -1.;\r\n    }\r\n    return normalize(nor);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\r\n    \r\n    vec3 camPos = vec3(0,0,3.2);\r\n    vec3 rayDirection = normalize(vec3(p,-4));\r\n    \r\n    vec3 rayPosition = camPos;\r\n    float rayLength = 0.;\r\n    float dist = 0.;\r\n    bool bg = false;\r\n    vec3 col = vec3(.1);\r\n\r\n    for (int i = 0; i < 150; i++) {\r\n        rayLength += dist;\r\n        rayPosition = camPos + rayDirection * rayLength;\r\n        dist = map(rayPosition);\r\n\r\n        if (abs(dist) < .001) {\r\n        \tbreak;\r\n        }\r\n        \r\n        if (rayLength > 5.) {\r\n            bg = true;\r\n            break;\r\n        }\r\n    }\r\n    \r\n    if ( ! bg) {\r\n        vec3 albedo = isEye ? vec3(2) : vec3(1);\r\n        vec3 n = calcNormal(rayPosition);\r\n        vec3 lp = vec3(-.5,.5,.5);\r\n        float l = max(dot(lp, n), 0.);\r\n        vec3 ld = normalize(lp - rayPosition);\r\n        l += .02;\r\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\r\n        col = albedo * l;\r\n        col = pow(col, vec3(1./2.2));\r\n    }\r\n\r\n    fragColor = vec4(col,1);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Head","id":"29b838abc9ab44efa3df25e8b68eb1e4","date":null,"viewed":0,"name":"Head","description":"Just the head from my 4k and animated gif, including the ears this time.\nClick for a close up view.\nhttps://www.shadertoy.com/view/wlf3WX","likes":0,"published":null,"tags":["head"," human"," anatomy"]},"ver":null,"info":{"Name":"Head","id":"29b838abc9ab44efa3df25e8b68eb1e4","date":null,"viewed":0,"name":"Head","description":"Just the head from my 4k and animated gif, including the ears this time.\nClick for a close up view.\nhttps://www.shadertoy.com/view/wlf3WX","likes":0,"published":null,"tags":["head"," human"," anatomy"]},"renderpass":[{"Code":"/*\r\n\r\nHead\r\n----\r\n\r\nThis was painstakingly hand modeled by 'tracing' a polygonal model\r\nexported from Daz 3D.\r\n\r\nThe initial approach is to smooth blend small ellipses with a large\r\nblend radius, a technique I took from Ink Drawing by lnae\r\n(https://www.shadertoy.com/view/MltcDB)\r\n\r\nThe brow and jawline are formed by blending planes and spheres.\r\nThe nose is, of course, a few capsules.\r\nThe ears are various extruded and warped 2D layers, they were by\r\nfar the hardest part.\r\n\r\nI encourage you to comment parts out and see how it all adds up.\r\n\r\nUses a few primitives and tools from HG_SDF and IQ.\r\n\r\nApologies for the boring shading, you can see some more interesting\r\napplications in the GIF and 4K that this was created for:\r\n\r\n* Fractal Polycephaly https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/giphy.gif\r\n* \u1D07 s \u1D04 \u029C \u1D07 \u0280 \u1D21 \u1D00 \u1D20 \u1D07 https://www.shadertoy.com/view/wtf3RM\r\n\r\n\r\nLicense: Creative Commons Attribution-NonCommercial\r\nhttps://creativecommons.org/licenses/by-nc/4.0/\r\n\r\n*/\r\n\r\n#define PI 3.14159265359\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pRi(vec2 p, float a) {\r\n    pR(p, a);\r\n    return p;\r\n}\r\n\r\n#define saturate(x) clamp(x, 0., 1.)\r\n\r\nfloat vmax(vec2 v) {\r\n    return max(v.x, v.y);\r\n}\r\n\r\nfloat vmax(vec3 v) {\r\n    return max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec3 v) {\r\n    return min(min(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec2 v) {\r\n    return min(v.x, v.y);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nfloat fCorner2(vec2 p) {\r\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\r\n}\r\n\r\nfloat fDisc(vec3 p, float r) {\r\n    float l = length(p.xz) - r;\r\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\r\n}\r\n\r\n\r\nfloat fHalfCapsule(vec3 p, float r) {\r\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\r\n}\r\n\r\n\r\n// IQ https://www.shadertoy.com/view/Xds3zN\r\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\r\n{\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    \r\n    float b = (r1-r2)/h;\r\n    float a = sqrt(1.0-b*b);\r\n    float k = dot(q,vec2(-b,a));\r\n    \r\n    if( k < 0.0 ) return length(q) - r1;\r\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\r\n        \r\n    return dot(q, vec2(a,b) ) - r1;\r\n}\r\n\r\nfloat smin2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\r\n    return max(r, min (a, b)) - length(u);\r\n}\r\n\r\nfloat smax2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\r\n    return min(-r, max (a, b)) + length(u);\r\n}\r\n\r\nfloat smin(float a, float b, float k){\r\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\r\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\r\n}\r\n\r\nfloat smax(float a, float b, float k) {\r\n    return -smin(-a, -b, k);\r\n}\r\n\r\nfloat smin3(float a, float b, float k){\r\n    return min(\r\n        smin(a, b, k),\r\n        smin2(a, b, k)\r\n    );\r\n}\r\n\r\nfloat smax3(float a, float b, float k){\r\n    return max(\r\n        smax(a, b, k),\r\n        smax2(a, b, k)\r\n    );\r\n}\r\n\r\n\r\nfloat ellip(vec3 p, vec3 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ellip(vec2 p, vec2 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nbool isEye = false;\r\n\r\n\r\nfloat mHead(vec3 p) {\r\n\r\n    pR(p.yz, -.1);\r\n    p.y -= .11;\r\n\r\n    vec3 pa = p;\r\n    p.x = abs(p.x);\r\n    vec3 pp = p;\r\n\r\n    float d = 1e12;\r\n\r\n    // skull back\r\n    p += vec3(0,-.135,.09);\r\n    d = ellip(p, vec3(.395, .385, .395));\r\n\r\n    // skull base\r\n    p = pp;\r\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\r\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\r\n\r\n    // forehead\r\n    p = pp;\r\n    p += vec3(0,-.145,-.175);\r\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\r\n\r\n    p = pp;\r\n    pR(p.yz, -.5);\r\n    float bb = fBox(p, vec3(.5,.67,.7));\r\n    d = smax(d, bb, .2);\r\n\r\n    // face base\r\n    p = pp;\r\n    p += vec3(0,.25,-.13);\r\n    d = smin(d, length(p) - .28, .1);\r\n\r\n    // behind ear\r\n    p = pp;\r\n    p += vec3(-.15,.13,.06);\r\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\r\n\r\n    p = pp;\r\n    p += vec3(-.07,.18,.1);\r\n    d = smin(d, length(p) - .2, .18);\r\n\r\n    // cheek base\r\n    p = pp;\r\n    p += vec3(-.2,.12,-.14);\r\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\r\n\r\n    // jaw base\r\n    p = pp;\r\n    p += vec3(0,.475,-.16);\r\n    pR(p.yz, .8);\r\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\r\n    \r\n    // brow\r\n    p = pp;\r\n    p += vec3(0,-.0,-.18);\r\n    vec3 bp = p;\r\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\r\n    brow = length(p) - .36;\r\n    p.x -= .37;\r\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\r\n    p = bp;\r\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\r\n    p = bp;\r\n    pR(p.yz, -.5);\r\n    float peak = -p.y - .165;\r\n    peak += smoothstep(.0, .2, p.x) * .01;\r\n    peak -= smoothstep(.12, .29, p.x) * .025;\r\n    brow = smax(brow, peak, .07);\r\n    p = bp;\r\n    pR(p.yz, .5);\r\n    brow = smax(brow, -p.y - .06, .15);\r\n    d = smin(d, brow, .06);\r\n\r\n    // nose\r\n    p = pp;\r\n    p += vec3(0,.03,-.45);\r\n    pR(p.yz, 3.);\r\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\r\n\r\n    p = pp;\r\n    p += vec3(0,.06,-.47);\r\n    pR(p.yz, 2.77);\r\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\r\n\r\n    // jaw\r\n\r\n    p = pp;\r\n    vec3 jo = vec3(-.25,.4,-.07);\r\n    p = pp + jo;\r\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\r\n\r\n    p = pp;\r\n    p += vec3(0,.63,-.2);\r\n    pR(p.yz, .15);\r\n    float cr = .5;\r\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\r\n\r\n    p = pp + jo;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\r\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\r\n\r\n    p = pa;\r\n    p += vec3(.2,.5,-.1);\r\n    float jb = length(p);\r\n    jb = smoothstep(.0, .4, jb);\r\n    float js = mix(0., -.005, jb);\r\n    jb = mix(.01, .04, jb);\r\n\r\n    d = smin(d, jaw - js, jb);\r\n\r\n    // chin\r\n    p = pp;\r\n    p += vec3(0,.585,-.395);\r\n    p.x *= .7;\r\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\r\n\r\n    // cheek\r\n\r\n    p = pp;\r\n    p += vec3(-.2,.2,-.28);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, .4);\r\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.26,.02,-.1);\r\n    pR(p.xz, .13);\r\n    pR(p.yz, .5);\r\n    float temple = ellip(p, vec3(.1,.1,.15));\r\n    temple = smax(temple, p.x - .07, .1);\r\n    d = smin(d, temple, .1);\r\n\r\n    p = pp;\r\n    p += vec3(.0,.2,-.32);\r\n    ch = ellip(p, vec3(.1,.08,.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.17,.31,-.17);\r\n    ch = ellip(p, vec3(.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    // mouth base\r\n    p = pp;\r\n    p += vec3(-.0,.29,-.29);\r\n    pR(p.yz, -.3);\r\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\r\n\r\n    p = pp;\r\n    p += vec3(0,.37,-.4);\r\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.09,.37,-.31);\r\n    d = smin(d, ellip(p, vec3(.04)), .18);\r\n\r\n    // bottom lip\r\n    p = pp;\r\n    p += vec3(0,.455,-.455);\r\n    p.z += smoothstep(.0, .2, p.x) * .05;\r\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\r\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\r\n    float w = .192;\r\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\r\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\r\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\r\n    d = smin(d, bottomlip, lb);\r\n    \r\n    // top lip\r\n    p = pp;\r\n    p += vec3(0,.38,-.45);\r\n    pR(p.xz, -.3);\r\n    ls = vec3(.065,.03,.05);\r\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\r\n    vec3 pl = p * vec3(.78,1,1);\r\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\r\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\r\n    p = pp;\r\n    p += vec3(0,.33,-.45);\r\n    pR(p.yz, .7);\r\n    float cut;\r\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\r\n    float dip = smin(\r\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\r\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\r\n        .025\r\n    );\r\n    cut = smax(cut, dip, .04);\r\n    cut = smax(cut, p.x - .1, .05);\r\n    toplip = smax(toplip, cut, .02);\r\n\r\n    d = smin(d, toplip, .07);\r\n\r\n    // seam\r\n    p = pp;\r\n    p += vec3(0,.425,-.44);\r\n    lb = length(p);\r\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\r\n    pR(p.yz, .1);\r\n    p.y -= smoothstep(0., .03, p.x) * .002;\r\n    p.y += smoothstep(.03, .1, p.x) * .007;\r\n    p.z -= .133;\r\n    float seam = fDisc(p, .2);\r\n    seam = smax(seam, -d - .015, .01); // fix inside shape\r\n    d = mix(d, smax(d, -seam, lr), .65);\r\n\r\n    // nostrils base\r\n    p = pp;\r\n    p += vec3(0,.3,-.43);\r\n    d = smin(d, length(p) - .05, .07);\r\n\r\n    // nostrils\r\n    p = pp;\r\n    p += vec3(0,.27,-.52);\r\n    pR(p.yz, .2);\r\n    float nostrils = ellip(p, vec3(.055,.05,.06));\r\n\r\n    p = pp;\r\n    p += vec3(-.043,.28,-.48);\r\n    pR(p.xy, .15);\r\n    p.z *= .8;\r\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\r\n\r\n    d = smin(d, nostrils, .02);\r\n\r\n    p = pp;\r\n    p += vec3(-.033,.3,-.515);\r\n    pR(p.xz, .5);\r\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\r\n\r\n    // return d;\r\n\r\n    // eyelids\r\n    p = pp;\r\n    p += vec3(-.16,.07,-.34);\r\n    float eyelids = ellip(p, vec3(.08,.1,.1));\r\n\r\n    p = pp;\r\n    p += vec3(-.16,.09,-.35);\r\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\r\n\r\n    // edge top\r\n    p = pp;\r\n    p += vec3(-.173,.148,-.43);\r\n    p.x *= .97;\r\n    float et = length(p.xy) - .09;\r\n\r\n    // edge bottom\r\n    p = pp;\r\n    p += vec3(-.168,.105,-.43);\r\n    p.x *= .9;\r\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\r\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\r\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\r\n\r\n    float edge = max(max(eb, et), -d);\r\n\r\n    d = smin(d, eyelids, .01);\r\n    d = smin(d, eyelids2, .03);\r\n    d = smax(d, -edge, .005);\r\n\r\n    // eyeball\r\n    p = pp;\r\n    p += vec3(-.165,.0715,-.346);\r\n    float eyeball = length(p) - .088;\r\n\tisEye = eyeball < d;\r\n    d = min(d, eyeball);\r\n\r\n    // tear duct\r\n    p = pp;\r\n    p += vec3(-.075,.1,-.37);\r\n    d = min(d, length(p) - .05);\r\n\r\n    \r\n \t// ear\r\n    p = pp;\r\n    p += vec3(-.405,.12,.10);\r\n    pR(p.xy, -.12);\r\n    pR(p.xz, .35);\r\n    pR(p.yz, -.3);\r\n    vec3 pe = p;\r\n\r\n    // base\r\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\r\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\r\n\r\n    // inner\r\n    pR(p.xz, -.5);\r\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\r\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\r\n    float ridge = iear;\r\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\r\n    ear = smax2(ear, -iear, .04);\r\n    earback = smin(earback, iear - .04, .02);\r\n\r\n    // ridge\r\n    p = pe;\r\n    pR(p.xz, .2);\r\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\r\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\r\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\r\n\r\n    float ridger = .01;\r\n\r\n    ridge = max(-ridge, ridge - ridger);\r\n\r\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\r\n\r\n    ear = smin(ear, ridge, .045);\r\n\r\n    p = pe;\r\n\r\n    // outline\r\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\r\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\r\n\r\n    // edge\r\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\r\n\r\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\r\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\r\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\r\n    edgeo = smax(edgeo, -edgeoin, .05);\r\n\r\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\r\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\r\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\r\n    eedent = min(eedent, 1.);\r\n\r\n    eedge += eedent * .06;\r\n\r\n    eedge = smax(eedge, -edgeo, .01);\r\n    ear = smin(ear, eedge, .01);\r\n    ear = max(ear, earback);\r\n\r\n    ear = smax2(ear, outline, .015);\r\n\r\n    d = smin(d, ear, .015);\r\n\r\n    // targus\r\n    p = pp;\r\n    p += vec3(-.34,.2,.02);\r\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\r\n    p = pp;\r\n    p += vec3(-.37,.18,.03);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, -.4);\r\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\r\n    \r\n    return d;\r\n}\r\n\r\nfloat sstep(float t) {\r\n\treturn sin(t * PI - PI / 2.) * .5 + .5;\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    \r\n    float scale = 1.;\r\n    float s = .2;\r\n    float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.;\r\n    float rx = sin(iTime * .33) * .2;\r\n\r\n    if (iMouse.z > 0. && iMouse.w > 0.) {\r\n        ry = (.5 - iMouse.x / iResolution.x) * PI * 2.;\r\n    \trx = (.5 - iMouse.y / iResolution.y) * PI / 2.;\r\n        scale = 2.;\r\n    }\r\n    \r\n    pR(p.yz, rx);\r\n    pR(p.xz, ry);\r\n    \r\n    p /= scale;\r\n   \treturn mHead(p) * scale;\r\n}\r\n\r\nconst int NORMAL_STEPS = 6;\r\nvec3 calcNormal(vec3 pos){\r\n    vec3 eps = vec3(.0005,0,0);\r\n    vec3 nor = vec3(0);\r\n    float invert = 1.;\r\n    for (int i = 0; i < NORMAL_STEPS; i++){\r\n        nor += map(pos + eps * invert) * eps * invert;\r\n        eps = eps.zxy;\r\n        invert *= -1.;\r\n    }\r\n    return normalize(nor);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\r\n    \r\n    vec3 camPos = vec3(0,0,3.2);\r\n    vec3 rayDirection = normalize(vec3(p,-4));\r\n    \r\n    vec3 rayPosition = camPos;\r\n    float rayLength = 0.;\r\n    float dist = 0.;\r\n    bool bg = false;\r\n    vec3 col = vec3(.1);\r\n\r\n    for (int i = 0; i < 150; i++) {\r\n        rayLength += dist;\r\n        rayPosition = camPos + rayDirection * rayLength;\r\n        dist = map(rayPosition);\r\n\r\n        if (abs(dist) < .001) {\r\n        \tbreak;\r\n        }\r\n        \r\n        if (rayLength > 5.) {\r\n            bg = true;\r\n            break;\r\n        }\r\n    }\r\n    \r\n    if ( ! bg) {\r\n        vec3 albedo = isEye ? vec3(2) : vec3(1);\r\n        vec3 n = calcNormal(rayPosition);\r\n        vec3 lp = vec3(-.5,.5,.5);\r\n        float l = max(dot(lp, n), 0.);\r\n        vec3 ld = normalize(lp - rayPosition);\r\n        l += .02;\r\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\r\n        col = albedo * l;\r\n        col = pow(col, vec3(1./2.2));\r\n    }\r\n\r\n    fragColor = vec4(col,1);\r\n}\r\n","inputs":[],"outputs":[],"code":"/*\r\n\r\nHead\r\n----\r\n\r\nThis was painstakingly hand modeled by 'tracing' a polygonal model\r\nexported from Daz 3D.\r\n\r\nThe initial approach is to smooth blend small ellipses with a large\r\nblend radius, a technique I took from Ink Drawing by lnae\r\n(https://www.shadertoy.com/view/MltcDB)\r\n\r\nThe brow and jawline are formed by blending planes and spheres.\r\nThe nose is, of course, a few capsules.\r\nThe ears are various extruded and warped 2D layers, they were by\r\nfar the hardest part.\r\n\r\nI encourage you to comment parts out and see how it all adds up.\r\n\r\nUses a few primitives and tools from HG_SDF and IQ.\r\n\r\nApologies for the boring shading, you can see some more interesting\r\napplications in the GIF and 4K that this was created for:\r\n\r\n* Fractal Polycephaly https://media.giphy.com/media/J2xwceb3Kk50fGXWdj/giphy.gif\r\n* \u1D07 s \u1D04 \u029C \u1D07 \u0280 \u1D21 \u1D00 \u1D20 \u1D07 https://www.shadertoy.com/view/wtf3RM\r\n\r\n\r\nLicense: Creative Commons Attribution-NonCommercial\r\nhttps://creativecommons.org/licenses/by-nc/4.0/\r\n\r\n*/\r\n\r\n#define PI 3.14159265359\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pRi(vec2 p, float a) {\r\n    pR(p, a);\r\n    return p;\r\n}\r\n\r\n#define saturate(x) clamp(x, 0., 1.)\r\n\r\nfloat vmax(vec2 v) {\r\n    return max(v.x, v.y);\r\n}\r\n\r\nfloat vmax(vec3 v) {\r\n    return max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec3 v) {\r\n    return min(min(v.x, v.y), v.z);\r\n}\r\n\r\nfloat vmin(vec2 v) {\r\n    return min(v.x, v.y);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nfloat fCorner2(vec2 p) {\r\n    return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\r\n}\r\n\r\nfloat fDisc(vec3 p, float r) {\r\n    float l = length(p.xz) - r;\r\n    return l < 0. ? abs(p.y) : length(vec2(p.y, l));\r\n}\r\n\r\n\r\nfloat fHalfCapsule(vec3 p, float r) {\r\n    return mix(length(p.xz) - r, length(p) - r, step(0., p.y));\r\n}\r\n\r\n\r\n// IQ https://www.shadertoy.com/view/Xds3zN\r\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\r\n{\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    \r\n    float b = (r1-r2)/h;\r\n    float a = sqrt(1.0-b*b);\r\n    float k = dot(q,vec2(-b,a));\r\n    \r\n    if( k < 0.0 ) return length(q) - r1;\r\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\r\n        \r\n    return dot(q, vec2(a,b) ) - r1;\r\n}\r\n\r\nfloat smin2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\r\n    return max(r, min (a, b)) - length(u);\r\n}\r\n\r\nfloat smax2(float a, float b, float r) {\r\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\r\n    return min(-r, max (a, b)) + length(u);\r\n}\r\n\r\nfloat smin(float a, float b, float k){\r\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\r\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\r\n}\r\n\r\nfloat smax(float a, float b, float k) {\r\n    return -smin(-a, -b, k);\r\n}\r\n\r\nfloat smin3(float a, float b, float k){\r\n    return min(\r\n        smin(a, b, k),\r\n        smin2(a, b, k)\r\n    );\r\n}\r\n\r\nfloat smax3(float a, float b, float k){\r\n    return max(\r\n        smax(a, b, k),\r\n        smax2(a, b, k)\r\n    );\r\n}\r\n\r\n\r\nfloat ellip(vec3 p, vec3 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nfloat ellip(vec2 p, vec2 s) {\r\n    float r = vmin(s);\r\n    p *= r / s;\r\n    return length(p) - r;\r\n}\r\n\r\nbool isEye = false;\r\n\r\n\r\nfloat mHead(vec3 p) {\r\n\r\n    pR(p.yz, -.1);\r\n    p.y -= .11;\r\n\r\n    vec3 pa = p;\r\n    p.x = abs(p.x);\r\n    vec3 pp = p;\r\n\r\n    float d = 1e12;\r\n\r\n    // skull back\r\n    p += vec3(0,-.135,.09);\r\n    d = ellip(p, vec3(.395, .385, .395));\r\n\r\n    // skull base\r\n    p = pp;\r\n    p += vec3(0,-.135,.09) + vec3(0,.1,.07);\r\n    d = smin(d, ellip(p, vec3(.38, .36, .35)), .05);\r\n\r\n    // forehead\r\n    p = pp;\r\n    p += vec3(0,-.145,-.175);\r\n    d = smin(d, ellip(p, vec3(.315, .3, .33)), .18);\r\n\r\n    p = pp;\r\n    pR(p.yz, -.5);\r\n    float bb = fBox(p, vec3(.5,.67,.7));\r\n    d = smax(d, bb, .2);\r\n\r\n    // face base\r\n    p = pp;\r\n    p += vec3(0,.25,-.13);\r\n    d = smin(d, length(p) - .28, .1);\r\n\r\n    // behind ear\r\n    p = pp;\r\n    p += vec3(-.15,.13,.06);\r\n    d = smin(d, ellip(p, vec3(.15,.15,.15)), .15);\r\n\r\n    p = pp;\r\n    p += vec3(-.07,.18,.1);\r\n    d = smin(d, length(p) - .2, .18);\r\n\r\n    // cheek base\r\n    p = pp;\r\n    p += vec3(-.2,.12,-.14);\r\n    d = smin(d, ellip(p, vec3(.15,.22,.2) * .8), .15);\r\n\r\n    // jaw base\r\n    p = pp;\r\n    p += vec3(0,.475,-.16);\r\n    pR(p.yz, .8);\r\n    d = smin(d, ellip(p, vec3(.19,.1,.2)), .1);\r\n    \r\n    // brow\r\n    p = pp;\r\n    p += vec3(0,-.0,-.18);\r\n    vec3 bp = p;\r\n    float brow = fHalfCapsule(p * vec3(.65,1,.9), .27);\r\n    brow = length(p) - .36;\r\n    p.x -= .37;\r\n    brow = smax(brow, dot(p, normalize(vec3(1,.2,-.2))), .2);\r\n    p = bp;\r\n    brow = smax(brow, dot(p, normalize(vec3(0,.6,1))) - .43, .25);\r\n    p = bp;\r\n    pR(p.yz, -.5);\r\n    float peak = -p.y - .165;\r\n    peak += smoothstep(.0, .2, p.x) * .01;\r\n    peak -= smoothstep(.12, .29, p.x) * .025;\r\n    brow = smax(brow, peak, .07);\r\n    p = bp;\r\n    pR(p.yz, .5);\r\n    brow = smax(brow, -p.y - .06, .15);\r\n    d = smin(d, brow, .06);\r\n\r\n    // nose\r\n    p = pp;\r\n    p += vec3(0,.03,-.45);\r\n    pR(p.yz, 3.);\r\n    d = smin(d, sdRoundCone(p, .008, .05, .18), .1);\r\n\r\n    p = pp;\r\n    p += vec3(0,.06,-.47);\r\n    pR(p.yz, 2.77);\r\n    d = smin(d, sdRoundCone(p, .005, .04, .225), .05);\r\n\r\n    // jaw\r\n\r\n    p = pp;\r\n    vec3 jo = vec3(-.25,.4,-.07);\r\n    p = pp + jo;\r\n    float jaw = dot(p, normalize(vec3(1,-.2,-.05))) - .069;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,-.25,.35))) - .13, .12);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(-.0,-1.,-.8))) - .12, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.98,-1.,.15))) - .13, .08);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.6,-.2,-.45))) - .19, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(.5,.1,-.5))) - .26, .15);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(1,.2,-.3))) - .22, .15);\r\n\r\n    p = pp;\r\n    p += vec3(0,.63,-.2);\r\n    pR(p.yz, .15);\r\n    float cr = .5;\r\n    jaw = smax(jaw, length(p.xy - vec2(0,cr)) - cr, .05);\r\n\r\n    p = pp + jo;\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,-.4,1))) - .35, .1);\r\n    jaw = smax(jaw, dot(p, normalize(vec3(0,1.5,2))) - .3, .2);\r\n    jaw = max(jaw, length(pp + vec3(0,.6,-.3)) - .7);\r\n\r\n    p = pa;\r\n    p += vec3(.2,.5,-.1);\r\n    float jb = length(p);\r\n    jb = smoothstep(.0, .4, jb);\r\n    float js = mix(0., -.005, jb);\r\n    jb = mix(.01, .04, jb);\r\n\r\n    d = smin(d, jaw - js, jb);\r\n\r\n    // chin\r\n    p = pp;\r\n    p += vec3(0,.585,-.395);\r\n    p.x *= .7;\r\n    d = smin(d, ellip(p, vec3(.028,.028,.028)*1.2), .15);\r\n\r\n    // cheek\r\n\r\n    p = pp;\r\n    p += vec3(-.2,.2,-.28);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, .4);\r\n    float ch = ellip(p, vec3(.1,.1,.12)*1.05);\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.26,.02,-.1);\r\n    pR(p.xz, .13);\r\n    pR(p.yz, .5);\r\n    float temple = ellip(p, vec3(.1,.1,.15));\r\n    temple = smax(temple, p.x - .07, .1);\r\n    d = smin(d, temple, .1);\r\n\r\n    p = pp;\r\n    p += vec3(.0,.2,-.32);\r\n    ch = ellip(p, vec3(.1,.08,.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.17,.31,-.17);\r\n    ch = ellip(p, vec3(.1));\r\n    d = smin(d, ch, .1);\r\n\r\n    // mouth base\r\n    p = pp;\r\n    p += vec3(-.0,.29,-.29);\r\n    pR(p.yz, -.3);\r\n    d = smin(d, ellip(p, vec3(.13,.15,.1)), .18);\r\n\r\n    p = pp;\r\n    p += vec3(0,.37,-.4);\r\n    d = smin(d, ellip(p, vec3(.03,.03,.02) * .5), .1);\r\n\r\n    p = pp;\r\n    p += vec3(-.09,.37,-.31);\r\n    d = smin(d, ellip(p, vec3(.04)), .18);\r\n\r\n    // bottom lip\r\n    p = pp;\r\n    p += vec3(0,.455,-.455);\r\n    p.z += smoothstep(.0, .2, p.x) * .05;\r\n    float lb = mix(.035, .03, smoothstep(.05, .15, length(p)));\r\n    vec3 ls = vec3(.055,.028,.022) * 1.25;\r\n    float w = .192;\r\n    vec2 pl2 = vec2(p.x, length(p.yz * vec2(.79,1)));\r\n    float bottomlip = length(pl2 + vec2(0,w-ls.z)) - w;\r\n    bottomlip = smax(bottomlip, length(pl2 - vec2(0,w-ls.z)) - w, .055);\r\n    d = smin(d, bottomlip, lb);\r\n    \r\n    // top lip\r\n    p = pp;\r\n    p += vec3(0,.38,-.45);\r\n    pR(p.xz, -.3);\r\n    ls = vec3(.065,.03,.05);\r\n    w = ls.x * (-log(ls.y/ls.x) + 1.);\r\n    vec3 pl = p * vec3(.78,1,1);\r\n    float toplip = length(pl + vec3(0,w-ls.y,0)) - w;\r\n    toplip = smax(toplip, length(pl - vec3(0,w-ls.y,0)) - w, .065);\r\n    p = pp;\r\n    p += vec3(0,.33,-.45);\r\n    pR(p.yz, .7);\r\n    float cut;\r\n    cut = dot(p, normalize(vec3(.5,.25,0))) - .056;\r\n    float dip = smin(\r\n        dot(p, normalize(vec3(-.5,.5,0))) + .005,\r\n        dot(p, normalize(vec3(.5,.5,0))) + .005,\r\n        .025\r\n    );\r\n    cut = smax(cut, dip, .04);\r\n    cut = smax(cut, p.x - .1, .05);\r\n    toplip = smax(toplip, cut, .02);\r\n\r\n    d = smin(d, toplip, .07);\r\n\r\n    // seam\r\n    p = pp;\r\n    p += vec3(0,.425,-.44);\r\n    lb = length(p);\r\n    float lr = mix(.04, .02, smoothstep(.05, .12, lb));\r\n    pR(p.yz, .1);\r\n    p.y -= smoothstep(0., .03, p.x) * .002;\r\n    p.y += smoothstep(.03, .1, p.x) * .007;\r\n    p.z -= .133;\r\n    float seam = fDisc(p, .2);\r\n    seam = smax(seam, -d - .015, .01); // fix inside shape\r\n    d = mix(d, smax(d, -seam, lr), .65);\r\n\r\n    // nostrils base\r\n    p = pp;\r\n    p += vec3(0,.3,-.43);\r\n    d = smin(d, length(p) - .05, .07);\r\n\r\n    // nostrils\r\n    p = pp;\r\n    p += vec3(0,.27,-.52);\r\n    pR(p.yz, .2);\r\n    float nostrils = ellip(p, vec3(.055,.05,.06));\r\n\r\n    p = pp;\r\n    p += vec3(-.043,.28,-.48);\r\n    pR(p.xy, .15);\r\n    p.z *= .8;\r\n    nostrils = smin(nostrils, sdRoundCone(p, .042, .0, .12), .02);\r\n\r\n    d = smin(d, nostrils, .02);\r\n\r\n    p = pp;\r\n    p += vec3(-.033,.3,-.515);\r\n    pR(p.xz, .5);\r\n    d = smax(d, -ellip(p, vec3(.011,.03,.025)), .015);\r\n\r\n    // return d;\r\n\r\n    // eyelids\r\n    p = pp;\r\n    p += vec3(-.16,.07,-.34);\r\n    float eyelids = ellip(p, vec3(.08,.1,.1));\r\n\r\n    p = pp;\r\n    p += vec3(-.16,.09,-.35);\r\n    float eyelids2 = ellip(p, vec3(.09,.1,.07));\r\n\r\n    // edge top\r\n    p = pp;\r\n    p += vec3(-.173,.148,-.43);\r\n    p.x *= .97;\r\n    float et = length(p.xy) - .09;\r\n\r\n    // edge bottom\r\n    p = pp;\r\n    p += vec3(-.168,.105,-.43);\r\n    p.x *= .9;\r\n    float eb = dot(p, normalize(vec3(-.1,-1,-.2))) + .001;\r\n    eb = smin(eb, dot(p, normalize(vec3(-.3,-1,0))) - .006, .01);\r\n    eb = smax(eb, dot(p, normalize(vec3(.5,-1,-.5))) - .018, .05);\r\n\r\n    float edge = max(max(eb, et), -d);\r\n\r\n    d = smin(d, eyelids, .01);\r\n    d = smin(d, eyelids2, .03);\r\n    d = smax(d, -edge, .005);\r\n\r\n    // eyeball\r\n    p = pp;\r\n    p += vec3(-.165,.0715,-.346);\r\n    float eyeball = length(p) - .088;\r\n\tisEye = eyeball < d;\r\n    d = min(d, eyeball);\r\n\r\n    // tear duct\r\n    p = pp;\r\n    p += vec3(-.075,.1,-.37);\r\n    d = min(d, length(p) - .05);\r\n\r\n    \r\n \t// ear\r\n    p = pp;\r\n    p += vec3(-.405,.12,.10);\r\n    pR(p.xy, -.12);\r\n    pR(p.xz, .35);\r\n    pR(p.yz, -.3);\r\n    vec3 pe = p;\r\n\r\n    // base\r\n    float ear = p.s + smoothstep(-.05, .1, p.y) * .015 - .005;\r\n    float earback = -ear - mix(.001, .025, smoothstep(.3, -.2, p.y));\r\n\r\n    // inner\r\n    pR(p.xz, -.5);\r\n    float iear = ellip(p.zy - vec2(.01,-.03), vec2(.045,.05));\r\n    iear = smin(iear, length(p.zy - vec2(.04,-.09)) - .02, .09);\r\n    float ridge = iear;\r\n    iear = smin(iear, length(p.zy - vec2(.1,-.03)) - .06, .07);\r\n    ear = smax2(ear, -iear, .04);\r\n    earback = smin(earback, iear - .04, .02);\r\n\r\n    // ridge\r\n    p = pe;\r\n    pR(p.xz, .2);\r\n    ridge = ellip(p.zy - vec2(.01,-.03), vec2(.045,.055));\r\n    ridge = smin3(ridge, -pRi(p.zy, .2).x - .01, .015);\r\n    ridge = smax3(ridge, -ellip(p.zy - vec2(-.01,.1), vec2(.12,.08)), .02);\r\n\r\n    float ridger = .01;\r\n\r\n    ridge = max(-ridge, ridge - ridger);\r\n\r\n    ridge = smax2(ridge, abs(p.x) - ridger/2., ridger/2.);\r\n\r\n    ear = smin(ear, ridge, .045);\r\n\r\n    p = pe;\r\n\r\n    // outline\r\n    float outline = ellip(pRi(p.yz, .2), vec2(.12,.09));\r\n    outline = smin(outline, ellip(p.yz + vec2(.155,-.02), vec2(.035, .03)), .14);\r\n\r\n    // edge\r\n    float eedge = p.x + smoothstep(.2, -.4, p.y) * .06 - .03;\r\n\r\n    float edgeo = ellip(pRi(p.yz, .1), vec2(.095,.065));\r\n    edgeo = smin(edgeo, length(p.zy - vec2(0,-.1)) - .03, .1);\r\n    float edgeoin = smax(abs(pRi(p.zy, .15).y + .035) - .01, -p.z-.01, .01);\r\n    edgeo = smax(edgeo, -edgeoin, .05);\r\n\r\n    float eedent = smoothstep(-.05, .05, -p.z) * smoothstep(.06, 0., fCorner2(vec2(-p.z, p.y)));\r\n    eedent += smoothstep(.1, -.1, -p.z) * .2;\r\n    eedent += smoothstep(.1, -.1, p.y) * smoothstep(-.03, .0, p.z) * .3;\r\n    eedent = min(eedent, 1.);\r\n\r\n    eedge += eedent * .06;\r\n\r\n    eedge = smax(eedge, -edgeo, .01);\r\n    ear = smin(ear, eedge, .01);\r\n    ear = max(ear, earback);\r\n\r\n    ear = smax2(ear, outline, .015);\r\n\r\n    d = smin(d, ear, .015);\r\n\r\n    // targus\r\n    p = pp;\r\n    p += vec3(-.34,.2,.02);\r\n    d = smin2(d, ellip(p, vec3(.015,.025,.015)), .035);\r\n    p = pp;\r\n    p += vec3(-.37,.18,.03);\r\n    pR(p.xz, .5);\r\n    pR(p.yz, -.4);\r\n    d = smin(d, ellip(p, vec3(.01,.03,.015)), .015);\r\n    \r\n    return d;\r\n}\r\n\r\nfloat sstep(float t) {\r\n\treturn sin(t * PI - PI / 2.) * .5 + .5;\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    \r\n    float scale = 1.;\r\n    float s = .2;\r\n    float ry = mix(sstep(sstep(sstep(mod(iTime * s, 1.)))), mod(iTime * s, 1.), .3) * PI * 2.;\r\n    float rx = sin(iTime * .33) * .2;\r\n\r\n    if (iMouse.z > 0. && iMouse.w > 0.) {\r\n        ry = (.5 - iMouse.x / iResolution.x) * PI * 2.;\r\n    \trx = (.5 - iMouse.y / iResolution.y) * PI / 2.;\r\n        scale = 2.;\r\n    }\r\n    \r\n    pR(p.yz, rx);\r\n    pR(p.xz, ry);\r\n    \r\n    p /= scale;\r\n   \treturn mHead(p) * scale;\r\n}\r\n\r\nconst int NORMAL_STEPS = 6;\r\nvec3 calcNormal(vec3 pos){\r\n    vec3 eps = vec3(.0005,0,0);\r\n    vec3 nor = vec3(0);\r\n    float invert = 1.;\r\n    for (int i = 0; i < NORMAL_STEPS; i++){\r\n        nor += map(pos + eps * invert) * eps * invert;\r\n        eps = eps.zxy;\r\n        invert *= -1.;\r\n    }\r\n    return normalize(nor);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\r\n    \r\n    vec3 camPos = vec3(0,0,3.2);\r\n    vec3 rayDirection = normalize(vec3(p,-4));\r\n    \r\n    vec3 rayPosition = camPos;\r\n    float rayLength = 0.;\r\n    float dist = 0.;\r\n    bool bg = false;\r\n    vec3 col = vec3(.1);\r\n\r\n    for (int i = 0; i < 150; i++) {\r\n        rayLength += dist;\r\n        rayPosition = camPos + rayDirection * rayLength;\r\n        dist = map(rayPosition);\r\n\r\n        if (abs(dist) < .001) {\r\n        \tbreak;\r\n        }\r\n        \r\n        if (rayLength > 5.) {\r\n            bg = true;\r\n            break;\r\n        }\r\n    }\r\n    \r\n    if ( ! bg) {\r\n        vec3 albedo = isEye ? vec3(2) : vec3(1);\r\n        vec3 n = calcNormal(rayPosition);\r\n        vec3 lp = vec3(-.5,.5,.5);\r\n        float l = max(dot(lp, n), 0.);\r\n        vec3 ld = normalize(lp - rayPosition);\r\n        l += .02;\r\n        l += pow(max(0., 1. + dot(n, rayDirection)), 3.) * .05;\r\n        col = albedo * l;\r\n        col = pow(col, vec3(1./2.2));\r\n    }\r\n\r\n    fragColor = vec4(col,1);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"vec4 h2rgb(float c) {  // classical hsv2rgb simplified\r\n    vec4 p = abs(fract(c + vec4(3,2,1,0)/3.) * 6. - 3.);\r\n    return clamp(p - 1., 0., 1.);\r\n}\r\n\r\nvec4 j2hue(float c) {\r\n    return .5+.5*cos(6.28*c+vec4(0,-2.1,2.1,0));\r\n}\r\n\r\nvec4 sin2hue(float c) {\r\n    vec4 C = .5+.5*cos(6.28*clamp(1.5*fract(c)-vec4(0,.5,1,1.5),-.5,.5));\r\n    return C+vec4(C.w,0,0,0);\r\n}\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.xy; U.y*=3.; U.x*=6.;\r\n\tO =   U.y>2. ? sin2hue(U.x) : U.y>1.99 ? O-O\r\n        : U.y>1. ? j2hue(U.x)   : U.y>0.99 ? O-O\r\n        :          h2rgb(U.x);\r\n    float v = O.r+O.g+O.b, \r\n          m = min(O.r,min(O.g,O.b)),\r\n        M = max(O.r,max(O.g,O.b));\r\n    \r\n    O =   U.x>5. ? sqrt((O-m)/(M-m)) : U.x>4.99 ? O-O\r\n        : U.x>4. ? sqrt(O/v)         : U.x>3.99 ? O-O\r\n        : U.x>3. ? sqrt(O)           : U.x>2.99 ? O-O+1.\r\n        : U.x>2. ? (O-m)/(M-m)       : U.x>1.99 ? O-O\r\n        : U.x>1. ? O/v               : U.x>0.99 ? O-O\r\n                 : O;\r\n\r\n}","inputs":[],"outputs":[],"code":"vec4 h2rgb(float c) {  // classical hsv2rgb simplified\r\n    vec4 p = abs(fract(c + vec4(3,2,1,0)/3.) * 6. - 3.);\r\n    return clamp(p - 1., 0., 1.);\r\n}\r\n\r\nvec4 j2hue(float c) {\r\n    return .5+.5*cos(6.28*c+vec4(0,-2.1,2.1,0));\r\n}\r\n\r\nvec4 sin2hue(float c) {\r\n    vec4 C = .5+.5*cos(6.28*clamp(1.5*fract(c)-vec4(0,.5,1,1.5),-.5,.5));\r\n    return C+vec4(C.w,0,0,0);\r\n}\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.xy; U.y*=3.; U.x*=6.;\r\n\tO =   U.y>2. ? sin2hue(U.x) : U.y>1.99 ? O-O\r\n        : U.y>1. ? j2hue(U.x)   : U.y>0.99 ? O-O\r\n        :          h2rgb(U.x);\r\n    float v = O.r+O.g+O.b, \r\n          m = min(O.r,min(O.g,O.b)),\r\n        M = max(O.r,max(O.g,O.b));\r\n    \r\n    O =   U.x>5. ? sqrt((O-m)/(M-m)) : U.x>4.99 ? O-O\r\n        : U.x>4. ? sqrt(O/v)         : U.x>3.99 ? O-O\r\n        : U.x>3. ? sqrt(O)           : U.x>2.99 ? O-O+1.\r\n        : U.x>2. ? (O-m)/(M-m)       : U.x>1.99 ? O-O\r\n        : U.x>1. ? O/v               : U.x>0.99 ? O-O\r\n                 : O;\r\n\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"hue / spectrum / rainbow ramps","id":"040c9f0945494d7e8f5d63ab4e79e3c3","date":null,"viewed":0,"name":"hue / spectrum / rainbow ramps","description":"Bottom to top:  h2rgb, 3-phased sines, 2-phased sines\r\nLeft to right:  brut, brut/lum, saturated,   then sames with gamma\r\ncf graphs: https://www.desmos.com/calculator/ccoc40kfhj\r\nhttps://www.shadertoy.com/view/ltyXRm","likes":0,"published":null,"tags":["spectrum"," color"," rainbow"," hue"]},"ver":null,"info":{"Name":"hue / spectrum / rainbow ramps","id":"040c9f0945494d7e8f5d63ab4e79e3c3","date":null,"viewed":0,"name":"hue / spectrum / rainbow ramps","description":"Bottom to top:  h2rgb, 3-phased sines, 2-phased sines\r\nLeft to right:  brut, brut/lum, saturated,   then sames with gamma\r\ncf graphs: https://www.desmos.com/calculator/ccoc40kfhj\r\nhttps://www.shadertoy.com/view/ltyXRm","likes":0,"published":null,"tags":["spectrum"," color"," rainbow"," hue"]},"renderpass":[{"Code":"vec4 h2rgb(float c) {  // classical hsv2rgb simplified\r\n    vec4 p = abs(fract(c + vec4(3,2,1,0)/3.) * 6. - 3.);\r\n    return clamp(p - 1., 0., 1.);\r\n}\r\n\r\nvec4 j2hue(float c) {\r\n    return .5+.5*cos(6.28*c+vec4(0,-2.1,2.1,0));\r\n}\r\n\r\nvec4 sin2hue(float c) {\r\n    vec4 C = .5+.5*cos(6.28*clamp(1.5*fract(c)-vec4(0,.5,1,1.5),-.5,.5));\r\n    return C+vec4(C.w,0,0,0);\r\n}\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.xy; U.y*=3.; U.x*=6.;\r\n\tO =   U.y>2. ? sin2hue(U.x) : U.y>1.99 ? O-O\r\n        : U.y>1. ? j2hue(U.x)   : U.y>0.99 ? O-O\r\n        :          h2rgb(U.x);\r\n    float v = O.r+O.g+O.b, \r\n          m = min(O.r,min(O.g,O.b)),\r\n        M = max(O.r,max(O.g,O.b));\r\n    \r\n    O =   U.x>5. ? sqrt((O-m)/(M-m)) : U.x>4.99 ? O-O\r\n        : U.x>4. ? sqrt(O/v)         : U.x>3.99 ? O-O\r\n        : U.x>3. ? sqrt(O)           : U.x>2.99 ? O-O+1.\r\n        : U.x>2. ? (O-m)/(M-m)       : U.x>1.99 ? O-O\r\n        : U.x>1. ? O/v               : U.x>0.99 ? O-O\r\n                 : O;\r\n\r\n}","inputs":[],"outputs":[],"code":"vec4 h2rgb(float c) {  // classical hsv2rgb simplified\r\n    vec4 p = abs(fract(c + vec4(3,2,1,0)/3.) * 6. - 3.);\r\n    return clamp(p - 1., 0., 1.);\r\n}\r\n\r\nvec4 j2hue(float c) {\r\n    return .5+.5*cos(6.28*c+vec4(0,-2.1,2.1,0));\r\n}\r\n\r\nvec4 sin2hue(float c) {\r\n    vec4 C = .5+.5*cos(6.28*clamp(1.5*fract(c)-vec4(0,.5,1,1.5),-.5,.5));\r\n    return C+vec4(C.w,0,0,0);\r\n}\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.xy; U.y*=3.; U.x*=6.;\r\n\tO =   U.y>2. ? sin2hue(U.x) : U.y>1.99 ? O-O\r\n        : U.y>1. ? j2hue(U.x)   : U.y>0.99 ? O-O\r\n        :          h2rgb(U.x);\r\n    float v = O.r+O.g+O.b, \r\n          m = min(O.r,min(O.g,O.b)),\r\n        M = max(O.r,max(O.g,O.b));\r\n    \r\n    O =   U.x>5. ? sqrt((O-m)/(M-m)) : U.x>4.99 ? O-O\r\n        : U.x>4. ? sqrt(O/v)         : U.x>3.99 ? O-O\r\n        : U.x>3. ? sqrt(O)           : U.x>2.99 ? O-O+1.\r\n        : U.x>2. ? (O-m)/(M-m)       : U.x>1.99 ? O-O\r\n        : U.x>1. ? O/v               : U.x>0.99 ? O-O\r\n                 : O;\r\n\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define SHADED 1\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 1\r\n\r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"#define SHADED 1\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 1\r\n\r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"hypertexture - trabeculum","id":"a75398b2ccd44b78b15b0fbb135324e0","date":null,"viewed":0,"name":"hypertexture - trabeculum","description":"Trabeculum pattern. (camera follow mouse).\nYou can play with the defines for other patterns (NOISE) or larger trabelucum (VARIANT=0), and params in tweaknoise (thresh, scale).\nCheaper with SHADED=0 & FOG=1.\nhttps://www.shadertoy.com/view/ltj3Dc","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"ver":null,"info":{"Name":"hypertexture - trabeculum","id":"a75398b2ccd44b78b15b0fbb135324e0","date":null,"viewed":0,"name":"hypertexture - trabeculum","description":"Trabeculum pattern. (camera follow mouse).\nYou can play with the defines for other patterns (NOISE) or larger trabelucum (VARIANT=0), and params in tweaknoise (thresh, scale).\nCheaper with SHADED=0 & FOG=1.\nhttps://www.shadertoy.com/view/ltj3Dc","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"renderpass":[{"Code":"#define SHADED 1\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 1\r\n\r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"#define SHADED 1\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 1\r\n\r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// a variant from https://www.shadertoy.com/view/ltj3Dc\r\n\r\n#define SHADED 0\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n\r\nconst vec3 skyColor = 0.*vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.5+.5*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*iTime)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*iTime,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            float a = 2.*PI*float(i)/200.; vec3 c = .5+.5*cos(a+vec3(0.,2.*PI/3.,-2.*PI/3.)+iTime);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// a variant from https://www.shadertoy.com/view/ltj3Dc\r\n\r\n#define SHADED 0\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n\r\nconst vec3 skyColor = 0.*vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.5+.5*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*iTime)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*iTime,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            float a = 2.*PI*float(i)/200.; vec3 c = .5+.5*cos(a+vec3(0.,2.*PI/3.,-2.*PI/3.)+iTime);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"hypertexture - trabeculum 2","id":"b1233d6447ce4a64b876565cdd364622","date":null,"viewed":0,"name":"hypertexture - trabeculum 2","description":"Trabeculum pattern. (camera follow mouse).\n( a variant from https://www.shadertoy.com/view/ltj3Dc )\nhttps://www.shadertoy.com/view/MlB3Wt","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"ver":null,"info":{"Name":"hypertexture - trabeculum 2","id":"b1233d6447ce4a64b876565cdd364622","date":null,"viewed":0,"name":"hypertexture - trabeculum 2","description":"Trabeculum pattern. (camera follow mouse).\n( a variant from https://www.shadertoy.com/view/ltj3Dc )\nhttps://www.shadertoy.com/view/MlB3Wt","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"renderpass":[{"Code":"// a variant from https://www.shadertoy.com/view/ltj3Dc\r\n\r\n#define SHADED 0\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n\r\nconst vec3 skyColor = 0.*vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.5+.5*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*iTime)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*iTime,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            float a = 2.*PI*float(i)/200.; vec3 c = .5+.5*cos(a+vec3(0.,2.*PI/3.,-2.*PI/3.)+iTime);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// a variant from https://www.shadertoy.com/view/ltj3Dc\r\n\r\n#define SHADED 0\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n\r\nconst vec3 skyColor = 0.*vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.5+.5*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*iTime)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*iTime,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            float a = 2.*PI*float(i)/200.; vec3 c = .5+.5*cos(a+vec3(0.,2.*PI/3.,-2.*PI/3.)+iTime);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// mix of 3D trabeculum https://www.shadertoy.com/view/ltj3Dc\r\n// and even-border 2D-trabeculum https://www.shadertoy.com/view/MlGGDw\r\n\r\n#define SHADED 1\r\n#define FOG 1\r\n#define VARIANT 1\r\n#define ANIMATE 1 // 1: camera shake  2: evolving trabeculum\r\n    \r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n\r\nfloat hash( float n ) { // from https://www.shadertoy.com/view/XslGRr\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec3 dist(vec3 g, vec3 x) {\r\n    vec3 n = floor(x), f = fract(x),\r\n         o = hash33( n + g );\r\n\t#if ANIMATE==2\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 worley( vec3 x) {\r\n\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec3 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int k=-1; k<=1; k++ ) \r\n      for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec3  g = vec3(i,j,k), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    vec4 d = vec4(1e15);\r\n/**/\r\n    mg-=mg;\r\n    #define W 1   // shortcut. why does it work ?\r\n/**\r\n    #define W 2   // should be the correct way\r\n/**/\r\n    for( int k=-W; k<=W; k++ )\r\n      for( int j=-W; j<=W; j++ )\r\n        for( int i=-W; i<=W; i++ ) {\r\n            vec3 g = mg + vec3(i,j,k),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d0 = dot( .5*(mr+r), normalize(r-mr) );\r\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\r\n                else if (d0<d.z) {            d.z=d0; }   \r\n /*             if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   */\r\n            }\r\n        }\r\n    return d;           // distances to border P0-PN, N=1..4 closests (after P0)\r\n}\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5, // default value possibly overloaded below.\r\n    _dist=1.;\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p) {\r\n    // macroscopic shape pruning the noise\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1, v;\r\n\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    _dist = 1.;\r\n    if (d < .5) return 0.;\r\n    \r\n    // 3D noise\r\n    //grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    grad=.1, scale = 4., thresh=.9;\r\n    vec4 w = scale*worley(scale*p); \r\n#define TRAB 2 // variation for the magic trabeculum distance\r\n  #if TRAB==1\r\n    v = 1.-2./(0./w.x+1./w.y+1./w.z); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n  #elif TRAB==2\r\n    float n = 1.3; v= 1.-2.*pow(pow(w.y,-n)+pow(w.z,-n),-n);\r\n  #else\r\n    v= 1.-1.*w.y;\r\n  #endif\r\n    \r\n    _dist = 1.-v*d-thresh;\r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-tweaknoise(p-epsL*lightDir))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v*.5, 0.,1.); // Lambert shading  \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if ANIMATE==1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p); // density field\r\n        //epsC = .1*_dist;  // adaptive stepping\r\n        if (Aloc>0.01) {            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n          //vec3 c = ambient+diffuse*dot(N,lightDir); // if N already calculated\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// mix of 3D trabeculum https://www.shadertoy.com/view/ltj3Dc\r\n// and even-border 2D-trabeculum https://www.shadertoy.com/view/MlGGDw\r\n\r\n#define SHADED 1\r\n#define FOG 1\r\n#define VARIANT 1\r\n#define ANIMATE 1 // 1: camera shake  2: evolving trabeculum\r\n    \r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n\r\nfloat hash( float n ) { // from https://www.shadertoy.com/view/XslGRr\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec3 dist(vec3 g, vec3 x) {\r\n    vec3 n = floor(x), f = fract(x),\r\n         o = hash33( n + g );\r\n\t#if ANIMATE==2\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 worley( vec3 x) {\r\n\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec3 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int k=-1; k<=1; k++ ) \r\n      for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec3  g = vec3(i,j,k), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    vec4 d = vec4(1e15);\r\n/**/\r\n    mg-=mg;\r\n    #define W 1   // shortcut. why does it work ?\r\n/**\r\n    #define W 2   // should be the correct way\r\n/**/\r\n    for( int k=-W; k<=W; k++ )\r\n      for( int j=-W; j<=W; j++ )\r\n        for( int i=-W; i<=W; i++ ) {\r\n            vec3 g = mg + vec3(i,j,k),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d0 = dot( .5*(mr+r), normalize(r-mr) );\r\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\r\n                else if (d0<d.z) {            d.z=d0; }   \r\n /*             if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   */\r\n            }\r\n        }\r\n    return d;           // distances to border P0-PN, N=1..4 closests (after P0)\r\n}\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5, // default value possibly overloaded below.\r\n    _dist=1.;\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p) {\r\n    // macroscopic shape pruning the noise\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1, v;\r\n\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    _dist = 1.;\r\n    if (d < .5) return 0.;\r\n    \r\n    // 3D noise\r\n    //grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    grad=.1, scale = 4., thresh=.9;\r\n    vec4 w = scale*worley(scale*p); \r\n#define TRAB 2 // variation for the magic trabeculum distance\r\n  #if TRAB==1\r\n    v = 1.-2./(0./w.x+1./w.y+1./w.z); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n  #elif TRAB==2\r\n    float n = 1.3; v= 1.-2.*pow(pow(w.y,-n)+pow(w.z,-n),-n);\r\n  #else\r\n    v= 1.-1.*w.y;\r\n  #endif\r\n    \r\n    _dist = 1.-v*d-thresh;\r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-tweaknoise(p-epsL*lightDir))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v*.5, 0.,1.); // Lambert shading  \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if ANIMATE==1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p); // density field\r\n        //epsC = .1*_dist;  // adaptive stepping\r\n        if (Aloc>0.01) {            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n          //vec3 c = ambient+diffuse*dot(N,lightDir); // if N already calculated\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"hypertexture - trabeculum -2","id":"65b43cab3c5b43b0bac328cd5ebdcf79","date":null,"viewed":0,"name":"hypertexture - trabeculum -2","description":"3D Trabeculum pattern (camera follow mouse) - messy testbench.\nVoronoi with smooth corners and normalized thickness (see comments).\nhttps://www.shadertoy.com/view/ltyGRy","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"ver":null,"info":{"Name":"hypertexture - trabeculum -2","id":"65b43cab3c5b43b0bac328cd5ebdcf79","date":null,"viewed":0,"name":"hypertexture - trabeculum -2","description":"3D Trabeculum pattern (camera follow mouse) - messy testbench.\nVoronoi with smooth corners and normalized thickness (see comments).\nhttps://www.shadertoy.com/view/ltyGRy","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"renderpass":[{"Code":"// mix of 3D trabeculum https://www.shadertoy.com/view/ltj3Dc\r\n// and even-border 2D-trabeculum https://www.shadertoy.com/view/MlGGDw\r\n\r\n#define SHADED 1\r\n#define FOG 1\r\n#define VARIANT 1\r\n#define ANIMATE 1 // 1: camera shake  2: evolving trabeculum\r\n    \r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n\r\nfloat hash( float n ) { // from https://www.shadertoy.com/view/XslGRr\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec3 dist(vec3 g, vec3 x) {\r\n    vec3 n = floor(x), f = fract(x),\r\n         o = hash33( n + g );\r\n\t#if ANIMATE==2\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 worley( vec3 x) {\r\n\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec3 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int k=-1; k<=1; k++ ) \r\n      for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec3  g = vec3(i,j,k), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    vec4 d = vec4(1e15);\r\n/**/\r\n    mg-=mg;\r\n    #define W 1   // shortcut. why does it work ?\r\n/**\r\n    #define W 2   // should be the correct way\r\n/**/\r\n    for( int k=-W; k<=W; k++ )\r\n      for( int j=-W; j<=W; j++ )\r\n        for( int i=-W; i<=W; i++ ) {\r\n            vec3 g = mg + vec3(i,j,k),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d0 = dot( .5*(mr+r), normalize(r-mr) );\r\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\r\n                else if (d0<d.z) {            d.z=d0; }   \r\n /*             if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   */\r\n            }\r\n        }\r\n    return d;           // distances to border P0-PN, N=1..4 closests (after P0)\r\n}\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5, // default value possibly overloaded below.\r\n    _dist=1.;\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p) {\r\n    // macroscopic shape pruning the noise\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1, v;\r\n\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    _dist = 1.;\r\n    if (d < .5) return 0.;\r\n    \r\n    // 3D noise\r\n    //grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    grad=.1, scale = 4., thresh=.9;\r\n    vec4 w = scale*worley(scale*p); \r\n#define TRAB 2 // variation for the magic trabeculum distance\r\n  #if TRAB==1\r\n    v = 1.-2./(0./w.x+1./w.y+1./w.z); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n  #elif TRAB==2\r\n    float n = 1.3; v= 1.-2.*pow(pow(w.y,-n)+pow(w.z,-n),-n);\r\n  #else\r\n    v= 1.-1.*w.y;\r\n  #endif\r\n    \r\n    _dist = 1.-v*d-thresh;\r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-tweaknoise(p-epsL*lightDir))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v*.5, 0.,1.); // Lambert shading  \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if ANIMATE==1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p); // density field\r\n        //epsC = .1*_dist;  // adaptive stepping\r\n        if (Aloc>0.01) {            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n          //vec3 c = ambient+diffuse*dot(N,lightDir); // if N already calculated\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// mix of 3D trabeculum https://www.shadertoy.com/view/ltj3Dc\r\n// and even-border 2D-trabeculum https://www.shadertoy.com/view/MlGGDw\r\n\r\n#define SHADED 1\r\n#define FOG 1\r\n#define VARIANT 1\r\n#define ANIMATE 1 // 1: camera shake  2: evolving trabeculum\r\n    \r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n\r\nfloat hash( float n ) { // from https://www.shadertoy.com/view/XslGRr\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec3 dist(vec3 g, vec3 x) {\r\n    vec3 n = floor(x), f = fract(x),\r\n         o = hash33( n + g );\r\n\t#if ANIMATE==2\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 worley( vec3 x) {\r\n\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec3 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int k=-1; k<=1; k++ ) \r\n      for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec3  g = vec3(i,j,k), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    vec4 d = vec4(1e15);\r\n/**/\r\n    mg-=mg;\r\n    #define W 1   // shortcut. why does it work ?\r\n/**\r\n    #define W 2   // should be the correct way\r\n/**/\r\n    for( int k=-W; k<=W; k++ )\r\n      for( int j=-W; j<=W; j++ )\r\n        for( int i=-W; i<=W; i++ ) {\r\n            vec3 g = mg + vec3(i,j,k),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d0 = dot( .5*(mr+r), normalize(r-mr) );\r\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\r\n                else if (d0<d.z) {            d.z=d0; }   \r\n /*             if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   */\r\n            }\r\n        }\r\n    return d;           // distances to border P0-PN, N=1..4 closests (after P0)\r\n}\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5, // default value possibly overloaded below.\r\n    _dist=1.;\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p) {\r\n    // macroscopic shape pruning the noise\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1, v;\r\n\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    _dist = 1.;\r\n    if (d < .5) return 0.;\r\n    \r\n    // 3D noise\r\n    //grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    grad=.1, scale = 4., thresh=.9;\r\n    vec4 w = scale*worley(scale*p); \r\n#define TRAB 2 // variation for the magic trabeculum distance\r\n  #if TRAB==1\r\n    v = 1.-2./(0./w.x+1./w.y+1./w.z); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n  #elif TRAB==2\r\n    float n = 1.3; v= 1.-2.*pow(pow(w.y,-n)+pow(w.z,-n),-n);\r\n  #else\r\n    v= 1.-1.*w.y;\r\n  #endif\r\n    \r\n    _dist = 1.-v*d-thresh;\r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-tweaknoise(p-epsL*lightDir))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v*.5, 0.,1.); // Lambert shading  \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if ANIMATE==1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p); // density field\r\n        //epsC = .1*_dist;  // adaptive stepping\r\n        if (Aloc>0.01) {            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n          //vec3 c = ambient+diffuse*dot(N,lightDir); // if N already calculated\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// a variant from https://www.shadertoy.com/view/ltj3Dc and https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define SHADED 0\r\n#define FOG 1\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n#define SPIKES 1\r\n#define RANDtex 0 // 0: math rand 1: texture rand ( thanks Dave ! :-) )\r\nfloat time;\r\n\r\nconst vec3 skyColor = vec3(1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n#if !RANDtex\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n#else\r\nfloat noise( in vec3 f )\r\n{\r\n    vec3 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n#if !RANDtex\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n#else  // thanks Dave ! :-)\r\n    return texture( iChannel0, ((n.xy+vec2(37.0,17.0)*n.z+.5))/256.0, -100.0).xyz;\r\n#endif\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=1.; //d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 7., thresh=.7+.2*(cos(.5*time)+.36*cos(.5*3.*time))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*time)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#  if SPIKES    \r\n    v *= 1.-.9*(2.*fbm(10.*scale*p)-1.);\r\n#  endif\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    time = iTime*1.;\r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.4,.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*time,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    { float  t=.5*time, c=cos(t),s=sin(t); q *= mat2(c,-s,s,c); }\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n            //{ vec3 pp=smoothstep(0.,0.2,mod(p*scale,1.)); if (pp.x*pp.y*pp.z<.02) {col+=vec3(1.); break;}}\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.,.05,0.);\r\n#endif            \r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// a variant from https://www.shadertoy.com/view/ltj3Dc and https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define SHADED 0\r\n#define FOG 1\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n#define SPIKES 1\r\n#define RANDtex 0 // 0: math rand 1: texture rand ( thanks Dave ! :-) )\r\nfloat time;\r\n\r\nconst vec3 skyColor = vec3(1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n#if !RANDtex\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n#else\r\nfloat noise( in vec3 f )\r\n{\r\n    vec3 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n#if !RANDtex\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n#else  // thanks Dave ! :-)\r\n    return texture( iChannel0, ((n.xy+vec2(37.0,17.0)*n.z+.5))/256.0, -100.0).xyz;\r\n#endif\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=1.; //d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 7., thresh=.7+.2*(cos(.5*time)+.36*cos(.5*3.*time))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*time)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#  if SPIKES    \r\n    v *= 1.-.9*(2.*fbm(10.*scale*p)-1.);\r\n#  endif\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    time = iTime*1.;\r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.4,.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*time,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    { float  t=.5*time, c=cos(t),s=sin(t); q *= mat2(c,-s,s,c); }\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n            //{ vec3 pp=smoothstep(0.,0.2,mod(p*scale,1.)); if (pp.x*pp.y*pp.z<.02) {col+=vec3(1.); break;}}\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.,.05,0.);\r\n#endif            \r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"hypertexture - trabeculum 3","id":"bbc068a257e74c4290600dd3e4d647ac","date":null,"viewed":0,"name":"hypertexture - trabeculum 3","description":"Trabeculum pattern. (camera follow mouse).\n( a variant from https://www.shadertoy.com/view/MlB3Wt ).\nhttps://www.shadertoy.com/view/XtfXRn","likes":0,"published":null,"tags":["procedural"," raytracing"," noise"," perlin"," hypertexture"," trabeculum"]},"ver":null,"info":{"Name":"hypertexture - trabeculum 3","id":"bbc068a257e74c4290600dd3e4d647ac","date":null,"viewed":0,"name":"hypertexture - trabeculum 3","description":"Trabeculum pattern. (camera follow mouse).\n( a variant from https://www.shadertoy.com/view/MlB3Wt ).\nhttps://www.shadertoy.com/view/XtfXRn","likes":0,"published":null,"tags":["procedural"," raytracing"," noise"," perlin"," hypertexture"," trabeculum"]},"renderpass":[{"Code":"// a variant from https://www.shadertoy.com/view/ltj3Dc and https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define SHADED 0\r\n#define FOG 1\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n#define SPIKES 1\r\n#define RANDtex 0 // 0: math rand 1: texture rand ( thanks Dave ! :-) )\r\nfloat time;\r\n\r\nconst vec3 skyColor = vec3(1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n#if !RANDtex\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n#else\r\nfloat noise( in vec3 f )\r\n{\r\n    vec3 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n#if !RANDtex\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n#else  // thanks Dave ! :-)\r\n    return texture( iChannel0, ((n.xy+vec2(37.0,17.0)*n.z+.5))/256.0, -100.0).xyz;\r\n#endif\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=1.; //d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 7., thresh=.7+.2*(cos(.5*time)+.36*cos(.5*3.*time))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*time)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#  if SPIKES    \r\n    v *= 1.-.9*(2.*fbm(10.*scale*p)-1.);\r\n#  endif\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    time = iTime*1.;\r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.4,.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*time,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    { float  t=.5*time, c=cos(t),s=sin(t); q *= mat2(c,-s,s,c); }\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n            //{ vec3 pp=smoothstep(0.,0.2,mod(p*scale,1.)); if (pp.x*pp.y*pp.z<.02) {col+=vec3(1.); break;}}\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.,.05,0.);\r\n#endif            \r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// a variant from https://www.shadertoy.com/view/ltj3Dc and https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define SHADED 0\r\n#define FOG 1\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n#define SPIKES 1\r\n#define RANDtex 0 // 0: math rand 1: texture rand ( thanks Dave ! :-) )\r\nfloat time;\r\n\r\nconst vec3 skyColor = vec3(1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n#if !RANDtex\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n#else\r\nfloat noise( in vec3 f )\r\n{\r\n    vec3 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n#if !RANDtex\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n#else  // thanks Dave ! :-)\r\n    return texture( iChannel0, ((n.xy+vec2(37.0,17.0)*n.z+.5))/256.0, -100.0).xyz;\r\n#endif\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=1.; //d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 7., thresh=.7+.2*(cos(.5*time)+.36*cos(.5*3.*time))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*time)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#  if SPIKES    \r\n    v *= 1.-.9*(2.*fbm(10.*scale*p)-1.);\r\n#  endif\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    time = iTime*1.;\r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.4,.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*time,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    { float  t=.5*time, c=cos(t),s=sin(t); q *= mat2(c,-s,s,c); }\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n            //{ vec3 pp=smoothstep(0.,0.2,mod(p*scale,1.)); if (pp.x*pp.y*pp.z<.02) {col+=vec3(1.); break;}}\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.,.05,0.);\r\n#endif            \r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// These are 316 gaussian points (201 brushes by using local symmetry) forming the picture\r\n// of Audrey Hepburn. They pack down to 800 bytes (34 bits per point) before huffman/arithmetic\r\n// compression.\r\n//\r\n// The points were chosen by (very quickly) runing this \r\n//\r\n// http://www.iquilezles.org/www/articles/genetic/genetic.htm\r\n//\r\n// with some importance sampling for the eyes, nouse and mouth.\r\n\r\nfloat brush( float col, vec2 p, in vec4 b, float an )\r\n{\r\n\tp += an*cos( iTime + 100.0*b.yz );\r\n\t\t\t\t\r\n    vec2 dd = p - b.yz;\r\n    col = mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    if( abs(b.z-0.5)<0.251 )\r\n    {\r\n        dd.x = p.x - 1.0 + b.y;\r\n        col =  mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    }\r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.y;\r\n    uv.x -=  0.5*(iResolution.x / iResolution.y - 1.0);\r\n\r\n    float an = smoothstep( 0.0, 1.0, cos(iTime) );\r\n\r\n\tfloat col = 0.0;\r\n\r\n    col = brush( col, uv, vec4(1.000,0.371,0.379,11.770), an );\r\n    col = brush( col, uv, vec4(0.992,0.545,0.551,8.359), an );\r\n    col = brush( col, uv, vec4(0.749,0.623,0.990,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.510,0.395,11.315), an );\r\n    col = brush( col, uv, vec4(1.000,0.723,0.564,15.170), an );\r\n    col = brush( col, uv, vec4(0.953,0.729,0.750,14.629), an );\r\n    col = brush( col, uv, vec4(0.706,0.982,0.033,16.254), an );\r\n    col = brush( col, uv, vec4(1.000,0.855,0.652,26.256), an );\r\n    col = brush( col, uv, vec4(1.000,0.664,0.623,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.881,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.686,0.682,0.900,27.676), an );\r\n    col = brush( col, uv, vec4(1.000,0.189,0.684,18.618), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.422,0.195,44.522), an );\r\n    col = brush( col, uv, vec4(1.000,0.779,0.750,16.787), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.330,14.222), an );\r\n    col = brush( col, uv, vec4(1.000,0.197,0.648,22.505), an );\r\n    col = brush( col, uv, vec4(0.702,0.512,0.393,35.310), an );\r\n    col = brush( col, uv, vec4(1.000,0.744,0.621,14.949), an );\r\n    col = brush( col, uv, vec4(0.671,0.885,0.092,24.675), an );\r\n    col = brush( col, uv, vec4(0.000,0.344,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.760,0.465,40.960), an );\r\n    col = brush( col, uv, vec4(0.008,0.908,0.311,8.031), an );\r\n    col = brush( col, uv, vec4(0.016,0.959,0.750,10.039), an );\r\n    col = brush( col, uv, vec4(0.004,0.930,0.750,12.800), an );\r\n    col = brush( col, uv, vec4(1.000,0.555,0.250,19.883), an );\r\n    col = brush( col, uv, vec4(1.000,0.770,1.018,15.876), an );\r\n    col = brush( col, uv, vec4(0.000,0.828,0.756,36.571), an );\r\n    col = brush( col, uv, vec4(0.580,0.566,0.424,89.043), an );\r\n    col = brush( col, uv, vec4(0.988,0.162,0.691,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.314,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.947,0.125,32.000), an );\r\n    col = brush( col, uv, vec4(0.914,0.844,0.725,52.513), an );\r\n    col = brush( col, uv, vec4(1.000,0.313,0.762,42.667), an );\r\n    col = brush( col, uv, vec4(0.996,0.676,0.689,85.333), an );\r\n    col = brush( col, uv, vec4(0.980,0.346,0.559,24.675), an );\r\n    col = brush( col, uv, vec4(1.000,0.553,0.250,18.789), an );\r\n    col = brush( col, uv, vec4(0.004,0.258,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.420,0.742,30.567), an );\r\n    col = brush( col, uv, vec4(0.906,0.543,0.250,22.756), an );\r\n    col = brush( col, uv, vec4(0.863,0.674,0.322,20.078), an );\r\n    col = brush( col, uv, vec4(0.753,0.357,0.686,78.769), an );\r\n    col = brush( col, uv, vec4(0.906,0.795,0.705,37.236), an );\r\n    col = brush( col, uv, vec4(0.933,0.520,0.365,38.642), an );\r\n    col = brush( col, uv, vec4(0.996,0.318,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.337,0.486,0.281,81.920), an );\r\n    col = brush( col, uv, vec4(0.965,0.691,0.516,16.650), an );\r\n    col = brush( col, uv, vec4(0.808,0.582,0.973,52.513), an );\r\n    col = brush( col, uv, vec4(0.012,0.240,0.928,8.063), an );\r\n    col = brush( col, uv, vec4(1.000,0.496,0.217,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.658,0.953,34.133), an );\r\n    col = brush( col, uv, vec4(0.871,0.582,0.172,62.061), an );\r\n    col = brush( col, uv, vec4(0.855,0.346,0.342,17.504), an );\r\n    col = brush( col, uv, vec4(0.878,0.787,0.648,28.845), an );\r\n    col = brush( col, uv, vec4(0.000,0.984,0.111,35.310), an );\r\n    col = brush( col, uv, vec4(0.855,0.514,0.965,66.065), an );\r\n    col = brush( col, uv, vec4(0.561,0.613,0.350,81.920), an );\r\n    col = brush( col, uv, vec4(0.992,0.818,0.902,21.558), an );\r\n    col = brush( col, uv, vec4(0.914,0.746,0.615,40.157), an );\r\n    col = brush( col, uv, vec4(0.557,0.580,0.125,60.235), an );\r\n    col = brush( col, uv, vec4(0.475,0.547,0.414,70.621), an );\r\n    col = brush( col, uv, vec4(0.843,0.680,0.793,20.277), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.758,56.889), an );\r\n    col = brush( col, uv, vec4(1.000,0.299,0.691,68.267), an );\r\n    col = brush( col, uv, vec4(0.737,0.518,0.100,68.267), an );\r\n    col = brush( col, uv, vec4(0.996,0.227,0.514,41.796), an );\r\n    col = brush( col, uv, vec4(0.929,0.850,0.770,62.061), an );\r\n    col = brush( col, uv, vec4(0.682,0.834,0.111,30.118), an );\r\n    col = brush( col, uv, vec4(0.996,0.854,0.793,58.514), an );\r\n    col = brush( col, uv, vec4(0.490,0.736,0.889,19.321), an );\r\n    col = brush( col, uv, vec4(0.980,0.465,0.725,16.126), an );\r\n    col = brush( col, uv, vec4(0.992,0.484,1.010,23.273), an );\r\n    col = brush( col, uv, vec4(0.008,0.949,0.727,23.540), an );\r\n    col = brush( col, uv, vec4(0.012,0.086,0.086,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.121,0.750,44.522), an );\r\n    col = brush( col, uv, vec4(0.427,0.617,0.891,27.676), an );\r\n    col = brush( col, uv, vec4(0.804,0.693,0.633,78.769), an );\r\n    col = brush( col, uv, vec4(0.012,0.711,0.084,13.745), an );\r\n    col = brush( col, uv, vec4(0.082,0.584,0.338,107.789), an );\r\n    col = brush( col, uv, vec4(0.929,0.613,0.268,19.692), an );\r\n    col = brush( col, uv, vec4(0.200,0.549,0.420,128.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.402,0.717,26.947), an );\r\n    col = brush( col, uv, vec4(0.000,0.551,0.168,45.511), an );\r\n    col = brush( col, uv, vec4(0.992,0.627,0.621,56.889), an );\r\n    col = brush( col, uv, vec4(0.902,0.361,0.748,40.960), an );\r\n    col = brush( col, uv, vec4(0.984,0.344,0.754,38.642), an );\r\n    col = brush( col, uv, vec4(0.902,0.203,0.818,51.200), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.803,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.738,0.691,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.385,0.797,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.725,0.305,62.061), an );\r\n    col = brush( col, uv, vec4(0.000,0.150,0.750,45.511), an );\r\n    col = brush( col, uv, vec4(1.000,0.742,0.408,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.645,0.643,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.438,35.310), an );\r\n    col = brush( col, uv, vec4(0.510,0.564,0.789,18.450), an );\r\n    col = brush( col, uv, vec4(0.863,0.211,0.781,30.567), an );\r\n    col = brush( col, uv, vec4(0.106,0.508,0.328,89.043), an );\r\n    col = brush( col, uv, vec4(0.012,0.410,0.875,14.629), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.877,48.762), an );\r\n    col = brush( col, uv, vec4(1.000,0.258,0.779,37.926), an );\r\n    col = brush( col, uv, vec4(0.000,0.436,0.807,28.845), an );\r\n    col = brush( col, uv, vec4(0.918,0.861,0.836,49.951), an );\r\n    col = brush( col, uv, vec4(1.000,0.291,0.770,40.960), an );\r\n    col = brush( col, uv, vec4(0.000,0.750,0.283,27.676), an );\r\n    col = brush( col, uv, vec4(0.965,0.596,0.572,28.055), an );\r\n    col = brush( col, uv, vec4(0.902,0.803,0.953,24.976), an );\r\n    col = brush( col, uv, vec4(0.957,0.498,0.600,16.126), an );\r\n    col = brush( col, uv, vec4(0.914,0.322,0.432,15.634), an );\r\n    col = brush( col, uv, vec4(0.008,0.025,0.621,17.809), an );\r\n    col = brush( col, uv, vec4(0.000,0.916,0.713,56.889), an );\r\n    col = brush( col, uv, vec4(0.914,0.547,0.971,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.207,0.432,37.926), an );\r\n    col = brush( col, uv, vec4(0.875,0.176,0.793,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.646,0.668,41.796), an );\r\n    col = brush( col, uv, vec4(1.000,0.721,0.691,51.200), an );\r\n    col = brush( col, uv, vec4(0.451,0.559,0.754,49.951), an );\r\n    col = brush( col, uv, vec4(0.969,0.846,0.750,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.146,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.613,0.635,85.333), an );\r\n    col = brush( col, uv, vec4(0.596,0.807,0.150,58.514), an );\r\n    col = brush( col, uv, vec4(0.898,0.330,0.760,40.157), an );\r\n    col = brush( col, uv, vec4(0.694,0.594,0.012,51.200), an );\r\n    col = brush( col, uv, vec4(0.698,0.592,0.055,53.895), an );\r\n    col = brush( col, uv, vec4(0.902,0.268,0.773,39.385), an );\r\n    col = brush( col, uv, vec4(0.925,0.838,0.660,58.514), an );\r\n    col = brush( col, uv, vec4(0.843,0.670,0.242,28.444), an );\r\n    col = brush( col, uv, vec4(0.243,0.465,0.285,85.333), an );\r\n    col = brush( col, uv, vec4(0.816,0.588,0.674,44.522), an );\r\n    col = brush( col, uv, vec4(0.008,0.283,0.115,8.031), an );\r\n    col = brush( col, uv, vec4(0.247,0.414,0.691,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.104,0.781,60.235), an );\r\n    col = brush( col, uv, vec4(0.000,0.619,0.660,60.235), an );\r\n    col = brush( col, uv, vec4(0.584,0.650,0.994,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.219,0.393,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.307,0.645,97.524), an );\r\n    col = brush( col, uv, vec4(0.953,0.639,0.771,38.642), an );\r\n    col = brush( col, uv, vec4(0.000,0.238,0.357,34.712), an );\r\n    col = brush( col, uv, vec4(0.922,0.713,0.352,53.895), an );\r\n    col = brush( col, uv, vec4(0.965,0.387,0.748,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.898,0.633,41.796), an );\r\n    col = brush( col, uv, vec4(0.941,0.352,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.933,0.439,0.725,30.567), an );\r\n    col = brush( col, uv, vec4(0.310,0.541,0.906,47.628), an );\r\n    col = brush( col, uv, vec4(0.941,0.502,0.689,24.094), an );\r\n    col = brush( col, uv, vec4(0.094,0.527,0.330,85.333), an );\r\n    col = brush( col, uv, vec4(0.000,0.090,0.688,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.652,0.713,75.852), an );\r\n    col = brush( col, uv, vec4(0.949,0.320,0.623,107.789), an );\r\n    col = brush( col, uv, vec4(0.890,0.775,0.750,22.505), an );\r\n    col = brush( col, uv, vec4(0.012,0.918,0.490,14.322), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.967,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.324,0.676,64.000), an );\r\n    col = brush( col, uv, vec4(0.008,0.141,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.633,0.707,75.852), an );\r\n    col = brush( col, uv, vec4(0.910,0.385,0.207,44.522), an );\r\n    col = brush( col, uv, vec4(0.012,0.703,0.182,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.617,0.703,73.143), an );\r\n    col = brush( col, uv, vec4(0.890,0.352,0.225,45.511), an );\r\n    col = brush( col, uv, vec4(0.933,0.826,0.604,44.522), an );\r\n    col = brush( col, uv, vec4(0.914,0.777,0.574,25.924), an );\r\n    col = brush( col, uv, vec4(0.631,0.781,0.182,68.267), an );\r\n    col = brush( col, uv, vec4(1.000,0.873,0.916,48.762), an );\r\n    col = brush( col, uv, vec4(0.694,0.520,0.113,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.926,58.514), an );\r\n    col = brush( col, uv, vec4(0.184,0.598,0.344,146.286), an );\r\n    col = brush( col, uv, vec4(0.863,0.678,0.250,35.310), an );\r\n    col = brush( col, uv, vec4(0.090,0.566,0.332,78.769), an );\r\n    col = brush( col, uv, vec4(0.420,0.445,0.301,56.889), an );\r\n    col = brush( col, uv, vec4(0.973,0.617,0.516,18.124), an );\r\n    col = brush( col, uv, vec4(0.000,0.191,0.500,39.385), an );\r\n    col = brush( col, uv, vec4(0.000,0.240,0.326,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.264,0.322,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.604,0.699,70.621), an );\r\n    col = brush( col, uv, vec4(0.000,0.113,0.604,43.574), an );\r\n    col = brush( col, uv, vec4(0.894,0.760,0.697,49.951), an );\r\n    col = brush( col, uv, vec4(0.914,0.725,0.383,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.199,0.467,48.762), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.660,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.611,0.191,45.511), an );\r\n    col = brush( col, uv, vec4(0.059,0.789,0.869,30.118), an );\r\n    col = brush( col, uv, vec4(0.976,0.641,0.213,40.960), an );\r\n    col = brush( col, uv, vec4(0.918,0.402,0.742,47.628), an );\r\n    col = brush( col, uv, vec4(0.945,0.717,0.582,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.299,0.672,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.719,0.666,48.762), an );\r\n    col = brush( col, uv, vec4(0.882,0.697,0.271,58.514), an );\r\n    col = brush( col, uv, vec4(0.929,0.752,0.436,64.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.867,0.813,56.889), an );\r\n    col = brush( col, uv, vec4(0.643,0.588,0.090,64.000), an );\r\n    col = brush( col, uv, vec4(0.012,0.063,0.922,10.952), an );\r\n    col = brush( col, uv, vec4(0.878,0.186,0.750,31.508), an );\r\n    col = brush( col, uv, vec4(0.953,0.648,0.613,120.471), an );\r\n    col = brush( col, uv, vec4(0.973,0.180,0.576,45.511), an );\r\n    col = brush( col, uv, vec4(0.741,0.943,0.076,52.513), an );\r\n    col = brush( col, uv, vec4(0.059,0.545,0.332,89.043), an );\r\n    col = brush( col, uv, vec4(0.094,0.295,0.734,85.333), an );\r\n    col = brush( col, uv, vec4(0.008,0.676,0.721,85.333), an );\r\n    col = brush( col, uv, vec4(0.550,0.350,0.650,85.000), an );\r\n\r\n\tfragColor = vec4(col,col,col,1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// These are 316 gaussian points (201 brushes by using local symmetry) forming the picture\r\n// of Audrey Hepburn. They pack down to 800 bytes (34 bits per point) before huffman/arithmetic\r\n// compression.\r\n//\r\n// The points were chosen by (very quickly) runing this \r\n//\r\n// http://www.iquilezles.org/www/articles/genetic/genetic.htm\r\n//\r\n// with some importance sampling for the eyes, nouse and mouth.\r\n\r\nfloat brush( float col, vec2 p, in vec4 b, float an )\r\n{\r\n\tp += an*cos( iTime + 100.0*b.yz );\r\n\t\t\t\t\r\n    vec2 dd = p - b.yz;\r\n    col = mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    if( abs(b.z-0.5)<0.251 )\r\n    {\r\n        dd.x = p.x - 1.0 + b.y;\r\n        col =  mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    }\r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.y;\r\n    uv.x -=  0.5*(iResolution.x / iResolution.y - 1.0);\r\n\r\n    float an = smoothstep( 0.0, 1.0, cos(iTime) );\r\n\r\n\tfloat col = 0.0;\r\n\r\n    col = brush( col, uv, vec4(1.000,0.371,0.379,11.770), an );\r\n    col = brush( col, uv, vec4(0.992,0.545,0.551,8.359), an );\r\n    col = brush( col, uv, vec4(0.749,0.623,0.990,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.510,0.395,11.315), an );\r\n    col = brush( col, uv, vec4(1.000,0.723,0.564,15.170), an );\r\n    col = brush( col, uv, vec4(0.953,0.729,0.750,14.629), an );\r\n    col = brush( col, uv, vec4(0.706,0.982,0.033,16.254), an );\r\n    col = brush( col, uv, vec4(1.000,0.855,0.652,26.256), an );\r\n    col = brush( col, uv, vec4(1.000,0.664,0.623,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.881,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.686,0.682,0.900,27.676), an );\r\n    col = brush( col, uv, vec4(1.000,0.189,0.684,18.618), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.422,0.195,44.522), an );\r\n    col = brush( col, uv, vec4(1.000,0.779,0.750,16.787), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.330,14.222), an );\r\n    col = brush( col, uv, vec4(1.000,0.197,0.648,22.505), an );\r\n    col = brush( col, uv, vec4(0.702,0.512,0.393,35.310), an );\r\n    col = brush( col, uv, vec4(1.000,0.744,0.621,14.949), an );\r\n    col = brush( col, uv, vec4(0.671,0.885,0.092,24.675), an );\r\n    col = brush( col, uv, vec4(0.000,0.344,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.760,0.465,40.960), an );\r\n    col = brush( col, uv, vec4(0.008,0.908,0.311,8.031), an );\r\n    col = brush( col, uv, vec4(0.016,0.959,0.750,10.039), an );\r\n    col = brush( col, uv, vec4(0.004,0.930,0.750,12.800), an );\r\n    col = brush( col, uv, vec4(1.000,0.555,0.250,19.883), an );\r\n    col = brush( col, uv, vec4(1.000,0.770,1.018,15.876), an );\r\n    col = brush( col, uv, vec4(0.000,0.828,0.756,36.571), an );\r\n    col = brush( col, uv, vec4(0.580,0.566,0.424,89.043), an );\r\n    col = brush( col, uv, vec4(0.988,0.162,0.691,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.314,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.947,0.125,32.000), an );\r\n    col = brush( col, uv, vec4(0.914,0.844,0.725,52.513), an );\r\n    col = brush( col, uv, vec4(1.000,0.313,0.762,42.667), an );\r\n    col = brush( col, uv, vec4(0.996,0.676,0.689,85.333), an );\r\n    col = brush( col, uv, vec4(0.980,0.346,0.559,24.675), an );\r\n    col = brush( col, uv, vec4(1.000,0.553,0.250,18.789), an );\r\n    col = brush( col, uv, vec4(0.004,0.258,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.420,0.742,30.567), an );\r\n    col = brush( col, uv, vec4(0.906,0.543,0.250,22.756), an );\r\n    col = brush( col, uv, vec4(0.863,0.674,0.322,20.078), an );\r\n    col = brush( col, uv, vec4(0.753,0.357,0.686,78.769), an );\r\n    col = brush( col, uv, vec4(0.906,0.795,0.705,37.236), an );\r\n    col = brush( col, uv, vec4(0.933,0.520,0.365,38.642), an );\r\n    col = brush( col, uv, vec4(0.996,0.318,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.337,0.486,0.281,81.920), an );\r\n    col = brush( col, uv, vec4(0.965,0.691,0.516,16.650), an );\r\n    col = brush( col, uv, vec4(0.808,0.582,0.973,52.513), an );\r\n    col = brush( col, uv, vec4(0.012,0.240,0.928,8.063), an );\r\n    col = brush( col, uv, vec4(1.000,0.496,0.217,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.658,0.953,34.133), an );\r\n    col = brush( col, uv, vec4(0.871,0.582,0.172,62.061), an );\r\n    col = brush( col, uv, vec4(0.855,0.346,0.342,17.504), an );\r\n    col = brush( col, uv, vec4(0.878,0.787,0.648,28.845), an );\r\n    col = brush( col, uv, vec4(0.000,0.984,0.111,35.310), an );\r\n    col = brush( col, uv, vec4(0.855,0.514,0.965,66.065), an );\r\n    col = brush( col, uv, vec4(0.561,0.613,0.350,81.920), an );\r\n    col = brush( col, uv, vec4(0.992,0.818,0.902,21.558), an );\r\n    col = brush( col, uv, vec4(0.914,0.746,0.615,40.157), an );\r\n    col = brush( col, uv, vec4(0.557,0.580,0.125,60.235), an );\r\n    col = brush( col, uv, vec4(0.475,0.547,0.414,70.621), an );\r\n    col = brush( col, uv, vec4(0.843,0.680,0.793,20.277), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.758,56.889), an );\r\n    col = brush( col, uv, vec4(1.000,0.299,0.691,68.267), an );\r\n    col = brush( col, uv, vec4(0.737,0.518,0.100,68.267), an );\r\n    col = brush( col, uv, vec4(0.996,0.227,0.514,41.796), an );\r\n    col = brush( col, uv, vec4(0.929,0.850,0.770,62.061), an );\r\n    col = brush( col, uv, vec4(0.682,0.834,0.111,30.118), an );\r\n    col = brush( col, uv, vec4(0.996,0.854,0.793,58.514), an );\r\n    col = brush( col, uv, vec4(0.490,0.736,0.889,19.321), an );\r\n    col = brush( col, uv, vec4(0.980,0.465,0.725,16.126), an );\r\n    col = brush( col, uv, vec4(0.992,0.484,1.010,23.273), an );\r\n    col = brush( col, uv, vec4(0.008,0.949,0.727,23.540), an );\r\n    col = brush( col, uv, vec4(0.012,0.086,0.086,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.121,0.750,44.522), an );\r\n    col = brush( col, uv, vec4(0.427,0.617,0.891,27.676), an );\r\n    col = brush( col, uv, vec4(0.804,0.693,0.633,78.769), an );\r\n    col = brush( col, uv, vec4(0.012,0.711,0.084,13.745), an );\r\n    col = brush( col, uv, vec4(0.082,0.584,0.338,107.789), an );\r\n    col = brush( col, uv, vec4(0.929,0.613,0.268,19.692), an );\r\n    col = brush( col, uv, vec4(0.200,0.549,0.420,128.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.402,0.717,26.947), an );\r\n    col = brush( col, uv, vec4(0.000,0.551,0.168,45.511), an );\r\n    col = brush( col, uv, vec4(0.992,0.627,0.621,56.889), an );\r\n    col = brush( col, uv, vec4(0.902,0.361,0.748,40.960), an );\r\n    col = brush( col, uv, vec4(0.984,0.344,0.754,38.642), an );\r\n    col = brush( col, uv, vec4(0.902,0.203,0.818,51.200), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.803,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.738,0.691,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.385,0.797,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.725,0.305,62.061), an );\r\n    col = brush( col, uv, vec4(0.000,0.150,0.750,45.511), an );\r\n    col = brush( col, uv, vec4(1.000,0.742,0.408,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.645,0.643,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.438,35.310), an );\r\n    col = brush( col, uv, vec4(0.510,0.564,0.789,18.450), an );\r\n    col = brush( col, uv, vec4(0.863,0.211,0.781,30.567), an );\r\n    col = brush( col, uv, vec4(0.106,0.508,0.328,89.043), an );\r\n    col = brush( col, uv, vec4(0.012,0.410,0.875,14.629), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.877,48.762), an );\r\n    col = brush( col, uv, vec4(1.000,0.258,0.779,37.926), an );\r\n    col = brush( col, uv, vec4(0.000,0.436,0.807,28.845), an );\r\n    col = brush( col, uv, vec4(0.918,0.861,0.836,49.951), an );\r\n    col = brush( col, uv, vec4(1.000,0.291,0.770,40.960), an );\r\n    col = brush( col, uv, vec4(0.000,0.750,0.283,27.676), an );\r\n    col = brush( col, uv, vec4(0.965,0.596,0.572,28.055), an );\r\n    col = brush( col, uv, vec4(0.902,0.803,0.953,24.976), an );\r\n    col = brush( col, uv, vec4(0.957,0.498,0.600,16.126), an );\r\n    col = brush( col, uv, vec4(0.914,0.322,0.432,15.634), an );\r\n    col = brush( col, uv, vec4(0.008,0.025,0.621,17.809), an );\r\n    col = brush( col, uv, vec4(0.000,0.916,0.713,56.889), an );\r\n    col = brush( col, uv, vec4(0.914,0.547,0.971,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.207,0.432,37.926), an );\r\n    col = brush( col, uv, vec4(0.875,0.176,0.793,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.646,0.668,41.796), an );\r\n    col = brush( col, uv, vec4(1.000,0.721,0.691,51.200), an );\r\n    col = brush( col, uv, vec4(0.451,0.559,0.754,49.951), an );\r\n    col = brush( col, uv, vec4(0.969,0.846,0.750,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.146,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.613,0.635,85.333), an );\r\n    col = brush( col, uv, vec4(0.596,0.807,0.150,58.514), an );\r\n    col = brush( col, uv, vec4(0.898,0.330,0.760,40.157), an );\r\n    col = brush( col, uv, vec4(0.694,0.594,0.012,51.200), an );\r\n    col = brush( col, uv, vec4(0.698,0.592,0.055,53.895), an );\r\n    col = brush( col, uv, vec4(0.902,0.268,0.773,39.385), an );\r\n    col = brush( col, uv, vec4(0.925,0.838,0.660,58.514), an );\r\n    col = brush( col, uv, vec4(0.843,0.670,0.242,28.444), an );\r\n    col = brush( col, uv, vec4(0.243,0.465,0.285,85.333), an );\r\n    col = brush( col, uv, vec4(0.816,0.588,0.674,44.522), an );\r\n    col = brush( col, uv, vec4(0.008,0.283,0.115,8.031), an );\r\n    col = brush( col, uv, vec4(0.247,0.414,0.691,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.104,0.781,60.235), an );\r\n    col = brush( col, uv, vec4(0.000,0.619,0.660,60.235), an );\r\n    col = brush( col, uv, vec4(0.584,0.650,0.994,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.219,0.393,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.307,0.645,97.524), an );\r\n    col = brush( col, uv, vec4(0.953,0.639,0.771,38.642), an );\r\n    col = brush( col, uv, vec4(0.000,0.238,0.357,34.712), an );\r\n    col = brush( col, uv, vec4(0.922,0.713,0.352,53.895), an );\r\n    col = brush( col, uv, vec4(0.965,0.387,0.748,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.898,0.633,41.796), an );\r\n    col = brush( col, uv, vec4(0.941,0.352,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.933,0.439,0.725,30.567), an );\r\n    col = brush( col, uv, vec4(0.310,0.541,0.906,47.628), an );\r\n    col = brush( col, uv, vec4(0.941,0.502,0.689,24.094), an );\r\n    col = brush( col, uv, vec4(0.094,0.527,0.330,85.333), an );\r\n    col = brush( col, uv, vec4(0.000,0.090,0.688,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.652,0.713,75.852), an );\r\n    col = brush( col, uv, vec4(0.949,0.320,0.623,107.789), an );\r\n    col = brush( col, uv, vec4(0.890,0.775,0.750,22.505), an );\r\n    col = brush( col, uv, vec4(0.012,0.918,0.490,14.322), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.967,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.324,0.676,64.000), an );\r\n    col = brush( col, uv, vec4(0.008,0.141,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.633,0.707,75.852), an );\r\n    col = brush( col, uv, vec4(0.910,0.385,0.207,44.522), an );\r\n    col = brush( col, uv, vec4(0.012,0.703,0.182,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.617,0.703,73.143), an );\r\n    col = brush( col, uv, vec4(0.890,0.352,0.225,45.511), an );\r\n    col = brush( col, uv, vec4(0.933,0.826,0.604,44.522), an );\r\n    col = brush( col, uv, vec4(0.914,0.777,0.574,25.924), an );\r\n    col = brush( col, uv, vec4(0.631,0.781,0.182,68.267), an );\r\n    col = brush( col, uv, vec4(1.000,0.873,0.916,48.762), an );\r\n    col = brush( col, uv, vec4(0.694,0.520,0.113,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.926,58.514), an );\r\n    col = brush( col, uv, vec4(0.184,0.598,0.344,146.286), an );\r\n    col = brush( col, uv, vec4(0.863,0.678,0.250,35.310), an );\r\n    col = brush( col, uv, vec4(0.090,0.566,0.332,78.769), an );\r\n    col = brush( col, uv, vec4(0.420,0.445,0.301,56.889), an );\r\n    col = brush( col, uv, vec4(0.973,0.617,0.516,18.124), an );\r\n    col = brush( col, uv, vec4(0.000,0.191,0.500,39.385), an );\r\n    col = brush( col, uv, vec4(0.000,0.240,0.326,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.264,0.322,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.604,0.699,70.621), an );\r\n    col = brush( col, uv, vec4(0.000,0.113,0.604,43.574), an );\r\n    col = brush( col, uv, vec4(0.894,0.760,0.697,49.951), an );\r\n    col = brush( col, uv, vec4(0.914,0.725,0.383,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.199,0.467,48.762), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.660,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.611,0.191,45.511), an );\r\n    col = brush( col, uv, vec4(0.059,0.789,0.869,30.118), an );\r\n    col = brush( col, uv, vec4(0.976,0.641,0.213,40.960), an );\r\n    col = brush( col, uv, vec4(0.918,0.402,0.742,47.628), an );\r\n    col = brush( col, uv, vec4(0.945,0.717,0.582,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.299,0.672,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.719,0.666,48.762), an );\r\n    col = brush( col, uv, vec4(0.882,0.697,0.271,58.514), an );\r\n    col = brush( col, uv, vec4(0.929,0.752,0.436,64.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.867,0.813,56.889), an );\r\n    col = brush( col, uv, vec4(0.643,0.588,0.090,64.000), an );\r\n    col = brush( col, uv, vec4(0.012,0.063,0.922,10.952), an );\r\n    col = brush( col, uv, vec4(0.878,0.186,0.750,31.508), an );\r\n    col = brush( col, uv, vec4(0.953,0.648,0.613,120.471), an );\r\n    col = brush( col, uv, vec4(0.973,0.180,0.576,45.511), an );\r\n    col = brush( col, uv, vec4(0.741,0.943,0.076,52.513), an );\r\n    col = brush( col, uv, vec4(0.059,0.545,0.332,89.043), an );\r\n    col = brush( col, uv, vec4(0.094,0.295,0.734,85.333), an );\r\n    col = brush( col, uv, vec4(0.008,0.676,0.721,85.333), an );\r\n    col = brush( col, uv, vec4(0.550,0.350,0.650,85.000), an );\r\n\r\n\tfragColor = vec4(col,col,col,1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Image - Audrey","id":"62576e86697641c999341f0e36c0c26d","date":null,"viewed":0,"name":"Image - Audrey","description":"If you were entrusted to portray Audrey Hepburn (you've seen \"Breakfast at Tiffany's\") BUT asked to do it in no more than 316 brushstrokes you'd surely have to be very careful on your choice of strokes! (you'll only see 201 in the code thanks to symmetry)\nhttps://www.shadertoy.com/view/4df3D8","likes":0,"published":null,"tags":["2d"," compression"," genetic"," photo"," image"]},"ver":null,"info":{"Name":"Image - Audrey","id":"62576e86697641c999341f0e36c0c26d","date":null,"viewed":0,"name":"Image - Audrey","description":"If you were entrusted to portray Audrey Hepburn (you've seen \"Breakfast at Tiffany's\") BUT asked to do it in no more than 316 brushstrokes you'd surely have to be very careful on your choice of strokes! (you'll only see 201 in the code thanks to symmetry)\nhttps://www.shadertoy.com/view/4df3D8","likes":0,"published":null,"tags":["2d"," compression"," genetic"," photo"," image"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// These are 316 gaussian points (201 brushes by using local symmetry) forming the picture\r\n// of Audrey Hepburn. They pack down to 800 bytes (34 bits per point) before huffman/arithmetic\r\n// compression.\r\n//\r\n// The points were chosen by (very quickly) runing this \r\n//\r\n// http://www.iquilezles.org/www/articles/genetic/genetic.htm\r\n//\r\n// with some importance sampling for the eyes, nouse and mouth.\r\n\r\nfloat brush( float col, vec2 p, in vec4 b, float an )\r\n{\r\n\tp += an*cos( iTime + 100.0*b.yz );\r\n\t\t\t\t\r\n    vec2 dd = p - b.yz;\r\n    col = mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    if( abs(b.z-0.5)<0.251 )\r\n    {\r\n        dd.x = p.x - 1.0 + b.y;\r\n        col =  mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    }\r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.y;\r\n    uv.x -=  0.5*(iResolution.x / iResolution.y - 1.0);\r\n\r\n    float an = smoothstep( 0.0, 1.0, cos(iTime) );\r\n\r\n\tfloat col = 0.0;\r\n\r\n    col = brush( col, uv, vec4(1.000,0.371,0.379,11.770), an );\r\n    col = brush( col, uv, vec4(0.992,0.545,0.551,8.359), an );\r\n    col = brush( col, uv, vec4(0.749,0.623,0.990,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.510,0.395,11.315), an );\r\n    col = brush( col, uv, vec4(1.000,0.723,0.564,15.170), an );\r\n    col = brush( col, uv, vec4(0.953,0.729,0.750,14.629), an );\r\n    col = brush( col, uv, vec4(0.706,0.982,0.033,16.254), an );\r\n    col = brush( col, uv, vec4(1.000,0.855,0.652,26.256), an );\r\n    col = brush( col, uv, vec4(1.000,0.664,0.623,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.881,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.686,0.682,0.900,27.676), an );\r\n    col = brush( col, uv, vec4(1.000,0.189,0.684,18.618), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.422,0.195,44.522), an );\r\n    col = brush( col, uv, vec4(1.000,0.779,0.750,16.787), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.330,14.222), an );\r\n    col = brush( col, uv, vec4(1.000,0.197,0.648,22.505), an );\r\n    col = brush( col, uv, vec4(0.702,0.512,0.393,35.310), an );\r\n    col = brush( col, uv, vec4(1.000,0.744,0.621,14.949), an );\r\n    col = brush( col, uv, vec4(0.671,0.885,0.092,24.675), an );\r\n    col = brush( col, uv, vec4(0.000,0.344,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.760,0.465,40.960), an );\r\n    col = brush( col, uv, vec4(0.008,0.908,0.311,8.031), an );\r\n    col = brush( col, uv, vec4(0.016,0.959,0.750,10.039), an );\r\n    col = brush( col, uv, vec4(0.004,0.930,0.750,12.800), an );\r\n    col = brush( col, uv, vec4(1.000,0.555,0.250,19.883), an );\r\n    col = brush( col, uv, vec4(1.000,0.770,1.018,15.876), an );\r\n    col = brush( col, uv, vec4(0.000,0.828,0.756,36.571), an );\r\n    col = brush( col, uv, vec4(0.580,0.566,0.424,89.043), an );\r\n    col = brush( col, uv, vec4(0.988,0.162,0.691,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.314,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.947,0.125,32.000), an );\r\n    col = brush( col, uv, vec4(0.914,0.844,0.725,52.513), an );\r\n    col = brush( col, uv, vec4(1.000,0.313,0.762,42.667), an );\r\n    col = brush( col, uv, vec4(0.996,0.676,0.689,85.333), an );\r\n    col = brush( col, uv, vec4(0.980,0.346,0.559,24.675), an );\r\n    col = brush( col, uv, vec4(1.000,0.553,0.250,18.789), an );\r\n    col = brush( col, uv, vec4(0.004,0.258,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.420,0.742,30.567), an );\r\n    col = brush( col, uv, vec4(0.906,0.543,0.250,22.756), an );\r\n    col = brush( col, uv, vec4(0.863,0.674,0.322,20.078), an );\r\n    col = brush( col, uv, vec4(0.753,0.357,0.686,78.769), an );\r\n    col = brush( col, uv, vec4(0.906,0.795,0.705,37.236), an );\r\n    col = brush( col, uv, vec4(0.933,0.520,0.365,38.642), an );\r\n    col = brush( col, uv, vec4(0.996,0.318,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.337,0.486,0.281,81.920), an );\r\n    col = brush( col, uv, vec4(0.965,0.691,0.516,16.650), an );\r\n    col = brush( col, uv, vec4(0.808,0.582,0.973,52.513), an );\r\n    col = brush( col, uv, vec4(0.012,0.240,0.928,8.063), an );\r\n    col = brush( col, uv, vec4(1.000,0.496,0.217,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.658,0.953,34.133), an );\r\n    col = brush( col, uv, vec4(0.871,0.582,0.172,62.061), an );\r\n    col = brush( col, uv, vec4(0.855,0.346,0.342,17.504), an );\r\n    col = brush( col, uv, vec4(0.878,0.787,0.648,28.845), an );\r\n    col = brush( col, uv, vec4(0.000,0.984,0.111,35.310), an );\r\n    col = brush( col, uv, vec4(0.855,0.514,0.965,66.065), an );\r\n    col = brush( col, uv, vec4(0.561,0.613,0.350,81.920), an );\r\n    col = brush( col, uv, vec4(0.992,0.818,0.902,21.558), an );\r\n    col = brush( col, uv, vec4(0.914,0.746,0.615,40.157), an );\r\n    col = brush( col, uv, vec4(0.557,0.580,0.125,60.235), an );\r\n    col = brush( col, uv, vec4(0.475,0.547,0.414,70.621), an );\r\n    col = brush( col, uv, vec4(0.843,0.680,0.793,20.277), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.758,56.889), an );\r\n    col = brush( col, uv, vec4(1.000,0.299,0.691,68.267), an );\r\n    col = brush( col, uv, vec4(0.737,0.518,0.100,68.267), an );\r\n    col = brush( col, uv, vec4(0.996,0.227,0.514,41.796), an );\r\n    col = brush( col, uv, vec4(0.929,0.850,0.770,62.061), an );\r\n    col = brush( col, uv, vec4(0.682,0.834,0.111,30.118), an );\r\n    col = brush( col, uv, vec4(0.996,0.854,0.793,58.514), an );\r\n    col = brush( col, uv, vec4(0.490,0.736,0.889,19.321), an );\r\n    col = brush( col, uv, vec4(0.980,0.465,0.725,16.126), an );\r\n    col = brush( col, uv, vec4(0.992,0.484,1.010,23.273), an );\r\n    col = brush( col, uv, vec4(0.008,0.949,0.727,23.540), an );\r\n    col = brush( col, uv, vec4(0.012,0.086,0.086,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.121,0.750,44.522), an );\r\n    col = brush( col, uv, vec4(0.427,0.617,0.891,27.676), an );\r\n    col = brush( col, uv, vec4(0.804,0.693,0.633,78.769), an );\r\n    col = brush( col, uv, vec4(0.012,0.711,0.084,13.745), an );\r\n    col = brush( col, uv, vec4(0.082,0.584,0.338,107.789), an );\r\n    col = brush( col, uv, vec4(0.929,0.613,0.268,19.692), an );\r\n    col = brush( col, uv, vec4(0.200,0.549,0.420,128.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.402,0.717,26.947), an );\r\n    col = brush( col, uv, vec4(0.000,0.551,0.168,45.511), an );\r\n    col = brush( col, uv, vec4(0.992,0.627,0.621,56.889), an );\r\n    col = brush( col, uv, vec4(0.902,0.361,0.748,40.960), an );\r\n    col = brush( col, uv, vec4(0.984,0.344,0.754,38.642), an );\r\n    col = brush( col, uv, vec4(0.902,0.203,0.818,51.200), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.803,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.738,0.691,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.385,0.797,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.725,0.305,62.061), an );\r\n    col = brush( col, uv, vec4(0.000,0.150,0.750,45.511), an );\r\n    col = brush( col, uv, vec4(1.000,0.742,0.408,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.645,0.643,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.438,35.310), an );\r\n    col = brush( col, uv, vec4(0.510,0.564,0.789,18.450), an );\r\n    col = brush( col, uv, vec4(0.863,0.211,0.781,30.567), an );\r\n    col = brush( col, uv, vec4(0.106,0.508,0.328,89.043), an );\r\n    col = brush( col, uv, vec4(0.012,0.410,0.875,14.629), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.877,48.762), an );\r\n    col = brush( col, uv, vec4(1.000,0.258,0.779,37.926), an );\r\n    col = brush( col, uv, vec4(0.000,0.436,0.807,28.845), an );\r\n    col = brush( col, uv, vec4(0.918,0.861,0.836,49.951), an );\r\n    col = brush( col, uv, vec4(1.000,0.291,0.770,40.960), an );\r\n    col = brush( col, uv, vec4(0.000,0.750,0.283,27.676), an );\r\n    col = brush( col, uv, vec4(0.965,0.596,0.572,28.055), an );\r\n    col = brush( col, uv, vec4(0.902,0.803,0.953,24.976), an );\r\n    col = brush( col, uv, vec4(0.957,0.498,0.600,16.126), an );\r\n    col = brush( col, uv, vec4(0.914,0.322,0.432,15.634), an );\r\n    col = brush( col, uv, vec4(0.008,0.025,0.621,17.809), an );\r\n    col = brush( col, uv, vec4(0.000,0.916,0.713,56.889), an );\r\n    col = brush( col, uv, vec4(0.914,0.547,0.971,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.207,0.432,37.926), an );\r\n    col = brush( col, uv, vec4(0.875,0.176,0.793,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.646,0.668,41.796), an );\r\n    col = brush( col, uv, vec4(1.000,0.721,0.691,51.200), an );\r\n    col = brush( col, uv, vec4(0.451,0.559,0.754,49.951), an );\r\n    col = brush( col, uv, vec4(0.969,0.846,0.750,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.146,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.613,0.635,85.333), an );\r\n    col = brush( col, uv, vec4(0.596,0.807,0.150,58.514), an );\r\n    col = brush( col, uv, vec4(0.898,0.330,0.760,40.157), an );\r\n    col = brush( col, uv, vec4(0.694,0.594,0.012,51.200), an );\r\n    col = brush( col, uv, vec4(0.698,0.592,0.055,53.895), an );\r\n    col = brush( col, uv, vec4(0.902,0.268,0.773,39.385), an );\r\n    col = brush( col, uv, vec4(0.925,0.838,0.660,58.514), an );\r\n    col = brush( col, uv, vec4(0.843,0.670,0.242,28.444), an );\r\n    col = brush( col, uv, vec4(0.243,0.465,0.285,85.333), an );\r\n    col = brush( col, uv, vec4(0.816,0.588,0.674,44.522), an );\r\n    col = brush( col, uv, vec4(0.008,0.283,0.115,8.031), an );\r\n    col = brush( col, uv, vec4(0.247,0.414,0.691,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.104,0.781,60.235), an );\r\n    col = brush( col, uv, vec4(0.000,0.619,0.660,60.235), an );\r\n    col = brush( col, uv, vec4(0.584,0.650,0.994,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.219,0.393,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.307,0.645,97.524), an );\r\n    col = brush( col, uv, vec4(0.953,0.639,0.771,38.642), an );\r\n    col = brush( col, uv, vec4(0.000,0.238,0.357,34.712), an );\r\n    col = brush( col, uv, vec4(0.922,0.713,0.352,53.895), an );\r\n    col = brush( col, uv, vec4(0.965,0.387,0.748,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.898,0.633,41.796), an );\r\n    col = brush( col, uv, vec4(0.941,0.352,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.933,0.439,0.725,30.567), an );\r\n    col = brush( col, uv, vec4(0.310,0.541,0.906,47.628), an );\r\n    col = brush( col, uv, vec4(0.941,0.502,0.689,24.094), an );\r\n    col = brush( col, uv, vec4(0.094,0.527,0.330,85.333), an );\r\n    col = brush( col, uv, vec4(0.000,0.090,0.688,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.652,0.713,75.852), an );\r\n    col = brush( col, uv, vec4(0.949,0.320,0.623,107.789), an );\r\n    col = brush( col, uv, vec4(0.890,0.775,0.750,22.505), an );\r\n    col = brush( col, uv, vec4(0.012,0.918,0.490,14.322), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.967,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.324,0.676,64.000), an );\r\n    col = brush( col, uv, vec4(0.008,0.141,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.633,0.707,75.852), an );\r\n    col = brush( col, uv, vec4(0.910,0.385,0.207,44.522), an );\r\n    col = brush( col, uv, vec4(0.012,0.703,0.182,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.617,0.703,73.143), an );\r\n    col = brush( col, uv, vec4(0.890,0.352,0.225,45.511), an );\r\n    col = brush( col, uv, vec4(0.933,0.826,0.604,44.522), an );\r\n    col = brush( col, uv, vec4(0.914,0.777,0.574,25.924), an );\r\n    col = brush( col, uv, vec4(0.631,0.781,0.182,68.267), an );\r\n    col = brush( col, uv, vec4(1.000,0.873,0.916,48.762), an );\r\n    col = brush( col, uv, vec4(0.694,0.520,0.113,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.926,58.514), an );\r\n    col = brush( col, uv, vec4(0.184,0.598,0.344,146.286), an );\r\n    col = brush( col, uv, vec4(0.863,0.678,0.250,35.310), an );\r\n    col = brush( col, uv, vec4(0.090,0.566,0.332,78.769), an );\r\n    col = brush( col, uv, vec4(0.420,0.445,0.301,56.889), an );\r\n    col = brush( col, uv, vec4(0.973,0.617,0.516,18.124), an );\r\n    col = brush( col, uv, vec4(0.000,0.191,0.500,39.385), an );\r\n    col = brush( col, uv, vec4(0.000,0.240,0.326,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.264,0.322,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.604,0.699,70.621), an );\r\n    col = brush( col, uv, vec4(0.000,0.113,0.604,43.574), an );\r\n    col = brush( col, uv, vec4(0.894,0.760,0.697,49.951), an );\r\n    col = brush( col, uv, vec4(0.914,0.725,0.383,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.199,0.467,48.762), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.660,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.611,0.191,45.511), an );\r\n    col = brush( col, uv, vec4(0.059,0.789,0.869,30.118), an );\r\n    col = brush( col, uv, vec4(0.976,0.641,0.213,40.960), an );\r\n    col = brush( col, uv, vec4(0.918,0.402,0.742,47.628), an );\r\n    col = brush( col, uv, vec4(0.945,0.717,0.582,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.299,0.672,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.719,0.666,48.762), an );\r\n    col = brush( col, uv, vec4(0.882,0.697,0.271,58.514), an );\r\n    col = brush( col, uv, vec4(0.929,0.752,0.436,64.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.867,0.813,56.889), an );\r\n    col = brush( col, uv, vec4(0.643,0.588,0.090,64.000), an );\r\n    col = brush( col, uv, vec4(0.012,0.063,0.922,10.952), an );\r\n    col = brush( col, uv, vec4(0.878,0.186,0.750,31.508), an );\r\n    col = brush( col, uv, vec4(0.953,0.648,0.613,120.471), an );\r\n    col = brush( col, uv, vec4(0.973,0.180,0.576,45.511), an );\r\n    col = brush( col, uv, vec4(0.741,0.943,0.076,52.513), an );\r\n    col = brush( col, uv, vec4(0.059,0.545,0.332,89.043), an );\r\n    col = brush( col, uv, vec4(0.094,0.295,0.734,85.333), an );\r\n    col = brush( col, uv, vec4(0.008,0.676,0.721,85.333), an );\r\n    col = brush( col, uv, vec4(0.550,0.350,0.650,85.000), an );\r\n\r\n\tfragColor = vec4(col,col,col,1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// These are 316 gaussian points (201 brushes by using local symmetry) forming the picture\r\n// of Audrey Hepburn. They pack down to 800 bytes (34 bits per point) before huffman/arithmetic\r\n// compression.\r\n//\r\n// The points were chosen by (very quickly) runing this \r\n//\r\n// http://www.iquilezles.org/www/articles/genetic/genetic.htm\r\n//\r\n// with some importance sampling for the eyes, nouse and mouth.\r\n\r\nfloat brush( float col, vec2 p, in vec4 b, float an )\r\n{\r\n\tp += an*cos( iTime + 100.0*b.yz );\r\n\t\t\t\t\r\n    vec2 dd = p - b.yz;\r\n    col = mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    if( abs(b.z-0.5)<0.251 )\r\n    {\r\n        dd.x = p.x - 1.0 + b.y;\r\n        col =  mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    }\r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.y;\r\n    uv.x -=  0.5*(iResolution.x / iResolution.y - 1.0);\r\n\r\n    float an = smoothstep( 0.0, 1.0, cos(iTime) );\r\n\r\n\tfloat col = 0.0;\r\n\r\n    col = brush( col, uv, vec4(1.000,0.371,0.379,11.770), an );\r\n    col = brush( col, uv, vec4(0.992,0.545,0.551,8.359), an );\r\n    col = brush( col, uv, vec4(0.749,0.623,0.990,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.510,0.395,11.315), an );\r\n    col = brush( col, uv, vec4(1.000,0.723,0.564,15.170), an );\r\n    col = brush( col, uv, vec4(0.953,0.729,0.750,14.629), an );\r\n    col = brush( col, uv, vec4(0.706,0.982,0.033,16.254), an );\r\n    col = brush( col, uv, vec4(1.000,0.855,0.652,26.256), an );\r\n    col = brush( col, uv, vec4(1.000,0.664,0.623,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.881,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.686,0.682,0.900,27.676), an );\r\n    col = brush( col, uv, vec4(1.000,0.189,0.684,18.618), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.422,0.195,44.522), an );\r\n    col = brush( col, uv, vec4(1.000,0.779,0.750,16.787), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.330,14.222), an );\r\n    col = brush( col, uv, vec4(1.000,0.197,0.648,22.505), an );\r\n    col = brush( col, uv, vec4(0.702,0.512,0.393,35.310), an );\r\n    col = brush( col, uv, vec4(1.000,0.744,0.621,14.949), an );\r\n    col = brush( col, uv, vec4(0.671,0.885,0.092,24.675), an );\r\n    col = brush( col, uv, vec4(0.000,0.344,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.760,0.465,40.960), an );\r\n    col = brush( col, uv, vec4(0.008,0.908,0.311,8.031), an );\r\n    col = brush( col, uv, vec4(0.016,0.959,0.750,10.039), an );\r\n    col = brush( col, uv, vec4(0.004,0.930,0.750,12.800), an );\r\n    col = brush( col, uv, vec4(1.000,0.555,0.250,19.883), an );\r\n    col = brush( col, uv, vec4(1.000,0.770,1.018,15.876), an );\r\n    col = brush( col, uv, vec4(0.000,0.828,0.756,36.571), an );\r\n    col = brush( col, uv, vec4(0.580,0.566,0.424,89.043), an );\r\n    col = brush( col, uv, vec4(0.988,0.162,0.691,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.314,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.947,0.125,32.000), an );\r\n    col = brush( col, uv, vec4(0.914,0.844,0.725,52.513), an );\r\n    col = brush( col, uv, vec4(1.000,0.313,0.762,42.667), an );\r\n    col = brush( col, uv, vec4(0.996,0.676,0.689,85.333), an );\r\n    col = brush( col, uv, vec4(0.980,0.346,0.559,24.675), an );\r\n    col = brush( col, uv, vec4(1.000,0.553,0.250,18.789), an );\r\n    col = brush( col, uv, vec4(0.004,0.258,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.420,0.742,30.567), an );\r\n    col = brush( col, uv, vec4(0.906,0.543,0.250,22.756), an );\r\n    col = brush( col, uv, vec4(0.863,0.674,0.322,20.078), an );\r\n    col = brush( col, uv, vec4(0.753,0.357,0.686,78.769), an );\r\n    col = brush( col, uv, vec4(0.906,0.795,0.705,37.236), an );\r\n    col = brush( col, uv, vec4(0.933,0.520,0.365,38.642), an );\r\n    col = brush( col, uv, vec4(0.996,0.318,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.337,0.486,0.281,81.920), an );\r\n    col = brush( col, uv, vec4(0.965,0.691,0.516,16.650), an );\r\n    col = brush( col, uv, vec4(0.808,0.582,0.973,52.513), an );\r\n    col = brush( col, uv, vec4(0.012,0.240,0.928,8.063), an );\r\n    col = brush( col, uv, vec4(1.000,0.496,0.217,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.658,0.953,34.133), an );\r\n    col = brush( col, uv, vec4(0.871,0.582,0.172,62.061), an );\r\n    col = brush( col, uv, vec4(0.855,0.346,0.342,17.504), an );\r\n    col = brush( col, uv, vec4(0.878,0.787,0.648,28.845), an );\r\n    col = brush( col, uv, vec4(0.000,0.984,0.111,35.310), an );\r\n    col = brush( col, uv, vec4(0.855,0.514,0.965,66.065), an );\r\n    col = brush( col, uv, vec4(0.561,0.613,0.350,81.920), an );\r\n    col = brush( col, uv, vec4(0.992,0.818,0.902,21.558), an );\r\n    col = brush( col, uv, vec4(0.914,0.746,0.615,40.157), an );\r\n    col = brush( col, uv, vec4(0.557,0.580,0.125,60.235), an );\r\n    col = brush( col, uv, vec4(0.475,0.547,0.414,70.621), an );\r\n    col = brush( col, uv, vec4(0.843,0.680,0.793,20.277), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.758,56.889), an );\r\n    col = brush( col, uv, vec4(1.000,0.299,0.691,68.267), an );\r\n    col = brush( col, uv, vec4(0.737,0.518,0.100,68.267), an );\r\n    col = brush( col, uv, vec4(0.996,0.227,0.514,41.796), an );\r\n    col = brush( col, uv, vec4(0.929,0.850,0.770,62.061), an );\r\n    col = brush( col, uv, vec4(0.682,0.834,0.111,30.118), an );\r\n    col = brush( col, uv, vec4(0.996,0.854,0.793,58.514), an );\r\n    col = brush( col, uv, vec4(0.490,0.736,0.889,19.321), an );\r\n    col = brush( col, uv, vec4(0.980,0.465,0.725,16.126), an );\r\n    col = brush( col, uv, vec4(0.992,0.484,1.010,23.273), an );\r\n    col = brush( col, uv, vec4(0.008,0.949,0.727,23.540), an );\r\n    col = brush( col, uv, vec4(0.012,0.086,0.086,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.121,0.750,44.522), an );\r\n    col = brush( col, uv, vec4(0.427,0.617,0.891,27.676), an );\r\n    col = brush( col, uv, vec4(0.804,0.693,0.633,78.769), an );\r\n    col = brush( col, uv, vec4(0.012,0.711,0.084,13.745), an );\r\n    col = brush( col, uv, vec4(0.082,0.584,0.338,107.789), an );\r\n    col = brush( col, uv, vec4(0.929,0.613,0.268,19.692), an );\r\n    col = brush( col, uv, vec4(0.200,0.549,0.420,128.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.402,0.717,26.947), an );\r\n    col = brush( col, uv, vec4(0.000,0.551,0.168,45.511), an );\r\n    col = brush( col, uv, vec4(0.992,0.627,0.621,56.889), an );\r\n    col = brush( col, uv, vec4(0.902,0.361,0.748,40.960), an );\r\n    col = brush( col, uv, vec4(0.984,0.344,0.754,38.642), an );\r\n    col = brush( col, uv, vec4(0.902,0.203,0.818,51.200), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.803,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.738,0.691,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.385,0.797,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.725,0.305,62.061), an );\r\n    col = brush( col, uv, vec4(0.000,0.150,0.750,45.511), an );\r\n    col = brush( col, uv, vec4(1.000,0.742,0.408,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.645,0.643,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.438,35.310), an );\r\n    col = brush( col, uv, vec4(0.510,0.564,0.789,18.450), an );\r\n    col = brush( col, uv, vec4(0.863,0.211,0.781,30.567), an );\r\n    col = brush( col, uv, vec4(0.106,0.508,0.328,89.043), an );\r\n    col = brush( col, uv, vec4(0.012,0.410,0.875,14.629), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.877,48.762), an );\r\n    col = brush( col, uv, vec4(1.000,0.258,0.779,37.926), an );\r\n    col = brush( col, uv, vec4(0.000,0.436,0.807,28.845), an );\r\n    col = brush( col, uv, vec4(0.918,0.861,0.836,49.951), an );\r\n    col = brush( col, uv, vec4(1.000,0.291,0.770,40.960), an );\r\n    col = brush( col, uv, vec4(0.000,0.750,0.283,27.676), an );\r\n    col = brush( col, uv, vec4(0.965,0.596,0.572,28.055), an );\r\n    col = brush( col, uv, vec4(0.902,0.803,0.953,24.976), an );\r\n    col = brush( col, uv, vec4(0.957,0.498,0.600,16.126), an );\r\n    col = brush( col, uv, vec4(0.914,0.322,0.432,15.634), an );\r\n    col = brush( col, uv, vec4(0.008,0.025,0.621,17.809), an );\r\n    col = brush( col, uv, vec4(0.000,0.916,0.713,56.889), an );\r\n    col = brush( col, uv, vec4(0.914,0.547,0.971,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.207,0.432,37.926), an );\r\n    col = brush( col, uv, vec4(0.875,0.176,0.793,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.646,0.668,41.796), an );\r\n    col = brush( col, uv, vec4(1.000,0.721,0.691,51.200), an );\r\n    col = brush( col, uv, vec4(0.451,0.559,0.754,49.951), an );\r\n    col = brush( col, uv, vec4(0.969,0.846,0.750,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.146,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.613,0.635,85.333), an );\r\n    col = brush( col, uv, vec4(0.596,0.807,0.150,58.514), an );\r\n    col = brush( col, uv, vec4(0.898,0.330,0.760,40.157), an );\r\n    col = brush( col, uv, vec4(0.694,0.594,0.012,51.200), an );\r\n    col = brush( col, uv, vec4(0.698,0.592,0.055,53.895), an );\r\n    col = brush( col, uv, vec4(0.902,0.268,0.773,39.385), an );\r\n    col = brush( col, uv, vec4(0.925,0.838,0.660,58.514), an );\r\n    col = brush( col, uv, vec4(0.843,0.670,0.242,28.444), an );\r\n    col = brush( col, uv, vec4(0.243,0.465,0.285,85.333), an );\r\n    col = brush( col, uv, vec4(0.816,0.588,0.674,44.522), an );\r\n    col = brush( col, uv, vec4(0.008,0.283,0.115,8.031), an );\r\n    col = brush( col, uv, vec4(0.247,0.414,0.691,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.104,0.781,60.235), an );\r\n    col = brush( col, uv, vec4(0.000,0.619,0.660,60.235), an );\r\n    col = brush( col, uv, vec4(0.584,0.650,0.994,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.219,0.393,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.307,0.645,97.524), an );\r\n    col = brush( col, uv, vec4(0.953,0.639,0.771,38.642), an );\r\n    col = brush( col, uv, vec4(0.000,0.238,0.357,34.712), an );\r\n    col = brush( col, uv, vec4(0.922,0.713,0.352,53.895), an );\r\n    col = brush( col, uv, vec4(0.965,0.387,0.748,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.898,0.633,41.796), an );\r\n    col = brush( col, uv, vec4(0.941,0.352,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.933,0.439,0.725,30.567), an );\r\n    col = brush( col, uv, vec4(0.310,0.541,0.906,47.628), an );\r\n    col = brush( col, uv, vec4(0.941,0.502,0.689,24.094), an );\r\n    col = brush( col, uv, vec4(0.094,0.527,0.330,85.333), an );\r\n    col = brush( col, uv, vec4(0.000,0.090,0.688,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.652,0.713,75.852), an );\r\n    col = brush( col, uv, vec4(0.949,0.320,0.623,107.789), an );\r\n    col = brush( col, uv, vec4(0.890,0.775,0.750,22.505), an );\r\n    col = brush( col, uv, vec4(0.012,0.918,0.490,14.322), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.967,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.324,0.676,64.000), an );\r\n    col = brush( col, uv, vec4(0.008,0.141,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.633,0.707,75.852), an );\r\n    col = brush( col, uv, vec4(0.910,0.385,0.207,44.522), an );\r\n    col = brush( col, uv, vec4(0.012,0.703,0.182,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.617,0.703,73.143), an );\r\n    col = brush( col, uv, vec4(0.890,0.352,0.225,45.511), an );\r\n    col = brush( col, uv, vec4(0.933,0.826,0.604,44.522), an );\r\n    col = brush( col, uv, vec4(0.914,0.777,0.574,25.924), an );\r\n    col = brush( col, uv, vec4(0.631,0.781,0.182,68.267), an );\r\n    col = brush( col, uv, vec4(1.000,0.873,0.916,48.762), an );\r\n    col = brush( col, uv, vec4(0.694,0.520,0.113,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.926,58.514), an );\r\n    col = brush( col, uv, vec4(0.184,0.598,0.344,146.286), an );\r\n    col = brush( col, uv, vec4(0.863,0.678,0.250,35.310), an );\r\n    col = brush( col, uv, vec4(0.090,0.566,0.332,78.769), an );\r\n    col = brush( col, uv, vec4(0.420,0.445,0.301,56.889), an );\r\n    col = brush( col, uv, vec4(0.973,0.617,0.516,18.124), an );\r\n    col = brush( col, uv, vec4(0.000,0.191,0.500,39.385), an );\r\n    col = brush( col, uv, vec4(0.000,0.240,0.326,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.264,0.322,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.604,0.699,70.621), an );\r\n    col = brush( col, uv, vec4(0.000,0.113,0.604,43.574), an );\r\n    col = brush( col, uv, vec4(0.894,0.760,0.697,49.951), an );\r\n    col = brush( col, uv, vec4(0.914,0.725,0.383,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.199,0.467,48.762), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.660,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.611,0.191,45.511), an );\r\n    col = brush( col, uv, vec4(0.059,0.789,0.869,30.118), an );\r\n    col = brush( col, uv, vec4(0.976,0.641,0.213,40.960), an );\r\n    col = brush( col, uv, vec4(0.918,0.402,0.742,47.628), an );\r\n    col = brush( col, uv, vec4(0.945,0.717,0.582,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.299,0.672,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.719,0.666,48.762), an );\r\n    col = brush( col, uv, vec4(0.882,0.697,0.271,58.514), an );\r\n    col = brush( col, uv, vec4(0.929,0.752,0.436,64.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.867,0.813,56.889), an );\r\n    col = brush( col, uv, vec4(0.643,0.588,0.090,64.000), an );\r\n    col = brush( col, uv, vec4(0.012,0.063,0.922,10.952), an );\r\n    col = brush( col, uv, vec4(0.878,0.186,0.750,31.508), an );\r\n    col = brush( col, uv, vec4(0.953,0.648,0.613,120.471), an );\r\n    col = brush( col, uv, vec4(0.973,0.180,0.576,45.511), an );\r\n    col = brush( col, uv, vec4(0.741,0.943,0.076,52.513), an );\r\n    col = brush( col, uv, vec4(0.059,0.545,0.332,89.043), an );\r\n    col = brush( col, uv, vec4(0.094,0.295,0.734,85.333), an );\r\n    col = brush( col, uv, vec4(0.008,0.676,0.721,85.333), an );\r\n    col = brush( col, uv, vec4(0.550,0.350,0.650,85.000), an );\r\n\r\n\tfragColor = vec4(col,col,col,1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// \"in my crawl space\"\r\n// Shadertoy port of our windows 4k intro:\r\n\r\n// https://www.pouet.net/prod.php?which=82169\r\n\r\n// https://www.youtube.com/watch?v=jw-nC5bINFc\r\nvec3 scatter =vec3(0.);\r\nfloat sp = 2.0833;\r\nvec3 lpos1=vec3(0); vec3 lpos2=vec3(0);\r\nvec3 lpos3=vec3(0, 1, 0);\r\n\r\nfloat time =0.;\r\nfloat kk=0.;\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif( x < d.x ) d = vec3(x, y, z);\r\n}\r\n\r\n// method by iq/shane\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tp = fract(p * .1031);\r\n\tp *= p + 19.19;\r\n\tp *= p + p;\r\n\treturn fract(p);\r\n}\r\n\r\n// method by fizzer\r\nvec3 hashHs(vec3 n, float seed)\r\n{\r\n\tfloat u = hash11(78.233+seed);\r\n\tfloat v = hash11(10.873+seed);\r\n\tfloat a = 6.2831853 * v;\r\n\tu = 2.0*u - 1.0;\r\n\treturn normalize(n+vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u));\r\n}\r\n\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nfloat sdRoundBox(vec3 p, vec3 b, float r)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn length(max(d, 0.0)) - r;\r\n}\r\n\r\nfloat pattern(vec2 p)\r\n{\r\n\tp.x += 5.5;\r\n\tp.y *= 2.;\r\n\tp = floor(p);\r\n\tif( iTime>160./sp*kk&&iTime<192./sp ) p.y += floor(iTime*sp/2.)*17.;\r\n\tp = floor(p);\r\n\treturn (sin(p.x*p.y) > .8) ? 2. : .9;\r\n}\r\n\r\nfloat vines(vec3 p, float s, float t)\r\n{\r\n\tp.x=abs(p.x)+t*.1;\r\n\tpR(p.yz, p.x*1.); p=abs(p); p.yz -= .06*s;\r\n\tpR(p.yz, p.x*-3.); p=abs(p); p.yz -= .05*s;\r\n\tpR(p.yz, p.x*5.+t); p=abs(p); p.yz -= .04*(s*.5+.5);\r\n\treturn length(p.yz);\r\n}\r\n\r\nvec3 map(vec3 p, bool flag)\r\n{\r\n\tfloat wallnoise = (noise(83.*p)+noise(17.*p))*noise(7.*p);\r\n\tvec3 d = vec3(1, 0, 0);\r\n\r\n\tfloat sd1 = length(p+lpos1)-.4;\r\n\tfloat sd2 = length(p+lpos2)-.4;\r\n\tfloat waves = 0.;\r\n\tif( iTime > 48./sp) waves=0.03;\t\t\t\t\t\t\r\n\tdmin(d, 1.49+kk*2.5-abs(p.x+0.01*wallnoise), .99-0.5*wallnoise, 0.); \r\n\tif( kk>0. ) {\r\n\t\tdmin(d, 1.2+p.y, pattern(p.xz)-.6*wallnoise, 0.); \t\r\n\r\n\t\tdmin(d,\r\n\t\t\tmax(vines(p+vec3(0, 0, 2), .5+5./(1.+p.x*p.x*2.), iTime)-.02,\r\n\t\t\t\tmax(\r\n\t\t\t\t\tabs(p.x)-3.,\r\n\t\t\t\t\t3.5-(iTime-77.)*.25+max(iTime-192./sp, 0.)*2.+sin(p.y*20.)*sin(p.z*10.) - abs(p.x)\r\n\t\t\t\t)\r\n\t\t\t),.1, .2);\r\n\r\n\t\tvec3 q=p.yxz;\r\n\t\tq.z=fract(q.z/3.-.2)*3.-1.5;\r\n\t\tq.y=abs(q.y)-3.5;\r\n\t\tq.x -= 6.;\r\n\t\tdmin(d,vines(q, 1.3+20./(1.+q.x*q.x*.45), 0.)-.05,.1, .2);\r\n\t}\r\n\telse {\r\n\t\tdmin(d, .8-waves*sin(8.*p.z+time)*sin(6.*p.x+1.6*time+sin(2.*p.z))+p.y, .25, waves);\r\n\t\tdmin(d, 0.75-p.z, .8*sin(20.*p.x), 0.); \t\r\n\t\tdmin(d, 0.8-p.y, pattern(p.xz)-.6*wallnoise, 0.); \t\r\n\t}\r\n\tfloat amp = 0.;\r\n\tif( iTime > 96./sp &&fract(iTime*sp/4.)<=0.75+kk )  amp=abs(sin(20.*p.z));\r\n\tif( iTime>96./sp && flag && fract(iTime*sp/4.)<=0.75+kk )\r\n\t{\r\n\t\tscatter += max(-(sd1-1.2), 0.)*.06*vec3(0, 1, 1); \r\n\t\tscatter += max(-(sd2-1.2), 0.)*.06*vec3(2, 1, 0);\r\n\t}\r\n\r\n\tif( iTime>32./sp )\r\n\t{\r\n\t\tdmin(d,sd1,.07+amp,-1.);\r\n\t\tdmin(d,sd2,.07+amp,1.); \r\n\t}\r\n\r\n\tvec3 q = abs(p);\r\n\tif (iTime>24./sp&&fract(iTime*sp/8.)>=0.924-kk&&(iTime<60./sp||iTime>64./sp))\r\n\t{\r\n\t\tq.x -= 1.49+kk*2.4;\r\n\t\tq.y -= .4+.4*sin(time)*(1.-kk)+kk*.4;\r\n\t\tdmin(d, length(q.xy)-.015, 2., -.4);\r\n\t}\r\n\r\n\tif( iTime>64./sp)\r\n\t\tif( iTime<192./sp)\r\n\t\t{\r\n\t\t\tq=p+vec3(0, 0, 2.);\r\n\t\t\tpR(q.xy, 0.33*time);\r\n\t\t\tpR(q.xz, 0.4*time);\r\n\t\t\tfloat rb=sdRoundBox(q, vec3(.48), .08);\r\n\t\t\tdmin(d, rb, -.7+1.9*abs(sin(10.*q.x+10.*q.y)), 0.);\r\n\t\t}\r\n\t\telse\r\n\t\t\tdmin(d, length(p+vec3(0, 0, 2))-.5, .07+amp, 0.);\r\n\treturn d;\r\n}\r\n\r\nvec3 normal(vec3 p)\r\n{\r\n\tvec2 e = vec2(0,.0001);\r\n\treturn normalize(map(p, false).x-vec3(map(p - e.yxx, false).x, map(p - e.xyx, false).x, map(p - e.xxy, false).x));\r\n}\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\ttime=iTime*0.7;\r\n\tkk = step(128., iTime*sp);\r\n\tif( fract(iTime*sp/8.)<.75 )\r\n\t{\r\n\t\ttime += fract(-iTime*sp)+17.*ceil(iTime*sp);\r\n\t\tkk = step(156., iTime*sp);\r\n\t}\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tfragColor = vec4(0);\r\n\tif( uv.y>.11 && uv.y<.89 )\r\n\t{\r\n\t\tfloat t1 = 0., t2 = 0., t3=0., seed = 0.;\r\n\t\tvec3 ro1 = vec3(0, 0, -2.5-kk*(1.+max(159.-iTime*sp, 0.)+max(iTime*sp-192., 0.)*.1)),\r\n\t\t\t rd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\r\n\r\n\t\tif( iTime>160./sp&&iTime<192./sp)\r\n\t\t{\r\n\t\t\tvec2 ca=sin(vec2(.35, .47)*(iTime+fract(-iTime/8.*sp)+42.*ceil(iTime/8.*sp)))*vec2(1., .3);\r\n\t\t\tpR(ro1.zy, ca.y); pR(rd1.zy, ca.y);\t\r\n\t\t\tpR(ro1.xz, ca.x); pR(rd1.xz, ca.x);\t\r\n\t\t}\r\n        \r\n\t\tro1.z-=2.5;\r\n\t\tlpos1 = vec3(1.*cos(time), .3*sin(time), 2.+sin(0.5*time));\t\r\n\t\tlpos2 = vec3(1.2*cos(0.3*time), .4*sin(0.4*time), 2.+sin(0.2*time));\r\n\t\tlpos3=vec3(sin(0.5*time), 1, 0);\r\n\t\tif( kk>0. )\r\n\t\t{\r\n\t\t\tlpos1 = vec3(3, 0, 2);\r\n\t\t\tlpos2 = vec3(-3, 0, 2);\r\n\t\t\tlpos3=vec3(0, -1, 0);\r\n\t\t}\r\n\t\tseed=uv.x*uv.y+uv.y+uv.x+fract(iTime);\r\n\t\tvec3 scol=vec3(0), m1, m2, m3, ro2, rd2, nor1, nor2, pos1, pos2, pos3;\r\n\r\n\t\tfor( int i = 0; i < 150; i++ )\r\n\t\t{\r\n\t\t\tseed=32.+seed*fract(seed);\r\n\t\t\tpos1 = ro1+rd1*t1;\r\n\t\t\tm1 = map(pos1, true);\r\n\t\t\tt1+=0.2*(m1.x);\r\n\r\n\t\t\tif( m1.x<0.001 )\r\n\t\t\t{\r\n\t\t\t\tscol+= vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*(150.-float(i))*(m1.z==.03 ? vec3(.6, .8, 1.) : vec3(1));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tpos2=pos1+mix(lpos3, hashHs(lpos3, seed), 0.15)*t2; \r\n\t\t\tm2 = map(pos2, false);\r\n\t\t\tt2+=m2.x;\r\n\r\n\t\t\tif( m2.y>=1.&&m2.z==0. )\r\n\t\t\t\tscol+=(.5+5.*m1.x*noise(7.*pos1+mix(vec3(iTime), vec3(0, -iTime, 0), kk)));\t\r\n\t\t}\r\n\r\n\t\tnor1 = normal(pos1);\r\n\t\tm1.y=clamp(m1.y, 0., 1.);\r\n\t\tt2=0.;\r\n\t\tfor( int i = 1; i < 100; i++ )\r\n\t\t{\r\n\t\t\tseed=32.+seed*fract(seed);\r\n\t\t\trd2 = mix(reflect(rd1, nor1), hashHs(nor1, seed), m1.y);\r\n\t\t\tpos2 = pos1+ rd2*t2;\r\n\t\t\tm2 = map(pos2, false);\r\n\t\t\tt2+=0.2*m2.x;\r\n\t\t\tscol += vec3(1.+m2.z, 1., 1.-m2.z)*step(1., m2.y)*(m1.z==.03 ? vec3(.6, .8, 1.) : vec3(1));\r\n\r\n\t\t}\r\n\r\n\t\tscol=clamp(.009*scol+.06*scatter, 0., 1.) * clamp((236. / sp - iTime) / 8., 0., 1.);;\r\n        fragColor = scol.xyzz;\r\n        //fragColor = pow(fragColor,vec4(1.0/2.2));\r\n\t\t//fragColor =mix(scol.xyzz, texture(iChannel0, uv), pow(.0001, iTimeDelta));\r\n\t}\r\n}\r\n","inputs":[],"outputs":[],"code":"// \"in my crawl space\"\r\n// Shadertoy port of our windows 4k intro:\r\n\r\n// https://www.pouet.net/prod.php?which=82169\r\n\r\n// https://www.youtube.com/watch?v=jw-nC5bINFc\r\nvec3 scatter =vec3(0.);\r\nfloat sp = 2.0833;\r\nvec3 lpos1=vec3(0); vec3 lpos2=vec3(0);\r\nvec3 lpos3=vec3(0, 1, 0);\r\n\r\nfloat time =0.;\r\nfloat kk=0.;\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif( x < d.x ) d = vec3(x, y, z);\r\n}\r\n\r\n// method by iq/shane\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tp = fract(p * .1031);\r\n\tp *= p + 19.19;\r\n\tp *= p + p;\r\n\treturn fract(p);\r\n}\r\n\r\n// method by fizzer\r\nvec3 hashHs(vec3 n, float seed)\r\n{\r\n\tfloat u = hash11(78.233+seed);\r\n\tfloat v = hash11(10.873+seed);\r\n\tfloat a = 6.2831853 * v;\r\n\tu = 2.0*u - 1.0;\r\n\treturn normalize(n+vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u));\r\n}\r\n\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nfloat sdRoundBox(vec3 p, vec3 b, float r)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn length(max(d, 0.0)) - r;\r\n}\r\n\r\nfloat pattern(vec2 p)\r\n{\r\n\tp.x += 5.5;\r\n\tp.y *= 2.;\r\n\tp = floor(p);\r\n\tif( iTime>160./sp*kk&&iTime<192./sp ) p.y += floor(iTime*sp/2.)*17.;\r\n\tp = floor(p);\r\n\treturn (sin(p.x*p.y) > .8) ? 2. : .9;\r\n}\r\n\r\nfloat vines(vec3 p, float s, float t)\r\n{\r\n\tp.x=abs(p.x)+t*.1;\r\n\tpR(p.yz, p.x*1.); p=abs(p); p.yz -= .06*s;\r\n\tpR(p.yz, p.x*-3.); p=abs(p); p.yz -= .05*s;\r\n\tpR(p.yz, p.x*5.+t); p=abs(p); p.yz -= .04*(s*.5+.5);\r\n\treturn length(p.yz);\r\n}\r\n\r\nvec3 map(vec3 p, bool flag)\r\n{\r\n\tfloat wallnoise = (noise(83.*p)+noise(17.*p))*noise(7.*p);\r\n\tvec3 d = vec3(1, 0, 0);\r\n\r\n\tfloat sd1 = length(p+lpos1)-.4;\r\n\tfloat sd2 = length(p+lpos2)-.4;\r\n\tfloat waves = 0.;\r\n\tif( iTime > 48./sp) waves=0.03;\t\t\t\t\t\t\r\n\tdmin(d, 1.49+kk*2.5-abs(p.x+0.01*wallnoise), .99-0.5*wallnoise, 0.); \r\n\tif( kk>0. ) {\r\n\t\tdmin(d, 1.2+p.y, pattern(p.xz)-.6*wallnoise, 0.); \t\r\n\r\n\t\tdmin(d,\r\n\t\t\tmax(vines(p+vec3(0, 0, 2), .5+5./(1.+p.x*p.x*2.), iTime)-.02,\r\n\t\t\t\tmax(\r\n\t\t\t\t\tabs(p.x)-3.,\r\n\t\t\t\t\t3.5-(iTime-77.)*.25+max(iTime-192./sp, 0.)*2.+sin(p.y*20.)*sin(p.z*10.) - abs(p.x)\r\n\t\t\t\t)\r\n\t\t\t),.1, .2);\r\n\r\n\t\tvec3 q=p.yxz;\r\n\t\tq.z=fract(q.z/3.-.2)*3.-1.5;\r\n\t\tq.y=abs(q.y)-3.5;\r\n\t\tq.x -= 6.;\r\n\t\tdmin(d,vines(q, 1.3+20./(1.+q.x*q.x*.45), 0.)-.05,.1, .2);\r\n\t}\r\n\telse {\r\n\t\tdmin(d, .8-waves*sin(8.*p.z+time)*sin(6.*p.x+1.6*time+sin(2.*p.z))+p.y, .25, waves);\r\n\t\tdmin(d, 0.75-p.z, .8*sin(20.*p.x), 0.); \t\r\n\t\tdmin(d, 0.8-p.y, pattern(p.xz)-.6*wallnoise, 0.); \t\r\n\t}\r\n\tfloat amp = 0.;\r\n\tif( iTime > 96./sp &&fract(iTime*sp/4.)<=0.75+kk )  amp=abs(sin(20.*p.z));\r\n\tif( iTime>96./sp && flag && fract(iTime*sp/4.)<=0.75+kk )\r\n\t{\r\n\t\tscatter += max(-(sd1-1.2), 0.)*.06*vec3(0, 1, 1); \r\n\t\tscatter += max(-(sd2-1.2), 0.)*.06*vec3(2, 1, 0);\r\n\t}\r\n\r\n\tif( iTime>32./sp )\r\n\t{\r\n\t\tdmin(d,sd1,.07+amp,-1.);\r\n\t\tdmin(d,sd2,.07+amp,1.); \r\n\t}\r\n\r\n\tvec3 q = abs(p);\r\n\tif (iTime>24./sp&&fract(iTime*sp/8.)>=0.924-kk&&(iTime<60./sp||iTime>64./sp))\r\n\t{\r\n\t\tq.x -= 1.49+kk*2.4;\r\n\t\tq.y -= .4+.4*sin(time)*(1.-kk)+kk*.4;\r\n\t\tdmin(d, length(q.xy)-.015, 2., -.4);\r\n\t}\r\n\r\n\tif( iTime>64./sp)\r\n\t\tif( iTime<192./sp)\r\n\t\t{\r\n\t\t\tq=p+vec3(0, 0, 2.);\r\n\t\t\tpR(q.xy, 0.33*time);\r\n\t\t\tpR(q.xz, 0.4*time);\r\n\t\t\tfloat rb=sdRoundBox(q, vec3(.48), .08);\r\n\t\t\tdmin(d, rb, -.7+1.9*abs(sin(10.*q.x+10.*q.y)), 0.);\r\n\t\t}\r\n\t\telse\r\n\t\t\tdmin(d, length(p+vec3(0, 0, 2))-.5, .07+amp, 0.);\r\n\treturn d;\r\n}\r\n\r\nvec3 normal(vec3 p)\r\n{\r\n\tvec2 e = vec2(0,.0001);\r\n\treturn normalize(map(p, false).x-vec3(map(p - e.yxx, false).x, map(p - e.xyx, false).x, map(p - e.xxy, false).x));\r\n}\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\ttime=iTime*0.7;\r\n\tkk = step(128., iTime*sp);\r\n\tif( fract(iTime*sp/8.)<.75 )\r\n\t{\r\n\t\ttime += fract(-iTime*sp)+17.*ceil(iTime*sp);\r\n\t\tkk = step(156., iTime*sp);\r\n\t}\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tfragColor = vec4(0);\r\n\tif( uv.y>.11 && uv.y<.89 )\r\n\t{\r\n\t\tfloat t1 = 0., t2 = 0., t3=0., seed = 0.;\r\n\t\tvec3 ro1 = vec3(0, 0, -2.5-kk*(1.+max(159.-iTime*sp, 0.)+max(iTime*sp-192., 0.)*.1)),\r\n\t\t\t rd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\r\n\r\n\t\tif( iTime>160./sp&&iTime<192./sp)\r\n\t\t{\r\n\t\t\tvec2 ca=sin(vec2(.35, .47)*(iTime+fract(-iTime/8.*sp)+42.*ceil(iTime/8.*sp)))*vec2(1., .3);\r\n\t\t\tpR(ro1.zy, ca.y); pR(rd1.zy, ca.y);\t\r\n\t\t\tpR(ro1.xz, ca.x); pR(rd1.xz, ca.x);\t\r\n\t\t}\r\n        \r\n\t\tro1.z-=2.5;\r\n\t\tlpos1 = vec3(1.*cos(time), .3*sin(time), 2.+sin(0.5*time));\t\r\n\t\tlpos2 = vec3(1.2*cos(0.3*time), .4*sin(0.4*time), 2.+sin(0.2*time));\r\n\t\tlpos3=vec3(sin(0.5*time), 1, 0);\r\n\t\tif( kk>0. )\r\n\t\t{\r\n\t\t\tlpos1 = vec3(3, 0, 2);\r\n\t\t\tlpos2 = vec3(-3, 0, 2);\r\n\t\t\tlpos3=vec3(0, -1, 0);\r\n\t\t}\r\n\t\tseed=uv.x*uv.y+uv.y+uv.x+fract(iTime);\r\n\t\tvec3 scol=vec3(0), m1, m2, m3, ro2, rd2, nor1, nor2, pos1, pos2, pos3;\r\n\r\n\t\tfor( int i = 0; i < 150; i++ )\r\n\t\t{\r\n\t\t\tseed=32.+seed*fract(seed);\r\n\t\t\tpos1 = ro1+rd1*t1;\r\n\t\t\tm1 = map(pos1, true);\r\n\t\t\tt1+=0.2*(m1.x);\r\n\r\n\t\t\tif( m1.x<0.001 )\r\n\t\t\t{\r\n\t\t\t\tscol+= vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*(150.-float(i))*(m1.z==.03 ? vec3(.6, .8, 1.) : vec3(1));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tpos2=pos1+mix(lpos3, hashHs(lpos3, seed), 0.15)*t2; \r\n\t\t\tm2 = map(pos2, false);\r\n\t\t\tt2+=m2.x;\r\n\r\n\t\t\tif( m2.y>=1.&&m2.z==0. )\r\n\t\t\t\tscol+=(.5+5.*m1.x*noise(7.*pos1+mix(vec3(iTime), vec3(0, -iTime, 0), kk)));\t\r\n\t\t}\r\n\r\n\t\tnor1 = normal(pos1);\r\n\t\tm1.y=clamp(m1.y, 0., 1.);\r\n\t\tt2=0.;\r\n\t\tfor( int i = 1; i < 100; i++ )\r\n\t\t{\r\n\t\t\tseed=32.+seed*fract(seed);\r\n\t\t\trd2 = mix(reflect(rd1, nor1), hashHs(nor1, seed), m1.y);\r\n\t\t\tpos2 = pos1+ rd2*t2;\r\n\t\t\tm2 = map(pos2, false);\r\n\t\t\tt2+=0.2*m2.x;\r\n\t\t\tscol += vec3(1.+m2.z, 1., 1.-m2.z)*step(1., m2.y)*(m1.z==.03 ? vec3(.6, .8, 1.) : vec3(1));\r\n\r\n\t\t}\r\n\r\n\t\tscol=clamp(.009*scol+.06*scatter, 0., 1.) * clamp((236. / sp - iTime) / 8., 0., 1.);;\r\n        fragColor = scol.xyzz;\r\n        //fragColor = pow(fragColor,vec4(1.0/2.2));\r\n\t\t//fragColor =mix(scol.xyzz, texture(iChannel0, uv), pow(.0001, iTimeDelta));\r\n\t}\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"in my crawl space","id":"ceaf24a5e9d04336b6abaaaca1189480","date":null,"viewed":0,"name":"in my crawl space","description":"Shadertoy port of our windows 4k intro.\n1st @ Nordlicht 2019\nCode by Virgill & KK,\nmusic by Virgill\n\nhttps://www.pouet.net/prod.php?which=82169\n\nhttps://www.youtube.com/watch?v=jw-nC5bINFc\nhttps://www.shadertoy.com/view/ttlXRf","likes":0,"published":null,"tags":["4k"," demoscene"," volumetric"," pathtracing"," madtracing"]},"ver":null,"info":{"Name":"in my crawl space","id":"ceaf24a5e9d04336b6abaaaca1189480","date":null,"viewed":0,"name":"in my crawl space","description":"Shadertoy port of our windows 4k intro.\n1st @ Nordlicht 2019\nCode by Virgill & KK,\nmusic by Virgill\n\nhttps://www.pouet.net/prod.php?which=82169\n\nhttps://www.youtube.com/watch?v=jw-nC5bINFc\nhttps://www.shadertoy.com/view/ttlXRf","likes":0,"published":null,"tags":["4k"," demoscene"," volumetric"," pathtracing"," madtracing"]},"renderpass":[{"Code":"// \"in my crawl space\"\r\n// Shadertoy port of our windows 4k intro:\r\n\r\n// https://www.pouet.net/prod.php?which=82169\r\n\r\n// https://www.youtube.com/watch?v=jw-nC5bINFc\r\nvec3 scatter =vec3(0.);\r\nfloat sp = 2.0833;\r\nvec3 lpos1=vec3(0); vec3 lpos2=vec3(0);\r\nvec3 lpos3=vec3(0, 1, 0);\r\n\r\nfloat time =0.;\r\nfloat kk=0.;\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif( x < d.x ) d = vec3(x, y, z);\r\n}\r\n\r\n// method by iq/shane\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tp = fract(p * .1031);\r\n\tp *= p + 19.19;\r\n\tp *= p + p;\r\n\treturn fract(p);\r\n}\r\n\r\n// method by fizzer\r\nvec3 hashHs(vec3 n, float seed)\r\n{\r\n\tfloat u = hash11(78.233+seed);\r\n\tfloat v = hash11(10.873+seed);\r\n\tfloat a = 6.2831853 * v;\r\n\tu = 2.0*u - 1.0;\r\n\treturn normalize(n+vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u));\r\n}\r\n\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nfloat sdRoundBox(vec3 p, vec3 b, float r)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn length(max(d, 0.0)) - r;\r\n}\r\n\r\nfloat pattern(vec2 p)\r\n{\r\n\tp.x += 5.5;\r\n\tp.y *= 2.;\r\n\tp = floor(p);\r\n\tif( iTime>160./sp*kk&&iTime<192./sp ) p.y += floor(iTime*sp/2.)*17.;\r\n\tp = floor(p);\r\n\treturn (sin(p.x*p.y) > .8) ? 2. : .9;\r\n}\r\n\r\nfloat vines(vec3 p, float s, float t)\r\n{\r\n\tp.x=abs(p.x)+t*.1;\r\n\tpR(p.yz, p.x*1.); p=abs(p); p.yz -= .06*s;\r\n\tpR(p.yz, p.x*-3.); p=abs(p); p.yz -= .05*s;\r\n\tpR(p.yz, p.x*5.+t); p=abs(p); p.yz -= .04*(s*.5+.5);\r\n\treturn length(p.yz);\r\n}\r\n\r\nvec3 map(vec3 p, bool flag)\r\n{\r\n\tfloat wallnoise = (noise(83.*p)+noise(17.*p))*noise(7.*p);\r\n\tvec3 d = vec3(1, 0, 0);\r\n\r\n\tfloat sd1 = length(p+lpos1)-.4;\r\n\tfloat sd2 = length(p+lpos2)-.4;\r\n\tfloat waves = 0.;\r\n\tif( iTime > 48./sp) waves=0.03;\t\t\t\t\t\t\r\n\tdmin(d, 1.49+kk*2.5-abs(p.x+0.01*wallnoise), .99-0.5*wallnoise, 0.); \r\n\tif( kk>0. ) {\r\n\t\tdmin(d, 1.2+p.y, pattern(p.xz)-.6*wallnoise, 0.); \t\r\n\r\n\t\tdmin(d,\r\n\t\t\tmax(vines(p+vec3(0, 0, 2), .5+5./(1.+p.x*p.x*2.), iTime)-.02,\r\n\t\t\t\tmax(\r\n\t\t\t\t\tabs(p.x)-3.,\r\n\t\t\t\t\t3.5-(iTime-77.)*.25+max(iTime-192./sp, 0.)*2.+sin(p.y*20.)*sin(p.z*10.) - abs(p.x)\r\n\t\t\t\t)\r\n\t\t\t),.1, .2);\r\n\r\n\t\tvec3 q=p.yxz;\r\n\t\tq.z=fract(q.z/3.-.2)*3.-1.5;\r\n\t\tq.y=abs(q.y)-3.5;\r\n\t\tq.x -= 6.;\r\n\t\tdmin(d,vines(q, 1.3+20./(1.+q.x*q.x*.45), 0.)-.05,.1, .2);\r\n\t}\r\n\telse {\r\n\t\tdmin(d, .8-waves*sin(8.*p.z+time)*sin(6.*p.x+1.6*time+sin(2.*p.z))+p.y, .25, waves);\r\n\t\tdmin(d, 0.75-p.z, .8*sin(20.*p.x), 0.); \t\r\n\t\tdmin(d, 0.8-p.y, pattern(p.xz)-.6*wallnoise, 0.); \t\r\n\t}\r\n\tfloat amp = 0.;\r\n\tif( iTime > 96./sp &&fract(iTime*sp/4.)<=0.75+kk )  amp=abs(sin(20.*p.z));\r\n\tif( iTime>96./sp && flag && fract(iTime*sp/4.)<=0.75+kk )\r\n\t{\r\n\t\tscatter += max(-(sd1-1.2), 0.)*.06*vec3(0, 1, 1); \r\n\t\tscatter += max(-(sd2-1.2), 0.)*.06*vec3(2, 1, 0);\r\n\t}\r\n\r\n\tif( iTime>32./sp )\r\n\t{\r\n\t\tdmin(d,sd1,.07+amp,-1.);\r\n\t\tdmin(d,sd2,.07+amp,1.); \r\n\t}\r\n\r\n\tvec3 q = abs(p);\r\n\tif (iTime>24./sp&&fract(iTime*sp/8.)>=0.924-kk&&(iTime<60./sp||iTime>64./sp))\r\n\t{\r\n\t\tq.x -= 1.49+kk*2.4;\r\n\t\tq.y -= .4+.4*sin(time)*(1.-kk)+kk*.4;\r\n\t\tdmin(d, length(q.xy)-.015, 2., -.4);\r\n\t}\r\n\r\n\tif( iTime>64./sp)\r\n\t\tif( iTime<192./sp)\r\n\t\t{\r\n\t\t\tq=p+vec3(0, 0, 2.);\r\n\t\t\tpR(q.xy, 0.33*time);\r\n\t\t\tpR(q.xz, 0.4*time);\r\n\t\t\tfloat rb=sdRoundBox(q, vec3(.48), .08);\r\n\t\t\tdmin(d, rb, -.7+1.9*abs(sin(10.*q.x+10.*q.y)), 0.);\r\n\t\t}\r\n\t\telse\r\n\t\t\tdmin(d, length(p+vec3(0, 0, 2))-.5, .07+amp, 0.);\r\n\treturn d;\r\n}\r\n\r\nvec3 normal(vec3 p)\r\n{\r\n\tvec2 e = vec2(0,.0001);\r\n\treturn normalize(map(p, false).x-vec3(map(p - e.yxx, false).x, map(p - e.xyx, false).x, map(p - e.xxy, false).x));\r\n}\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\ttime=iTime*0.7;\r\n\tkk = step(128., iTime*sp);\r\n\tif( fract(iTime*sp/8.)<.75 )\r\n\t{\r\n\t\ttime += fract(-iTime*sp)+17.*ceil(iTime*sp);\r\n\t\tkk = step(156., iTime*sp);\r\n\t}\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tfragColor = vec4(0);\r\n\tif( uv.y>.11 && uv.y<.89 )\r\n\t{\r\n\t\tfloat t1 = 0., t2 = 0., t3=0., seed = 0.;\r\n\t\tvec3 ro1 = vec3(0, 0, -2.5-kk*(1.+max(159.-iTime*sp, 0.)+max(iTime*sp-192., 0.)*.1)),\r\n\t\t\t rd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\r\n\r\n\t\tif( iTime>160./sp&&iTime<192./sp)\r\n\t\t{\r\n\t\t\tvec2 ca=sin(vec2(.35, .47)*(iTime+fract(-iTime/8.*sp)+42.*ceil(iTime/8.*sp)))*vec2(1., .3);\r\n\t\t\tpR(ro1.zy, ca.y); pR(rd1.zy, ca.y);\t\r\n\t\t\tpR(ro1.xz, ca.x); pR(rd1.xz, ca.x);\t\r\n\t\t}\r\n        \r\n\t\tro1.z-=2.5;\r\n\t\tlpos1 = vec3(1.*cos(time), .3*sin(time), 2.+sin(0.5*time));\t\r\n\t\tlpos2 = vec3(1.2*cos(0.3*time), .4*sin(0.4*time), 2.+sin(0.2*time));\r\n\t\tlpos3=vec3(sin(0.5*time), 1, 0);\r\n\t\tif( kk>0. )\r\n\t\t{\r\n\t\t\tlpos1 = vec3(3, 0, 2);\r\n\t\t\tlpos2 = vec3(-3, 0, 2);\r\n\t\t\tlpos3=vec3(0, -1, 0);\r\n\t\t}\r\n\t\tseed=uv.x*uv.y+uv.y+uv.x+fract(iTime);\r\n\t\tvec3 scol=vec3(0), m1, m2, m3, ro2, rd2, nor1, nor2, pos1, pos2, pos3;\r\n\r\n\t\tfor( int i = 0; i < 150; i++ )\r\n\t\t{\r\n\t\t\tseed=32.+seed*fract(seed);\r\n\t\t\tpos1 = ro1+rd1*t1;\r\n\t\t\tm1 = map(pos1, true);\r\n\t\t\tt1+=0.2*(m1.x);\r\n\r\n\t\t\tif( m1.x<0.001 )\r\n\t\t\t{\r\n\t\t\t\tscol+= vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*(150.-float(i))*(m1.z==.03 ? vec3(.6, .8, 1.) : vec3(1));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tpos2=pos1+mix(lpos3, hashHs(lpos3, seed), 0.15)*t2; \r\n\t\t\tm2 = map(pos2, false);\r\n\t\t\tt2+=m2.x;\r\n\r\n\t\t\tif( m2.y>=1.&&m2.z==0. )\r\n\t\t\t\tscol+=(.5+5.*m1.x*noise(7.*pos1+mix(vec3(iTime), vec3(0, -iTime, 0), kk)));\t\r\n\t\t}\r\n\r\n\t\tnor1 = normal(pos1);\r\n\t\tm1.y=clamp(m1.y, 0., 1.);\r\n\t\tt2=0.;\r\n\t\tfor( int i = 1; i < 100; i++ )\r\n\t\t{\r\n\t\t\tseed=32.+seed*fract(seed);\r\n\t\t\trd2 = mix(reflect(rd1, nor1), hashHs(nor1, seed), m1.y);\r\n\t\t\tpos2 = pos1+ rd2*t2;\r\n\t\t\tm2 = map(pos2, false);\r\n\t\t\tt2+=0.2*m2.x;\r\n\t\t\tscol += vec3(1.+m2.z, 1., 1.-m2.z)*step(1., m2.y)*(m1.z==.03 ? vec3(.6, .8, 1.) : vec3(1));\r\n\r\n\t\t}\r\n\r\n\t\tscol=clamp(.009*scol+.06*scatter, 0., 1.) * clamp((236. / sp - iTime) / 8., 0., 1.);;\r\n        fragColor = scol.xyzz;\r\n        //fragColor = pow(fragColor,vec4(1.0/2.2));\r\n\t\t//fragColor =mix(scol.xyzz, texture(iChannel0, uv), pow(.0001, iTimeDelta));\r\n\t}\r\n}\r\n","inputs":[],"outputs":[],"code":"// \"in my crawl space\"\r\n// Shadertoy port of our windows 4k intro:\r\n\r\n// https://www.pouet.net/prod.php?which=82169\r\n\r\n// https://www.youtube.com/watch?v=jw-nC5bINFc\r\nvec3 scatter =vec3(0.);\r\nfloat sp = 2.0833;\r\nvec3 lpos1=vec3(0); vec3 lpos2=vec3(0);\r\nvec3 lpos3=vec3(0, 1, 0);\r\n\r\nfloat time =0.;\r\nfloat kk=0.;\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif( x < d.x ) d = vec3(x, y, z);\r\n}\r\n\r\n// method by iq/shane\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tp = fract(p * .1031);\r\n\tp *= p + 19.19;\r\n\tp *= p + p;\r\n\treturn fract(p);\r\n}\r\n\r\n// method by fizzer\r\nvec3 hashHs(vec3 n, float seed)\r\n{\r\n\tfloat u = hash11(78.233+seed);\r\n\tfloat v = hash11(10.873+seed);\r\n\tfloat a = 6.2831853 * v;\r\n\tu = 2.0*u - 1.0;\r\n\treturn normalize(n+vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u));\r\n}\r\n\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nfloat sdRoundBox(vec3 p, vec3 b, float r)\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn length(max(d, 0.0)) - r;\r\n}\r\n\r\nfloat pattern(vec2 p)\r\n{\r\n\tp.x += 5.5;\r\n\tp.y *= 2.;\r\n\tp = floor(p);\r\n\tif( iTime>160./sp*kk&&iTime<192./sp ) p.y += floor(iTime*sp/2.)*17.;\r\n\tp = floor(p);\r\n\treturn (sin(p.x*p.y) > .8) ? 2. : .9;\r\n}\r\n\r\nfloat vines(vec3 p, float s, float t)\r\n{\r\n\tp.x=abs(p.x)+t*.1;\r\n\tpR(p.yz, p.x*1.); p=abs(p); p.yz -= .06*s;\r\n\tpR(p.yz, p.x*-3.); p=abs(p); p.yz -= .05*s;\r\n\tpR(p.yz, p.x*5.+t); p=abs(p); p.yz -= .04*(s*.5+.5);\r\n\treturn length(p.yz);\r\n}\r\n\r\nvec3 map(vec3 p, bool flag)\r\n{\r\n\tfloat wallnoise = (noise(83.*p)+noise(17.*p))*noise(7.*p);\r\n\tvec3 d = vec3(1, 0, 0);\r\n\r\n\tfloat sd1 = length(p+lpos1)-.4;\r\n\tfloat sd2 = length(p+lpos2)-.4;\r\n\tfloat waves = 0.;\r\n\tif( iTime > 48./sp) waves=0.03;\t\t\t\t\t\t\r\n\tdmin(d, 1.49+kk*2.5-abs(p.x+0.01*wallnoise), .99-0.5*wallnoise, 0.); \r\n\tif( kk>0. ) {\r\n\t\tdmin(d, 1.2+p.y, pattern(p.xz)-.6*wallnoise, 0.); \t\r\n\r\n\t\tdmin(d,\r\n\t\t\tmax(vines(p+vec3(0, 0, 2), .5+5./(1.+p.x*p.x*2.), iTime)-.02,\r\n\t\t\t\tmax(\r\n\t\t\t\t\tabs(p.x)-3.,\r\n\t\t\t\t\t3.5-(iTime-77.)*.25+max(iTime-192./sp, 0.)*2.+sin(p.y*20.)*sin(p.z*10.) - abs(p.x)\r\n\t\t\t\t)\r\n\t\t\t),.1, .2);\r\n\r\n\t\tvec3 q=p.yxz;\r\n\t\tq.z=fract(q.z/3.-.2)*3.-1.5;\r\n\t\tq.y=abs(q.y)-3.5;\r\n\t\tq.x -= 6.;\r\n\t\tdmin(d,vines(q, 1.3+20./(1.+q.x*q.x*.45), 0.)-.05,.1, .2);\r\n\t}\r\n\telse {\r\n\t\tdmin(d, .8-waves*sin(8.*p.z+time)*sin(6.*p.x+1.6*time+sin(2.*p.z))+p.y, .25, waves);\r\n\t\tdmin(d, 0.75-p.z, .8*sin(20.*p.x), 0.); \t\r\n\t\tdmin(d, 0.8-p.y, pattern(p.xz)-.6*wallnoise, 0.); \t\r\n\t}\r\n\tfloat amp = 0.;\r\n\tif( iTime > 96./sp &&fract(iTime*sp/4.)<=0.75+kk )  amp=abs(sin(20.*p.z));\r\n\tif( iTime>96./sp && flag && fract(iTime*sp/4.)<=0.75+kk )\r\n\t{\r\n\t\tscatter += max(-(sd1-1.2), 0.)*.06*vec3(0, 1, 1); \r\n\t\tscatter += max(-(sd2-1.2), 0.)*.06*vec3(2, 1, 0);\r\n\t}\r\n\r\n\tif( iTime>32./sp )\r\n\t{\r\n\t\tdmin(d,sd1,.07+amp,-1.);\r\n\t\tdmin(d,sd2,.07+amp,1.); \r\n\t}\r\n\r\n\tvec3 q = abs(p);\r\n\tif (iTime>24./sp&&fract(iTime*sp/8.)>=0.924-kk&&(iTime<60./sp||iTime>64./sp))\r\n\t{\r\n\t\tq.x -= 1.49+kk*2.4;\r\n\t\tq.y -= .4+.4*sin(time)*(1.-kk)+kk*.4;\r\n\t\tdmin(d, length(q.xy)-.015, 2., -.4);\r\n\t}\r\n\r\n\tif( iTime>64./sp)\r\n\t\tif( iTime<192./sp)\r\n\t\t{\r\n\t\t\tq=p+vec3(0, 0, 2.);\r\n\t\t\tpR(q.xy, 0.33*time);\r\n\t\t\tpR(q.xz, 0.4*time);\r\n\t\t\tfloat rb=sdRoundBox(q, vec3(.48), .08);\r\n\t\t\tdmin(d, rb, -.7+1.9*abs(sin(10.*q.x+10.*q.y)), 0.);\r\n\t\t}\r\n\t\telse\r\n\t\t\tdmin(d, length(p+vec3(0, 0, 2))-.5, .07+amp, 0.);\r\n\treturn d;\r\n}\r\n\r\nvec3 normal(vec3 p)\r\n{\r\n\tvec2 e = vec2(0,.0001);\r\n\treturn normalize(map(p, false).x-vec3(map(p - e.yxx, false).x, map(p - e.xyx, false).x, map(p - e.xxy, false).x));\r\n}\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\ttime=iTime*0.7;\r\n\tkk = step(128., iTime*sp);\r\n\tif( fract(iTime*sp/8.)<.75 )\r\n\t{\r\n\t\ttime += fract(-iTime*sp)+17.*ceil(iTime*sp);\r\n\t\tkk = step(156., iTime*sp);\r\n\t}\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tfragColor = vec4(0);\r\n\tif( uv.y>.11 && uv.y<.89 )\r\n\t{\r\n\t\tfloat t1 = 0., t2 = 0., t3=0., seed = 0.;\r\n\t\tvec3 ro1 = vec3(0, 0, -2.5-kk*(1.+max(159.-iTime*sp, 0.)+max(iTime*sp-192., 0.)*.1)),\r\n\t\t\t rd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\r\n\r\n\t\tif( iTime>160./sp&&iTime<192./sp)\r\n\t\t{\r\n\t\t\tvec2 ca=sin(vec2(.35, .47)*(iTime+fract(-iTime/8.*sp)+42.*ceil(iTime/8.*sp)))*vec2(1., .3);\r\n\t\t\tpR(ro1.zy, ca.y); pR(rd1.zy, ca.y);\t\r\n\t\t\tpR(ro1.xz, ca.x); pR(rd1.xz, ca.x);\t\r\n\t\t}\r\n        \r\n\t\tro1.z-=2.5;\r\n\t\tlpos1 = vec3(1.*cos(time), .3*sin(time), 2.+sin(0.5*time));\t\r\n\t\tlpos2 = vec3(1.2*cos(0.3*time), .4*sin(0.4*time), 2.+sin(0.2*time));\r\n\t\tlpos3=vec3(sin(0.5*time), 1, 0);\r\n\t\tif( kk>0. )\r\n\t\t{\r\n\t\t\tlpos1 = vec3(3, 0, 2);\r\n\t\t\tlpos2 = vec3(-3, 0, 2);\r\n\t\t\tlpos3=vec3(0, -1, 0);\r\n\t\t}\r\n\t\tseed=uv.x*uv.y+uv.y+uv.x+fract(iTime);\r\n\t\tvec3 scol=vec3(0), m1, m2, m3, ro2, rd2, nor1, nor2, pos1, pos2, pos3;\r\n\r\n\t\tfor( int i = 0; i < 150; i++ )\r\n\t\t{\r\n\t\t\tseed=32.+seed*fract(seed);\r\n\t\t\tpos1 = ro1+rd1*t1;\r\n\t\t\tm1 = map(pos1, true);\r\n\t\t\tt1+=0.2*(m1.x);\r\n\r\n\t\t\tif( m1.x<0.001 )\r\n\t\t\t{\r\n\t\t\t\tscol+= vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*(150.-float(i))*(m1.z==.03 ? vec3(.6, .8, 1.) : vec3(1));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tpos2=pos1+mix(lpos3, hashHs(lpos3, seed), 0.15)*t2; \r\n\t\t\tm2 = map(pos2, false);\r\n\t\t\tt2+=m2.x;\r\n\r\n\t\t\tif( m2.y>=1.&&m2.z==0. )\r\n\t\t\t\tscol+=(.5+5.*m1.x*noise(7.*pos1+mix(vec3(iTime), vec3(0, -iTime, 0), kk)));\t\r\n\t\t}\r\n\r\n\t\tnor1 = normal(pos1);\r\n\t\tm1.y=clamp(m1.y, 0., 1.);\r\n\t\tt2=0.;\r\n\t\tfor( int i = 1; i < 100; i++ )\r\n\t\t{\r\n\t\t\tseed=32.+seed*fract(seed);\r\n\t\t\trd2 = mix(reflect(rd1, nor1), hashHs(nor1, seed), m1.y);\r\n\t\t\tpos2 = pos1+ rd2*t2;\r\n\t\t\tm2 = map(pos2, false);\r\n\t\t\tt2+=0.2*m2.x;\r\n\t\t\tscol += vec3(1.+m2.z, 1., 1.-m2.z)*step(1., m2.y)*(m1.z==.03 ? vec3(.6, .8, 1.) : vec3(1));\r\n\r\n\t\t}\r\n\r\n\t\tscol=clamp(.009*scol+.06*scatter, 0., 1.) * clamp((236. / sp - iTime) / 8., 0., 1.);;\r\n        fragColor = scol.xyzz;\r\n        //fragColor = pow(fragColor,vec4(1.0/2.2));\r\n\t\t//fragColor =mix(scol.xyzz, texture(iChannel0, uv), pow(.0001, iTimeDelta));\r\n\t}\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Input - Time","id":"af7d383d414741edb4159353bc76c6ab","date":null,"viewed":0,"name":"Input - Time","description":"Simple realtime, real time, watch. The background changes with the time of day - dark grey at night, and blue during the day \nhttps://www.shadertoy.com/view/lsXGz8","likes":0,"published":null,"tags":["2d"," time"," clock"," watch"]},"ver":null,"info":{"Name":"Input - Time","id":"af7d383d414741edb4159353bc76c6ab","date":null,"viewed":0,"name":"Input - Time","description":"Simple realtime, real time, watch. The background changes with the time of day - dark grey at night, and blue during the day \nhttps://www.shadertoy.com/view/lsXGz8","likes":0,"published":null,"tags":["2d"," time"," clock"," watch"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","inputs":[],"outputs":[],"code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Jupiter","id":"f42bd54a7b094bdfa426589faab377d5","date":null,"viewed":0,"name":"Jupiter","description":"Jupiter UV effect WIP\r\nTry increasing iteration, and enabling fullscreen to see less aliasing artifact. \r\n\r\nBased on --> https://www.shadertoy.com/view/ltc3Rj\r\nBlog post --> http://viclw17.github.io/2018/06/12/GLSL-Practice-With-Shadertoy/\r\nhttps://www.shadertoy.com/view/MdyfWw","likes":0,"published":null,"tags":["2d"," uv"]},"ver":null,"info":{"Name":"Jupiter","id":"f42bd54a7b094bdfa426589faab377d5","date":null,"viewed":0,"name":"Jupiter","description":"Jupiter UV effect WIP\r\nTry increasing iteration, and enabling fullscreen to see less aliasing artifact. \r\n\r\nBased on --> https://www.shadertoy.com/view/ltc3Rj\r\nBlog post --> http://viclw17.github.io/2018/06/12/GLSL-Practice-With-Shadertoy/\r\nhttps://www.shadertoy.com/view/MdyfWw","likes":0,"published":null,"tags":["2d"," uv"]},"renderpass":[{"Code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","inputs":[],"outputs":[],"code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2017\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n\r\n#define MAT_MUSH_HEAD 1.0\r\n#define MAT_MUSH_NECK 2.0\r\n#define MAT_LADY_BODY 3.0\r\n#define MAT_LADY_HEAD 4.0\r\n#define MAT_LADY_LEGS 5.0\r\n#define MAT_GRASS     6.0\r\n#define MAT_GROUND    7.0\r\n#define MAT_MOSS      8.0\r\n#define MAT_CITA      9.0\r\n\r\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\r\n\r\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\r\n{\r\n#if 1\r\n    vec3 p = pos - cen;\r\n    float d = length(p/rad) - 1.0;   \r\n    return d * min(min(rad.x,rad.y),rad.z);\r\n#else\r\n    vec3 p = pos - cen;\r\n    float k0 = length(p/rad);\r\n    float k1 = length(p/(rad*rad));\r\n    return k0*(k0-1.0)/k1;\r\n#endif    \r\n}\r\n    \r\nvec2 sdLine( in vec3 pos, in vec3 a, in vec3 b )\r\n{\r\n    vec3 pa = pos - a;\r\n    vec3 ba = b - a;\r\n   \r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    \r\n    return vec2( length(pa-h*ba), h );\r\n}\r\n\r\nvec2 sdLineOri( in vec3 p, in vec3 b )\r\n{\r\n    float h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );\r\n    \r\n    return vec2( length(p-h*b), h );\r\n}\r\nvec2 sdLineOriY( in vec3 p, in float b )\r\n{\r\n    float h = clamp( p.y/b, 0.0, 1.0 );\r\n    \r\n    return vec2( length(vec3(p.x,p.y-b*h,p.z)), h );\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return min(a, b) - h*h*0.25/k;\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return max(a, b) + h*h*0.25/k;\r\n}\r\n\r\nfloat length2(in vec2 p ) { return dot(p,p); }\r\nfloat length2(in vec3 p ) { return dot(p,p); }\r\n\r\nvec3 rotateY( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateX( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\nvec3 rotateZ( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\n\r\n//==================================================\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n//==================================================\r\n\r\nvec3 mapLadyBug( vec3 p, float curmin )\r\n{\r\n    \r\n    float db = length(p-vec3(0.0,-0.35,0.05))-1.3;\r\n    if( db>curmin ) return vec3(10000.0,0.0,0.0);\r\n    \r\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\r\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\r\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\r\n\r\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\r\n\r\n    // --------\r\n    vec3 hc = vec3(0.0,0.1,0.8);\r\n    vec3 ph = rotateX(p-hc,0.5);\r\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\r\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\r\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\r\n\r\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\r\n    \r\n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq\r\n\r\n    // -------------\r\n    \r\n    vec3 k1 = vec3(0.42,-0.05,0.92);\r\n    vec3 k2 = vec3(0.49,-0.2,1.05);\r\n    float dLegs = 10.0;\r\n\r\n    float sx = sign(p.x);\r\n    p.x = abs(p.x);\r\n    for( int k=0; k<3; k++ )\r\n    {   \r\n        vec3 q = p;\r\n        q.y -= min(sx,0.0)*0.1;\r\n        if( k==0) q += vec3( 0.0,0.11,0.0);\r\n        if( k==1) q += vec3(-0.3,0.1,0.2);\r\n        if( k==2) q += vec3(-0.3,0.1,0.6);\r\n        \r\n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\r\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k1, k2 );\r\n        se.x -= 0.01 + 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\r\n        se.x -= 0.02 - 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n    }\r\n    \r\n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\r\n\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToMushrom( in vec3 pos )\r\n{\r\n    vec3 qos = pos;\r\n    qos.xy = (mat2(60,11,-11,60)/61.0) * qos.xy;\r\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\r\n    qos.y -= 0.4;\r\n    return qos;\r\n}\r\n\r\nvec3 mapMushroom( in vec3 pos, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n\r\n    vec3 qos = worldToMushrom(pos);\r\n    float db = length(qos-vec3(0.0,1.2,0.0)) - 1.3;\r\n    if( db<cur.x )\r\n    {\r\n\r\n        {\r\n\r\n            float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\r\n\r\n            d1 -= 0.025*textureLod( iChannel1, 0.05*qos.xz, 0.0 ).x - 0.02;\r\n\r\n            float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\r\n            float d = smax( d1, -d2, 0.1 );\r\n            d *= 0.8;\r\n            if( d<res.x )\r\n            {\r\n                res = vec3( d, MAT_MUSH_HEAD, 0.0 );\r\n            }\r\n        }\r\n\r\n\r\n        {\r\n            pos.x += 0.3*sin(pos.y) - 0.65;\r\n            float pa = sin( 20.0*atan(pos.z,pos.x) );\r\n            vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\r\n\r\n            float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\r\n\r\n            float d3 = se.x - tt;\r\n\r\n            d3 = smin( d3, sdEllipsoid( pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz),0.0), vec3(0.3,0.05,0.3) ), 0.05);\r\n            d3 += 0.003*pa;\r\n            d3 *= 0.7;\r\n            \r\n            if( d3<res.x )\r\n                res = vec3( d3, MAT_MUSH_NECK, 0.0 );\r\n        }\r\n    \r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n\r\nvec3 mapGrass( in vec3 pos, float h, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n    \r\n    float db = pos.y-2.6;\r\n    \r\n    if( db<cur.x && pos.z>-1.65 )\r\n    {\r\n        const float gf = 4.0;\r\n\r\n        vec3 qos = pos * gf;\r\n\r\n        vec2 n = floor( qos.xz );\r\n        vec2 f = fract( qos.xz );\r\n        for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n\r\n            vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\r\n\r\n            if( ra2.x<0.73 ) continue;\r\n\r\n            vec2  o = hash2( n + g );\r\n            vec2  r = g - f + o;\r\n            vec2 ra = hash2( n + g + vec2(11.0,37.0) );\r\n\r\n            float gh = 2.0*(0.3+0.7*ra.x);\r\n\r\n            float rosy = qos.y - h*gf;\r\n\r\n            r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\r\n            r.x -= 0.03*rosy*rosy;\r\n\r\n            r.x *= 4.0;\r\n\r\n            float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\r\n            vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\r\n\r\n            float gr = 0.3*sqrt(1.0-0.99*se.y);\r\n            float d = se.x - gr;\r\n            d /= 4.0;\r\n\r\n            d /= gf;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_GRASS;\r\n                res.z = r.y;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n    \r\n    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));\r\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\r\n    float dm = 1e10;\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 o = vec3(0.0,3.2,0.0);\r\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\r\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\r\n        float d = length2(pos - o);\r\n        dm = min(d,dm);\r\n    }\r\n    dm = sqrt(dm)-0.02;\r\n    \r\n    if( dm<res.x )\r\n        res = vec3( dm,MAT_CITA,0);\r\n    \r\n    return res;\r\n}\r\n\r\nvec3 mapMoss( in vec3 pos, float h, vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n\r\n    float db = pos.y-2.2;\r\n    if( db<res.x )\r\n    {\r\n    const float gf = 2.0;\r\n    \r\n    vec3 qos = pos * gf;\r\n    vec2 n = floor( qos.xz );\r\n    vec2 f = fract( qos.xz );\r\n\r\n    for( int k=ZERO; k<2; k++ )\r\n    {\r\n        for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\r\n            vec2  r = g - f + o;\r\n\r\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\r\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\r\n\r\n            float mh = 0.5 + 1.0*ra2.y;\r\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\r\n\r\n            vec3 rr = vec3(r.x,ros.y,r.y);\r\n\r\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\r\n\r\n            rr.xz += 0.5*(-1.0+2.0*ra2);\r\n            vec2 se  = sdLineOriY( rr, gf*mh );\r\n            float sey = se.y;\r\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\r\n\r\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\r\n\r\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );\r\n            float cc = cos(an);\r\n            float ss = sin(an);\r\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\r\n\r\n            pp.xz = abs(pp.xz);\r\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \r\n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\r\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\r\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\r\n\r\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\r\n            d = smin( d, d2, 0.05 );\r\n\r\n            d /= gf;\r\n            d *= 0.9;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_MOSS;\r\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\r\n                float e = clamp((pos.y - h)/1.0,0.0,1.0);\r\n                res.z *= 0.02 + 0.98*e*e;\r\n                \r\n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToLadyBug( in vec3 p )\r\n{\r\n    // TODO: combine all of the above in a single 4x4 matrix\r\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\r\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\r\n    p.y += 0.2;\r\n    return p;\r\n}\r\n\r\n\r\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\r\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\r\n\r\nfloat terrain( in vec2 pos )\r\n{\r\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\r\n}\r\n\r\nvec3 mapShadow( in vec3 pos )\r\n{\r\n    float h = terrain( pos.xz );\r\n    float d = pos.y - h;\r\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\r\n    \r\n    res = mapGrass(pos,h,res);\r\n    res = mapMoss(pos,h,res);\r\n\r\n    vec3 m1 =  pos - mushroomPos1;\r\n    vec3 m2 = (pos - mushroomPos2).zyx;\r\n    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\tres = mapMushroom(m1, res);\r\n\r\n\r\n    vec3 q = worldToLadyBug(pos);\r\n    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;\r\n    if( d3.x<res.x ) res = d3;\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 map( in vec3 pos )\r\n{\r\n    vec3 res = mapShadow(pos);\r\n        \r\n    res = mapCrapInTheAir(pos, res);\r\n\r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n#if 0    \r\n    vec2 e = vec2(0.002,0.0); \r\n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\r\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\r\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*0.002).x;\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n    \r\nfloat calcShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    float res = 1.0;\r\n    float t = 0.01;\r\n    for( int i=ZERO; i<100; i++ )\r\n    {\r\n        vec3 pos = ro + rd*t;\r\n        float h = mapShadow( pos ).x;\r\n        res = min( res, 16.0*max(h,0.0)/t );\r\n        if( h<0.0001 || pos.y>3.0 ) break;\r\n        \r\n        t += clamp(h,0.01,0.2);\r\n    }\r\n    \r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n    const float tmax = 12.0;\r\n    \r\n\tvec3 res = vec3(1.0,-1.0, 0.0);\r\n\r\n    for( int i=ZERO; i<256; i++ )\r\n    {\r\n        vec3 h = map( ro + rd*res.x );\r\n        if( h.x<(0.00015*res.x) || res.x>tmax )\r\n            break;\r\n        res.x += h.x;\r\n        res.y = h.y;\r\n        res.z = h.z;\r\n    }\r\n    \r\n    if( res.x>=tmax ) res.y = -1.0;\r\n    \r\n    return res;\r\n}\r\n\r\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\r\n                out vec3 matColor, out float matRough,\r\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\r\n{\r\n    matNor = nor;\r\n    matOcc = 1.0;\r\n    matSSS = 0.0;\r\n    matRough = 1.0;\r\n    matRefOcc = 1.0;\r\n    matGamma = vec3(1.0);\r\n    \r\n    if( matID<MAT_MUSH_HEAD+0.5 )\r\n    {\r\n        vec3 m1 =  pos - mushroomPos1;\r\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\r\n    \tif( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\r\n        vec3 qos = worldToMushrom( m1 );\r\n\r\n        matColor = vec3(0.26,0.21,0.15);\r\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\r\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\r\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\r\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\r\n        matColor *= 0.4*0.45;\r\n        matColor = max( matColor, 0.0 );\r\n        \r\n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\r\n        \r\n        matRough = 0.6;\r\n        matSSS = 1.0;\r\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.87,1.0);\r\n    }\r\n    else if( matID<MAT_MUSH_NECK+0.5 )\r\n    {\r\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0/3.14159) );\r\n\r\n        matColor = vec3(0.42,0.35,0.15);\r\n        \r\n        float pa = smoothstep(0.3,0.8,pos.y);\r\n\r\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\r\n        matColor = max(vec3(0.0),matColor);\r\n        \r\n        matColor *= 0.22;\r\n        matColor = clamp( matColor, 0.0, 1.0 );\r\n        \r\n        matRough = 0.7;\r\n        matSSS = 1.0;\r\n        \r\n        matOcc = clamp( (pos.y-0.5)/1.3,0.0,1.0);\r\n        matOcc = matOcc*matOcc;\r\n        matOcc *= clamp( 1.0-(pos.y-1.2)/1.2,0.0,1.0);\r\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.95,1.0);\r\n\r\n    }\r\n    else if( matID<MAT_LADY_BODY+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n            \r\n        // red\r\n        matColor = vec3(0.16,0.008,0.0);\r\n\r\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\r\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\r\n        \r\n        qos.x = abs(qos.x);\r\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\r\n\r\n        // white\r\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\r\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\r\n\r\n        // black\r\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\r\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\r\n        \r\n        \r\n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\r\n        matColor *= 1.0 - 0.5*f;\r\n        f = texture( iChannel1, 4.0*qos.xz ).x;\r\n        matColor *= 1.0 - 0.99*f*f;\r\n        \r\n        \r\n        matColor *= 1.3;\r\n        matRough = 0.15;\r\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\r\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\r\n    }\r\n    else if( matID<MAT_LADY_HEAD+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n\r\n        matColor = vec3(0.001);\r\n\r\n        qos.z += -0.22;\r\n        qos.y += -0.7;\r\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\r\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\r\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\r\n        matRough = 0.2;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_LADY_LEGS+.5 )\r\n    {\r\n        matColor = vec3(0.0,0.0,0.0);\r\n        matRough = 0.8;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_GRASS+0.5 )\r\n    {\r\n    \tmatColor = vec3(0.1,0.15,0.03);\r\n        \r\n        float h = terrain( pos.xz );\r\n        float e = clamp(pos.y-h,0.0,1.0);\r\n        matOcc = 0.01 + 0.99*e*e;\r\n        \r\n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\r\n        matColor += 0.04*sin(matID2*41.0);\r\n        \r\n        matSSS = 0.2;\r\n        matColor *= 0.75;\r\n        matRough = 0.5;\r\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        //matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.9,0.9,1.0);\r\n    }\r\n    else if( matID<MAT_GROUND+0.5 )\r\n    {\r\n        matColor = vec3(0.2,0.2,0.0);\r\n        matRough = 1.0;\r\n        matOcc = 0.02;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_MOSS+0.5 )\r\n    {\r\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\r\n        \r\n        float f = texture( iChannel1, pos.xy*8.0 ).x;\r\n        matColor *= 0.55 + f;\r\n            \r\n        matOcc = abs(matID2);\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRough = 0.25;\r\n        matSSS = 0.5;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.7,0.7,1.0);\r\n        \r\n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\r\n    }\r\n    else //if( matID<MAT_CITA+0.5 )\r\n    {\r\n        matColor = vec3(1.0);\r\n        matSSS = 1.0;\r\n        matRough = 1.0;\r\n        matGamma = vec3(0.5);\r\n    }\r\n}\r\n\r\n\r\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\r\n               in float occ,\r\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\r\n               in vec3 matGamma )\r\n{\r\n    vec3 col = vec3(0.0);\r\n\r\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\r\n    \r\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\r\n    \r\n    float pn = exp2( 10.0*(1.0-matRough) );\r\n    \r\n\r\n    // sun light\r\n    {\r\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\r\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\r\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\r\n        float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );\r\n        vec3 hal = normalize( sun - rd );\r\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\r\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\r\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\r\n    }\r\n\r\n    // sky light\r\n    {\r\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\r\n        float dif = 0.5 + 0.5*nor.y;\r\n        col += matColor * skyColor * dif * occ;\r\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\r\n    }\r\n\r\n    // bounce light\r\n    {\r\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\r\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\r\n        col += matColor * bouColor * dif * occ;\r\n    }\r\n\r\n    col += fre*matColor*occ*matSSS;\r\n    col = pow( max(col,0.0), matGamma );\r\n\r\n    return col;\r\n}\r\n\r\nvec3 background(in vec3 d)\r\n{\r\n    // cheap cubemap\r\n    vec3 n = abs(d);\r\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \r\n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\r\n                                     d.xy/d.z;\r\n    \r\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\r\n}\r\n\r\nmat3 calcCamera( in vec3 ro, in vec3 ta )\r\n{\r\n    vec3 w = normalize( ro-ta );\r\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\r\n    vec3 v =          ( cross( w, u ) );\r\n    \r\n    return mat3( u, v, w );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\r\n    \r\n    // camera\r\n    vec3 ro = vec3(0.0,2.7,-3.0);\r\n    vec3 ta = vec3(0.0,1.9,0.0);\r\n    ro.x += 0.3*sin(0.03*iTime);    \r\n    mat3 camRot = calcCamera( ro, ta );\r\n    \r\n    // ray\r\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\r\n    \r\n    // background\r\n    vec3 col = background(rd);\r\n \r\n    // scene\r\n    vec3 tm = intersect(ro,rd);\r\n    float t = tm.x;\r\n    float matID = tm.y;\r\n    if( matID>0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n    \tvec3 nor = calcNormal( pos ); \r\n        \r\n        vec3 matNormal, matColor, matGamma;\r\n        float matRough, matOcc, matSSS, matRefOcc;\r\n        \r\n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\r\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\r\n    }\r\n    else\r\n    {\r\n        t = 30.0;\r\n    }\r\n    \r\n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\r\n\tfragColor = pow(fragColor,vec4(1.0/2.2));\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2017\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n\r\n#define MAT_MUSH_HEAD 1.0\r\n#define MAT_MUSH_NECK 2.0\r\n#define MAT_LADY_BODY 3.0\r\n#define MAT_LADY_HEAD 4.0\r\n#define MAT_LADY_LEGS 5.0\r\n#define MAT_GRASS     6.0\r\n#define MAT_GROUND    7.0\r\n#define MAT_MOSS      8.0\r\n#define MAT_CITA      9.0\r\n\r\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\r\n\r\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\r\n{\r\n#if 1\r\n    vec3 p = pos - cen;\r\n    float d = length(p/rad) - 1.0;   \r\n    return d * min(min(rad.x,rad.y),rad.z);\r\n#else\r\n    vec3 p = pos - cen;\r\n    float k0 = length(p/rad);\r\n    float k1 = length(p/(rad*rad));\r\n    return k0*(k0-1.0)/k1;\r\n#endif    \r\n}\r\n    \r\nvec2 sdLine( in vec3 pos, in vec3 a, in vec3 b )\r\n{\r\n    vec3 pa = pos - a;\r\n    vec3 ba = b - a;\r\n   \r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    \r\n    return vec2( length(pa-h*ba), h );\r\n}\r\n\r\nvec2 sdLineOri( in vec3 p, in vec3 b )\r\n{\r\n    float h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );\r\n    \r\n    return vec2( length(p-h*b), h );\r\n}\r\nvec2 sdLineOriY( in vec3 p, in float b )\r\n{\r\n    float h = clamp( p.y/b, 0.0, 1.0 );\r\n    \r\n    return vec2( length(vec3(p.x,p.y-b*h,p.z)), h );\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return min(a, b) - h*h*0.25/k;\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return max(a, b) + h*h*0.25/k;\r\n}\r\n\r\nfloat length2(in vec2 p ) { return dot(p,p); }\r\nfloat length2(in vec3 p ) { return dot(p,p); }\r\n\r\nvec3 rotateY( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateX( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\nvec3 rotateZ( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\n\r\n//==================================================\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n//==================================================\r\n\r\nvec3 mapLadyBug( vec3 p, float curmin )\r\n{\r\n    \r\n    float db = length(p-vec3(0.0,-0.35,0.05))-1.3;\r\n    if( db>curmin ) return vec3(10000.0,0.0,0.0);\r\n    \r\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\r\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\r\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\r\n\r\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\r\n\r\n    // --------\r\n    vec3 hc = vec3(0.0,0.1,0.8);\r\n    vec3 ph = rotateX(p-hc,0.5);\r\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\r\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\r\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\r\n\r\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\r\n    \r\n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq\r\n\r\n    // -------------\r\n    \r\n    vec3 k1 = vec3(0.42,-0.05,0.92);\r\n    vec3 k2 = vec3(0.49,-0.2,1.05);\r\n    float dLegs = 10.0;\r\n\r\n    float sx = sign(p.x);\r\n    p.x = abs(p.x);\r\n    for( int k=0; k<3; k++ )\r\n    {   \r\n        vec3 q = p;\r\n        q.y -= min(sx,0.0)*0.1;\r\n        if( k==0) q += vec3( 0.0,0.11,0.0);\r\n        if( k==1) q += vec3(-0.3,0.1,0.2);\r\n        if( k==2) q += vec3(-0.3,0.1,0.6);\r\n        \r\n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\r\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k1, k2 );\r\n        se.x -= 0.01 + 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\r\n        se.x -= 0.02 - 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n    }\r\n    \r\n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\r\n\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToMushrom( in vec3 pos )\r\n{\r\n    vec3 qos = pos;\r\n    qos.xy = (mat2(60,11,-11,60)/61.0) * qos.xy;\r\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\r\n    qos.y -= 0.4;\r\n    return qos;\r\n}\r\n\r\nvec3 mapMushroom( in vec3 pos, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n\r\n    vec3 qos = worldToMushrom(pos);\r\n    float db = length(qos-vec3(0.0,1.2,0.0)) - 1.3;\r\n    if( db<cur.x )\r\n    {\r\n\r\n        {\r\n\r\n            float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\r\n\r\n            d1 -= 0.025*textureLod( iChannel1, 0.05*qos.xz, 0.0 ).x - 0.02;\r\n\r\n            float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\r\n            float d = smax( d1, -d2, 0.1 );\r\n            d *= 0.8;\r\n            if( d<res.x )\r\n            {\r\n                res = vec3( d, MAT_MUSH_HEAD, 0.0 );\r\n            }\r\n        }\r\n\r\n\r\n        {\r\n            pos.x += 0.3*sin(pos.y) - 0.65;\r\n            float pa = sin( 20.0*atan(pos.z,pos.x) );\r\n            vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\r\n\r\n            float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\r\n\r\n            float d3 = se.x - tt;\r\n\r\n            d3 = smin( d3, sdEllipsoid( pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz),0.0), vec3(0.3,0.05,0.3) ), 0.05);\r\n            d3 += 0.003*pa;\r\n            d3 *= 0.7;\r\n            \r\n            if( d3<res.x )\r\n                res = vec3( d3, MAT_MUSH_NECK, 0.0 );\r\n        }\r\n    \r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n\r\nvec3 mapGrass( in vec3 pos, float h, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n    \r\n    float db = pos.y-2.6;\r\n    \r\n    if( db<cur.x && pos.z>-1.65 )\r\n    {\r\n        const float gf = 4.0;\r\n\r\n        vec3 qos = pos * gf;\r\n\r\n        vec2 n = floor( qos.xz );\r\n        vec2 f = fract( qos.xz );\r\n        for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n\r\n            vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\r\n\r\n            if( ra2.x<0.73 ) continue;\r\n\r\n            vec2  o = hash2( n + g );\r\n            vec2  r = g - f + o;\r\n            vec2 ra = hash2( n + g + vec2(11.0,37.0) );\r\n\r\n            float gh = 2.0*(0.3+0.7*ra.x);\r\n\r\n            float rosy = qos.y - h*gf;\r\n\r\n            r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\r\n            r.x -= 0.03*rosy*rosy;\r\n\r\n            r.x *= 4.0;\r\n\r\n            float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\r\n            vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\r\n\r\n            float gr = 0.3*sqrt(1.0-0.99*se.y);\r\n            float d = se.x - gr;\r\n            d /= 4.0;\r\n\r\n            d /= gf;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_GRASS;\r\n                res.z = r.y;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n    \r\n    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));\r\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\r\n    float dm = 1e10;\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 o = vec3(0.0,3.2,0.0);\r\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\r\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\r\n        float d = length2(pos - o);\r\n        dm = min(d,dm);\r\n    }\r\n    dm = sqrt(dm)-0.02;\r\n    \r\n    if( dm<res.x )\r\n        res = vec3( dm,MAT_CITA,0);\r\n    \r\n    return res;\r\n}\r\n\r\nvec3 mapMoss( in vec3 pos, float h, vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n\r\n    float db = pos.y-2.2;\r\n    if( db<res.x )\r\n    {\r\n    const float gf = 2.0;\r\n    \r\n    vec3 qos = pos * gf;\r\n    vec2 n = floor( qos.xz );\r\n    vec2 f = fract( qos.xz );\r\n\r\n    for( int k=ZERO; k<2; k++ )\r\n    {\r\n        for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\r\n            vec2  r = g - f + o;\r\n\r\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\r\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\r\n\r\n            float mh = 0.5 + 1.0*ra2.y;\r\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\r\n\r\n            vec3 rr = vec3(r.x,ros.y,r.y);\r\n\r\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\r\n\r\n            rr.xz += 0.5*(-1.0+2.0*ra2);\r\n            vec2 se  = sdLineOriY( rr, gf*mh );\r\n            float sey = se.y;\r\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\r\n\r\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\r\n\r\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );\r\n            float cc = cos(an);\r\n            float ss = sin(an);\r\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\r\n\r\n            pp.xz = abs(pp.xz);\r\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \r\n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\r\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\r\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\r\n\r\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\r\n            d = smin( d, d2, 0.05 );\r\n\r\n            d /= gf;\r\n            d *= 0.9;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_MOSS;\r\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\r\n                float e = clamp((pos.y - h)/1.0,0.0,1.0);\r\n                res.z *= 0.02 + 0.98*e*e;\r\n                \r\n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToLadyBug( in vec3 p )\r\n{\r\n    // TODO: combine all of the above in a single 4x4 matrix\r\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\r\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\r\n    p.y += 0.2;\r\n    return p;\r\n}\r\n\r\n\r\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\r\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\r\n\r\nfloat terrain( in vec2 pos )\r\n{\r\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\r\n}\r\n\r\nvec3 mapShadow( in vec3 pos )\r\n{\r\n    float h = terrain( pos.xz );\r\n    float d = pos.y - h;\r\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\r\n    \r\n    res = mapGrass(pos,h,res);\r\n    res = mapMoss(pos,h,res);\r\n\r\n    vec3 m1 =  pos - mushroomPos1;\r\n    vec3 m2 = (pos - mushroomPos2).zyx;\r\n    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\tres = mapMushroom(m1, res);\r\n\r\n\r\n    vec3 q = worldToLadyBug(pos);\r\n    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;\r\n    if( d3.x<res.x ) res = d3;\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 map( in vec3 pos )\r\n{\r\n    vec3 res = mapShadow(pos);\r\n        \r\n    res = mapCrapInTheAir(pos, res);\r\n\r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n#if 0    \r\n    vec2 e = vec2(0.002,0.0); \r\n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\r\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\r\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*0.002).x;\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n    \r\nfloat calcShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    float res = 1.0;\r\n    float t = 0.01;\r\n    for( int i=ZERO; i<100; i++ )\r\n    {\r\n        vec3 pos = ro + rd*t;\r\n        float h = mapShadow( pos ).x;\r\n        res = min( res, 16.0*max(h,0.0)/t );\r\n        if( h<0.0001 || pos.y>3.0 ) break;\r\n        \r\n        t += clamp(h,0.01,0.2);\r\n    }\r\n    \r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n    const float tmax = 12.0;\r\n    \r\n\tvec3 res = vec3(1.0,-1.0, 0.0);\r\n\r\n    for( int i=ZERO; i<256; i++ )\r\n    {\r\n        vec3 h = map( ro + rd*res.x );\r\n        if( h.x<(0.00015*res.x) || res.x>tmax )\r\n            break;\r\n        res.x += h.x;\r\n        res.y = h.y;\r\n        res.z = h.z;\r\n    }\r\n    \r\n    if( res.x>=tmax ) res.y = -1.0;\r\n    \r\n    return res;\r\n}\r\n\r\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\r\n                out vec3 matColor, out float matRough,\r\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\r\n{\r\n    matNor = nor;\r\n    matOcc = 1.0;\r\n    matSSS = 0.0;\r\n    matRough = 1.0;\r\n    matRefOcc = 1.0;\r\n    matGamma = vec3(1.0);\r\n    \r\n    if( matID<MAT_MUSH_HEAD+0.5 )\r\n    {\r\n        vec3 m1 =  pos - mushroomPos1;\r\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\r\n    \tif( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\r\n        vec3 qos = worldToMushrom( m1 );\r\n\r\n        matColor = vec3(0.26,0.21,0.15);\r\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\r\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\r\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\r\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\r\n        matColor *= 0.4*0.45;\r\n        matColor = max( matColor, 0.0 );\r\n        \r\n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\r\n        \r\n        matRough = 0.6;\r\n        matSSS = 1.0;\r\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.87,1.0);\r\n    }\r\n    else if( matID<MAT_MUSH_NECK+0.5 )\r\n    {\r\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0/3.14159) );\r\n\r\n        matColor = vec3(0.42,0.35,0.15);\r\n        \r\n        float pa = smoothstep(0.3,0.8,pos.y);\r\n\r\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\r\n        matColor = max(vec3(0.0),matColor);\r\n        \r\n        matColor *= 0.22;\r\n        matColor = clamp( matColor, 0.0, 1.0 );\r\n        \r\n        matRough = 0.7;\r\n        matSSS = 1.0;\r\n        \r\n        matOcc = clamp( (pos.y-0.5)/1.3,0.0,1.0);\r\n        matOcc = matOcc*matOcc;\r\n        matOcc *= clamp( 1.0-(pos.y-1.2)/1.2,0.0,1.0);\r\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.95,1.0);\r\n\r\n    }\r\n    else if( matID<MAT_LADY_BODY+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n            \r\n        // red\r\n        matColor = vec3(0.16,0.008,0.0);\r\n\r\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\r\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\r\n        \r\n        qos.x = abs(qos.x);\r\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\r\n\r\n        // white\r\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\r\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\r\n\r\n        // black\r\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\r\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\r\n        \r\n        \r\n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\r\n        matColor *= 1.0 - 0.5*f;\r\n        f = texture( iChannel1, 4.0*qos.xz ).x;\r\n        matColor *= 1.0 - 0.99*f*f;\r\n        \r\n        \r\n        matColor *= 1.3;\r\n        matRough = 0.15;\r\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\r\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\r\n    }\r\n    else if( matID<MAT_LADY_HEAD+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n\r\n        matColor = vec3(0.001);\r\n\r\n        qos.z += -0.22;\r\n        qos.y += -0.7;\r\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\r\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\r\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\r\n        matRough = 0.2;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_LADY_LEGS+.5 )\r\n    {\r\n        matColor = vec3(0.0,0.0,0.0);\r\n        matRough = 0.8;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_GRASS+0.5 )\r\n    {\r\n    \tmatColor = vec3(0.1,0.15,0.03);\r\n        \r\n        float h = terrain( pos.xz );\r\n        float e = clamp(pos.y-h,0.0,1.0);\r\n        matOcc = 0.01 + 0.99*e*e;\r\n        \r\n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\r\n        matColor += 0.04*sin(matID2*41.0);\r\n        \r\n        matSSS = 0.2;\r\n        matColor *= 0.75;\r\n        matRough = 0.5;\r\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        //matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.9,0.9,1.0);\r\n    }\r\n    else if( matID<MAT_GROUND+0.5 )\r\n    {\r\n        matColor = vec3(0.2,0.2,0.0);\r\n        matRough = 1.0;\r\n        matOcc = 0.02;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_MOSS+0.5 )\r\n    {\r\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\r\n        \r\n        float f = texture( iChannel1, pos.xy*8.0 ).x;\r\n        matColor *= 0.55 + f;\r\n            \r\n        matOcc = abs(matID2);\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRough = 0.25;\r\n        matSSS = 0.5;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.7,0.7,1.0);\r\n        \r\n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\r\n    }\r\n    else //if( matID<MAT_CITA+0.5 )\r\n    {\r\n        matColor = vec3(1.0);\r\n        matSSS = 1.0;\r\n        matRough = 1.0;\r\n        matGamma = vec3(0.5);\r\n    }\r\n}\r\n\r\n\r\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\r\n               in float occ,\r\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\r\n               in vec3 matGamma )\r\n{\r\n    vec3 col = vec3(0.0);\r\n\r\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\r\n    \r\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\r\n    \r\n    float pn = exp2( 10.0*(1.0-matRough) );\r\n    \r\n\r\n    // sun light\r\n    {\r\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\r\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\r\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\r\n        float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );\r\n        vec3 hal = normalize( sun - rd );\r\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\r\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\r\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\r\n    }\r\n\r\n    // sky light\r\n    {\r\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\r\n        float dif = 0.5 + 0.5*nor.y;\r\n        col += matColor * skyColor * dif * occ;\r\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\r\n    }\r\n\r\n    // bounce light\r\n    {\r\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\r\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\r\n        col += matColor * bouColor * dif * occ;\r\n    }\r\n\r\n    col += fre*matColor*occ*matSSS;\r\n    col = pow( max(col,0.0), matGamma );\r\n\r\n    return col;\r\n}\r\n\r\nvec3 background(in vec3 d)\r\n{\r\n    // cheap cubemap\r\n    vec3 n = abs(d);\r\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \r\n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\r\n                                     d.xy/d.z;\r\n    \r\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\r\n}\r\n\r\nmat3 calcCamera( in vec3 ro, in vec3 ta )\r\n{\r\n    vec3 w = normalize( ro-ta );\r\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\r\n    vec3 v =          ( cross( w, u ) );\r\n    \r\n    return mat3( u, v, w );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\r\n    \r\n    // camera\r\n    vec3 ro = vec3(0.0,2.7,-3.0);\r\n    vec3 ta = vec3(0.0,1.9,0.0);\r\n    ro.x += 0.3*sin(0.03*iTime);    \r\n    mat3 camRot = calcCamera( ro, ta );\r\n    \r\n    // ray\r\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\r\n    \r\n    // background\r\n    vec3 col = background(rd);\r\n \r\n    // scene\r\n    vec3 tm = intersect(ro,rd);\r\n    float t = tm.x;\r\n    float matID = tm.y;\r\n    if( matID>0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n    \tvec3 nor = calcNormal( pos ); \r\n        \r\n        vec3 matNormal, matColor, matGamma;\r\n        float matRough, matOcc, matSSS, matRefOcc;\r\n        \r\n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\r\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\r\n    }\r\n    else\r\n    {\r\n        t = 30.0;\r\n    }\r\n    \r\n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\r\n\tfragColor = pow(fragColor,vec4(1.0/2.2));\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"ladybug","id":"3939cb89fe0a4270a2c8097e2b63a658","date":null,"viewed":0,"name":"ladybug","description":"A ladybug on a mushroom. It renders really slowly. Sorry for that, this is not meant to be rendered with raymarching really, but well, here we are. I'll get a pass later\r\nhttps://www.shadertoy.com/view/4tByz3","likes":0,"published":null,"tags":["procedural"," 3d"," raymarching"," distancefield"]},"ver":null,"info":{"Name":"ladybug","id":"3939cb89fe0a4270a2c8097e2b63a658","date":null,"viewed":0,"name":"ladybug","description":"A ladybug on a mushroom. It renders really slowly. Sorry for that, this is not meant to be rendered with raymarching really, but well, here we are. I'll get a pass later\r\nhttps://www.shadertoy.com/view/4tByz3","likes":0,"published":null,"tags":["procedural"," 3d"," raymarching"," distancefield"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2017\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n\r\n#define MAT_MUSH_HEAD 1.0\r\n#define MAT_MUSH_NECK 2.0\r\n#define MAT_LADY_BODY 3.0\r\n#define MAT_LADY_HEAD 4.0\r\n#define MAT_LADY_LEGS 5.0\r\n#define MAT_GRASS     6.0\r\n#define MAT_GROUND    7.0\r\n#define MAT_MOSS      8.0\r\n#define MAT_CITA      9.0\r\n\r\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\r\n\r\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\r\n{\r\n#if 1\r\n    vec3 p = pos - cen;\r\n    float d = length(p/rad) - 1.0;   \r\n    return d * min(min(rad.x,rad.y),rad.z);\r\n#else\r\n    vec3 p = pos - cen;\r\n    float k0 = length(p/rad);\r\n    float k1 = length(p/(rad*rad));\r\n    return k0*(k0-1.0)/k1;\r\n#endif    \r\n}\r\n    \r\nvec2 sdLine( in vec3 pos, in vec3 a, in vec3 b )\r\n{\r\n    vec3 pa = pos - a;\r\n    vec3 ba = b - a;\r\n   \r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    \r\n    return vec2( length(pa-h*ba), h );\r\n}\r\n\r\nvec2 sdLineOri( in vec3 p, in vec3 b )\r\n{\r\n    float h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );\r\n    \r\n    return vec2( length(p-h*b), h );\r\n}\r\nvec2 sdLineOriY( in vec3 p, in float b )\r\n{\r\n    float h = clamp( p.y/b, 0.0, 1.0 );\r\n    \r\n    return vec2( length(vec3(p.x,p.y-b*h,p.z)), h );\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return min(a, b) - h*h*0.25/k;\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return max(a, b) + h*h*0.25/k;\r\n}\r\n\r\nfloat length2(in vec2 p ) { return dot(p,p); }\r\nfloat length2(in vec3 p ) { return dot(p,p); }\r\n\r\nvec3 rotateY( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateX( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\nvec3 rotateZ( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\n\r\n//==================================================\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n//==================================================\r\n\r\nvec3 mapLadyBug( vec3 p, float curmin )\r\n{\r\n    \r\n    float db = length(p-vec3(0.0,-0.35,0.05))-1.3;\r\n    if( db>curmin ) return vec3(10000.0,0.0,0.0);\r\n    \r\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\r\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\r\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\r\n\r\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\r\n\r\n    // --------\r\n    vec3 hc = vec3(0.0,0.1,0.8);\r\n    vec3 ph = rotateX(p-hc,0.5);\r\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\r\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\r\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\r\n\r\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\r\n    \r\n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq\r\n\r\n    // -------------\r\n    \r\n    vec3 k1 = vec3(0.42,-0.05,0.92);\r\n    vec3 k2 = vec3(0.49,-0.2,1.05);\r\n    float dLegs = 10.0;\r\n\r\n    float sx = sign(p.x);\r\n    p.x = abs(p.x);\r\n    for( int k=0; k<3; k++ )\r\n    {   \r\n        vec3 q = p;\r\n        q.y -= min(sx,0.0)*0.1;\r\n        if( k==0) q += vec3( 0.0,0.11,0.0);\r\n        if( k==1) q += vec3(-0.3,0.1,0.2);\r\n        if( k==2) q += vec3(-0.3,0.1,0.6);\r\n        \r\n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\r\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k1, k2 );\r\n        se.x -= 0.01 + 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\r\n        se.x -= 0.02 - 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n    }\r\n    \r\n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\r\n\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToMushrom( in vec3 pos )\r\n{\r\n    vec3 qos = pos;\r\n    qos.xy = (mat2(60,11,-11,60)/61.0) * qos.xy;\r\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\r\n    qos.y -= 0.4;\r\n    return qos;\r\n}\r\n\r\nvec3 mapMushroom( in vec3 pos, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n\r\n    vec3 qos = worldToMushrom(pos);\r\n    float db = length(qos-vec3(0.0,1.2,0.0)) - 1.3;\r\n    if( db<cur.x )\r\n    {\r\n\r\n        {\r\n\r\n            float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\r\n\r\n            d1 -= 0.025*textureLod( iChannel1, 0.05*qos.xz, 0.0 ).x - 0.02;\r\n\r\n            float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\r\n            float d = smax( d1, -d2, 0.1 );\r\n            d *= 0.8;\r\n            if( d<res.x )\r\n            {\r\n                res = vec3( d, MAT_MUSH_HEAD, 0.0 );\r\n            }\r\n        }\r\n\r\n\r\n        {\r\n            pos.x += 0.3*sin(pos.y) - 0.65;\r\n            float pa = sin( 20.0*atan(pos.z,pos.x) );\r\n            vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\r\n\r\n            float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\r\n\r\n            float d3 = se.x - tt;\r\n\r\n            d3 = smin( d3, sdEllipsoid( pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz),0.0), vec3(0.3,0.05,0.3) ), 0.05);\r\n            d3 += 0.003*pa;\r\n            d3 *= 0.7;\r\n            \r\n            if( d3<res.x )\r\n                res = vec3( d3, MAT_MUSH_NECK, 0.0 );\r\n        }\r\n    \r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n\r\nvec3 mapGrass( in vec3 pos, float h, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n    \r\n    float db = pos.y-2.6;\r\n    \r\n    if( db<cur.x && pos.z>-1.65 )\r\n    {\r\n        const float gf = 4.0;\r\n\r\n        vec3 qos = pos * gf;\r\n\r\n        vec2 n = floor( qos.xz );\r\n        vec2 f = fract( qos.xz );\r\n        for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n\r\n            vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\r\n\r\n            if( ra2.x<0.73 ) continue;\r\n\r\n            vec2  o = hash2( n + g );\r\n            vec2  r = g - f + o;\r\n            vec2 ra = hash2( n + g + vec2(11.0,37.0) );\r\n\r\n            float gh = 2.0*(0.3+0.7*ra.x);\r\n\r\n            float rosy = qos.y - h*gf;\r\n\r\n            r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\r\n            r.x -= 0.03*rosy*rosy;\r\n\r\n            r.x *= 4.0;\r\n\r\n            float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\r\n            vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\r\n\r\n            float gr = 0.3*sqrt(1.0-0.99*se.y);\r\n            float d = se.x - gr;\r\n            d /= 4.0;\r\n\r\n            d /= gf;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_GRASS;\r\n                res.z = r.y;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n    \r\n    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));\r\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\r\n    float dm = 1e10;\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 o = vec3(0.0,3.2,0.0);\r\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\r\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\r\n        float d = length2(pos - o);\r\n        dm = min(d,dm);\r\n    }\r\n    dm = sqrt(dm)-0.02;\r\n    \r\n    if( dm<res.x )\r\n        res = vec3( dm,MAT_CITA,0);\r\n    \r\n    return res;\r\n}\r\n\r\nvec3 mapMoss( in vec3 pos, float h, vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n\r\n    float db = pos.y-2.2;\r\n    if( db<res.x )\r\n    {\r\n    const float gf = 2.0;\r\n    \r\n    vec3 qos = pos * gf;\r\n    vec2 n = floor( qos.xz );\r\n    vec2 f = fract( qos.xz );\r\n\r\n    for( int k=ZERO; k<2; k++ )\r\n    {\r\n        for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\r\n            vec2  r = g - f + o;\r\n\r\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\r\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\r\n\r\n            float mh = 0.5 + 1.0*ra2.y;\r\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\r\n\r\n            vec3 rr = vec3(r.x,ros.y,r.y);\r\n\r\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\r\n\r\n            rr.xz += 0.5*(-1.0+2.0*ra2);\r\n            vec2 se  = sdLineOriY( rr, gf*mh );\r\n            float sey = se.y;\r\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\r\n\r\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\r\n\r\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );\r\n            float cc = cos(an);\r\n            float ss = sin(an);\r\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\r\n\r\n            pp.xz = abs(pp.xz);\r\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \r\n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\r\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\r\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\r\n\r\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\r\n            d = smin( d, d2, 0.05 );\r\n\r\n            d /= gf;\r\n            d *= 0.9;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_MOSS;\r\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\r\n                float e = clamp((pos.y - h)/1.0,0.0,1.0);\r\n                res.z *= 0.02 + 0.98*e*e;\r\n                \r\n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToLadyBug( in vec3 p )\r\n{\r\n    // TODO: combine all of the above in a single 4x4 matrix\r\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\r\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\r\n    p.y += 0.2;\r\n    return p;\r\n}\r\n\r\n\r\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\r\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\r\n\r\nfloat terrain( in vec2 pos )\r\n{\r\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\r\n}\r\n\r\nvec3 mapShadow( in vec3 pos )\r\n{\r\n    float h = terrain( pos.xz );\r\n    float d = pos.y - h;\r\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\r\n    \r\n    res = mapGrass(pos,h,res);\r\n    res = mapMoss(pos,h,res);\r\n\r\n    vec3 m1 =  pos - mushroomPos1;\r\n    vec3 m2 = (pos - mushroomPos2).zyx;\r\n    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\tres = mapMushroom(m1, res);\r\n\r\n\r\n    vec3 q = worldToLadyBug(pos);\r\n    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;\r\n    if( d3.x<res.x ) res = d3;\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 map( in vec3 pos )\r\n{\r\n    vec3 res = mapShadow(pos);\r\n        \r\n    res = mapCrapInTheAir(pos, res);\r\n\r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n#if 0    \r\n    vec2 e = vec2(0.002,0.0); \r\n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\r\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\r\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*0.002).x;\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n    \r\nfloat calcShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    float res = 1.0;\r\n    float t = 0.01;\r\n    for( int i=ZERO; i<100; i++ )\r\n    {\r\n        vec3 pos = ro + rd*t;\r\n        float h = mapShadow( pos ).x;\r\n        res = min( res, 16.0*max(h,0.0)/t );\r\n        if( h<0.0001 || pos.y>3.0 ) break;\r\n        \r\n        t += clamp(h,0.01,0.2);\r\n    }\r\n    \r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n    const float tmax = 12.0;\r\n    \r\n\tvec3 res = vec3(1.0,-1.0, 0.0);\r\n\r\n    for( int i=ZERO; i<256; i++ )\r\n    {\r\n        vec3 h = map( ro + rd*res.x );\r\n        if( h.x<(0.00015*res.x) || res.x>tmax )\r\n            break;\r\n        res.x += h.x;\r\n        res.y = h.y;\r\n        res.z = h.z;\r\n    }\r\n    \r\n    if( res.x>=tmax ) res.y = -1.0;\r\n    \r\n    return res;\r\n}\r\n\r\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\r\n                out vec3 matColor, out float matRough,\r\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\r\n{\r\n    matNor = nor;\r\n    matOcc = 1.0;\r\n    matSSS = 0.0;\r\n    matRough = 1.0;\r\n    matRefOcc = 1.0;\r\n    matGamma = vec3(1.0);\r\n    \r\n    if( matID<MAT_MUSH_HEAD+0.5 )\r\n    {\r\n        vec3 m1 =  pos - mushroomPos1;\r\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\r\n    \tif( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\r\n        vec3 qos = worldToMushrom( m1 );\r\n\r\n        matColor = vec3(0.26,0.21,0.15);\r\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\r\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\r\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\r\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\r\n        matColor *= 0.4*0.45;\r\n        matColor = max( matColor, 0.0 );\r\n        \r\n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\r\n        \r\n        matRough = 0.6;\r\n        matSSS = 1.0;\r\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.87,1.0);\r\n    }\r\n    else if( matID<MAT_MUSH_NECK+0.5 )\r\n    {\r\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0/3.14159) );\r\n\r\n        matColor = vec3(0.42,0.35,0.15);\r\n        \r\n        float pa = smoothstep(0.3,0.8,pos.y);\r\n\r\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\r\n        matColor = max(vec3(0.0),matColor);\r\n        \r\n        matColor *= 0.22;\r\n        matColor = clamp( matColor, 0.0, 1.0 );\r\n        \r\n        matRough = 0.7;\r\n        matSSS = 1.0;\r\n        \r\n        matOcc = clamp( (pos.y-0.5)/1.3,0.0,1.0);\r\n        matOcc = matOcc*matOcc;\r\n        matOcc *= clamp( 1.0-(pos.y-1.2)/1.2,0.0,1.0);\r\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.95,1.0);\r\n\r\n    }\r\n    else if( matID<MAT_LADY_BODY+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n            \r\n        // red\r\n        matColor = vec3(0.16,0.008,0.0);\r\n\r\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\r\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\r\n        \r\n        qos.x = abs(qos.x);\r\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\r\n\r\n        // white\r\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\r\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\r\n\r\n        // black\r\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\r\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\r\n        \r\n        \r\n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\r\n        matColor *= 1.0 - 0.5*f;\r\n        f = texture( iChannel1, 4.0*qos.xz ).x;\r\n        matColor *= 1.0 - 0.99*f*f;\r\n        \r\n        \r\n        matColor *= 1.3;\r\n        matRough = 0.15;\r\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\r\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\r\n    }\r\n    else if( matID<MAT_LADY_HEAD+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n\r\n        matColor = vec3(0.001);\r\n\r\n        qos.z += -0.22;\r\n        qos.y += -0.7;\r\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\r\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\r\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\r\n        matRough = 0.2;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_LADY_LEGS+.5 )\r\n    {\r\n        matColor = vec3(0.0,0.0,0.0);\r\n        matRough = 0.8;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_GRASS+0.5 )\r\n    {\r\n    \tmatColor = vec3(0.1,0.15,0.03);\r\n        \r\n        float h = terrain( pos.xz );\r\n        float e = clamp(pos.y-h,0.0,1.0);\r\n        matOcc = 0.01 + 0.99*e*e;\r\n        \r\n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\r\n        matColor += 0.04*sin(matID2*41.0);\r\n        \r\n        matSSS = 0.2;\r\n        matColor *= 0.75;\r\n        matRough = 0.5;\r\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        //matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.9,0.9,1.0);\r\n    }\r\n    else if( matID<MAT_GROUND+0.5 )\r\n    {\r\n        matColor = vec3(0.2,0.2,0.0);\r\n        matRough = 1.0;\r\n        matOcc = 0.02;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_MOSS+0.5 )\r\n    {\r\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\r\n        \r\n        float f = texture( iChannel1, pos.xy*8.0 ).x;\r\n        matColor *= 0.55 + f;\r\n            \r\n        matOcc = abs(matID2);\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRough = 0.25;\r\n        matSSS = 0.5;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.7,0.7,1.0);\r\n        \r\n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\r\n    }\r\n    else //if( matID<MAT_CITA+0.5 )\r\n    {\r\n        matColor = vec3(1.0);\r\n        matSSS = 1.0;\r\n        matRough = 1.0;\r\n        matGamma = vec3(0.5);\r\n    }\r\n}\r\n\r\n\r\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\r\n               in float occ,\r\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\r\n               in vec3 matGamma )\r\n{\r\n    vec3 col = vec3(0.0);\r\n\r\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\r\n    \r\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\r\n    \r\n    float pn = exp2( 10.0*(1.0-matRough) );\r\n    \r\n\r\n    // sun light\r\n    {\r\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\r\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\r\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\r\n        float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );\r\n        vec3 hal = normalize( sun - rd );\r\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\r\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\r\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\r\n    }\r\n\r\n    // sky light\r\n    {\r\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\r\n        float dif = 0.5 + 0.5*nor.y;\r\n        col += matColor * skyColor * dif * occ;\r\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\r\n    }\r\n\r\n    // bounce light\r\n    {\r\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\r\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\r\n        col += matColor * bouColor * dif * occ;\r\n    }\r\n\r\n    col += fre*matColor*occ*matSSS;\r\n    col = pow( max(col,0.0), matGamma );\r\n\r\n    return col;\r\n}\r\n\r\nvec3 background(in vec3 d)\r\n{\r\n    // cheap cubemap\r\n    vec3 n = abs(d);\r\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \r\n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\r\n                                     d.xy/d.z;\r\n    \r\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\r\n}\r\n\r\nmat3 calcCamera( in vec3 ro, in vec3 ta )\r\n{\r\n    vec3 w = normalize( ro-ta );\r\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\r\n    vec3 v =          ( cross( w, u ) );\r\n    \r\n    return mat3( u, v, w );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\r\n    \r\n    // camera\r\n    vec3 ro = vec3(0.0,2.7,-3.0);\r\n    vec3 ta = vec3(0.0,1.9,0.0);\r\n    ro.x += 0.3*sin(0.03*iTime);    \r\n    mat3 camRot = calcCamera( ro, ta );\r\n    \r\n    // ray\r\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\r\n    \r\n    // background\r\n    vec3 col = background(rd);\r\n \r\n    // scene\r\n    vec3 tm = intersect(ro,rd);\r\n    float t = tm.x;\r\n    float matID = tm.y;\r\n    if( matID>0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n    \tvec3 nor = calcNormal( pos ); \r\n        \r\n        vec3 matNormal, matColor, matGamma;\r\n        float matRough, matOcc, matSSS, matRefOcc;\r\n        \r\n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\r\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\r\n    }\r\n    else\r\n    {\r\n        t = 30.0;\r\n    }\r\n    \r\n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\r\n\tfragColor = pow(fragColor,vec4(1.0/2.2));\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2017\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n\r\n#define MAT_MUSH_HEAD 1.0\r\n#define MAT_MUSH_NECK 2.0\r\n#define MAT_LADY_BODY 3.0\r\n#define MAT_LADY_HEAD 4.0\r\n#define MAT_LADY_LEGS 5.0\r\n#define MAT_GRASS     6.0\r\n#define MAT_GROUND    7.0\r\n#define MAT_MOSS      8.0\r\n#define MAT_CITA      9.0\r\n\r\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\r\n\r\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\r\n{\r\n#if 1\r\n    vec3 p = pos - cen;\r\n    float d = length(p/rad) - 1.0;   \r\n    return d * min(min(rad.x,rad.y),rad.z);\r\n#else\r\n    vec3 p = pos - cen;\r\n    float k0 = length(p/rad);\r\n    float k1 = length(p/(rad*rad));\r\n    return k0*(k0-1.0)/k1;\r\n#endif    \r\n}\r\n    \r\nvec2 sdLine( in vec3 pos, in vec3 a, in vec3 b )\r\n{\r\n    vec3 pa = pos - a;\r\n    vec3 ba = b - a;\r\n   \r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    \r\n    return vec2( length(pa-h*ba), h );\r\n}\r\n\r\nvec2 sdLineOri( in vec3 p, in vec3 b )\r\n{\r\n    float h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );\r\n    \r\n    return vec2( length(p-h*b), h );\r\n}\r\nvec2 sdLineOriY( in vec3 p, in float b )\r\n{\r\n    float h = clamp( p.y/b, 0.0, 1.0 );\r\n    \r\n    return vec2( length(vec3(p.x,p.y-b*h,p.z)), h );\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return min(a, b) - h*h*0.25/k;\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return max(a, b) + h*h*0.25/k;\r\n}\r\n\r\nfloat length2(in vec2 p ) { return dot(p,p); }\r\nfloat length2(in vec3 p ) { return dot(p,p); }\r\n\r\nvec3 rotateY( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateX( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\nvec3 rotateZ( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\n\r\n//==================================================\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n//==================================================\r\n\r\nvec3 mapLadyBug( vec3 p, float curmin )\r\n{\r\n    \r\n    float db = length(p-vec3(0.0,-0.35,0.05))-1.3;\r\n    if( db>curmin ) return vec3(10000.0,0.0,0.0);\r\n    \r\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\r\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\r\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\r\n\r\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\r\n\r\n    // --------\r\n    vec3 hc = vec3(0.0,0.1,0.8);\r\n    vec3 ph = rotateX(p-hc,0.5);\r\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\r\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\r\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\r\n\r\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\r\n    \r\n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq\r\n\r\n    // -------------\r\n    \r\n    vec3 k1 = vec3(0.42,-0.05,0.92);\r\n    vec3 k2 = vec3(0.49,-0.2,1.05);\r\n    float dLegs = 10.0;\r\n\r\n    float sx = sign(p.x);\r\n    p.x = abs(p.x);\r\n    for( int k=0; k<3; k++ )\r\n    {   \r\n        vec3 q = p;\r\n        q.y -= min(sx,0.0)*0.1;\r\n        if( k==0) q += vec3( 0.0,0.11,0.0);\r\n        if( k==1) q += vec3(-0.3,0.1,0.2);\r\n        if( k==2) q += vec3(-0.3,0.1,0.6);\r\n        \r\n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\r\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k1, k2 );\r\n        se.x -= 0.01 + 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\r\n        se.x -= 0.02 - 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n    }\r\n    \r\n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\r\n\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToMushrom( in vec3 pos )\r\n{\r\n    vec3 qos = pos;\r\n    qos.xy = (mat2(60,11,-11,60)/61.0) * qos.xy;\r\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\r\n    qos.y -= 0.4;\r\n    return qos;\r\n}\r\n\r\nvec3 mapMushroom( in vec3 pos, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n\r\n    vec3 qos = worldToMushrom(pos);\r\n    float db = length(qos-vec3(0.0,1.2,0.0)) - 1.3;\r\n    if( db<cur.x )\r\n    {\r\n\r\n        {\r\n\r\n            float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\r\n\r\n            d1 -= 0.025*textureLod( iChannel1, 0.05*qos.xz, 0.0 ).x - 0.02;\r\n\r\n            float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\r\n            float d = smax( d1, -d2, 0.1 );\r\n            d *= 0.8;\r\n            if( d<res.x )\r\n            {\r\n                res = vec3( d, MAT_MUSH_HEAD, 0.0 );\r\n            }\r\n        }\r\n\r\n\r\n        {\r\n            pos.x += 0.3*sin(pos.y) - 0.65;\r\n            float pa = sin( 20.0*atan(pos.z,pos.x) );\r\n            vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\r\n\r\n            float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\r\n\r\n            float d3 = se.x - tt;\r\n\r\n            d3 = smin( d3, sdEllipsoid( pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz),0.0), vec3(0.3,0.05,0.3) ), 0.05);\r\n            d3 += 0.003*pa;\r\n            d3 *= 0.7;\r\n            \r\n            if( d3<res.x )\r\n                res = vec3( d3, MAT_MUSH_NECK, 0.0 );\r\n        }\r\n    \r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n\r\nvec3 mapGrass( in vec3 pos, float h, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n    \r\n    float db = pos.y-2.6;\r\n    \r\n    if( db<cur.x && pos.z>-1.65 )\r\n    {\r\n        const float gf = 4.0;\r\n\r\n        vec3 qos = pos * gf;\r\n\r\n        vec2 n = floor( qos.xz );\r\n        vec2 f = fract( qos.xz );\r\n        for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n\r\n            vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\r\n\r\n            if( ra2.x<0.73 ) continue;\r\n\r\n            vec2  o = hash2( n + g );\r\n            vec2  r = g - f + o;\r\n            vec2 ra = hash2( n + g + vec2(11.0,37.0) );\r\n\r\n            float gh = 2.0*(0.3+0.7*ra.x);\r\n\r\n            float rosy = qos.y - h*gf;\r\n\r\n            r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\r\n            r.x -= 0.03*rosy*rosy;\r\n\r\n            r.x *= 4.0;\r\n\r\n            float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\r\n            vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\r\n\r\n            float gr = 0.3*sqrt(1.0-0.99*se.y);\r\n            float d = se.x - gr;\r\n            d /= 4.0;\r\n\r\n            d /= gf;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_GRASS;\r\n                res.z = r.y;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n    \r\n    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));\r\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\r\n    float dm = 1e10;\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 o = vec3(0.0,3.2,0.0);\r\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\r\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\r\n        float d = length2(pos - o);\r\n        dm = min(d,dm);\r\n    }\r\n    dm = sqrt(dm)-0.02;\r\n    \r\n    if( dm<res.x )\r\n        res = vec3( dm,MAT_CITA,0);\r\n    \r\n    return res;\r\n}\r\n\r\nvec3 mapMoss( in vec3 pos, float h, vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n\r\n    float db = pos.y-2.2;\r\n    if( db<res.x )\r\n    {\r\n    const float gf = 2.0;\r\n    \r\n    vec3 qos = pos * gf;\r\n    vec2 n = floor( qos.xz );\r\n    vec2 f = fract( qos.xz );\r\n\r\n    for( int k=ZERO; k<2; k++ )\r\n    {\r\n        for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\r\n            vec2  r = g - f + o;\r\n\r\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\r\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\r\n\r\n            float mh = 0.5 + 1.0*ra2.y;\r\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\r\n\r\n            vec3 rr = vec3(r.x,ros.y,r.y);\r\n\r\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\r\n\r\n            rr.xz += 0.5*(-1.0+2.0*ra2);\r\n            vec2 se  = sdLineOriY( rr, gf*mh );\r\n            float sey = se.y;\r\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\r\n\r\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\r\n\r\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );\r\n            float cc = cos(an);\r\n            float ss = sin(an);\r\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\r\n\r\n            pp.xz = abs(pp.xz);\r\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \r\n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\r\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\r\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\r\n\r\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\r\n            d = smin( d, d2, 0.05 );\r\n\r\n            d /= gf;\r\n            d *= 0.9;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_MOSS;\r\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\r\n                float e = clamp((pos.y - h)/1.0,0.0,1.0);\r\n                res.z *= 0.02 + 0.98*e*e;\r\n                \r\n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToLadyBug( in vec3 p )\r\n{\r\n    // TODO: combine all of the above in a single 4x4 matrix\r\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\r\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\r\n    p.y += 0.2;\r\n    return p;\r\n}\r\n\r\n\r\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\r\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\r\n\r\nfloat terrain( in vec2 pos )\r\n{\r\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\r\n}\r\n\r\nvec3 mapShadow( in vec3 pos )\r\n{\r\n    float h = terrain( pos.xz );\r\n    float d = pos.y - h;\r\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\r\n    \r\n    res = mapGrass(pos,h,res);\r\n    res = mapMoss(pos,h,res);\r\n\r\n    vec3 m1 =  pos - mushroomPos1;\r\n    vec3 m2 = (pos - mushroomPos2).zyx;\r\n    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\tres = mapMushroom(m1, res);\r\n\r\n\r\n    vec3 q = worldToLadyBug(pos);\r\n    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;\r\n    if( d3.x<res.x ) res = d3;\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 map( in vec3 pos )\r\n{\r\n    vec3 res = mapShadow(pos);\r\n        \r\n    res = mapCrapInTheAir(pos, res);\r\n\r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n#if 0    \r\n    vec2 e = vec2(0.002,0.0); \r\n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\r\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\r\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*0.002).x;\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n    \r\nfloat calcShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    float res = 1.0;\r\n    float t = 0.01;\r\n    for( int i=ZERO; i<100; i++ )\r\n    {\r\n        vec3 pos = ro + rd*t;\r\n        float h = mapShadow( pos ).x;\r\n        res = min( res, 16.0*max(h,0.0)/t );\r\n        if( h<0.0001 || pos.y>3.0 ) break;\r\n        \r\n        t += clamp(h,0.01,0.2);\r\n    }\r\n    \r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n    const float tmax = 12.0;\r\n    \r\n\tvec3 res = vec3(1.0,-1.0, 0.0);\r\n\r\n    for( int i=ZERO; i<256; i++ )\r\n    {\r\n        vec3 h = map( ro + rd*res.x );\r\n        if( h.x<(0.00015*res.x) || res.x>tmax )\r\n            break;\r\n        res.x += h.x;\r\n        res.y = h.y;\r\n        res.z = h.z;\r\n    }\r\n    \r\n    if( res.x>=tmax ) res.y = -1.0;\r\n    \r\n    return res;\r\n}\r\n\r\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\r\n                out vec3 matColor, out float matRough,\r\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\r\n{\r\n    matNor = nor;\r\n    matOcc = 1.0;\r\n    matSSS = 0.0;\r\n    matRough = 1.0;\r\n    matRefOcc = 1.0;\r\n    matGamma = vec3(1.0);\r\n    \r\n    if( matID<MAT_MUSH_HEAD+0.5 )\r\n    {\r\n        vec3 m1 =  pos - mushroomPos1;\r\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\r\n    \tif( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\r\n        vec3 qos = worldToMushrom( m1 );\r\n\r\n        matColor = vec3(0.26,0.21,0.15);\r\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\r\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\r\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\r\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\r\n        matColor *= 0.4*0.45;\r\n        matColor = max( matColor, 0.0 );\r\n        \r\n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\r\n        \r\n        matRough = 0.6;\r\n        matSSS = 1.0;\r\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.87,1.0);\r\n    }\r\n    else if( matID<MAT_MUSH_NECK+0.5 )\r\n    {\r\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0/3.14159) );\r\n\r\n        matColor = vec3(0.42,0.35,0.15);\r\n        \r\n        float pa = smoothstep(0.3,0.8,pos.y);\r\n\r\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\r\n        matColor = max(vec3(0.0),matColor);\r\n        \r\n        matColor *= 0.22;\r\n        matColor = clamp( matColor, 0.0, 1.0 );\r\n        \r\n        matRough = 0.7;\r\n        matSSS = 1.0;\r\n        \r\n        matOcc = clamp( (pos.y-0.5)/1.3,0.0,1.0);\r\n        matOcc = matOcc*matOcc;\r\n        matOcc *= clamp( 1.0-(pos.y-1.2)/1.2,0.0,1.0);\r\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.95,1.0);\r\n\r\n    }\r\n    else if( matID<MAT_LADY_BODY+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n            \r\n        // red\r\n        matColor = vec3(0.16,0.008,0.0);\r\n\r\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\r\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\r\n        \r\n        qos.x = abs(qos.x);\r\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\r\n\r\n        // white\r\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\r\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\r\n\r\n        // black\r\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\r\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\r\n        \r\n        \r\n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\r\n        matColor *= 1.0 - 0.5*f;\r\n        f = texture( iChannel1, 4.0*qos.xz ).x;\r\n        matColor *= 1.0 - 0.99*f*f;\r\n        \r\n        \r\n        matColor *= 1.3;\r\n        matRough = 0.15;\r\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\r\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\r\n    }\r\n    else if( matID<MAT_LADY_HEAD+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n\r\n        matColor = vec3(0.001);\r\n\r\n        qos.z += -0.22;\r\n        qos.y += -0.7;\r\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\r\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\r\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\r\n        matRough = 0.2;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_LADY_LEGS+.5 )\r\n    {\r\n        matColor = vec3(0.0,0.0,0.0);\r\n        matRough = 0.8;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_GRASS+0.5 )\r\n    {\r\n    \tmatColor = vec3(0.1,0.15,0.03);\r\n        \r\n        float h = terrain( pos.xz );\r\n        float e = clamp(pos.y-h,0.0,1.0);\r\n        matOcc = 0.01 + 0.99*e*e;\r\n        \r\n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\r\n        matColor += 0.04*sin(matID2*41.0);\r\n        \r\n        matSSS = 0.2;\r\n        matColor *= 0.75;\r\n        matRough = 0.5;\r\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        //matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.9,0.9,1.0);\r\n    }\r\n    else if( matID<MAT_GROUND+0.5 )\r\n    {\r\n        matColor = vec3(0.2,0.2,0.0);\r\n        matRough = 1.0;\r\n        matOcc = 0.02;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_MOSS+0.5 )\r\n    {\r\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\r\n        \r\n        float f = texture( iChannel1, pos.xy*8.0 ).x;\r\n        matColor *= 0.55 + f;\r\n            \r\n        matOcc = abs(matID2);\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRough = 0.25;\r\n        matSSS = 0.5;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.7,0.7,1.0);\r\n        \r\n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\r\n    }\r\n    else //if( matID<MAT_CITA+0.5 )\r\n    {\r\n        matColor = vec3(1.0);\r\n        matSSS = 1.0;\r\n        matRough = 1.0;\r\n        matGamma = vec3(0.5);\r\n    }\r\n}\r\n\r\n\r\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\r\n               in float occ,\r\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\r\n               in vec3 matGamma )\r\n{\r\n    vec3 col = vec3(0.0);\r\n\r\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\r\n    \r\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\r\n    \r\n    float pn = exp2( 10.0*(1.0-matRough) );\r\n    \r\n\r\n    // sun light\r\n    {\r\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\r\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\r\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\r\n        float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );\r\n        vec3 hal = normalize( sun - rd );\r\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\r\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\r\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\r\n    }\r\n\r\n    // sky light\r\n    {\r\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\r\n        float dif = 0.5 + 0.5*nor.y;\r\n        col += matColor * skyColor * dif * occ;\r\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\r\n    }\r\n\r\n    // bounce light\r\n    {\r\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\r\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\r\n        col += matColor * bouColor * dif * occ;\r\n    }\r\n\r\n    col += fre*matColor*occ*matSSS;\r\n    col = pow( max(col,0.0), matGamma );\r\n\r\n    return col;\r\n}\r\n\r\nvec3 background(in vec3 d)\r\n{\r\n    // cheap cubemap\r\n    vec3 n = abs(d);\r\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \r\n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\r\n                                     d.xy/d.z;\r\n    \r\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\r\n}\r\n\r\nmat3 calcCamera( in vec3 ro, in vec3 ta )\r\n{\r\n    vec3 w = normalize( ro-ta );\r\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\r\n    vec3 v =          ( cross( w, u ) );\r\n    \r\n    return mat3( u, v, w );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\r\n    \r\n    // camera\r\n    vec3 ro = vec3(0.0,2.7,-3.0);\r\n    vec3 ta = vec3(0.0,1.9,0.0);\r\n    ro.x += 0.3*sin(0.03*iTime);    \r\n    mat3 camRot = calcCamera( ro, ta );\r\n    \r\n    // ray\r\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\r\n    \r\n    // background\r\n    vec3 col = background(rd);\r\n \r\n    // scene\r\n    vec3 tm = intersect(ro,rd);\r\n    float t = tm.x;\r\n    float matID = tm.y;\r\n    if( matID>0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n    \tvec3 nor = calcNormal( pos ); \r\n        \r\n        vec3 matNormal, matColor, matGamma;\r\n        float matRough, matOcc, matSSS, matRefOcc;\r\n        \r\n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\r\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\r\n    }\r\n    else\r\n    {\r\n        t = 30.0;\r\n    }\r\n    \r\n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\r\n\tfragColor = pow(fragColor,vec4(1.0/2.2));\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/* This is free and unencumbered software released into the public domain. https://unlicense.org/\r\n\r\nTrying to get some interesting looking lens flares, seems like it worked. \r\nSee https://www.shadertoy.com/view/lsBGDK for a more avanced, generalized solution\r\n\r\nIf you find this useful send me an email at peterekepeter at gmail dot com, \r\nI've seen this shader pop up before in other works, but I'm curious where it ends up.\r\n\r\nIf you want to use it, feel free to do so, there is no need to credit but it is appreciated.\r\n\r\n\r\nUsed in:\r\n\r\n Water World - https://www.shadertoy.com/view/lslGDB\r\n\r\n Floating Mountains - https://www.shadertoy.com/view/XsSGDy\r\n \r\n Clouds and Sun With Flare - https://www.shadertoy.com/view/4sl3zl\r\n \r\n musk's lens flare mod - https://www.shadertoy.com/view/XdfXRX\r\n\r\n Land of Dreams - https://github.com/Tomius/LoD\r\n\r\n Where is Starman? - https://spacein3d.com/starman\r\n\r\n\r\nChangelog:\r\n\r\n 13/08/13: \r\n\tfirst published\r\n\r\n 17/11/27\r\n    fixed seam, thanks to Shane\r\n\r\n 19/08/08:\r\n    updated description and license change\r\n\r\n 20/06/24:\r\n    renamed to Lens Flare Example, updated description\r\n\r\n*/\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat noise(float t)\r\n{\r\n\treturn value_noise(vec2(t,.0)/iResolution.xy*234.0);\r\n}\r\nfloat noise(vec2 t)\r\n{\r\n\treturn value_noise(t/iResolution.xy*234.0);\r\n}\r\n\r\nvec3 lensflare(vec2 uv,vec2 pos)\r\n{\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat ang = atan(main.x,main.y);\r\n\tfloat dist=length(main); dist = pow(dist,.1);\r\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\r\n\t\r\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tf0 = f0 + f0*(sin(noise(sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-.4);\r\n\t\r\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\r\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\r\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\r\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\r\n\tc = c*1.3 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\r\n{\r\n\tfloat w = color.x+color.y+color.z;\r\n\treturn mix(color,vec3(w)*factor,w*factor2);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\r\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tif (iMouse.z<.5)\r\n\t{\r\n\t\tmouse.x=sin(iTime)*.5;\r\n\t\tmouse.y=sin(iTime*.913)*.5;\r\n\t}\r\n\t\r\n\tvec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);\r\n\tcolor -= noise(fragCoord.xy)*.015;\r\n\tcolor = cc(color,.5,.1);\r\n\tfragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"/* This is free and unencumbered software released into the public domain. https://unlicense.org/\r\n\r\nTrying to get some interesting looking lens flares, seems like it worked. \r\nSee https://www.shadertoy.com/view/lsBGDK for a more avanced, generalized solution\r\n\r\nIf you find this useful send me an email at peterekepeter at gmail dot com, \r\nI've seen this shader pop up before in other works, but I'm curious where it ends up.\r\n\r\nIf you want to use it, feel free to do so, there is no need to credit but it is appreciated.\r\n\r\n\r\nUsed in:\r\n\r\n Water World - https://www.shadertoy.com/view/lslGDB\r\n\r\n Floating Mountains - https://www.shadertoy.com/view/XsSGDy\r\n \r\n Clouds and Sun With Flare - https://www.shadertoy.com/view/4sl3zl\r\n \r\n musk's lens flare mod - https://www.shadertoy.com/view/XdfXRX\r\n\r\n Land of Dreams - https://github.com/Tomius/LoD\r\n\r\n Where is Starman? - https://spacein3d.com/starman\r\n\r\n\r\nChangelog:\r\n\r\n 13/08/13: \r\n\tfirst published\r\n\r\n 17/11/27\r\n    fixed seam, thanks to Shane\r\n\r\n 19/08/08:\r\n    updated description and license change\r\n\r\n 20/06/24:\r\n    renamed to Lens Flare Example, updated description\r\n\r\n*/\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat noise(float t)\r\n{\r\n\treturn value_noise(vec2(t,.0)/iResolution.xy*234.0);\r\n}\r\nfloat noise(vec2 t)\r\n{\r\n\treturn value_noise(t/iResolution.xy*234.0);\r\n}\r\n\r\nvec3 lensflare(vec2 uv,vec2 pos)\r\n{\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat ang = atan(main.x,main.y);\r\n\tfloat dist=length(main); dist = pow(dist,.1);\r\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\r\n\t\r\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tf0 = f0 + f0*(sin(noise(sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-.4);\r\n\t\r\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\r\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\r\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\r\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\r\n\tc = c*1.3 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\r\n{\r\n\tfloat w = color.x+color.y+color.z;\r\n\treturn mix(color,vec3(w)*factor,w*factor2);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\r\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tif (iMouse.z<.5)\r\n\t{\r\n\t\tmouse.x=sin(iTime)*.5;\r\n\t\tmouse.y=sin(iTime*.913)*.5;\r\n\t}\r\n\t\r\n\tvec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);\r\n\tcolor -= noise(fragCoord.xy)*.015;\r\n\tcolor = cc(color,.5,.1);\r\n\tfragColor = vec4(color,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Lens Flare Example ","id":"9e980511f9714413b8dab7400641a73f","date":null,"viewed":0,"name":"Lens Flare Example ","description":"Trying to get some interesting looking lens flares.\nhttps://www.shadertoy.com/view/4sX3Rs","likes":0,"published":null,"tags":["2d"," lens"," flare"]},"ver":null,"info":{"Name":"Lens Flare Example ","id":"9e980511f9714413b8dab7400641a73f","date":null,"viewed":0,"name":"Lens Flare Example ","description":"Trying to get some interesting looking lens flares.\nhttps://www.shadertoy.com/view/4sX3Rs","likes":0,"published":null,"tags":["2d"," lens"," flare"]},"renderpass":[{"Code":"/* This is free and unencumbered software released into the public domain. https://unlicense.org/\r\n\r\nTrying to get some interesting looking lens flares, seems like it worked. \r\nSee https://www.shadertoy.com/view/lsBGDK for a more avanced, generalized solution\r\n\r\nIf you find this useful send me an email at peterekepeter at gmail dot com, \r\nI've seen this shader pop up before in other works, but I'm curious where it ends up.\r\n\r\nIf you want to use it, feel free to do so, there is no need to credit but it is appreciated.\r\n\r\n\r\nUsed in:\r\n\r\n Water World - https://www.shadertoy.com/view/lslGDB\r\n\r\n Floating Mountains - https://www.shadertoy.com/view/XsSGDy\r\n \r\n Clouds and Sun With Flare - https://www.shadertoy.com/view/4sl3zl\r\n \r\n musk's lens flare mod - https://www.shadertoy.com/view/XdfXRX\r\n\r\n Land of Dreams - https://github.com/Tomius/LoD\r\n\r\n Where is Starman? - https://spacein3d.com/starman\r\n\r\n\r\nChangelog:\r\n\r\n 13/08/13: \r\n\tfirst published\r\n\r\n 17/11/27\r\n    fixed seam, thanks to Shane\r\n\r\n 19/08/08:\r\n    updated description and license change\r\n\r\n 20/06/24:\r\n    renamed to Lens Flare Example, updated description\r\n\r\n*/\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat noise(float t)\r\n{\r\n\treturn value_noise(vec2(t,.0)/iResolution.xy*234.0);\r\n}\r\nfloat noise(vec2 t)\r\n{\r\n\treturn value_noise(t/iResolution.xy*234.0);\r\n}\r\n\r\nvec3 lensflare(vec2 uv,vec2 pos)\r\n{\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat ang = atan(main.x,main.y);\r\n\tfloat dist=length(main); dist = pow(dist,.1);\r\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\r\n\t\r\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tf0 = f0 + f0*(sin(noise(sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-.4);\r\n\t\r\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\r\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\r\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\r\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\r\n\tc = c*1.3 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\r\n{\r\n\tfloat w = color.x+color.y+color.z;\r\n\treturn mix(color,vec3(w)*factor,w*factor2);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\r\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tif (iMouse.z<.5)\r\n\t{\r\n\t\tmouse.x=sin(iTime)*.5;\r\n\t\tmouse.y=sin(iTime*.913)*.5;\r\n\t}\r\n\t\r\n\tvec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);\r\n\tcolor -= noise(fragCoord.xy)*.015;\r\n\tcolor = cc(color,.5,.1);\r\n\tfragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"/* This is free and unencumbered software released into the public domain. https://unlicense.org/\r\n\r\nTrying to get some interesting looking lens flares, seems like it worked. \r\nSee https://www.shadertoy.com/view/lsBGDK for a more avanced, generalized solution\r\n\r\nIf you find this useful send me an email at peterekepeter at gmail dot com, \r\nI've seen this shader pop up before in other works, but I'm curious where it ends up.\r\n\r\nIf you want to use it, feel free to do so, there is no need to credit but it is appreciated.\r\n\r\n\r\nUsed in:\r\n\r\n Water World - https://www.shadertoy.com/view/lslGDB\r\n\r\n Floating Mountains - https://www.shadertoy.com/view/XsSGDy\r\n \r\n Clouds and Sun With Flare - https://www.shadertoy.com/view/4sl3zl\r\n \r\n musk's lens flare mod - https://www.shadertoy.com/view/XdfXRX\r\n\r\n Land of Dreams - https://github.com/Tomius/LoD\r\n\r\n Where is Starman? - https://spacein3d.com/starman\r\n\r\n\r\nChangelog:\r\n\r\n 13/08/13: \r\n\tfirst published\r\n\r\n 17/11/27\r\n    fixed seam, thanks to Shane\r\n\r\n 19/08/08:\r\n    updated description and license change\r\n\r\n 20/06/24:\r\n    renamed to Lens Flare Example, updated description\r\n\r\n*/\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat noise(float t)\r\n{\r\n\treturn value_noise(vec2(t,.0)/iResolution.xy*234.0);\r\n}\r\nfloat noise(vec2 t)\r\n{\r\n\treturn value_noise(t/iResolution.xy*234.0);\r\n}\r\n\r\nvec3 lensflare(vec2 uv,vec2 pos)\r\n{\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat ang = atan(main.x,main.y);\r\n\tfloat dist=length(main); dist = pow(dist,.1);\r\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\r\n\t\r\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tf0 = f0 + f0*(sin(noise(sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-.4);\r\n\t\r\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\r\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\r\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\r\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\r\n\tc = c*1.3 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\r\n{\r\n\tfloat w = color.x+color.y+color.z;\r\n\treturn mix(color,vec3(w)*factor,w*factor2);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\r\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tif (iMouse.z<.5)\r\n\t{\r\n\t\tmouse.x=sin(iTime)*.5;\r\n\t\tmouse.y=sin(iTime*.913)*.5;\r\n\t}\r\n\t\r\n\tvec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);\r\n\tcolor -= noise(fragCoord.xy)*.015;\r\n\tcolor = cc(color,.5,.1);\r\n\tfragColor = vec4(color,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Star Nest by Pablo Rom\u00C3\u00A1n Andrioli\r\n\r\n// This content is under the MIT License.\r\n\r\n#define iterations 12\r\n#define formuparam 0.57\r\n\r\n#define volsteps 10\r\n#define stepsize 0.2\r\n\r\n#define zoom   1.200\r\n#define tile   1.0\r\n#define speed  0.010 \r\n\r\n#define brightness 0.0015\r\n#define darkmatter 1.00\r\n#define distfading 0.730\r\n#define saturation 1.0\r\n\r\n#define mo (2.0 * iMouse.xy - iResolution.xy) / iResolution.y\r\n#define blackholeCenter vec3(time*2.,time,-2.)\r\n#define blackholeRadius 1.2\r\n#define blackholeIntensity 1.0\r\n\r\nfloat iSphere(vec3 ray, vec3 dir, vec3 center, float radius)\r\n{\r\n\tvec3 rc = ray-center;\r\n\tfloat c = dot(rc, rc) - (radius*radius);\r\n\tfloat b = dot(dir, rc);\r\n\tfloat d = b*b - c;\r\n\tfloat t = -b - sqrt(abs(d));\r\n\tfloat st = step(0.0, min(t,d));\r\n\treturn mix(-1.0, t, st);\r\n}\r\n\r\nvec3 iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pd){\r\n    float d = dot(po - ro, pd) / dot(rd, pd);\r\n    return d * rd + ro;\r\n}\r\n\r\nvec3 r(vec3 v, vec2 r)//incomplete but ultrafast rotation fcn thnx to rodolphito\r\n{\r\n    vec4 t = sin(vec4(r, r + 1.5707963268));\r\n    float g = dot(v.yz, t.yw);\r\n    return vec3(v.x * t.z - g * t.x,\r\n                v.y * t.w - v.z * t.y,\r\n                v.x * t.x + g * t.z);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//get coords and direction\r\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\r\n\tuv.y*=iResolution.y/iResolution.x;\r\n\tvec3 dir=vec3(uv*zoom,1.);\r\n\tfloat time=iTime*speed+.25;\r\n\r\n\t//mouse rotation\r\n\tvec3 from=vec3(0.0, 0.0, -15.0);\r\n    from = r(from, mo / 10.0);\r\n    dir = r(dir, mo / 10.0);\r\n\tfrom+=blackholeCenter;\r\n\t\r\n    vec3 nml = normalize(blackholeCenter - from);\r\n    vec3 pos = iPlane(from, dir, blackholeCenter, nml);\r\n    pos = blackholeCenter - pos;\r\n    float intensity = dot(pos, pos);\r\n    if(intensity > blackholeRadius * blackholeRadius){\r\n        intensity = 1.0 / intensity;\r\n    \tdir = mix(dir, pos * sqrt(intensity), blackholeIntensity * intensity);\r\n    \t\r\n\t\t//volumetric rendering\r\n\t\tfloat s=0.1,fade=1.;\r\n\t\tvec3 v=vec3(0.);\r\n\t\tfor (int r=0; r<volsteps; r++) {\r\n\t\t\tvec3 p=from+s*dir*.5;\r\n\t\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\r\n\t\t\tfloat pa,a=pa=0.;\r\n\t\t\tfor (int i=0; i<iterations; i++) { \r\n\t\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\r\n\t\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\r\n\t\t\t\tpa=length(p);\r\n\t\t\t}\r\n\t\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\r\n\t\t\ta*=a*a; // add contrast\r\n\t\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\r\n\t\t\t//v+=vec3(dm,dm*.5,0.);\r\n\t\t\tv+=fade;\r\n\t\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\r\n\t\t\tfade*=distfading; // distance fading\r\n\t\t\ts+=stepsize;\r\n\t\t}\r\n\t\tv=mix(vec3(length(v)),v,saturation); //color adjust\r\n\t\tfragColor = vec4(v*.01,1.);\t\r\n    }\r\n    else fragColor = vec4(0.0);\r\n}","inputs":[],"outputs":[],"code":"// Star Nest by Pablo Rom\u00C3\u00A1n Andrioli\r\n\r\n// This content is under the MIT License.\r\n\r\n#define iterations 12\r\n#define formuparam 0.57\r\n\r\n#define volsteps 10\r\n#define stepsize 0.2\r\n\r\n#define zoom   1.200\r\n#define tile   1.0\r\n#define speed  0.010 \r\n\r\n#define brightness 0.0015\r\n#define darkmatter 1.00\r\n#define distfading 0.730\r\n#define saturation 1.0\r\n\r\n#define mo (2.0 * iMouse.xy - iResolution.xy) / iResolution.y\r\n#define blackholeCenter vec3(time*2.,time,-2.)\r\n#define blackholeRadius 1.2\r\n#define blackholeIntensity 1.0\r\n\r\nfloat iSphere(vec3 ray, vec3 dir, vec3 center, float radius)\r\n{\r\n\tvec3 rc = ray-center;\r\n\tfloat c = dot(rc, rc) - (radius*radius);\r\n\tfloat b = dot(dir, rc);\r\n\tfloat d = b*b - c;\r\n\tfloat t = -b - sqrt(abs(d));\r\n\tfloat st = step(0.0, min(t,d));\r\n\treturn mix(-1.0, t, st);\r\n}\r\n\r\nvec3 iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pd){\r\n    float d = dot(po - ro, pd) / dot(rd, pd);\r\n    return d * rd + ro;\r\n}\r\n\r\nvec3 r(vec3 v, vec2 r)//incomplete but ultrafast rotation fcn thnx to rodolphito\r\n{\r\n    vec4 t = sin(vec4(r, r + 1.5707963268));\r\n    float g = dot(v.yz, t.yw);\r\n    return vec3(v.x * t.z - g * t.x,\r\n                v.y * t.w - v.z * t.y,\r\n                v.x * t.x + g * t.z);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//get coords and direction\r\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\r\n\tuv.y*=iResolution.y/iResolution.x;\r\n\tvec3 dir=vec3(uv*zoom,1.);\r\n\tfloat time=iTime*speed+.25;\r\n\r\n\t//mouse rotation\r\n\tvec3 from=vec3(0.0, 0.0, -15.0);\r\n    from = r(from, mo / 10.0);\r\n    dir = r(dir, mo / 10.0);\r\n\tfrom+=blackholeCenter;\r\n\t\r\n    vec3 nml = normalize(blackholeCenter - from);\r\n    vec3 pos = iPlane(from, dir, blackholeCenter, nml);\r\n    pos = blackholeCenter - pos;\r\n    float intensity = dot(pos, pos);\r\n    if(intensity > blackholeRadius * blackholeRadius){\r\n        intensity = 1.0 / intensity;\r\n    \tdir = mix(dir, pos * sqrt(intensity), blackholeIntensity * intensity);\r\n    \t\r\n\t\t//volumetric rendering\r\n\t\tfloat s=0.1,fade=1.;\r\n\t\tvec3 v=vec3(0.);\r\n\t\tfor (int r=0; r<volsteps; r++) {\r\n\t\t\tvec3 p=from+s*dir*.5;\r\n\t\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\r\n\t\t\tfloat pa,a=pa=0.;\r\n\t\t\tfor (int i=0; i<iterations; i++) { \r\n\t\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\r\n\t\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\r\n\t\t\t\tpa=length(p);\r\n\t\t\t}\r\n\t\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\r\n\t\t\ta*=a*a; // add contrast\r\n\t\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\r\n\t\t\t//v+=vec3(dm,dm*.5,0.);\r\n\t\t\tv+=fade;\r\n\t\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\r\n\t\t\tfade*=distfading; // distance fading\r\n\t\t\ts+=stepsize;\r\n\t\t}\r\n\t\tv=mix(vec3(length(v)),v,saturation); //color adjust\r\n\t\tfragColor = vec4(v*.01,1.);\t\r\n    }\r\n    else fragColor = vec4(0.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Lensing","id":"2cf60d955779465f9c68fecfeeba92ba","date":null,"viewed":0,"name":"Lensing","description":"based on  Star Nest by Kali . see here for realitic lensing.\nhttps://www.shadertoy.com/view/MtByRh","likes":0,"published":null,"tags":["3d"," blackhole"," starfield"," lensing"]},"ver":null,"info":{"Name":"Lensing","id":"2cf60d955779465f9c68fecfeeba92ba","date":null,"viewed":0,"name":"Lensing","description":"based on  Star Nest by Kali . see here for realitic lensing.\nhttps://www.shadertoy.com/view/MtByRh","likes":0,"published":null,"tags":["3d"," blackhole"," starfield"," lensing"]},"renderpass":[{"Code":"// Star Nest by Pablo Rom\u00C3\u00A1n Andrioli\r\n\r\n// This content is under the MIT License.\r\n\r\n#define iterations 12\r\n#define formuparam 0.57\r\n\r\n#define volsteps 10\r\n#define stepsize 0.2\r\n\r\n#define zoom   1.200\r\n#define tile   1.0\r\n#define speed  0.010 \r\n\r\n#define brightness 0.0015\r\n#define darkmatter 1.00\r\n#define distfading 0.730\r\n#define saturation 1.0\r\n\r\n#define mo (2.0 * iMouse.xy - iResolution.xy) / iResolution.y\r\n#define blackholeCenter vec3(time*2.,time,-2.)\r\n#define blackholeRadius 1.2\r\n#define blackholeIntensity 1.0\r\n\r\nfloat iSphere(vec3 ray, vec3 dir, vec3 center, float radius)\r\n{\r\n\tvec3 rc = ray-center;\r\n\tfloat c = dot(rc, rc) - (radius*radius);\r\n\tfloat b = dot(dir, rc);\r\n\tfloat d = b*b - c;\r\n\tfloat t = -b - sqrt(abs(d));\r\n\tfloat st = step(0.0, min(t,d));\r\n\treturn mix(-1.0, t, st);\r\n}\r\n\r\nvec3 iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pd){\r\n    float d = dot(po - ro, pd) / dot(rd, pd);\r\n    return d * rd + ro;\r\n}\r\n\r\nvec3 r(vec3 v, vec2 r)//incomplete but ultrafast rotation fcn thnx to rodolphito\r\n{\r\n    vec4 t = sin(vec4(r, r + 1.5707963268));\r\n    float g = dot(v.yz, t.yw);\r\n    return vec3(v.x * t.z - g * t.x,\r\n                v.y * t.w - v.z * t.y,\r\n                v.x * t.x + g * t.z);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//get coords and direction\r\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\r\n\tuv.y*=iResolution.y/iResolution.x;\r\n\tvec3 dir=vec3(uv*zoom,1.);\r\n\tfloat time=iTime*speed+.25;\r\n\r\n\t//mouse rotation\r\n\tvec3 from=vec3(0.0, 0.0, -15.0);\r\n    from = r(from, mo / 10.0);\r\n    dir = r(dir, mo / 10.0);\r\n\tfrom+=blackholeCenter;\r\n\t\r\n    vec3 nml = normalize(blackholeCenter - from);\r\n    vec3 pos = iPlane(from, dir, blackholeCenter, nml);\r\n    pos = blackholeCenter - pos;\r\n    float intensity = dot(pos, pos);\r\n    if(intensity > blackholeRadius * blackholeRadius){\r\n        intensity = 1.0 / intensity;\r\n    \tdir = mix(dir, pos * sqrt(intensity), blackholeIntensity * intensity);\r\n    \t\r\n\t\t//volumetric rendering\r\n\t\tfloat s=0.1,fade=1.;\r\n\t\tvec3 v=vec3(0.);\r\n\t\tfor (int r=0; r<volsteps; r++) {\r\n\t\t\tvec3 p=from+s*dir*.5;\r\n\t\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\r\n\t\t\tfloat pa,a=pa=0.;\r\n\t\t\tfor (int i=0; i<iterations; i++) { \r\n\t\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\r\n\t\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\r\n\t\t\t\tpa=length(p);\r\n\t\t\t}\r\n\t\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\r\n\t\t\ta*=a*a; // add contrast\r\n\t\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\r\n\t\t\t//v+=vec3(dm,dm*.5,0.);\r\n\t\t\tv+=fade;\r\n\t\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\r\n\t\t\tfade*=distfading; // distance fading\r\n\t\t\ts+=stepsize;\r\n\t\t}\r\n\t\tv=mix(vec3(length(v)),v,saturation); //color adjust\r\n\t\tfragColor = vec4(v*.01,1.);\t\r\n    }\r\n    else fragColor = vec4(0.0);\r\n}","inputs":[],"outputs":[],"code":"// Star Nest by Pablo Rom\u00C3\u00A1n Andrioli\r\n\r\n// This content is under the MIT License.\r\n\r\n#define iterations 12\r\n#define formuparam 0.57\r\n\r\n#define volsteps 10\r\n#define stepsize 0.2\r\n\r\n#define zoom   1.200\r\n#define tile   1.0\r\n#define speed  0.010 \r\n\r\n#define brightness 0.0015\r\n#define darkmatter 1.00\r\n#define distfading 0.730\r\n#define saturation 1.0\r\n\r\n#define mo (2.0 * iMouse.xy - iResolution.xy) / iResolution.y\r\n#define blackholeCenter vec3(time*2.,time,-2.)\r\n#define blackholeRadius 1.2\r\n#define blackholeIntensity 1.0\r\n\r\nfloat iSphere(vec3 ray, vec3 dir, vec3 center, float radius)\r\n{\r\n\tvec3 rc = ray-center;\r\n\tfloat c = dot(rc, rc) - (radius*radius);\r\n\tfloat b = dot(dir, rc);\r\n\tfloat d = b*b - c;\r\n\tfloat t = -b - sqrt(abs(d));\r\n\tfloat st = step(0.0, min(t,d));\r\n\treturn mix(-1.0, t, st);\r\n}\r\n\r\nvec3 iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pd){\r\n    float d = dot(po - ro, pd) / dot(rd, pd);\r\n    return d * rd + ro;\r\n}\r\n\r\nvec3 r(vec3 v, vec2 r)//incomplete but ultrafast rotation fcn thnx to rodolphito\r\n{\r\n    vec4 t = sin(vec4(r, r + 1.5707963268));\r\n    float g = dot(v.yz, t.yw);\r\n    return vec3(v.x * t.z - g * t.x,\r\n                v.y * t.w - v.z * t.y,\r\n                v.x * t.x + g * t.z);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//get coords and direction\r\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\r\n\tuv.y*=iResolution.y/iResolution.x;\r\n\tvec3 dir=vec3(uv*zoom,1.);\r\n\tfloat time=iTime*speed+.25;\r\n\r\n\t//mouse rotation\r\n\tvec3 from=vec3(0.0, 0.0, -15.0);\r\n    from = r(from, mo / 10.0);\r\n    dir = r(dir, mo / 10.0);\r\n\tfrom+=blackholeCenter;\r\n\t\r\n    vec3 nml = normalize(blackholeCenter - from);\r\n    vec3 pos = iPlane(from, dir, blackholeCenter, nml);\r\n    pos = blackholeCenter - pos;\r\n    float intensity = dot(pos, pos);\r\n    if(intensity > blackholeRadius * blackholeRadius){\r\n        intensity = 1.0 / intensity;\r\n    \tdir = mix(dir, pos * sqrt(intensity), blackholeIntensity * intensity);\r\n    \t\r\n\t\t//volumetric rendering\r\n\t\tfloat s=0.1,fade=1.;\r\n\t\tvec3 v=vec3(0.);\r\n\t\tfor (int r=0; r<volsteps; r++) {\r\n\t\t\tvec3 p=from+s*dir*.5;\r\n\t\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\r\n\t\t\tfloat pa,a=pa=0.;\r\n\t\t\tfor (int i=0; i<iterations; i++) { \r\n\t\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\r\n\t\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\r\n\t\t\t\tpa=length(p);\r\n\t\t\t}\r\n\t\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\r\n\t\t\ta*=a*a; // add contrast\r\n\t\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\r\n\t\t\t//v+=vec3(dm,dm*.5,0.);\r\n\t\t\tv+=fade;\r\n\t\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\r\n\t\t\tfade*=distfading; // distance fading\r\n\t\t\ts+=stepsize;\r\n\t\t}\r\n\t\tv=mix(vec3(length(v)),v,saturation); //color adjust\r\n\t\tfragColor = vec4(v*.01,1.);\t\r\n    }\r\n    else fragColor = vec4(0.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Mandelbrot Set Render","id":"wtlSW8","date":"1562830347","viewed":89,"name":"Mandelbrot Set Render","description":"mandelbrot set Render2\nreferences:\nhttps://www.shadertoy.com/view/lsX3W4\n","likes":1,"published":"Public","tags":["fractal"]},"ver":"0.1","info":{"Name":"Mandelbrot Set Render","id":"wtlSW8","date":"1562830347","viewed":89,"name":"Mandelbrot Set Render","description":"mandelbrot set Render2\nreferences:\nhttps://www.shadertoy.com/view/lsX3W4\n","likes":1,"published":"Public","tags":["fractal"]},"renderpass":[{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Marble Material","id":"Wtc3DM","date":"1576576570","viewed":47,"name":"Marble Material","description":"\u7A0B\u5E8F\u6027\u7684\u5927\u7406\u77F3\u6750\u8D28\uFF0C\u770B\u8D77\u6765\u66F4\u50CF\u62FC\u5408\u677F","likes":2,"published":"Public","tags":["marble","fractalnoise"]},"ver":"0.1","info":{"Name":"Marble Material","id":"Wtc3DM","date":"1576576570","viewed":47,"name":"Marble Material","description":"\u7A0B\u5E8F\u6027\u7684\u5927\u7406\u77F3\u6750\u8D28\uFF0C\u770B\u8D77\u6765\u66F4\u50CF\u62FC\u5408\u677F","likes":2,"published":"Public","tags":["marble","fractalnoise"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//\r\n/* Panteleymonov Aleksandr Konstantinovich 2015\r\n//\r\n// if i write this string my code will be 0 chars, :) */\r\n\r\n#define iterations 15.0\r\n#define depth 0.0125\r\n#define layers 8.0\r\n#define layersblob 20\r\n#define step 1.0\r\n#define far 10000.0\r\n\r\nfloat radius=0.25; // radius of Snowflakes. maximum for this demo 0.25.\r\nfloat zoom=4.0; // use this to change details. optimal 0.1 - 4.0.\r\n\r\nvec3 light=vec3(0.0,0.0,1.0);\r\nvec2 seed=vec2(0.0,0.0);\r\nfloat iteratorc=iterations;\r\nfloat powr;\r\nfloat res;\r\n\r\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\r\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\r\n\r\nlowp vec4 hash4( mediump vec4 n ) { return fract(sin(n)*1399763.5453123); }\r\nlowp float noise2( mediump vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    lowp vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0;\r\n    lowp vec4 h = hash4(vec4(n)+vec4(NC0.xy,NC1.xy));\r\n    lowp vec2 s1 = mix(h.xy,h.zw,f.xx);\r\n    return mix(s1.x,s1.y,f.y);\r\n}\r\n\r\nlowp float noise222( mediump vec2 x, mediump vec2 y, mediump vec2 z )\r\n{\r\n    mediump vec4 lx = vec4(x*y.x,x*y.y);\r\n    mediump vec4 p = floor(lx);\r\n    lowp vec4 f = fract(lx);\r\n    f = f*f*(3.0-2.0*f);\r\n    mediump vec2 n = p.xz + p.yw*157.0;\r\n    lowp vec4 h = mix(hash4(n.xxyy+NC0.xyxy),hash4(n.xxyy+NC1.xyxy),f.xxzz);\r\n    return dot(mix(h.xz,h.yw,f.yw),z);\r\n}\r\n\r\nlowp float noise3( mediump vec3 x )\r\n{\r\n    mediump vec3 p = floor(x);\r\n    lowp vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    mediump float n = p.x + dot(p.yz,vec2(157.0,113.0));\r\n    lowp vec4 s1 = mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),f.xxxx);\r\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\r\n}\r\nlowp vec2 noise3_2( mediump vec3 x ) { return vec2(noise3(x),noise3(x+100.0)); }\r\n\r\nfloat map(mediump vec2 rad)\r\n{\r\n    float a;\r\n    if (res<0.0015) {\r\n    \t//a = noise2(rad.xy*20.6)*0.9+noise2(rad.xy*100.6)*0.1;\r\n        a = noise222(rad.xy,vec2(20.6,100.6),vec2(0.9,0.1));\r\n    } else if (res<0.005) {\r\n        //float a1 = mix(noise2(rad.xy*10.6),1.0,l);\r\n        //a = texture(iChannel0,rad*0.3).x;\r\n        a = noise2(rad.xy*20.6);\r\n        //if (a1<a) a=a1;\r\n    } else a = noise2(rad.xy*10.3);\r\n    return (a-0.5);\r\n}\r\n\r\nvec3 distObj(vec3 pos,vec3 ray,float r,vec2 seed)\r\n{   \r\n    mediump float rq = r*r;\r\n    mediump vec3 dist = ray*far;\r\n    \r\n    mediump vec3 norm = vec3(0.0,0.0,1.0);\r\n    mediump float invn = 1.0/dot(norm,ray);\r\n    mediump float depthi = depth;\r\n    if (invn<0.0) depthi =- depthi;\r\n    mediump float ds = 2.0*depthi*invn;\r\n    mediump vec3 r1 = ray*(dot(norm,pos)-depthi)*invn-pos;\r\n    mediump vec3 op1 = r1+norm*depthi;\r\n    mediump float len1 = dot(op1,op1);\r\n    mediump vec3 r2 = r1+ray*ds;\r\n    mediump vec3 op2 = r2-norm*depthi;\r\n    mediump float len2 = dot(op2,op2);\r\n    \r\n    mediump vec3 n = normalize(cross(ray,norm));\r\n    mediump float mind = dot(pos,n);\r\n    mediump vec3 n2 = cross(ray,n);\r\n    mediump float d = dot(n2,pos)/dot(n2,norm);\r\n    mediump float invd = 0.2/depth;\r\n    \r\n    if ((len1<rq || len2<rq) || (abs(mind)<r && d<=depth && d>=-depth))\r\n    {        \r\n        mediump vec3 r3 = r2;\r\n        mediump float len = len1;\r\n        if (len>=rq) {\r\n        \tmediump vec3 n3 = cross(norm,n);\r\n        \tmediump float a = inversesqrt(rq-mind*mind)*abs(dot(ray,n3));\r\n            mediump vec3 dt = ray/a;\r\n        \tr1 =- d*norm-mind*n-dt;\r\n            if (len2>=rq) {\r\n                r2 =- d*norm-mind*n+dt;\r\n            }\r\n            ds = dot(r2-r1,ray);\r\n        }\r\n        ds = (abs(ds)+0.1)/(iterations);\r\n        ds = mix(depth,ds,0.2);\r\n        if (ds>0.01) ds=0.01;\r\n        mediump float ir = 0.35/r;\r\n        r *= zoom;\r\n        ray = ray*ds*5.0;\r\n        for (float m=0.0; m<iterations; m+=1.0) {\r\n            if (m>=iteratorc) break;\r\n           \tmediump float l = length(r1.xy); //inversesqrt(dot(r1.xy,r1.xy));\r\n            lowp vec2 c3 = abs(r1.xy/l);\r\n            if (c3.x>0.5) c3=abs(c3*0.5+vec2(-c3.y,c3.x)*0.86602540);\r\n\t\t\tmediump float g = l+c3.x*c3.x; //*1.047197551;\r\n\t\t\tl *= zoom;\r\n            mediump float h = l-r-0.1;\r\n            l = pow(l,powr)+0.1;\r\n          \th = max(h,mix(map(c3*l+seed),1.0,abs(r1.z*invd)))+g*ir-0.245; //0.7*0.35=0.245 //*0.911890636\r\n            if ((h<res*20.0) || abs(r1.z)>depth+0.01) break;\r\n            r1 += ray*h;\r\n            ray*=0.99;\r\n        }\r\n        if (abs(r1.z)<depth+0.01) dist=r1+pos;\r\n    }\r\n    return dist;\r\n}\r\n\r\nvec3 nray;\r\nvec3 nray1;\r\nvec3 nray2;\r\nfloat mxc=1.0;\r\n\r\nvec4 filterFlake(vec4 color,vec3 pos,vec3 ray,vec3 ray1,vec3 ray2)\r\n{\r\n    vec3 d=distObj(pos,ray,radius,seed);\r\n    vec3 n1=distObj(pos,ray1,radius,seed);\r\n    vec3 n2=distObj(pos,ray2,radius,seed);\r\n\r\n    vec3 lq=vec3(dot(d,d),dot(n1,n1),dot(n2,n2));\r\n\tif (lq.x<far || lq.y<far || lq.z<far) {\r\n    \tvec3 n=normalize(cross(n1-d,n2-d));\r\n        if (lq.x<far && lq.y<far && lq.z<far) {\r\n       \t\tnray = n;//normalize(nray+n);\r\n       \t\t//nray1 = normalize(ray1+n);\r\n       \t\t//nray2 = normalize(ray2+n);\r\n        }\r\n       \tfloat da = pow(abs(dot(n,light)),3.0);\r\n        vec3 cf = mix(vec3(0.0,0.4,1.0),color.xyz*10.0,abs(dot(n,ray)));\r\n       \tcf=mix(cf,vec3(2.0),da);\r\n      \tcolor.xyz = mix(color.xyz,cf,mxc*mxc*(0.5+abs(dot(n,ray))*0.5));\r\n    }\r\n    \r\n    return color;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float time = iTime*0.2;//*0.1;\r\n    res = 1.0 / iResolution.y;\r\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) *res;\r\n\r\n    vec3 rotate;\r\n    \r\n    mat3 mr;\r\n    \r\n    vec3 ray = normalize(vec3(p,2.0));\r\n    vec3 ray1;\r\n    vec3 ray2;\r\n    vec3 pos = vec3(0.0,0.0,1.0);\r\n\r\n    fragColor = vec4(0.0,0.0,0.0,0.0);\r\n    \r\n\tnray = vec3(0.0);\r\n\tnray1 = vec3(0.0);\r\n\tnray2 = vec3(0.0);\r\n    \r\n    vec4 refcolor=vec4(0.0);\r\n    iteratorc=iterations-layers;\r\n    \r\n    vec2 addrot = vec2(0.0);\r\n    if (iMouse.z>0.0) addrot=(iMouse.xy-iResolution.xy*0.5)*res;\r\n    \r\n    float mxcl = 1.0;\r\n    vec3 addpos=vec3(0.0);\r\n    pos.z = 1.0;\r\n    mxc=1.0;\r\n    radius = 0.25;\r\n    float mzd=(zoom-0.1)/layers;\r\n    for (int i=0; i<layersblob;i++) {\r\n        vec2 p2 = p-vec2(0.25)+vec2(0.1*float(i));\r\n        ray = vec3(p2,2.0)-nray*2.0;\r\n    \t//ray = nray;//*0.6;\r\n    \tray1 = normalize(ray+vec3(0.0,res*2.0,0.0));\r\n    \tray2 = normalize(ray+vec3(res*2.0,0.0,0.0));\r\n        ray = normalize(ray);\r\n    \tvec2 sb = ray.xy*length(pos)/dot(normalize(pos),ray)+vec2(0.0,time);\r\n        seed=floor((sb+vec2(0.0,pos.z)))+pos.z;\r\n        vec3 seedn = vec3(seed,pos.z);\r\n        sb = floor(sb);\r\n        if (noise3(seedn)>0.2 && i<int(layers)) {\r\n            powr = noise3(seedn*10.0)*1.9+0.1;\r\n            rotate.xy=sin((0.5-noise3_2(seedn))*time*5.0)*0.3+addrot;\r\n            rotate.z = (0.5-noise3(seedn+vec3(10.0,3.0,1.0)))*time*5.0;\r\n            seedn.z += time*0.5;\r\n            addpos.xy = sb+vec2(0.25,0.25-time)+noise3_2(seedn)*0.5;\r\n            vec3 sins = sin(rotate);\r\n    \t\tvec3 coss = cos(rotate);\r\n    \t\tmr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\r\n\t\t    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;\r\n            mr=mat3(vec3(coss.z,sins.z,0.0),vec3(-sins.z,coss.z,0.0),vec3(0.0,0.0,1.0))*mr;\r\n\r\n            light = normalize(vec3(1.0,0.0,1.0))*mr;\r\n    \t\t//vec4 cc=filterFlake(fragColor,(pos+addpos)*mr,normalize(ray*mr+nray*0.1),normalize(ray1*mr+nray*0.1),normalize(ray2*mr+nray*0.1));\r\n            vec4 cc = filterFlake(fragColor,(pos+addpos)*mr,ray*mr,ray1*mr,ray2*mr);\r\n            //if (i>0 && dot(nray,nray)!=0.0 && dot(nray1,nray1)!=0.0 && dot(nray2,nray2)!=0.0) refcolor=filterFlake(refcolor,(pos+addpos)*mr,nray,nray1,nray2);\r\n            //cc+=refcolor*0.5;\r\n            fragColor=mix(cc,fragColor,min(1.0,fragColor.w));\r\n        }\r\n        seedn = vec3(sb,pos.z)+vec3(0.5,1000.0,300.0);\r\n        if (noise3(seedn*10.0)>0.4) {\r\n            float raf = 0.3+noise3(seedn*100.0);\r\n            addpos.xy = sb+vec2(0.2,0.2-time)+noise3_2(seedn*100.0)*0.6;\r\n            float l = length(ray*dot(ray,pos+addpos)-pos-addpos);\r\n            l = max(0.0,(1.0-l*10.0*raf));\r\n            fragColor.xyzw += vec4(1.0,1.2,3.0,1.0)*pow(l,5.0)*(pow(0.6+raf,2.0)-0.6)*mxcl;\r\n        }\r\n        mxc -= 1.1/layers;\r\n        pos.z += step;\r\n        iteratorc += 2.0;\r\n        mxcl -= 1.1/float(layersblob);\r\n        zoom-= mzd;\r\n    }\r\n    \r\n    vec3 cr = mix(vec3(0.0),vec3(0.0,0.0,0.4),(-0.55+p.y)*2.0);\r\n    fragColor.xyz += mix((cr.xyz-fragColor.xyz)*0.1,vec3(0.2,0.5,1.0),clamp((-p.y+1.0)*0.5,0.0,1.0));\r\n    \r\n    fragColor = min( vec4(1.0), fragColor );\r\n}","inputs":[],"outputs":[],"code":"//\r\n/* Panteleymonov Aleksandr Konstantinovich 2015\r\n//\r\n// if i write this string my code will be 0 chars, :) */\r\n\r\n#define iterations 15.0\r\n#define depth 0.0125\r\n#define layers 8.0\r\n#define layersblob 20\r\n#define step 1.0\r\n#define far 10000.0\r\n\r\nfloat radius=0.25; // radius of Snowflakes. maximum for this demo 0.25.\r\nfloat zoom=4.0; // use this to change details. optimal 0.1 - 4.0.\r\n\r\nvec3 light=vec3(0.0,0.0,1.0);\r\nvec2 seed=vec2(0.0,0.0);\r\nfloat iteratorc=iterations;\r\nfloat powr;\r\nfloat res;\r\n\r\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\r\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\r\n\r\nlowp vec4 hash4( mediump vec4 n ) { return fract(sin(n)*1399763.5453123); }\r\nlowp float noise2( mediump vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    lowp vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0;\r\n    lowp vec4 h = hash4(vec4(n)+vec4(NC0.xy,NC1.xy));\r\n    lowp vec2 s1 = mix(h.xy,h.zw,f.xx);\r\n    return mix(s1.x,s1.y,f.y);\r\n}\r\n\r\nlowp float noise222( mediump vec2 x, mediump vec2 y, mediump vec2 z )\r\n{\r\n    mediump vec4 lx = vec4(x*y.x,x*y.y);\r\n    mediump vec4 p = floor(lx);\r\n    lowp vec4 f = fract(lx);\r\n    f = f*f*(3.0-2.0*f);\r\n    mediump vec2 n = p.xz + p.yw*157.0;\r\n    lowp vec4 h = mix(hash4(n.xxyy+NC0.xyxy),hash4(n.xxyy+NC1.xyxy),f.xxzz);\r\n    return dot(mix(h.xz,h.yw,f.yw),z);\r\n}\r\n\r\nlowp float noise3( mediump vec3 x )\r\n{\r\n    mediump vec3 p = floor(x);\r\n    lowp vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    mediump float n = p.x + dot(p.yz,vec2(157.0,113.0));\r\n    lowp vec4 s1 = mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),f.xxxx);\r\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\r\n}\r\nlowp vec2 noise3_2( mediump vec3 x ) { return vec2(noise3(x),noise3(x+100.0)); }\r\n\r\nfloat map(mediump vec2 rad)\r\n{\r\n    float a;\r\n    if (res<0.0015) {\r\n    \t//a = noise2(rad.xy*20.6)*0.9+noise2(rad.xy*100.6)*0.1;\r\n        a = noise222(rad.xy,vec2(20.6,100.6),vec2(0.9,0.1));\r\n    } else if (res<0.005) {\r\n        //float a1 = mix(noise2(rad.xy*10.6),1.0,l);\r\n        //a = texture(iChannel0,rad*0.3).x;\r\n        a = noise2(rad.xy*20.6);\r\n        //if (a1<a) a=a1;\r\n    } else a = noise2(rad.xy*10.3);\r\n    return (a-0.5);\r\n}\r\n\r\nvec3 distObj(vec3 pos,vec3 ray,float r,vec2 seed)\r\n{   \r\n    mediump float rq = r*r;\r\n    mediump vec3 dist = ray*far;\r\n    \r\n    mediump vec3 norm = vec3(0.0,0.0,1.0);\r\n    mediump float invn = 1.0/dot(norm,ray);\r\n    mediump float depthi = depth;\r\n    if (invn<0.0) depthi =- depthi;\r\n    mediump float ds = 2.0*depthi*invn;\r\n    mediump vec3 r1 = ray*(dot(norm,pos)-depthi)*invn-pos;\r\n    mediump vec3 op1 = r1+norm*depthi;\r\n    mediump float len1 = dot(op1,op1);\r\n    mediump vec3 r2 = r1+ray*ds;\r\n    mediump vec3 op2 = r2-norm*depthi;\r\n    mediump float len2 = dot(op2,op2);\r\n    \r\n    mediump vec3 n = normalize(cross(ray,norm));\r\n    mediump float mind = dot(pos,n);\r\n    mediump vec3 n2 = cross(ray,n);\r\n    mediump float d = dot(n2,pos)/dot(n2,norm);\r\n    mediump float invd = 0.2/depth;\r\n    \r\n    if ((len1<rq || len2<rq) || (abs(mind)<r && d<=depth && d>=-depth))\r\n    {        \r\n        mediump vec3 r3 = r2;\r\n        mediump float len = len1;\r\n        if (len>=rq) {\r\n        \tmediump vec3 n3 = cross(norm,n);\r\n        \tmediump float a = inversesqrt(rq-mind*mind)*abs(dot(ray,n3));\r\n            mediump vec3 dt = ray/a;\r\n        \tr1 =- d*norm-mind*n-dt;\r\n            if (len2>=rq) {\r\n                r2 =- d*norm-mind*n+dt;\r\n            }\r\n            ds = dot(r2-r1,ray);\r\n        }\r\n        ds = (abs(ds)+0.1)/(iterations);\r\n        ds = mix(depth,ds,0.2);\r\n        if (ds>0.01) ds=0.01;\r\n        mediump float ir = 0.35/r;\r\n        r *= zoom;\r\n        ray = ray*ds*5.0;\r\n        for (float m=0.0; m<iterations; m+=1.0) {\r\n            if (m>=iteratorc) break;\r\n           \tmediump float l = length(r1.xy); //inversesqrt(dot(r1.xy,r1.xy));\r\n            lowp vec2 c3 = abs(r1.xy/l);\r\n            if (c3.x>0.5) c3=abs(c3*0.5+vec2(-c3.y,c3.x)*0.86602540);\r\n\t\t\tmediump float g = l+c3.x*c3.x; //*1.047197551;\r\n\t\t\tl *= zoom;\r\n            mediump float h = l-r-0.1;\r\n            l = pow(l,powr)+0.1;\r\n          \th = max(h,mix(map(c3*l+seed),1.0,abs(r1.z*invd)))+g*ir-0.245; //0.7*0.35=0.245 //*0.911890636\r\n            if ((h<res*20.0) || abs(r1.z)>depth+0.01) break;\r\n            r1 += ray*h;\r\n            ray*=0.99;\r\n        }\r\n        if (abs(r1.z)<depth+0.01) dist=r1+pos;\r\n    }\r\n    return dist;\r\n}\r\n\r\nvec3 nray;\r\nvec3 nray1;\r\nvec3 nray2;\r\nfloat mxc=1.0;\r\n\r\nvec4 filterFlake(vec4 color,vec3 pos,vec3 ray,vec3 ray1,vec3 ray2)\r\n{\r\n    vec3 d=distObj(pos,ray,radius,seed);\r\n    vec3 n1=distObj(pos,ray1,radius,seed);\r\n    vec3 n2=distObj(pos,ray2,radius,seed);\r\n\r\n    vec3 lq=vec3(dot(d,d),dot(n1,n1),dot(n2,n2));\r\n\tif (lq.x<far || lq.y<far || lq.z<far) {\r\n    \tvec3 n=normalize(cross(n1-d,n2-d));\r\n        if (lq.x<far && lq.y<far && lq.z<far) {\r\n       \t\tnray = n;//normalize(nray+n);\r\n       \t\t//nray1 = normalize(ray1+n);\r\n       \t\t//nray2 = normalize(ray2+n);\r\n        }\r\n       \tfloat da = pow(abs(dot(n,light)),3.0);\r\n        vec3 cf = mix(vec3(0.0,0.4,1.0),color.xyz*10.0,abs(dot(n,ray)));\r\n       \tcf=mix(cf,vec3(2.0),da);\r\n      \tcolor.xyz = mix(color.xyz,cf,mxc*mxc*(0.5+abs(dot(n,ray))*0.5));\r\n    }\r\n    \r\n    return color;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float time = iTime*0.2;//*0.1;\r\n    res = 1.0 / iResolution.y;\r\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) *res;\r\n\r\n    vec3 rotate;\r\n    \r\n    mat3 mr;\r\n    \r\n    vec3 ray = normalize(vec3(p,2.0));\r\n    vec3 ray1;\r\n    vec3 ray2;\r\n    vec3 pos = vec3(0.0,0.0,1.0);\r\n\r\n    fragColor = vec4(0.0,0.0,0.0,0.0);\r\n    \r\n\tnray = vec3(0.0);\r\n\tnray1 = vec3(0.0);\r\n\tnray2 = vec3(0.0);\r\n    \r\n    vec4 refcolor=vec4(0.0);\r\n    iteratorc=iterations-layers;\r\n    \r\n    vec2 addrot = vec2(0.0);\r\n    if (iMouse.z>0.0) addrot=(iMouse.xy-iResolution.xy*0.5)*res;\r\n    \r\n    float mxcl = 1.0;\r\n    vec3 addpos=vec3(0.0);\r\n    pos.z = 1.0;\r\n    mxc=1.0;\r\n    radius = 0.25;\r\n    float mzd=(zoom-0.1)/layers;\r\n    for (int i=0; i<layersblob;i++) {\r\n        vec2 p2 = p-vec2(0.25)+vec2(0.1*float(i));\r\n        ray = vec3(p2,2.0)-nray*2.0;\r\n    \t//ray = nray;//*0.6;\r\n    \tray1 = normalize(ray+vec3(0.0,res*2.0,0.0));\r\n    \tray2 = normalize(ray+vec3(res*2.0,0.0,0.0));\r\n        ray = normalize(ray);\r\n    \tvec2 sb = ray.xy*length(pos)/dot(normalize(pos),ray)+vec2(0.0,time);\r\n        seed=floor((sb+vec2(0.0,pos.z)))+pos.z;\r\n        vec3 seedn = vec3(seed,pos.z);\r\n        sb = floor(sb);\r\n        if (noise3(seedn)>0.2 && i<int(layers)) {\r\n            powr = noise3(seedn*10.0)*1.9+0.1;\r\n            rotate.xy=sin((0.5-noise3_2(seedn))*time*5.0)*0.3+addrot;\r\n            rotate.z = (0.5-noise3(seedn+vec3(10.0,3.0,1.0)))*time*5.0;\r\n            seedn.z += time*0.5;\r\n            addpos.xy = sb+vec2(0.25,0.25-time)+noise3_2(seedn)*0.5;\r\n            vec3 sins = sin(rotate);\r\n    \t\tvec3 coss = cos(rotate);\r\n    \t\tmr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\r\n\t\t    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;\r\n            mr=mat3(vec3(coss.z,sins.z,0.0),vec3(-sins.z,coss.z,0.0),vec3(0.0,0.0,1.0))*mr;\r\n\r\n            light = normalize(vec3(1.0,0.0,1.0))*mr;\r\n    \t\t//vec4 cc=filterFlake(fragColor,(pos+addpos)*mr,normalize(ray*mr+nray*0.1),normalize(ray1*mr+nray*0.1),normalize(ray2*mr+nray*0.1));\r\n            vec4 cc = filterFlake(fragColor,(pos+addpos)*mr,ray*mr,ray1*mr,ray2*mr);\r\n            //if (i>0 && dot(nray,nray)!=0.0 && dot(nray1,nray1)!=0.0 && dot(nray2,nray2)!=0.0) refcolor=filterFlake(refcolor,(pos+addpos)*mr,nray,nray1,nray2);\r\n            //cc+=refcolor*0.5;\r\n            fragColor=mix(cc,fragColor,min(1.0,fragColor.w));\r\n        }\r\n        seedn = vec3(sb,pos.z)+vec3(0.5,1000.0,300.0);\r\n        if (noise3(seedn*10.0)>0.4) {\r\n            float raf = 0.3+noise3(seedn*100.0);\r\n            addpos.xy = sb+vec2(0.2,0.2-time)+noise3_2(seedn*100.0)*0.6;\r\n            float l = length(ray*dot(ray,pos+addpos)-pos-addpos);\r\n            l = max(0.0,(1.0-l*10.0*raf));\r\n            fragColor.xyzw += vec4(1.0,1.2,3.0,1.0)*pow(l,5.0)*(pow(0.6+raf,2.0)-0.6)*mxcl;\r\n        }\r\n        mxc -= 1.1/layers;\r\n        pos.z += step;\r\n        iteratorc += 2.0;\r\n        mxcl -= 1.1/float(layersblob);\r\n        zoom-= mzd;\r\n    }\r\n    \r\n    vec3 cr = mix(vec3(0.0),vec3(0.0,0.0,0.4),(-0.55+p.y)*2.0);\r\n    fragColor.xyz += mix((cr.xyz-fragColor.xyz)*0.1,vec3(0.2,0.5,1.0),clamp((-p.y+1.0)*0.5,0.0,1.0));\r\n    \r\n    fragColor = min( vec4(1.0), fragColor );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Miracle Snowflakes","id":"bca3d5bf468e4ac5a124036c0803ccbf","date":null,"viewed":0,"name":"Miracle Snowflakes","description":"Snowflake, snowflake, snowflake...When I was a kid, my whole family cut out paper snowflakes and pasted them on all windows for the new year. O\nhttps://www.shadertoy.com/view/Xsd3zf","likes":0,"published":null,"tags":["procedural"," 3d"," raymarching"," sound"," raycast"," snowflake"," snow"]},"ver":null,"info":{"Name":"Miracle Snowflakes","id":"bca3d5bf468e4ac5a124036c0803ccbf","date":null,"viewed":0,"name":"Miracle Snowflakes","description":"Snowflake, snowflake, snowflake...When I was a kid, my whole family cut out paper snowflakes and pasted them on all windows for the new year. O\nhttps://www.shadertoy.com/view/Xsd3zf","likes":0,"published":null,"tags":["procedural"," 3d"," raymarching"," sound"," raycast"," snowflake"," snow"]},"renderpass":[{"Code":"//\r\n/* Panteleymonov Aleksandr Konstantinovich 2015\r\n//\r\n// if i write this string my code will be 0 chars, :) */\r\n\r\n#define iterations 15.0\r\n#define depth 0.0125\r\n#define layers 8.0\r\n#define layersblob 20\r\n#define step 1.0\r\n#define far 10000.0\r\n\r\nfloat radius=0.25; // radius of Snowflakes. maximum for this demo 0.25.\r\nfloat zoom=4.0; // use this to change details. optimal 0.1 - 4.0.\r\n\r\nvec3 light=vec3(0.0,0.0,1.0);\r\nvec2 seed=vec2(0.0,0.0);\r\nfloat iteratorc=iterations;\r\nfloat powr;\r\nfloat res;\r\n\r\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\r\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\r\n\r\nlowp vec4 hash4( mediump vec4 n ) { return fract(sin(n)*1399763.5453123); }\r\nlowp float noise2( mediump vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    lowp vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0;\r\n    lowp vec4 h = hash4(vec4(n)+vec4(NC0.xy,NC1.xy));\r\n    lowp vec2 s1 = mix(h.xy,h.zw,f.xx);\r\n    return mix(s1.x,s1.y,f.y);\r\n}\r\n\r\nlowp float noise222( mediump vec2 x, mediump vec2 y, mediump vec2 z )\r\n{\r\n    mediump vec4 lx = vec4(x*y.x,x*y.y);\r\n    mediump vec4 p = floor(lx);\r\n    lowp vec4 f = fract(lx);\r\n    f = f*f*(3.0-2.0*f);\r\n    mediump vec2 n = p.xz + p.yw*157.0;\r\n    lowp vec4 h = mix(hash4(n.xxyy+NC0.xyxy),hash4(n.xxyy+NC1.xyxy),f.xxzz);\r\n    return dot(mix(h.xz,h.yw,f.yw),z);\r\n}\r\n\r\nlowp float noise3( mediump vec3 x )\r\n{\r\n    mediump vec3 p = floor(x);\r\n    lowp vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    mediump float n = p.x + dot(p.yz,vec2(157.0,113.0));\r\n    lowp vec4 s1 = mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),f.xxxx);\r\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\r\n}\r\nlowp vec2 noise3_2( mediump vec3 x ) { return vec2(noise3(x),noise3(x+100.0)); }\r\n\r\nfloat map(mediump vec2 rad)\r\n{\r\n    float a;\r\n    if (res<0.0015) {\r\n    \t//a = noise2(rad.xy*20.6)*0.9+noise2(rad.xy*100.6)*0.1;\r\n        a = noise222(rad.xy,vec2(20.6,100.6),vec2(0.9,0.1));\r\n    } else if (res<0.005) {\r\n        //float a1 = mix(noise2(rad.xy*10.6),1.0,l);\r\n        //a = texture(iChannel0,rad*0.3).x;\r\n        a = noise2(rad.xy*20.6);\r\n        //if (a1<a) a=a1;\r\n    } else a = noise2(rad.xy*10.3);\r\n    return (a-0.5);\r\n}\r\n\r\nvec3 distObj(vec3 pos,vec3 ray,float r,vec2 seed)\r\n{   \r\n    mediump float rq = r*r;\r\n    mediump vec3 dist = ray*far;\r\n    \r\n    mediump vec3 norm = vec3(0.0,0.0,1.0);\r\n    mediump float invn = 1.0/dot(norm,ray);\r\n    mediump float depthi = depth;\r\n    if (invn<0.0) depthi =- depthi;\r\n    mediump float ds = 2.0*depthi*invn;\r\n    mediump vec3 r1 = ray*(dot(norm,pos)-depthi)*invn-pos;\r\n    mediump vec3 op1 = r1+norm*depthi;\r\n    mediump float len1 = dot(op1,op1);\r\n    mediump vec3 r2 = r1+ray*ds;\r\n    mediump vec3 op2 = r2-norm*depthi;\r\n    mediump float len2 = dot(op2,op2);\r\n    \r\n    mediump vec3 n = normalize(cross(ray,norm));\r\n    mediump float mind = dot(pos,n);\r\n    mediump vec3 n2 = cross(ray,n);\r\n    mediump float d = dot(n2,pos)/dot(n2,norm);\r\n    mediump float invd = 0.2/depth;\r\n    \r\n    if ((len1<rq || len2<rq) || (abs(mind)<r && d<=depth && d>=-depth))\r\n    {        \r\n        mediump vec3 r3 = r2;\r\n        mediump float len = len1;\r\n        if (len>=rq) {\r\n        \tmediump vec3 n3 = cross(norm,n);\r\n        \tmediump float a = inversesqrt(rq-mind*mind)*abs(dot(ray,n3));\r\n            mediump vec3 dt = ray/a;\r\n        \tr1 =- d*norm-mind*n-dt;\r\n            if (len2>=rq) {\r\n                r2 =- d*norm-mind*n+dt;\r\n            }\r\n            ds = dot(r2-r1,ray);\r\n        }\r\n        ds = (abs(ds)+0.1)/(iterations);\r\n        ds = mix(depth,ds,0.2);\r\n        if (ds>0.01) ds=0.01;\r\n        mediump float ir = 0.35/r;\r\n        r *= zoom;\r\n        ray = ray*ds*5.0;\r\n        for (float m=0.0; m<iterations; m+=1.0) {\r\n            if (m>=iteratorc) break;\r\n           \tmediump float l = length(r1.xy); //inversesqrt(dot(r1.xy,r1.xy));\r\n            lowp vec2 c3 = abs(r1.xy/l);\r\n            if (c3.x>0.5) c3=abs(c3*0.5+vec2(-c3.y,c3.x)*0.86602540);\r\n\t\t\tmediump float g = l+c3.x*c3.x; //*1.047197551;\r\n\t\t\tl *= zoom;\r\n            mediump float h = l-r-0.1;\r\n            l = pow(l,powr)+0.1;\r\n          \th = max(h,mix(map(c3*l+seed),1.0,abs(r1.z*invd)))+g*ir-0.245; //0.7*0.35=0.245 //*0.911890636\r\n            if ((h<res*20.0) || abs(r1.z)>depth+0.01) break;\r\n            r1 += ray*h;\r\n            ray*=0.99;\r\n        }\r\n        if (abs(r1.z)<depth+0.01) dist=r1+pos;\r\n    }\r\n    return dist;\r\n}\r\n\r\nvec3 nray;\r\nvec3 nray1;\r\nvec3 nray2;\r\nfloat mxc=1.0;\r\n\r\nvec4 filterFlake(vec4 color,vec3 pos,vec3 ray,vec3 ray1,vec3 ray2)\r\n{\r\n    vec3 d=distObj(pos,ray,radius,seed);\r\n    vec3 n1=distObj(pos,ray1,radius,seed);\r\n    vec3 n2=distObj(pos,ray2,radius,seed);\r\n\r\n    vec3 lq=vec3(dot(d,d),dot(n1,n1),dot(n2,n2));\r\n\tif (lq.x<far || lq.y<far || lq.z<far) {\r\n    \tvec3 n=normalize(cross(n1-d,n2-d));\r\n        if (lq.x<far && lq.y<far && lq.z<far) {\r\n       \t\tnray = n;//normalize(nray+n);\r\n       \t\t//nray1 = normalize(ray1+n);\r\n       \t\t//nray2 = normalize(ray2+n);\r\n        }\r\n       \tfloat da = pow(abs(dot(n,light)),3.0);\r\n        vec3 cf = mix(vec3(0.0,0.4,1.0),color.xyz*10.0,abs(dot(n,ray)));\r\n       \tcf=mix(cf,vec3(2.0),da);\r\n      \tcolor.xyz = mix(color.xyz,cf,mxc*mxc*(0.5+abs(dot(n,ray))*0.5));\r\n    }\r\n    \r\n    return color;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float time = iTime*0.2;//*0.1;\r\n    res = 1.0 / iResolution.y;\r\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) *res;\r\n\r\n    vec3 rotate;\r\n    \r\n    mat3 mr;\r\n    \r\n    vec3 ray = normalize(vec3(p,2.0));\r\n    vec3 ray1;\r\n    vec3 ray2;\r\n    vec3 pos = vec3(0.0,0.0,1.0);\r\n\r\n    fragColor = vec4(0.0,0.0,0.0,0.0);\r\n    \r\n\tnray = vec3(0.0);\r\n\tnray1 = vec3(0.0);\r\n\tnray2 = vec3(0.0);\r\n    \r\n    vec4 refcolor=vec4(0.0);\r\n    iteratorc=iterations-layers;\r\n    \r\n    vec2 addrot = vec2(0.0);\r\n    if (iMouse.z>0.0) addrot=(iMouse.xy-iResolution.xy*0.5)*res;\r\n    \r\n    float mxcl = 1.0;\r\n    vec3 addpos=vec3(0.0);\r\n    pos.z = 1.0;\r\n    mxc=1.0;\r\n    radius = 0.25;\r\n    float mzd=(zoom-0.1)/layers;\r\n    for (int i=0; i<layersblob;i++) {\r\n        vec2 p2 = p-vec2(0.25)+vec2(0.1*float(i));\r\n        ray = vec3(p2,2.0)-nray*2.0;\r\n    \t//ray = nray;//*0.6;\r\n    \tray1 = normalize(ray+vec3(0.0,res*2.0,0.0));\r\n    \tray2 = normalize(ray+vec3(res*2.0,0.0,0.0));\r\n        ray = normalize(ray);\r\n    \tvec2 sb = ray.xy*length(pos)/dot(normalize(pos),ray)+vec2(0.0,time);\r\n        seed=floor((sb+vec2(0.0,pos.z)))+pos.z;\r\n        vec3 seedn = vec3(seed,pos.z);\r\n        sb = floor(sb);\r\n        if (noise3(seedn)>0.2 && i<int(layers)) {\r\n            powr = noise3(seedn*10.0)*1.9+0.1;\r\n            rotate.xy=sin((0.5-noise3_2(seedn))*time*5.0)*0.3+addrot;\r\n            rotate.z = (0.5-noise3(seedn+vec3(10.0,3.0,1.0)))*time*5.0;\r\n            seedn.z += time*0.5;\r\n            addpos.xy = sb+vec2(0.25,0.25-time)+noise3_2(seedn)*0.5;\r\n            vec3 sins = sin(rotate);\r\n    \t\tvec3 coss = cos(rotate);\r\n    \t\tmr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\r\n\t\t    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;\r\n            mr=mat3(vec3(coss.z,sins.z,0.0),vec3(-sins.z,coss.z,0.0),vec3(0.0,0.0,1.0))*mr;\r\n\r\n            light = normalize(vec3(1.0,0.0,1.0))*mr;\r\n    \t\t//vec4 cc=filterFlake(fragColor,(pos+addpos)*mr,normalize(ray*mr+nray*0.1),normalize(ray1*mr+nray*0.1),normalize(ray2*mr+nray*0.1));\r\n            vec4 cc = filterFlake(fragColor,(pos+addpos)*mr,ray*mr,ray1*mr,ray2*mr);\r\n            //if (i>0 && dot(nray,nray)!=0.0 && dot(nray1,nray1)!=0.0 && dot(nray2,nray2)!=0.0) refcolor=filterFlake(refcolor,(pos+addpos)*mr,nray,nray1,nray2);\r\n            //cc+=refcolor*0.5;\r\n            fragColor=mix(cc,fragColor,min(1.0,fragColor.w));\r\n        }\r\n        seedn = vec3(sb,pos.z)+vec3(0.5,1000.0,300.0);\r\n        if (noise3(seedn*10.0)>0.4) {\r\n            float raf = 0.3+noise3(seedn*100.0);\r\n            addpos.xy = sb+vec2(0.2,0.2-time)+noise3_2(seedn*100.0)*0.6;\r\n            float l = length(ray*dot(ray,pos+addpos)-pos-addpos);\r\n            l = max(0.0,(1.0-l*10.0*raf));\r\n            fragColor.xyzw += vec4(1.0,1.2,3.0,1.0)*pow(l,5.0)*(pow(0.6+raf,2.0)-0.6)*mxcl;\r\n        }\r\n        mxc -= 1.1/layers;\r\n        pos.z += step;\r\n        iteratorc += 2.0;\r\n        mxcl -= 1.1/float(layersblob);\r\n        zoom-= mzd;\r\n    }\r\n    \r\n    vec3 cr = mix(vec3(0.0),vec3(0.0,0.0,0.4),(-0.55+p.y)*2.0);\r\n    fragColor.xyz += mix((cr.xyz-fragColor.xyz)*0.1,vec3(0.2,0.5,1.0),clamp((-p.y+1.0)*0.5,0.0,1.0));\r\n    \r\n    fragColor = min( vec4(1.0), fragColor );\r\n}","inputs":[],"outputs":[],"code":"//\r\n/* Panteleymonov Aleksandr Konstantinovich 2015\r\n//\r\n// if i write this string my code will be 0 chars, :) */\r\n\r\n#define iterations 15.0\r\n#define depth 0.0125\r\n#define layers 8.0\r\n#define layersblob 20\r\n#define step 1.0\r\n#define far 10000.0\r\n\r\nfloat radius=0.25; // radius of Snowflakes. maximum for this demo 0.25.\r\nfloat zoom=4.0; // use this to change details. optimal 0.1 - 4.0.\r\n\r\nvec3 light=vec3(0.0,0.0,1.0);\r\nvec2 seed=vec2(0.0,0.0);\r\nfloat iteratorc=iterations;\r\nfloat powr;\r\nfloat res;\r\n\r\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\r\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\r\n\r\nlowp vec4 hash4( mediump vec4 n ) { return fract(sin(n)*1399763.5453123); }\r\nlowp float noise2( mediump vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    lowp vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0;\r\n    lowp vec4 h = hash4(vec4(n)+vec4(NC0.xy,NC1.xy));\r\n    lowp vec2 s1 = mix(h.xy,h.zw,f.xx);\r\n    return mix(s1.x,s1.y,f.y);\r\n}\r\n\r\nlowp float noise222( mediump vec2 x, mediump vec2 y, mediump vec2 z )\r\n{\r\n    mediump vec4 lx = vec4(x*y.x,x*y.y);\r\n    mediump vec4 p = floor(lx);\r\n    lowp vec4 f = fract(lx);\r\n    f = f*f*(3.0-2.0*f);\r\n    mediump vec2 n = p.xz + p.yw*157.0;\r\n    lowp vec4 h = mix(hash4(n.xxyy+NC0.xyxy),hash4(n.xxyy+NC1.xyxy),f.xxzz);\r\n    return dot(mix(h.xz,h.yw,f.yw),z);\r\n}\r\n\r\nlowp float noise3( mediump vec3 x )\r\n{\r\n    mediump vec3 p = floor(x);\r\n    lowp vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    mediump float n = p.x + dot(p.yz,vec2(157.0,113.0));\r\n    lowp vec4 s1 = mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),f.xxxx);\r\n    return mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\r\n}\r\nlowp vec2 noise3_2( mediump vec3 x ) { return vec2(noise3(x),noise3(x+100.0)); }\r\n\r\nfloat map(mediump vec2 rad)\r\n{\r\n    float a;\r\n    if (res<0.0015) {\r\n    \t//a = noise2(rad.xy*20.6)*0.9+noise2(rad.xy*100.6)*0.1;\r\n        a = noise222(rad.xy,vec2(20.6,100.6),vec2(0.9,0.1));\r\n    } else if (res<0.005) {\r\n        //float a1 = mix(noise2(rad.xy*10.6),1.0,l);\r\n        //a = texture(iChannel0,rad*0.3).x;\r\n        a = noise2(rad.xy*20.6);\r\n        //if (a1<a) a=a1;\r\n    } else a = noise2(rad.xy*10.3);\r\n    return (a-0.5);\r\n}\r\n\r\nvec3 distObj(vec3 pos,vec3 ray,float r,vec2 seed)\r\n{   \r\n    mediump float rq = r*r;\r\n    mediump vec3 dist = ray*far;\r\n    \r\n    mediump vec3 norm = vec3(0.0,0.0,1.0);\r\n    mediump float invn = 1.0/dot(norm,ray);\r\n    mediump float depthi = depth;\r\n    if (invn<0.0) depthi =- depthi;\r\n    mediump float ds = 2.0*depthi*invn;\r\n    mediump vec3 r1 = ray*(dot(norm,pos)-depthi)*invn-pos;\r\n    mediump vec3 op1 = r1+norm*depthi;\r\n    mediump float len1 = dot(op1,op1);\r\n    mediump vec3 r2 = r1+ray*ds;\r\n    mediump vec3 op2 = r2-norm*depthi;\r\n    mediump float len2 = dot(op2,op2);\r\n    \r\n    mediump vec3 n = normalize(cross(ray,norm));\r\n    mediump float mind = dot(pos,n);\r\n    mediump vec3 n2 = cross(ray,n);\r\n    mediump float d = dot(n2,pos)/dot(n2,norm);\r\n    mediump float invd = 0.2/depth;\r\n    \r\n    if ((len1<rq || len2<rq) || (abs(mind)<r && d<=depth && d>=-depth))\r\n    {        \r\n        mediump vec3 r3 = r2;\r\n        mediump float len = len1;\r\n        if (len>=rq) {\r\n        \tmediump vec3 n3 = cross(norm,n);\r\n        \tmediump float a = inversesqrt(rq-mind*mind)*abs(dot(ray,n3));\r\n            mediump vec3 dt = ray/a;\r\n        \tr1 =- d*norm-mind*n-dt;\r\n            if (len2>=rq) {\r\n                r2 =- d*norm-mind*n+dt;\r\n            }\r\n            ds = dot(r2-r1,ray);\r\n        }\r\n        ds = (abs(ds)+0.1)/(iterations);\r\n        ds = mix(depth,ds,0.2);\r\n        if (ds>0.01) ds=0.01;\r\n        mediump float ir = 0.35/r;\r\n        r *= zoom;\r\n        ray = ray*ds*5.0;\r\n        for (float m=0.0; m<iterations; m+=1.0) {\r\n            if (m>=iteratorc) break;\r\n           \tmediump float l = length(r1.xy); //inversesqrt(dot(r1.xy,r1.xy));\r\n            lowp vec2 c3 = abs(r1.xy/l);\r\n            if (c3.x>0.5) c3=abs(c3*0.5+vec2(-c3.y,c3.x)*0.86602540);\r\n\t\t\tmediump float g = l+c3.x*c3.x; //*1.047197551;\r\n\t\t\tl *= zoom;\r\n            mediump float h = l-r-0.1;\r\n            l = pow(l,powr)+0.1;\r\n          \th = max(h,mix(map(c3*l+seed),1.0,abs(r1.z*invd)))+g*ir-0.245; //0.7*0.35=0.245 //*0.911890636\r\n            if ((h<res*20.0) || abs(r1.z)>depth+0.01) break;\r\n            r1 += ray*h;\r\n            ray*=0.99;\r\n        }\r\n        if (abs(r1.z)<depth+0.01) dist=r1+pos;\r\n    }\r\n    return dist;\r\n}\r\n\r\nvec3 nray;\r\nvec3 nray1;\r\nvec3 nray2;\r\nfloat mxc=1.0;\r\n\r\nvec4 filterFlake(vec4 color,vec3 pos,vec3 ray,vec3 ray1,vec3 ray2)\r\n{\r\n    vec3 d=distObj(pos,ray,radius,seed);\r\n    vec3 n1=distObj(pos,ray1,radius,seed);\r\n    vec3 n2=distObj(pos,ray2,radius,seed);\r\n\r\n    vec3 lq=vec3(dot(d,d),dot(n1,n1),dot(n2,n2));\r\n\tif (lq.x<far || lq.y<far || lq.z<far) {\r\n    \tvec3 n=normalize(cross(n1-d,n2-d));\r\n        if (lq.x<far && lq.y<far && lq.z<far) {\r\n       \t\tnray = n;//normalize(nray+n);\r\n       \t\t//nray1 = normalize(ray1+n);\r\n       \t\t//nray2 = normalize(ray2+n);\r\n        }\r\n       \tfloat da = pow(abs(dot(n,light)),3.0);\r\n        vec3 cf = mix(vec3(0.0,0.4,1.0),color.xyz*10.0,abs(dot(n,ray)));\r\n       \tcf=mix(cf,vec3(2.0),da);\r\n      \tcolor.xyz = mix(color.xyz,cf,mxc*mxc*(0.5+abs(dot(n,ray))*0.5));\r\n    }\r\n    \r\n    return color;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float time = iTime*0.2;//*0.1;\r\n    res = 1.0 / iResolution.y;\r\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) *res;\r\n\r\n    vec3 rotate;\r\n    \r\n    mat3 mr;\r\n    \r\n    vec3 ray = normalize(vec3(p,2.0));\r\n    vec3 ray1;\r\n    vec3 ray2;\r\n    vec3 pos = vec3(0.0,0.0,1.0);\r\n\r\n    fragColor = vec4(0.0,0.0,0.0,0.0);\r\n    \r\n\tnray = vec3(0.0);\r\n\tnray1 = vec3(0.0);\r\n\tnray2 = vec3(0.0);\r\n    \r\n    vec4 refcolor=vec4(0.0);\r\n    iteratorc=iterations-layers;\r\n    \r\n    vec2 addrot = vec2(0.0);\r\n    if (iMouse.z>0.0) addrot=(iMouse.xy-iResolution.xy*0.5)*res;\r\n    \r\n    float mxcl = 1.0;\r\n    vec3 addpos=vec3(0.0);\r\n    pos.z = 1.0;\r\n    mxc=1.0;\r\n    radius = 0.25;\r\n    float mzd=(zoom-0.1)/layers;\r\n    for (int i=0; i<layersblob;i++) {\r\n        vec2 p2 = p-vec2(0.25)+vec2(0.1*float(i));\r\n        ray = vec3(p2,2.0)-nray*2.0;\r\n    \t//ray = nray;//*0.6;\r\n    \tray1 = normalize(ray+vec3(0.0,res*2.0,0.0));\r\n    \tray2 = normalize(ray+vec3(res*2.0,0.0,0.0));\r\n        ray = normalize(ray);\r\n    \tvec2 sb = ray.xy*length(pos)/dot(normalize(pos),ray)+vec2(0.0,time);\r\n        seed=floor((sb+vec2(0.0,pos.z)))+pos.z;\r\n        vec3 seedn = vec3(seed,pos.z);\r\n        sb = floor(sb);\r\n        if (noise3(seedn)>0.2 && i<int(layers)) {\r\n            powr = noise3(seedn*10.0)*1.9+0.1;\r\n            rotate.xy=sin((0.5-noise3_2(seedn))*time*5.0)*0.3+addrot;\r\n            rotate.z = (0.5-noise3(seedn+vec3(10.0,3.0,1.0)))*time*5.0;\r\n            seedn.z += time*0.5;\r\n            addpos.xy = sb+vec2(0.25,0.25-time)+noise3_2(seedn)*0.5;\r\n            vec3 sins = sin(rotate);\r\n    \t\tvec3 coss = cos(rotate);\r\n    \t\tmr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\r\n\t\t    mr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;\r\n            mr=mat3(vec3(coss.z,sins.z,0.0),vec3(-sins.z,coss.z,0.0),vec3(0.0,0.0,1.0))*mr;\r\n\r\n            light = normalize(vec3(1.0,0.0,1.0))*mr;\r\n    \t\t//vec4 cc=filterFlake(fragColor,(pos+addpos)*mr,normalize(ray*mr+nray*0.1),normalize(ray1*mr+nray*0.1),normalize(ray2*mr+nray*0.1));\r\n            vec4 cc = filterFlake(fragColor,(pos+addpos)*mr,ray*mr,ray1*mr,ray2*mr);\r\n            //if (i>0 && dot(nray,nray)!=0.0 && dot(nray1,nray1)!=0.0 && dot(nray2,nray2)!=0.0) refcolor=filterFlake(refcolor,(pos+addpos)*mr,nray,nray1,nray2);\r\n            //cc+=refcolor*0.5;\r\n            fragColor=mix(cc,fragColor,min(1.0,fragColor.w));\r\n        }\r\n        seedn = vec3(sb,pos.z)+vec3(0.5,1000.0,300.0);\r\n        if (noise3(seedn*10.0)>0.4) {\r\n            float raf = 0.3+noise3(seedn*100.0);\r\n            addpos.xy = sb+vec2(0.2,0.2-time)+noise3_2(seedn*100.0)*0.6;\r\n            float l = length(ray*dot(ray,pos+addpos)-pos-addpos);\r\n            l = max(0.0,(1.0-l*10.0*raf));\r\n            fragColor.xyzw += vec4(1.0,1.2,3.0,1.0)*pow(l,5.0)*(pow(0.6+raf,2.0)-0.6)*mxcl;\r\n        }\r\n        mxc -= 1.1/layers;\r\n        pos.z += step;\r\n        iteratorc += 2.0;\r\n        mxcl -= 1.1/float(layersblob);\r\n        zoom-= mzd;\r\n    }\r\n    \r\n    vec3 cr = mix(vec3(0.0),vec3(0.0,0.0,0.4),(-0.55+p.y)*2.0);\r\n    fragColor.xyz += mix((cr.xyz-fragColor.xyz)*0.1,vec3(0.2,0.5,1.0),clamp((-p.y+1.0)*0.5,0.0,1.0));\r\n    \r\n    fragColor = min( vec4(1.0), fragColor );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Code by Flopine\r\n\r\n// From Mist by Ohno!\r\n// 4k demo released at Cookie 2018 with a music by Triace from Desire\r\n// Pouet : http://www.pouet.net/prod.php?which=79350\r\n// Youtube : https://www.youtube.com/watch?v=UUtU3WVB144&t=3s\r\n\r\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\r\n// Thanks LJ for giving me the love of shadercoding :3\r\n\r\n// Cookie Collective rulz\r\n\r\n\r\nfloat time = 0.;\r\n#define PI 3.141592\r\n#define tempo_sin (time * 2.62)\r\n#define tempo (mix(4.5/6., 9./6., step(87., time)))\r\n\r\n\r\nvec2 hash(vec2 x)\r\n{\r\n\tvec2 k = vec2(0.3183099, 0.3678794);\r\n\tx = x * k + k.yx;\r\n\treturn -1.0 + 2.0 * fract(16.0 * k * fract(x.x * x.y * (x.x + x.y)));\r\n}\r\n\r\n\r\nfloat random(vec2 uv)\r\n{return fract(sin(dot(uv, vec2(12.2544, 35.1571)))*5418.548416);}\r\n\r\n\r\nfloat noise(in vec2 p)\r\n{\r\n\tvec2 i = floor(p);\r\n\tvec2 f = fract(p);\r\n\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n\treturn mix(mix(dot(hash(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\r\n\t\tdot(hash(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\r\n\t\tmix(dot(hash(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\r\n\t\t\tdot(hash(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x),\r\n\t\tu.y);\r\n}\r\n\r\n\r\nfloat fbm(vec2 uv)\r\n{\r\n\tfloat f;\r\n\tmat2 m = mat2(1.6, 1.2, -1.2, 1.6);\r\n\tf = 0.5000 * noise(uv);\r\n\tuv = m * uv;\r\n\tf += 0.2500 * noise(uv);\r\n\tuv = m * uv;\r\n\tf += 0.1250 * noise(uv);\r\n\treturn f;\r\n}\r\n\r\n\r\nmat2 r2d(float a) \r\n{\r\n\tfloat c = cos(a), s = sin(a);\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\n\r\nfloat smin(float a, float b, float k)\r\n{\r\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k * h*(1.0 - h);\r\n}\r\n\r\n\r\nvec3 re(vec3 p, float d) \r\n{return mod(p - d * .5, d) - d * .5;}\r\n\r\n\r\nvoid amod(inout vec2 p, float d) \r\n{\r\n\tfloat a = re(vec3(atan(p.y, p.x)), d).x;\r\n\tp = vec2(cos(a), sin(a)) * length(p);\r\n}\r\n\r\n\r\nvec3 get_cam(vec3 ro, vec3 ta, vec2 uv)\r\n{\r\n\tvec3 fwd = normalize(ta - ro);\r\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\r\n\treturn normalize(fwd + right * uv.x + cross(right, fwd) * uv.y);\r\n}\r\n\r\n\r\nfloat sphe(vec3 p, float r)\r\n{return length(p) - r;}\r\n\r\n\r\nfloat od(vec3 p, float d)\r\n{return dot(p, normalize(sign(p))) - d;}\r\n\r\n\r\nfloat sc(vec3 p, float d) {\r\n\tp = abs(p);\r\n\tp = max(p, p.yzx);\r\n\treturn min(p.x, min(p.y, p.z)) - d;\r\n}\r\n\r\n\r\nfloat torus(vec3 p, vec2 d)\r\n{\r\n\tvec2 q = vec2(length(p.xz) - d.x, p.y);\r\n\treturn length(q) - d.y;\r\n}\r\n\r\n\r\n\r\n////////// SCENE CONSTRUCTION //////////////////////////////////////////////////////////\r\nfloat pool(vec3 p)\r\n{return abs(p.y + fbm(p.xz*0.1 + time * 0.1 + fbm(p.xz*0.1 - time * 0.2)) + 0.5) - 0.05;}\r\n\r\n\r\nfloat g1 = 0.;\r\nfloat g2 = 0.;\r\nfloat tubes(vec3 p)\r\n{\r\n\tp.xz = re(p.xzz + 9., 18.).xy;\r\n\tp.xz *= r2d(time*0.4);\r\n\tp.xz *= r2d(p.y*0.3);\r\n\tamod(p.xz, 2.*PI / 5.);\r\n\tp.x -= 2.;\r\n\tp.x += sin(p.y*0.5 + time);\r\n\tfloat d = length(p.xz) - 0.2;\r\n\r\n\tg2 += (0.01 / (0.01 + d * d))*0.15;\r\n\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat ball(vec3 p)\r\n{\r\n\tp.y -= mix(-2., 5., smoothstep(4., 10., time) * (1. - smoothstep(112., 115., time)));\r\n\tfloat d = sphe(p, .8 + sin(tempo_sin)*0.1);\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat cage(vec3 p)\r\n{\r\n\tp.y -= 5.;\r\n\tp.xz *= r2d(time);\r\n\tp.yz *= r2d(time*0.5);\r\n\tfloat od_size = mix(-.1, 1., smoothstep(14., 19., time));\r\n\tfloat sphe_r1 = mix(1.14, 0.1, smoothstep(41., 42., time));\r\n\tfloat sphe_r = mix(sphe_r1, 3., pow(fract(time), 6.) * step(110., time) + (step(111., time)));\r\n\treturn max(-sphe(p, sphe_r), od(p, od_size));\r\n}\r\n\r\n\r\nfloat ring(vec3 p)\r\n{\r\n\tfloat anim = (PI / 2.)*(floor(time*tempo) + pow(fract(time*tempo), 3.));\r\n\r\n\tvec2 torus_size1 = mix(vec2(1.5, -0.5), vec2(2., 0.05), smoothstep(25., 28., time)*(1. - smoothstep(109., 110., time)));\r\n\tvec2 torus_size2 = mix(vec2(2.5, -0.5), vec2(3., 0.09), smoothstep(31., 34., time)*(1. - smoothstep(109., 110., time)));\r\n\r\n\r\n\tp.y -= 5.;\r\n\tp.xy *= r2d(PI / 4.);\r\n\tp.xz *= r2d(PI / 4.);\r\n\r\n\tvec3 pp = p;\r\n\tp.xz *= r2d(-anim);\r\n\tfloat r1 = max(-sc(p, 1.), torus(p, torus_size1));\r\n\r\n\tp = pp;\r\n\tp.xy *= r2d(anim);\r\n\tp.yz *= r2d(PI / 2.);\r\n\tfloat d = min(r1, max(-sc(p, 1.), torus(p, torus_size2)));\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat balls(vec3 p)\r\n{\r\n\tfloat d = sphe(vec3(p.x, p.y + 2., p.z), 0.5);\r\n\tp.y += mix(2., (sin(time) + 1.), smoothstep(35., 37., time));\r\n\tif (time > 88.) p.y = mix(2., 0., smoothstep(89., 92., time) * (1. - smoothstep(113., 115., time)));\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tamod(p.xz, 2.*PI / 5.);\r\n\t\tp.x -= mix(6., 0.1, clamp(pow(fract(time), 3.) * step(95., time) + step(96., time), 0., 1.));\r\n\t\td = min(d, sphe(p, 0.5));\r\n\t}\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat SDF(vec3 p)\r\n{\r\n\treturn time < 24. ? smin(tubes(p), smin(pool(p), min(ball(p), cage(p)), 2.), 1.5) :\r\n\t\tmin(min(ring(p), min(cage(p), ball(p))), smin(tubes(p), smin(pool(p), balls(p), 2.), 1.5));\r\n}\r\n\r\n\r\n\r\n////////// RAYMARCHING FUNCTION ////////////////\r\nvec3 raymarch_flopine(vec3 ro, vec3 rd, vec2 uv)\r\n{\r\n\tvec3 col;\r\n\tfloat dither = random(uv);\r\n\tfloat t = 0.;\r\n\tvec3 p;// = ro;\r\n\tfor (float i = 0.; i < 80.; i++)\r\n\t{\r\n\t\tp = ro + t * rd;\r\n\t\tfloat d = SDF(p);\r\n\t\tif (d < 0.001)\r\n\t\t{\r\n\t\t\tcol = vec3(i / 80.);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\td *= 1. + dither * 0.1;\r\n\r\n\t\tt += d * .8;\r\n\t}\r\n\r\n\tfloat g2_force = mix(0., 0.8, smoothstep(10., 14., time) * (1. - smoothstep(116., 120., time)));\r\n\tcol += g1 * vec3(0.2, 0.4, 0.);\r\n\tcol += (g2* g2_force) * vec3(0., 0.5, 0.5);\r\n\tcol = mix(col, vec3(0., 0.3, 0.4), 1. - exp(-0.001*t*t));\r\n\r\n\treturn col;\r\n}\r\n\r\n\r\n// Glitch function borrowed from mmerchante shader : https://www.shadertoy.com/view/MltcWs\r\nvoid glitch(inout vec2 uv, float start_time_stamp, float end_time_stamp)\r\n{\r\n\tint offset = int(floor(time)*2.) + int((uv.x + uv.y) * 8.0);\r\n\tfloat res = mix(10., 100.0, random(vec2(offset)));\r\n\r\n\t// glitch pixellate\r\n\tif (time > start_time_stamp && time <= end_time_stamp) uv = floor(uv * res) / res;\r\n\r\n\tint seedX = int(gl_FragCoord.x + time) / 32;\r\n\tint seedY = int(gl_FragCoord.y + time) / 32;\r\n\tint seed = mod(time, 2.) > 1. ? seedX : seedY;\r\n\r\n\r\n\t// glitch splitter\r\n\tuv.x += (random(vec2(seed)) * 2.0 - 1.0)\r\n\t\t* step(random(vec2(seed)), pow(sin(time * 4.), 7.0))\r\n\t\t* random(vec2(seed))\r\n\t\t* step(start_time_stamp, time)\r\n\t\t* (1. - step(end_time_stamp, time));\r\n}\r\n\r\n\r\n\r\n///////// MAIN FUNCTION //////////////////////////////\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = q - .5;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n    \r\n    \r\n\t/* just code for the shadertoy port */\r\n\ttime = mod(iTime, 45. + 10.6 + 17.);\r\n    if (time > 45. && time <= 88.)\r\n\t\ttime += 43.;\r\n    if (time > 98.6)\r\n\t\ttime += 10.4;\r\n   \r\n\tglitch(uv, 0., 2.);\r\n\tglitch(uv, 91., 92.);\r\n\tglitch(uv, 94.5, 95.5);\r\n\tglitch(uv, 98., 99.);\r\n\r\n\tvec3 flo_ro1 = vec3(-20. * cos(time*0.06), 10., -20.*sin(time*0.06));\r\n\tvec3 flo_ro2 = vec3(-5., 18., 0.);\r\n\tvec3 flo_ro3 = vec3(-5., 20., 12.);\r\n\tvec3 flo_ro = mix(mix(flo_ro1, flo_ro2, step(24., time)), flo_ro3, step(88., time));\r\n\tvec3 flo_target = vec3(0.);\r\n\tvec3 flo_cam = get_cam(flo_ro, flo_target, uv);\r\n\r\n\r\n\tvec3 col = vec3(0.);\r\n\tif (time <= 45.)\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\tif (time > 88. && time <= 98.6) // 98.\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\tif (time > 109. && time <= 126.)\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\r\n\r\n\t// vignetting from iq\r\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\r\n\r\n\t// fading out - end of the demo\r\n\tcol *= 1. - smoothstep(120., 125., time);\r\n\r\n\tfragColor = vec4(col, 1.);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Code by Flopine\r\n\r\n// From Mist by Ohno!\r\n// 4k demo released at Cookie 2018 with a music by Triace from Desire\r\n// Pouet : http://www.pouet.net/prod.php?which=79350\r\n// Youtube : https://www.youtube.com/watch?v=UUtU3WVB144&t=3s\r\n\r\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\r\n// Thanks LJ for giving me the love of shadercoding :3\r\n\r\n// Cookie Collective rulz\r\n\r\n\r\nfloat time = 0.;\r\n#define PI 3.141592\r\n#define tempo_sin (time * 2.62)\r\n#define tempo (mix(4.5/6., 9./6., step(87., time)))\r\n\r\n\r\nvec2 hash(vec2 x)\r\n{\r\n\tvec2 k = vec2(0.3183099, 0.3678794);\r\n\tx = x * k + k.yx;\r\n\treturn -1.0 + 2.0 * fract(16.0 * k * fract(x.x * x.y * (x.x + x.y)));\r\n}\r\n\r\n\r\nfloat random(vec2 uv)\r\n{return fract(sin(dot(uv, vec2(12.2544, 35.1571)))*5418.548416);}\r\n\r\n\r\nfloat noise(in vec2 p)\r\n{\r\n\tvec2 i = floor(p);\r\n\tvec2 f = fract(p);\r\n\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n\treturn mix(mix(dot(hash(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\r\n\t\tdot(hash(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\r\n\t\tmix(dot(hash(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\r\n\t\t\tdot(hash(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x),\r\n\t\tu.y);\r\n}\r\n\r\n\r\nfloat fbm(vec2 uv)\r\n{\r\n\tfloat f;\r\n\tmat2 m = mat2(1.6, 1.2, -1.2, 1.6);\r\n\tf = 0.5000 * noise(uv);\r\n\tuv = m * uv;\r\n\tf += 0.2500 * noise(uv);\r\n\tuv = m * uv;\r\n\tf += 0.1250 * noise(uv);\r\n\treturn f;\r\n}\r\n\r\n\r\nmat2 r2d(float a) \r\n{\r\n\tfloat c = cos(a), s = sin(a);\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\n\r\nfloat smin(float a, float b, float k)\r\n{\r\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k * h*(1.0 - h);\r\n}\r\n\r\n\r\nvec3 re(vec3 p, float d) \r\n{return mod(p - d * .5, d) - d * .5;}\r\n\r\n\r\nvoid amod(inout vec2 p, float d) \r\n{\r\n\tfloat a = re(vec3(atan(p.y, p.x)), d).x;\r\n\tp = vec2(cos(a), sin(a)) * length(p);\r\n}\r\n\r\n\r\nvec3 get_cam(vec3 ro, vec3 ta, vec2 uv)\r\n{\r\n\tvec3 fwd = normalize(ta - ro);\r\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\r\n\treturn normalize(fwd + right * uv.x + cross(right, fwd) * uv.y);\r\n}\r\n\r\n\r\nfloat sphe(vec3 p, float r)\r\n{return length(p) - r;}\r\n\r\n\r\nfloat od(vec3 p, float d)\r\n{return dot(p, normalize(sign(p))) - d;}\r\n\r\n\r\nfloat sc(vec3 p, float d) {\r\n\tp = abs(p);\r\n\tp = max(p, p.yzx);\r\n\treturn min(p.x, min(p.y, p.z)) - d;\r\n}\r\n\r\n\r\nfloat torus(vec3 p, vec2 d)\r\n{\r\n\tvec2 q = vec2(length(p.xz) - d.x, p.y);\r\n\treturn length(q) - d.y;\r\n}\r\n\r\n\r\n\r\n////////// SCENE CONSTRUCTION //////////////////////////////////////////////////////////\r\nfloat pool(vec3 p)\r\n{return abs(p.y + fbm(p.xz*0.1 + time * 0.1 + fbm(p.xz*0.1 - time * 0.2)) + 0.5) - 0.05;}\r\n\r\n\r\nfloat g1 = 0.;\r\nfloat g2 = 0.;\r\nfloat tubes(vec3 p)\r\n{\r\n\tp.xz = re(p.xzz + 9., 18.).xy;\r\n\tp.xz *= r2d(time*0.4);\r\n\tp.xz *= r2d(p.y*0.3);\r\n\tamod(p.xz, 2.*PI / 5.);\r\n\tp.x -= 2.;\r\n\tp.x += sin(p.y*0.5 + time);\r\n\tfloat d = length(p.xz) - 0.2;\r\n\r\n\tg2 += (0.01 / (0.01 + d * d))*0.15;\r\n\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat ball(vec3 p)\r\n{\r\n\tp.y -= mix(-2., 5., smoothstep(4., 10., time) * (1. - smoothstep(112., 115., time)));\r\n\tfloat d = sphe(p, .8 + sin(tempo_sin)*0.1);\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat cage(vec3 p)\r\n{\r\n\tp.y -= 5.;\r\n\tp.xz *= r2d(time);\r\n\tp.yz *= r2d(time*0.5);\r\n\tfloat od_size = mix(-.1, 1., smoothstep(14., 19., time));\r\n\tfloat sphe_r1 = mix(1.14, 0.1, smoothstep(41., 42., time));\r\n\tfloat sphe_r = mix(sphe_r1, 3., pow(fract(time), 6.) * step(110., time) + (step(111., time)));\r\n\treturn max(-sphe(p, sphe_r), od(p, od_size));\r\n}\r\n\r\n\r\nfloat ring(vec3 p)\r\n{\r\n\tfloat anim = (PI / 2.)*(floor(time*tempo) + pow(fract(time*tempo), 3.));\r\n\r\n\tvec2 torus_size1 = mix(vec2(1.5, -0.5), vec2(2., 0.05), smoothstep(25., 28., time)*(1. - smoothstep(109., 110., time)));\r\n\tvec2 torus_size2 = mix(vec2(2.5, -0.5), vec2(3., 0.09), smoothstep(31., 34., time)*(1. - smoothstep(109., 110., time)));\r\n\r\n\r\n\tp.y -= 5.;\r\n\tp.xy *= r2d(PI / 4.);\r\n\tp.xz *= r2d(PI / 4.);\r\n\r\n\tvec3 pp = p;\r\n\tp.xz *= r2d(-anim);\r\n\tfloat r1 = max(-sc(p, 1.), torus(p, torus_size1));\r\n\r\n\tp = pp;\r\n\tp.xy *= r2d(anim);\r\n\tp.yz *= r2d(PI / 2.);\r\n\tfloat d = min(r1, max(-sc(p, 1.), torus(p, torus_size2)));\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat balls(vec3 p)\r\n{\r\n\tfloat d = sphe(vec3(p.x, p.y + 2., p.z), 0.5);\r\n\tp.y += mix(2., (sin(time) + 1.), smoothstep(35., 37., time));\r\n\tif (time > 88.) p.y = mix(2., 0., smoothstep(89., 92., time) * (1. - smoothstep(113., 115., time)));\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tamod(p.xz, 2.*PI / 5.);\r\n\t\tp.x -= mix(6., 0.1, clamp(pow(fract(time), 3.) * step(95., time) + step(96., time), 0., 1.));\r\n\t\td = min(d, sphe(p, 0.5));\r\n\t}\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat SDF(vec3 p)\r\n{\r\n\treturn time < 24. ? smin(tubes(p), smin(pool(p), min(ball(p), cage(p)), 2.), 1.5) :\r\n\t\tmin(min(ring(p), min(cage(p), ball(p))), smin(tubes(p), smin(pool(p), balls(p), 2.), 1.5));\r\n}\r\n\r\n\r\n\r\n////////// RAYMARCHING FUNCTION ////////////////\r\nvec3 raymarch_flopine(vec3 ro, vec3 rd, vec2 uv)\r\n{\r\n\tvec3 col;\r\n\tfloat dither = random(uv);\r\n\tfloat t = 0.;\r\n\tvec3 p;// = ro;\r\n\tfor (float i = 0.; i < 80.; i++)\r\n\t{\r\n\t\tp = ro + t * rd;\r\n\t\tfloat d = SDF(p);\r\n\t\tif (d < 0.001)\r\n\t\t{\r\n\t\t\tcol = vec3(i / 80.);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\td *= 1. + dither * 0.1;\r\n\r\n\t\tt += d * .8;\r\n\t}\r\n\r\n\tfloat g2_force = mix(0., 0.8, smoothstep(10., 14., time) * (1. - smoothstep(116., 120., time)));\r\n\tcol += g1 * vec3(0.2, 0.4, 0.);\r\n\tcol += (g2* g2_force) * vec3(0., 0.5, 0.5);\r\n\tcol = mix(col, vec3(0., 0.3, 0.4), 1. - exp(-0.001*t*t));\r\n\r\n\treturn col;\r\n}\r\n\r\n\r\n// Glitch function borrowed from mmerchante shader : https://www.shadertoy.com/view/MltcWs\r\nvoid glitch(inout vec2 uv, float start_time_stamp, float end_time_stamp)\r\n{\r\n\tint offset = int(floor(time)*2.) + int((uv.x + uv.y) * 8.0);\r\n\tfloat res = mix(10., 100.0, random(vec2(offset)));\r\n\r\n\t// glitch pixellate\r\n\tif (time > start_time_stamp && time <= end_time_stamp) uv = floor(uv * res) / res;\r\n\r\n\tint seedX = int(gl_FragCoord.x + time) / 32;\r\n\tint seedY = int(gl_FragCoord.y + time) / 32;\r\n\tint seed = mod(time, 2.) > 1. ? seedX : seedY;\r\n\r\n\r\n\t// glitch splitter\r\n\tuv.x += (random(vec2(seed)) * 2.0 - 1.0)\r\n\t\t* step(random(vec2(seed)), pow(sin(time * 4.), 7.0))\r\n\t\t* random(vec2(seed))\r\n\t\t* step(start_time_stamp, time)\r\n\t\t* (1. - step(end_time_stamp, time));\r\n}\r\n\r\n\r\n\r\n///////// MAIN FUNCTION //////////////////////////////\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = q - .5;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n    \r\n    \r\n\t/* just code for the shadertoy port */\r\n\ttime = mod(iTime, 45. + 10.6 + 17.);\r\n    if (time > 45. && time <= 88.)\r\n\t\ttime += 43.;\r\n    if (time > 98.6)\r\n\t\ttime += 10.4;\r\n   \r\n\tglitch(uv, 0., 2.);\r\n\tglitch(uv, 91., 92.);\r\n\tglitch(uv, 94.5, 95.5);\r\n\tglitch(uv, 98., 99.);\r\n\r\n\tvec3 flo_ro1 = vec3(-20. * cos(time*0.06), 10., -20.*sin(time*0.06));\r\n\tvec3 flo_ro2 = vec3(-5., 18., 0.);\r\n\tvec3 flo_ro3 = vec3(-5., 20., 12.);\r\n\tvec3 flo_ro = mix(mix(flo_ro1, flo_ro2, step(24., time)), flo_ro3, step(88., time));\r\n\tvec3 flo_target = vec3(0.);\r\n\tvec3 flo_cam = get_cam(flo_ro, flo_target, uv);\r\n\r\n\r\n\tvec3 col = vec3(0.);\r\n\tif (time <= 45.)\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\tif (time > 88. && time <= 98.6) // 98.\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\tif (time > 109. && time <= 126.)\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\r\n\r\n\t// vignetting from iq\r\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\r\n\r\n\t// fading out - end of the demo\r\n\tcol *= 1. - smoothstep(120., 125., time);\r\n\r\n\tfragColor = vec4(col, 1.);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Mist by Ohno! - OctaHydra","id":"117ff14b80204d98b57ec61f62764d9b","date":null,"viewed":0,"name":"Mist by Ohno! - OctaHydra","description":"There are the scenes I worked on for a 4k demo at Cookie Demoparty 2018 with a music by Triace from Desire.\nThe other part was made by Lsdlive and you can find his work here : https://www.shadertoy.com/view/wdBGWD\nLink to pouet and youtube in the code.\nhttps://www.shadertoy.com/view/tdBGWD","likes":0,"published":null,"tags":["raymarching"," 4k"," demoscene"," animation"]},"ver":null,"info":{"Name":"Mist by Ohno! - OctaHydra","id":"117ff14b80204d98b57ec61f62764d9b","date":null,"viewed":0,"name":"Mist by Ohno! - OctaHydra","description":"There are the scenes I worked on for a 4k demo at Cookie Demoparty 2018 with a music by Triace from Desire.\nThe other part was made by Lsdlive and you can find his work here : https://www.shadertoy.com/view/wdBGWD\nLink to pouet and youtube in the code.\nhttps://www.shadertoy.com/view/tdBGWD","likes":0,"published":null,"tags":["raymarching"," 4k"," demoscene"," animation"]},"renderpass":[{"Code":"// Code by Flopine\r\n\r\n// From Mist by Ohno!\r\n// 4k demo released at Cookie 2018 with a music by Triace from Desire\r\n// Pouet : http://www.pouet.net/prod.php?which=79350\r\n// Youtube : https://www.youtube.com/watch?v=UUtU3WVB144&t=3s\r\n\r\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\r\n// Thanks LJ for giving me the love of shadercoding :3\r\n\r\n// Cookie Collective rulz\r\n\r\n\r\nfloat time = 0.;\r\n#define PI 3.141592\r\n#define tempo_sin (time * 2.62)\r\n#define tempo (mix(4.5/6., 9./6., step(87., time)))\r\n\r\n\r\nvec2 hash(vec2 x)\r\n{\r\n\tvec2 k = vec2(0.3183099, 0.3678794);\r\n\tx = x * k + k.yx;\r\n\treturn -1.0 + 2.0 * fract(16.0 * k * fract(x.x * x.y * (x.x + x.y)));\r\n}\r\n\r\n\r\nfloat random(vec2 uv)\r\n{return fract(sin(dot(uv, vec2(12.2544, 35.1571)))*5418.548416);}\r\n\r\n\r\nfloat noise(in vec2 p)\r\n{\r\n\tvec2 i = floor(p);\r\n\tvec2 f = fract(p);\r\n\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n\treturn mix(mix(dot(hash(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\r\n\t\tdot(hash(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\r\n\t\tmix(dot(hash(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\r\n\t\t\tdot(hash(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x),\r\n\t\tu.y);\r\n}\r\n\r\n\r\nfloat fbm(vec2 uv)\r\n{\r\n\tfloat f;\r\n\tmat2 m = mat2(1.6, 1.2, -1.2, 1.6);\r\n\tf = 0.5000 * noise(uv);\r\n\tuv = m * uv;\r\n\tf += 0.2500 * noise(uv);\r\n\tuv = m * uv;\r\n\tf += 0.1250 * noise(uv);\r\n\treturn f;\r\n}\r\n\r\n\r\nmat2 r2d(float a) \r\n{\r\n\tfloat c = cos(a), s = sin(a);\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\n\r\nfloat smin(float a, float b, float k)\r\n{\r\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k * h*(1.0 - h);\r\n}\r\n\r\n\r\nvec3 re(vec3 p, float d) \r\n{return mod(p - d * .5, d) - d * .5;}\r\n\r\n\r\nvoid amod(inout vec2 p, float d) \r\n{\r\n\tfloat a = re(vec3(atan(p.y, p.x)), d).x;\r\n\tp = vec2(cos(a), sin(a)) * length(p);\r\n}\r\n\r\n\r\nvec3 get_cam(vec3 ro, vec3 ta, vec2 uv)\r\n{\r\n\tvec3 fwd = normalize(ta - ro);\r\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\r\n\treturn normalize(fwd + right * uv.x + cross(right, fwd) * uv.y);\r\n}\r\n\r\n\r\nfloat sphe(vec3 p, float r)\r\n{return length(p) - r;}\r\n\r\n\r\nfloat od(vec3 p, float d)\r\n{return dot(p, normalize(sign(p))) - d;}\r\n\r\n\r\nfloat sc(vec3 p, float d) {\r\n\tp = abs(p);\r\n\tp = max(p, p.yzx);\r\n\treturn min(p.x, min(p.y, p.z)) - d;\r\n}\r\n\r\n\r\nfloat torus(vec3 p, vec2 d)\r\n{\r\n\tvec2 q = vec2(length(p.xz) - d.x, p.y);\r\n\treturn length(q) - d.y;\r\n}\r\n\r\n\r\n\r\n////////// SCENE CONSTRUCTION //////////////////////////////////////////////////////////\r\nfloat pool(vec3 p)\r\n{return abs(p.y + fbm(p.xz*0.1 + time * 0.1 + fbm(p.xz*0.1 - time * 0.2)) + 0.5) - 0.05;}\r\n\r\n\r\nfloat g1 = 0.;\r\nfloat g2 = 0.;\r\nfloat tubes(vec3 p)\r\n{\r\n\tp.xz = re(p.xzz + 9., 18.).xy;\r\n\tp.xz *= r2d(time*0.4);\r\n\tp.xz *= r2d(p.y*0.3);\r\n\tamod(p.xz, 2.*PI / 5.);\r\n\tp.x -= 2.;\r\n\tp.x += sin(p.y*0.5 + time);\r\n\tfloat d = length(p.xz) - 0.2;\r\n\r\n\tg2 += (0.01 / (0.01 + d * d))*0.15;\r\n\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat ball(vec3 p)\r\n{\r\n\tp.y -= mix(-2., 5., smoothstep(4., 10., time) * (1. - smoothstep(112., 115., time)));\r\n\tfloat d = sphe(p, .8 + sin(tempo_sin)*0.1);\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat cage(vec3 p)\r\n{\r\n\tp.y -= 5.;\r\n\tp.xz *= r2d(time);\r\n\tp.yz *= r2d(time*0.5);\r\n\tfloat od_size = mix(-.1, 1., smoothstep(14., 19., time));\r\n\tfloat sphe_r1 = mix(1.14, 0.1, smoothstep(41., 42., time));\r\n\tfloat sphe_r = mix(sphe_r1, 3., pow(fract(time), 6.) * step(110., time) + (step(111., time)));\r\n\treturn max(-sphe(p, sphe_r), od(p, od_size));\r\n}\r\n\r\n\r\nfloat ring(vec3 p)\r\n{\r\n\tfloat anim = (PI / 2.)*(floor(time*tempo) + pow(fract(time*tempo), 3.));\r\n\r\n\tvec2 torus_size1 = mix(vec2(1.5, -0.5), vec2(2., 0.05), smoothstep(25., 28., time)*(1. - smoothstep(109., 110., time)));\r\n\tvec2 torus_size2 = mix(vec2(2.5, -0.5), vec2(3., 0.09), smoothstep(31., 34., time)*(1. - smoothstep(109., 110., time)));\r\n\r\n\r\n\tp.y -= 5.;\r\n\tp.xy *= r2d(PI / 4.);\r\n\tp.xz *= r2d(PI / 4.);\r\n\r\n\tvec3 pp = p;\r\n\tp.xz *= r2d(-anim);\r\n\tfloat r1 = max(-sc(p, 1.), torus(p, torus_size1));\r\n\r\n\tp = pp;\r\n\tp.xy *= r2d(anim);\r\n\tp.yz *= r2d(PI / 2.);\r\n\tfloat d = min(r1, max(-sc(p, 1.), torus(p, torus_size2)));\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat balls(vec3 p)\r\n{\r\n\tfloat d = sphe(vec3(p.x, p.y + 2., p.z), 0.5);\r\n\tp.y += mix(2., (sin(time) + 1.), smoothstep(35., 37., time));\r\n\tif (time > 88.) p.y = mix(2., 0., smoothstep(89., 92., time) * (1. - smoothstep(113., 115., time)));\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tamod(p.xz, 2.*PI / 5.);\r\n\t\tp.x -= mix(6., 0.1, clamp(pow(fract(time), 3.) * step(95., time) + step(96., time), 0., 1.));\r\n\t\td = min(d, sphe(p, 0.5));\r\n\t}\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat SDF(vec3 p)\r\n{\r\n\treturn time < 24. ? smin(tubes(p), smin(pool(p), min(ball(p), cage(p)), 2.), 1.5) :\r\n\t\tmin(min(ring(p), min(cage(p), ball(p))), smin(tubes(p), smin(pool(p), balls(p), 2.), 1.5));\r\n}\r\n\r\n\r\n\r\n////////// RAYMARCHING FUNCTION ////////////////\r\nvec3 raymarch_flopine(vec3 ro, vec3 rd, vec2 uv)\r\n{\r\n\tvec3 col;\r\n\tfloat dither = random(uv);\r\n\tfloat t = 0.;\r\n\tvec3 p;// = ro;\r\n\tfor (float i = 0.; i < 80.; i++)\r\n\t{\r\n\t\tp = ro + t * rd;\r\n\t\tfloat d = SDF(p);\r\n\t\tif (d < 0.001)\r\n\t\t{\r\n\t\t\tcol = vec3(i / 80.);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\td *= 1. + dither * 0.1;\r\n\r\n\t\tt += d * .8;\r\n\t}\r\n\r\n\tfloat g2_force = mix(0., 0.8, smoothstep(10., 14., time) * (1. - smoothstep(116., 120., time)));\r\n\tcol += g1 * vec3(0.2, 0.4, 0.);\r\n\tcol += (g2* g2_force) * vec3(0., 0.5, 0.5);\r\n\tcol = mix(col, vec3(0., 0.3, 0.4), 1. - exp(-0.001*t*t));\r\n\r\n\treturn col;\r\n}\r\n\r\n\r\n// Glitch function borrowed from mmerchante shader : https://www.shadertoy.com/view/MltcWs\r\nvoid glitch(inout vec2 uv, float start_time_stamp, float end_time_stamp)\r\n{\r\n\tint offset = int(floor(time)*2.) + int((uv.x + uv.y) * 8.0);\r\n\tfloat res = mix(10., 100.0, random(vec2(offset)));\r\n\r\n\t// glitch pixellate\r\n\tif (time > start_time_stamp && time <= end_time_stamp) uv = floor(uv * res) / res;\r\n\r\n\tint seedX = int(gl_FragCoord.x + time) / 32;\r\n\tint seedY = int(gl_FragCoord.y + time) / 32;\r\n\tint seed = mod(time, 2.) > 1. ? seedX : seedY;\r\n\r\n\r\n\t// glitch splitter\r\n\tuv.x += (random(vec2(seed)) * 2.0 - 1.0)\r\n\t\t* step(random(vec2(seed)), pow(sin(time * 4.), 7.0))\r\n\t\t* random(vec2(seed))\r\n\t\t* step(start_time_stamp, time)\r\n\t\t* (1. - step(end_time_stamp, time));\r\n}\r\n\r\n\r\n\r\n///////// MAIN FUNCTION //////////////////////////////\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = q - .5;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n    \r\n    \r\n\t/* just code for the shadertoy port */\r\n\ttime = mod(iTime, 45. + 10.6 + 17.);\r\n    if (time > 45. && time <= 88.)\r\n\t\ttime += 43.;\r\n    if (time > 98.6)\r\n\t\ttime += 10.4;\r\n   \r\n\tglitch(uv, 0., 2.);\r\n\tglitch(uv, 91., 92.);\r\n\tglitch(uv, 94.5, 95.5);\r\n\tglitch(uv, 98., 99.);\r\n\r\n\tvec3 flo_ro1 = vec3(-20. * cos(time*0.06), 10., -20.*sin(time*0.06));\r\n\tvec3 flo_ro2 = vec3(-5., 18., 0.);\r\n\tvec3 flo_ro3 = vec3(-5., 20., 12.);\r\n\tvec3 flo_ro = mix(mix(flo_ro1, flo_ro2, step(24., time)), flo_ro3, step(88., time));\r\n\tvec3 flo_target = vec3(0.);\r\n\tvec3 flo_cam = get_cam(flo_ro, flo_target, uv);\r\n\r\n\r\n\tvec3 col = vec3(0.);\r\n\tif (time <= 45.)\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\tif (time > 88. && time <= 98.6) // 98.\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\tif (time > 109. && time <= 126.)\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\r\n\r\n\t// vignetting from iq\r\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\r\n\r\n\t// fading out - end of the demo\r\n\tcol *= 1. - smoothstep(120., 125., time);\r\n\r\n\tfragColor = vec4(col, 1.);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Code by Flopine\r\n\r\n// From Mist by Ohno!\r\n// 4k demo released at Cookie 2018 with a music by Triace from Desire\r\n// Pouet : http://www.pouet.net/prod.php?which=79350\r\n// Youtube : https://www.youtube.com/watch?v=UUtU3WVB144&t=3s\r\n\r\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot and Alkama for teaching me\r\n// Thanks LJ for giving me the love of shadercoding :3\r\n\r\n// Cookie Collective rulz\r\n\r\n\r\nfloat time = 0.;\r\n#define PI 3.141592\r\n#define tempo_sin (time * 2.62)\r\n#define tempo (mix(4.5/6., 9./6., step(87., time)))\r\n\r\n\r\nvec2 hash(vec2 x)\r\n{\r\n\tvec2 k = vec2(0.3183099, 0.3678794);\r\n\tx = x * k + k.yx;\r\n\treturn -1.0 + 2.0 * fract(16.0 * k * fract(x.x * x.y * (x.x + x.y)));\r\n}\r\n\r\n\r\nfloat random(vec2 uv)\r\n{return fract(sin(dot(uv, vec2(12.2544, 35.1571)))*5418.548416);}\r\n\r\n\r\nfloat noise(in vec2 p)\r\n{\r\n\tvec2 i = floor(p);\r\n\tvec2 f = fract(p);\r\n\r\n\tvec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n\treturn mix(mix(dot(hash(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),\r\n\t\tdot(hash(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),\r\n\t\tmix(dot(hash(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\r\n\t\t\tdot(hash(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x),\r\n\t\tu.y);\r\n}\r\n\r\n\r\nfloat fbm(vec2 uv)\r\n{\r\n\tfloat f;\r\n\tmat2 m = mat2(1.6, 1.2, -1.2, 1.6);\r\n\tf = 0.5000 * noise(uv);\r\n\tuv = m * uv;\r\n\tf += 0.2500 * noise(uv);\r\n\tuv = m * uv;\r\n\tf += 0.1250 * noise(uv);\r\n\treturn f;\r\n}\r\n\r\n\r\nmat2 r2d(float a) \r\n{\r\n\tfloat c = cos(a), s = sin(a);\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\n\r\nfloat smin(float a, float b, float k)\r\n{\r\n\tfloat h = clamp(0.5 + 0.5*(b - a) / k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k * h*(1.0 - h);\r\n}\r\n\r\n\r\nvec3 re(vec3 p, float d) \r\n{return mod(p - d * .5, d) - d * .5;}\r\n\r\n\r\nvoid amod(inout vec2 p, float d) \r\n{\r\n\tfloat a = re(vec3(atan(p.y, p.x)), d).x;\r\n\tp = vec2(cos(a), sin(a)) * length(p);\r\n}\r\n\r\n\r\nvec3 get_cam(vec3 ro, vec3 ta, vec2 uv)\r\n{\r\n\tvec3 fwd = normalize(ta - ro);\r\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\r\n\treturn normalize(fwd + right * uv.x + cross(right, fwd) * uv.y);\r\n}\r\n\r\n\r\nfloat sphe(vec3 p, float r)\r\n{return length(p) - r;}\r\n\r\n\r\nfloat od(vec3 p, float d)\r\n{return dot(p, normalize(sign(p))) - d;}\r\n\r\n\r\nfloat sc(vec3 p, float d) {\r\n\tp = abs(p);\r\n\tp = max(p, p.yzx);\r\n\treturn min(p.x, min(p.y, p.z)) - d;\r\n}\r\n\r\n\r\nfloat torus(vec3 p, vec2 d)\r\n{\r\n\tvec2 q = vec2(length(p.xz) - d.x, p.y);\r\n\treturn length(q) - d.y;\r\n}\r\n\r\n\r\n\r\n////////// SCENE CONSTRUCTION //////////////////////////////////////////////////////////\r\nfloat pool(vec3 p)\r\n{return abs(p.y + fbm(p.xz*0.1 + time * 0.1 + fbm(p.xz*0.1 - time * 0.2)) + 0.5) - 0.05;}\r\n\r\n\r\nfloat g1 = 0.;\r\nfloat g2 = 0.;\r\nfloat tubes(vec3 p)\r\n{\r\n\tp.xz = re(p.xzz + 9., 18.).xy;\r\n\tp.xz *= r2d(time*0.4);\r\n\tp.xz *= r2d(p.y*0.3);\r\n\tamod(p.xz, 2.*PI / 5.);\r\n\tp.x -= 2.;\r\n\tp.x += sin(p.y*0.5 + time);\r\n\tfloat d = length(p.xz) - 0.2;\r\n\r\n\tg2 += (0.01 / (0.01 + d * d))*0.15;\r\n\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat ball(vec3 p)\r\n{\r\n\tp.y -= mix(-2., 5., smoothstep(4., 10., time) * (1. - smoothstep(112., 115., time)));\r\n\tfloat d = sphe(p, .8 + sin(tempo_sin)*0.1);\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat cage(vec3 p)\r\n{\r\n\tp.y -= 5.;\r\n\tp.xz *= r2d(time);\r\n\tp.yz *= r2d(time*0.5);\r\n\tfloat od_size = mix(-.1, 1., smoothstep(14., 19., time));\r\n\tfloat sphe_r1 = mix(1.14, 0.1, smoothstep(41., 42., time));\r\n\tfloat sphe_r = mix(sphe_r1, 3., pow(fract(time), 6.) * step(110., time) + (step(111., time)));\r\n\treturn max(-sphe(p, sphe_r), od(p, od_size));\r\n}\r\n\r\n\r\nfloat ring(vec3 p)\r\n{\r\n\tfloat anim = (PI / 2.)*(floor(time*tempo) + pow(fract(time*tempo), 3.));\r\n\r\n\tvec2 torus_size1 = mix(vec2(1.5, -0.5), vec2(2., 0.05), smoothstep(25., 28., time)*(1. - smoothstep(109., 110., time)));\r\n\tvec2 torus_size2 = mix(vec2(2.5, -0.5), vec2(3., 0.09), smoothstep(31., 34., time)*(1. - smoothstep(109., 110., time)));\r\n\r\n\r\n\tp.y -= 5.;\r\n\tp.xy *= r2d(PI / 4.);\r\n\tp.xz *= r2d(PI / 4.);\r\n\r\n\tvec3 pp = p;\r\n\tp.xz *= r2d(-anim);\r\n\tfloat r1 = max(-sc(p, 1.), torus(p, torus_size1));\r\n\r\n\tp = pp;\r\n\tp.xy *= r2d(anim);\r\n\tp.yz *= r2d(PI / 2.);\r\n\tfloat d = min(r1, max(-sc(p, 1.), torus(p, torus_size2)));\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat balls(vec3 p)\r\n{\r\n\tfloat d = sphe(vec3(p.x, p.y + 2., p.z), 0.5);\r\n\tp.y += mix(2., (sin(time) + 1.), smoothstep(35., 37., time));\r\n\tif (time > 88.) p.y = mix(2., 0., smoothstep(89., 92., time) * (1. - smoothstep(113., 115., time)));\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tamod(p.xz, 2.*PI / 5.);\r\n\t\tp.x -= mix(6., 0.1, clamp(pow(fract(time), 3.) * step(95., time) + step(96., time), 0., 1.));\r\n\t\td = min(d, sphe(p, 0.5));\r\n\t}\r\n\tg1 += 0.01 / (0.01 + d * d);\r\n\treturn d;\r\n}\r\n\r\n\r\nfloat SDF(vec3 p)\r\n{\r\n\treturn time < 24. ? smin(tubes(p), smin(pool(p), min(ball(p), cage(p)), 2.), 1.5) :\r\n\t\tmin(min(ring(p), min(cage(p), ball(p))), smin(tubes(p), smin(pool(p), balls(p), 2.), 1.5));\r\n}\r\n\r\n\r\n\r\n////////// RAYMARCHING FUNCTION ////////////////\r\nvec3 raymarch_flopine(vec3 ro, vec3 rd, vec2 uv)\r\n{\r\n\tvec3 col;\r\n\tfloat dither = random(uv);\r\n\tfloat t = 0.;\r\n\tvec3 p;// = ro;\r\n\tfor (float i = 0.; i < 80.; i++)\r\n\t{\r\n\t\tp = ro + t * rd;\r\n\t\tfloat d = SDF(p);\r\n\t\tif (d < 0.001)\r\n\t\t{\r\n\t\t\tcol = vec3(i / 80.);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\td *= 1. + dither * 0.1;\r\n\r\n\t\tt += d * .8;\r\n\t}\r\n\r\n\tfloat g2_force = mix(0., 0.8, smoothstep(10., 14., time) * (1. - smoothstep(116., 120., time)));\r\n\tcol += g1 * vec3(0.2, 0.4, 0.);\r\n\tcol += (g2* g2_force) * vec3(0., 0.5, 0.5);\r\n\tcol = mix(col, vec3(0., 0.3, 0.4), 1. - exp(-0.001*t*t));\r\n\r\n\treturn col;\r\n}\r\n\r\n\r\n// Glitch function borrowed from mmerchante shader : https://www.shadertoy.com/view/MltcWs\r\nvoid glitch(inout vec2 uv, float start_time_stamp, float end_time_stamp)\r\n{\r\n\tint offset = int(floor(time)*2.) + int((uv.x + uv.y) * 8.0);\r\n\tfloat res = mix(10., 100.0, random(vec2(offset)));\r\n\r\n\t// glitch pixellate\r\n\tif (time > start_time_stamp && time <= end_time_stamp) uv = floor(uv * res) / res;\r\n\r\n\tint seedX = int(gl_FragCoord.x + time) / 32;\r\n\tint seedY = int(gl_FragCoord.y + time) / 32;\r\n\tint seed = mod(time, 2.) > 1. ? seedX : seedY;\r\n\r\n\r\n\t// glitch splitter\r\n\tuv.x += (random(vec2(seed)) * 2.0 - 1.0)\r\n\t\t* step(random(vec2(seed)), pow(sin(time * 4.), 7.0))\r\n\t\t* random(vec2(seed))\r\n\t\t* step(start_time_stamp, time)\r\n\t\t* (1. - step(end_time_stamp, time));\r\n}\r\n\r\n\r\n\r\n///////// MAIN FUNCTION //////////////////////////////\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = q - .5;\r\n\tuv.x *= iResolution.x / iResolution.y;\r\n    \r\n    \r\n\t/* just code for the shadertoy port */\r\n\ttime = mod(iTime, 45. + 10.6 + 17.);\r\n    if (time > 45. && time <= 88.)\r\n\t\ttime += 43.;\r\n    if (time > 98.6)\r\n\t\ttime += 10.4;\r\n   \r\n\tglitch(uv, 0., 2.);\r\n\tglitch(uv, 91., 92.);\r\n\tglitch(uv, 94.5, 95.5);\r\n\tglitch(uv, 98., 99.);\r\n\r\n\tvec3 flo_ro1 = vec3(-20. * cos(time*0.06), 10., -20.*sin(time*0.06));\r\n\tvec3 flo_ro2 = vec3(-5., 18., 0.);\r\n\tvec3 flo_ro3 = vec3(-5., 20., 12.);\r\n\tvec3 flo_ro = mix(mix(flo_ro1, flo_ro2, step(24., time)), flo_ro3, step(88., time));\r\n\tvec3 flo_target = vec3(0.);\r\n\tvec3 flo_cam = get_cam(flo_ro, flo_target, uv);\r\n\r\n\r\n\tvec3 col = vec3(0.);\r\n\tif (time <= 45.)\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\tif (time > 88. && time <= 98.6) // 98.\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\tif (time > 109. && time <= 126.)\r\n\t\tcol = raymarch_flopine(flo_ro, flo_cam, uv);\r\n\r\n\r\n\t// vignetting from iq\r\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\r\n\r\n\t// fading out - end of the demo\r\n\tcol *= 1. - smoothstep(120., 125., time);\r\n\r\n\tfragColor = vec4(col, 1.);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n\r\n@lsdlive\r\nCC-BY-NC-SA\r\n\r\nThis is my part for \"Mist\" by Ohno, a 4 kilobytes demo released at the Cookie 2018.\r\n\r\npouet: http://www.pouet.net/prod.php?which=79350\r\nyoutube: https://www.youtube.com/watch?v=UUtU3WVB144\r\n\r\nCode/Graphics: Flopine\r\nCode/Graphics: Lsdlive\r\nMusic: Triace from Desire\r\n\r\nPart1 from Flopine here: https://www.shadertoy.com/view/tdBGWD\r\n\r\nInformation about my process for making this demo here:\r\nhttps://twitter.com/lsdlive/status/1090627411379716096\r\n\r\n*/\r\n\r\nfloat time = 0.;\r\n\r\nfloat random(vec2 uv) {\r\n\treturn fract(sin(dot(uv, vec2(12.2544, 35.1571))) * 5418.548416);\r\n}\r\n\r\nmat2 r2d(float a) {\r\n\tfloat c = cos(a), s = sin(a);\r\n\t// Explained here why you still get an anti-clockwise rotation with this matrix:\r\n\t// https://www.shadertoy.com/view/wdB3DW\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\nvec3 re(vec3 p, float d) {\r\n\treturn mod(p - d * .5, d) - d * .5;\r\n}\r\n\r\nvoid amod2(inout vec2 p, float d) {\r\n\t// should be atan(p.y, p.x) but I had this function for a while\r\n\t// and putting parameters like this add a PI/6 rotation.\r\n\tfloat a = re(vec3(atan(p.x, p.y)), d).x; \r\n\tp = vec2(cos(a), sin(a)) * length(p);\r\n}\r\n\r\nvoid mo(inout vec2 p, vec2 d) {\r\n\tp = abs(p) - d;\r\n\tif (p.y > p.x)p = p.yx;\r\n}\r\n\r\nvec3 get_cam(vec3 ro, vec3 ta, vec2 uv) {\r\n\tvec3 fwd = normalize(ta - ro);\r\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\r\n\r\n\t//vec3 right = normalize(vec3(-fwd.z, 0, fwd.x));\r\n\treturn normalize(fwd + right * uv.x + cross(right, fwd) * uv.y);\r\n}\r\n\r\n// signed cube\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat cube(vec3 p, vec3 b) {\r\n\tb = abs(p) - b;\r\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\r\n}\r\n\r\n// iq's signed cross sc() - http://iquilezles.org/www/articles/menger/menger.htm\r\nfloat sc(vec3 p, float d) {\r\n\tp = abs(p);\r\n\tp = max(p, p.yzx);\r\n\treturn min(p.x, min(p.y, p.z)) - d;\r\n}\r\n\r\n\r\n////////////////////////// SHADER LSDLIVE //////////////////////////\r\n\r\nfloat prim(vec3 p) {\r\n\r\n\tp.xy *= r2d(3.14 * .5 + p.z * .1); // .1\r\n\r\n\tamod2(p.xy, 6.28 / 3.); // 3.\r\n\tp.x = abs(p.x) - 9.; // 9.\r\n\r\n\tp.xy *= r2d(p.z * .2); // .2\r\n\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(\r\n\t\t\tmix(10., 5., smoothstep(59.5, 61.5, time)), // T4\r\n\t\t\t3.,\r\n\t\t\tsmoothstep(77.5, 77.75, time)) // T8\r\n\t); // 3.\r\n\tmo(p.xy, vec2(2.)); // 2.\r\n\r\n\tp.x = abs(p.x) - .6; // .6\r\n\treturn length(p.xy) - .2;//- smoothstep(80., 87., time)*(.5+.5*sin(time)); // .2\r\n}\r\n\r\nfloat g = 0.; // glow\r\nfloat de(vec3 p) {\r\n\r\n\tif (time > 109.2) {\r\n\t\tmo(p.xy, vec2(.2));\r\n\t\tp.x -= 10.;\r\n\t}\r\n\r\n\tif (time > 101.4) {\r\n\t\tp.xy *= r2d(time*.2);\r\n\t}\r\n\r\n\tif (time > 106.5) {\r\n\t\tmo(p.xy, vec2(5. + sin(time)*3.*cos(time*.5), 0.));\r\n\t}\r\n\r\n\tif (time > 104.) {\r\n\t\tamod2(p.xy, 6.28 / 3.);\r\n\t\tp.x += 5.;\r\n\t}\r\n\r\n\tif (time > 101.4) {\r\n\t\tmo(p.xy, vec2(2. + sin(time)*3.*cos(time*.5), 0.));\r\n\t}\r\n\r\n\tp.xy *= r2d(time * .05); // .05\r\n\r\n\tp.xy *= r2d(p.z *\r\n\t\tmix(.05, .002, step(89.5, time)) // P2 - T11\r\n\t); // .05 & .002\r\n\r\n\tp.x += sin(time) * smoothstep(77., 82., time);\r\n\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(\r\n\t\t\tmix(1., 2., smoothstep(63.5, 68.5, time)), // T6\r\n\t\t\t5.,\r\n\t\t\tsmoothstep(72., 73.5, time)) // T7\r\n\t); // 5.\r\n\tp.x -= 21.; // 21.\r\n\r\n\tvec3 q = p;\r\n\r\n\tp.xy *= r2d(p.z * .1); // .1\r\n\r\n\tamod2(p.xy, 6.28 / 3.); // 3.\r\n\tp.x = abs(p.x) -\r\n\t\tmix(20., 5., smoothstep(49.5, 55., time)) // T2\r\n\t\t; // 5.\r\n\r\n\tp.xy *= r2d(p.z *\r\n\t\tmix(1., .2, smoothstep(77.5, 77.75, time)) // T8b\r\n\t); // .2\r\n\r\n\tp.z = re(p.zzz, 3.).x; // 3.\r\n\r\n\tp.x = abs(p.x);\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(6., 3., smoothstep(77.75, 78.5, time)) // T10\r\n\t); // 3.\r\n\tfloat sc1 = sc(p,\r\n\t\tmix(8., 1., smoothstep(45.5, 51., time)) // T1\r\n\t); // 1.\r\n\r\n\tamod2(p.xz, 6.28 /\r\n\t\tmix(3., 8., smoothstep(61.5, 65.5, time)) // T5\r\n\t); // 8.\r\n\tmo(p.xz, vec2(.1)); // .1\r\n\r\n\tp.x = abs(p.x) - 1.;// 1.\r\n\r\n\tfloat d = cube(p, vec3(.2, 10, 1)); // fractal primitive: cube substracted by a signed cross\r\n\td = max(d, -sc1) -\r\n\t\tmix(.01, 2., smoothstep(56., 58.5, time)) // T3\r\n\t\t; // 2.\r\n\r\n\r\n\tg += .006 / (.01 + d * d); // first layer of glow\r\n\r\n\td = min(d, prim(q)); // add twisted cylinders\r\n\r\n\tg += .004 / (.013 + d * d); // second layer of glow (after the union of two geometries)\r\n\r\n\treturn d;\r\n}\r\n\r\n\r\n////////////////////////// RAYMARCHING FUNCTIONS //////////////////////////\r\n\r\n\r\nvec3 raymarch_lsdlive(vec3 ro, vec3 rd, vec2 uv) {\r\n\tvec3 p;\r\n\tfloat t = 0., ri;\r\n\r\n\tfloat dither = random(uv);\r\n\r\n\tfor (float i = 0.; i < 1.; i += .02) {// 50 iterations to keep it \"fast\"\r\n\t\tri = i;\r\n\t\tp = ro + rd * t;\r\n\t\tfloat d = de(p);\r\n\t\td *= 1. + dither * .05; // avoid banding & add a nice \"artistic\" little noise to the rendering (leon gave us this trick)\r\n\t\td = max(abs(d), .002); // phantom mode trick from aiekick https://www.shadertoy.com/view/MtScWW\r\n\t\tt += d * .5;\r\n\t}\r\n\r\n\t// Shading: uv, iteration & glow:\r\n\tvec3 c = mix(vec3(.9, .8, .6), vec3(.1, .1, .2), length(uv) + ri);\r\n\tc.r += sin(p.z * .1) * .2;\r\n\tc += g * .035; // glow trick from balkhan https://www.shadertoy.com/view/4t2yW1\r\n\r\n\treturn c;\r\n}\r\n\r\n// borrowed from (mmerchante) : https://www.shadertoy.com/view/MltcWs\r\nvoid glitch(inout vec2 uv, float start_time_stamp, float end_time_stamp)\r\n{\r\n\tint offset = int(floor(time)*2.) + int((uv.x + uv.y) * 8.0);\r\n\tfloat res = mix(10., 100.0, random(vec2(offset)));\r\n\r\n\t// glitch pixellate\r\n\tif (time > start_time_stamp && time <= end_time_stamp) uv = floor(uv * res) / res;\r\n\r\n\tint seedX = int(gl_FragCoord.x + time) / 32;\r\n\tint seedY = int(gl_FragCoord.y + time) / 32;\r\n\tint seed = mod(time, 2.) > 1. ? seedX : seedY;\r\n\r\n\r\n\t// glitch splitter\r\n\tuv.x += (random(vec2(seed)) * 2.0 - 1.0)\r\n\t\t* step(random(vec2(seed)), pow(sin(time * 4.), 7.0))\r\n\t\t* random(vec2(seed))\r\n\t\t* step(start_time_stamp, time)\r\n\t\t* (1. - step(end_time_stamp, time));\r\n}\r\n\r\n////////////////////////// MAIN FUNCTION //////////////////////////\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\r\n\r\n\t/* just code for the shadertoy port */\r\n\ttime = mod(iTime, 43. + 10.4);\r\n\ttime = time + 45.;\r\n\tif (time > 88. && time <= 98.6) // 98.\r\n\t\ttime += 10.6;\r\n\r\n\r\n\t// added glitch\r\n\tglitch(uv, 0., 2.);\r\n\r\n\tglitch(uv, 98., 99.);\r\n\t// lsdlive 2nd part\r\n\tglitch(uv, 100.5, 101.5);\r\n\tglitch(uv, 103., 104.);\r\n\tglitch(uv, 105.5, 106.5);\r\n\r\n\tvec3 lsd_ro = vec3(0, 0, -4. + time * 8.);\r\n\tvec3 lsd_target = vec3(0., 0., time * 8.);\r\n\tvec3 lsd_cam = get_cam(lsd_ro, lsd_target, uv);\r\n\r\n\tvec3 col = vec3(0.);\r\n\r\n\tif (time > 45. && time <= 88.) // 43 seconds\r\n\t\tcol = raymarch_lsdlive(lsd_ro, lsd_cam, uv);\r\n\r\n\tif (time > 98.6 && time <= 109.) // 10.4 seconds\r\n\t\tcol = raymarch_lsdlive(lsd_ro, lsd_cam, uv);\r\n\r\n\r\n\t// vignetting (iq)\r\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\r\n\r\n\t// fading out - end of the demo\r\n\t//col *= 1. - smoothstep(120., 125., time);\r\n\r\n\tfragColor = vec4(col, 1.);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n\r\n@lsdlive\r\nCC-BY-NC-SA\r\n\r\nThis is my part for \"Mist\" by Ohno, a 4 kilobytes demo released at the Cookie 2018.\r\n\r\npouet: http://www.pouet.net/prod.php?which=79350\r\nyoutube: https://www.youtube.com/watch?v=UUtU3WVB144\r\n\r\nCode/Graphics: Flopine\r\nCode/Graphics: Lsdlive\r\nMusic: Triace from Desire\r\n\r\nPart1 from Flopine here: https://www.shadertoy.com/view/tdBGWD\r\n\r\nInformation about my process for making this demo here:\r\nhttps://twitter.com/lsdlive/status/1090627411379716096\r\n\r\n*/\r\n\r\nfloat time = 0.;\r\n\r\nfloat random(vec2 uv) {\r\n\treturn fract(sin(dot(uv, vec2(12.2544, 35.1571))) * 5418.548416);\r\n}\r\n\r\nmat2 r2d(float a) {\r\n\tfloat c = cos(a), s = sin(a);\r\n\t// Explained here why you still get an anti-clockwise rotation with this matrix:\r\n\t// https://www.shadertoy.com/view/wdB3DW\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\nvec3 re(vec3 p, float d) {\r\n\treturn mod(p - d * .5, d) - d * .5;\r\n}\r\n\r\nvoid amod2(inout vec2 p, float d) {\r\n\t// should be atan(p.y, p.x) but I had this function for a while\r\n\t// and putting parameters like this add a PI/6 rotation.\r\n\tfloat a = re(vec3(atan(p.x, p.y)), d).x; \r\n\tp = vec2(cos(a), sin(a)) * length(p);\r\n}\r\n\r\nvoid mo(inout vec2 p, vec2 d) {\r\n\tp = abs(p) - d;\r\n\tif (p.y > p.x)p = p.yx;\r\n}\r\n\r\nvec3 get_cam(vec3 ro, vec3 ta, vec2 uv) {\r\n\tvec3 fwd = normalize(ta - ro);\r\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\r\n\r\n\t//vec3 right = normalize(vec3(-fwd.z, 0, fwd.x));\r\n\treturn normalize(fwd + right * uv.x + cross(right, fwd) * uv.y);\r\n}\r\n\r\n// signed cube\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat cube(vec3 p, vec3 b) {\r\n\tb = abs(p) - b;\r\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\r\n}\r\n\r\n// iq's signed cross sc() - http://iquilezles.org/www/articles/menger/menger.htm\r\nfloat sc(vec3 p, float d) {\r\n\tp = abs(p);\r\n\tp = max(p, p.yzx);\r\n\treturn min(p.x, min(p.y, p.z)) - d;\r\n}\r\n\r\n\r\n////////////////////////// SHADER LSDLIVE //////////////////////////\r\n\r\nfloat prim(vec3 p) {\r\n\r\n\tp.xy *= r2d(3.14 * .5 + p.z * .1); // .1\r\n\r\n\tamod2(p.xy, 6.28 / 3.); // 3.\r\n\tp.x = abs(p.x) - 9.; // 9.\r\n\r\n\tp.xy *= r2d(p.z * .2); // .2\r\n\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(\r\n\t\t\tmix(10., 5., smoothstep(59.5, 61.5, time)), // T4\r\n\t\t\t3.,\r\n\t\t\tsmoothstep(77.5, 77.75, time)) // T8\r\n\t); // 3.\r\n\tmo(p.xy, vec2(2.)); // 2.\r\n\r\n\tp.x = abs(p.x) - .6; // .6\r\n\treturn length(p.xy) - .2;//- smoothstep(80., 87., time)*(.5+.5*sin(time)); // .2\r\n}\r\n\r\nfloat g = 0.; // glow\r\nfloat de(vec3 p) {\r\n\r\n\tif (time > 109.2) {\r\n\t\tmo(p.xy, vec2(.2));\r\n\t\tp.x -= 10.;\r\n\t}\r\n\r\n\tif (time > 101.4) {\r\n\t\tp.xy *= r2d(time*.2);\r\n\t}\r\n\r\n\tif (time > 106.5) {\r\n\t\tmo(p.xy, vec2(5. + sin(time)*3.*cos(time*.5), 0.));\r\n\t}\r\n\r\n\tif (time > 104.) {\r\n\t\tamod2(p.xy, 6.28 / 3.);\r\n\t\tp.x += 5.;\r\n\t}\r\n\r\n\tif (time > 101.4) {\r\n\t\tmo(p.xy, vec2(2. + sin(time)*3.*cos(time*.5), 0.));\r\n\t}\r\n\r\n\tp.xy *= r2d(time * .05); // .05\r\n\r\n\tp.xy *= r2d(p.z *\r\n\t\tmix(.05, .002, step(89.5, time)) // P2 - T11\r\n\t); // .05 & .002\r\n\r\n\tp.x += sin(time) * smoothstep(77., 82., time);\r\n\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(\r\n\t\t\tmix(1., 2., smoothstep(63.5, 68.5, time)), // T6\r\n\t\t\t5.,\r\n\t\t\tsmoothstep(72., 73.5, time)) // T7\r\n\t); // 5.\r\n\tp.x -= 21.; // 21.\r\n\r\n\tvec3 q = p;\r\n\r\n\tp.xy *= r2d(p.z * .1); // .1\r\n\r\n\tamod2(p.xy, 6.28 / 3.); // 3.\r\n\tp.x = abs(p.x) -\r\n\t\tmix(20., 5., smoothstep(49.5, 55., time)) // T2\r\n\t\t; // 5.\r\n\r\n\tp.xy *= r2d(p.z *\r\n\t\tmix(1., .2, smoothstep(77.5, 77.75, time)) // T8b\r\n\t); // .2\r\n\r\n\tp.z = re(p.zzz, 3.).x; // 3.\r\n\r\n\tp.x = abs(p.x);\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(6., 3., smoothstep(77.75, 78.5, time)) // T10\r\n\t); // 3.\r\n\tfloat sc1 = sc(p,\r\n\t\tmix(8., 1., smoothstep(45.5, 51., time)) // T1\r\n\t); // 1.\r\n\r\n\tamod2(p.xz, 6.28 /\r\n\t\tmix(3., 8., smoothstep(61.5, 65.5, time)) // T5\r\n\t); // 8.\r\n\tmo(p.xz, vec2(.1)); // .1\r\n\r\n\tp.x = abs(p.x) - 1.;// 1.\r\n\r\n\tfloat d = cube(p, vec3(.2, 10, 1)); // fractal primitive: cube substracted by a signed cross\r\n\td = max(d, -sc1) -\r\n\t\tmix(.01, 2., smoothstep(56., 58.5, time)) // T3\r\n\t\t; // 2.\r\n\r\n\r\n\tg += .006 / (.01 + d * d); // first layer of glow\r\n\r\n\td = min(d, prim(q)); // add twisted cylinders\r\n\r\n\tg += .004 / (.013 + d * d); // second layer of glow (after the union of two geometries)\r\n\r\n\treturn d;\r\n}\r\n\r\n\r\n////////////////////////// RAYMARCHING FUNCTIONS //////////////////////////\r\n\r\n\r\nvec3 raymarch_lsdlive(vec3 ro, vec3 rd, vec2 uv) {\r\n\tvec3 p;\r\n\tfloat t = 0., ri;\r\n\r\n\tfloat dither = random(uv);\r\n\r\n\tfor (float i = 0.; i < 1.; i += .02) {// 50 iterations to keep it \"fast\"\r\n\t\tri = i;\r\n\t\tp = ro + rd * t;\r\n\t\tfloat d = de(p);\r\n\t\td *= 1. + dither * .05; // avoid banding & add a nice \"artistic\" little noise to the rendering (leon gave us this trick)\r\n\t\td = max(abs(d), .002); // phantom mode trick from aiekick https://www.shadertoy.com/view/MtScWW\r\n\t\tt += d * .5;\r\n\t}\r\n\r\n\t// Shading: uv, iteration & glow:\r\n\tvec3 c = mix(vec3(.9, .8, .6), vec3(.1, .1, .2), length(uv) + ri);\r\n\tc.r += sin(p.z * .1) * .2;\r\n\tc += g * .035; // glow trick from balkhan https://www.shadertoy.com/view/4t2yW1\r\n\r\n\treturn c;\r\n}\r\n\r\n// borrowed from (mmerchante) : https://www.shadertoy.com/view/MltcWs\r\nvoid glitch(inout vec2 uv, float start_time_stamp, float end_time_stamp)\r\n{\r\n\tint offset = int(floor(time)*2.) + int((uv.x + uv.y) * 8.0);\r\n\tfloat res = mix(10., 100.0, random(vec2(offset)));\r\n\r\n\t// glitch pixellate\r\n\tif (time > start_time_stamp && time <= end_time_stamp) uv = floor(uv * res) / res;\r\n\r\n\tint seedX = int(gl_FragCoord.x + time) / 32;\r\n\tint seedY = int(gl_FragCoord.y + time) / 32;\r\n\tint seed = mod(time, 2.) > 1. ? seedX : seedY;\r\n\r\n\r\n\t// glitch splitter\r\n\tuv.x += (random(vec2(seed)) * 2.0 - 1.0)\r\n\t\t* step(random(vec2(seed)), pow(sin(time * 4.), 7.0))\r\n\t\t* random(vec2(seed))\r\n\t\t* step(start_time_stamp, time)\r\n\t\t* (1. - step(end_time_stamp, time));\r\n}\r\n\r\n////////////////////////// MAIN FUNCTION //////////////////////////\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\r\n\r\n\t/* just code for the shadertoy port */\r\n\ttime = mod(iTime, 43. + 10.4);\r\n\ttime = time + 45.;\r\n\tif (time > 88. && time <= 98.6) // 98.\r\n\t\ttime += 10.6;\r\n\r\n\r\n\t// added glitch\r\n\tglitch(uv, 0., 2.);\r\n\r\n\tglitch(uv, 98., 99.);\r\n\t// lsdlive 2nd part\r\n\tglitch(uv, 100.5, 101.5);\r\n\tglitch(uv, 103., 104.);\r\n\tglitch(uv, 105.5, 106.5);\r\n\r\n\tvec3 lsd_ro = vec3(0, 0, -4. + time * 8.);\r\n\tvec3 lsd_target = vec3(0., 0., time * 8.);\r\n\tvec3 lsd_cam = get_cam(lsd_ro, lsd_target, uv);\r\n\r\n\tvec3 col = vec3(0.);\r\n\r\n\tif (time > 45. && time <= 88.) // 43 seconds\r\n\t\tcol = raymarch_lsdlive(lsd_ro, lsd_cam, uv);\r\n\r\n\tif (time > 98.6 && time <= 109.) // 10.4 seconds\r\n\t\tcol = raymarch_lsdlive(lsd_ro, lsd_cam, uv);\r\n\r\n\r\n\t// vignetting (iq)\r\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\r\n\r\n\t// fading out - end of the demo\r\n\t//col *= 1. - smoothstep(120., 125., time);\r\n\r\n\tfragColor = vec4(col, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Mist by Ohno! - part2","id":"849ee204c5b54807ad51ee4604bfd9fc","date":null,"viewed":0,"name":"Mist by Ohno! - part2","description":"This is my part for \"Mist\" by Ohno, a 4 kilobytes demo released at the Cookie 2018.\n\npouet: http://www.pouet.net/prod.php?which=79350\nyoutube: https://www.youtube.com/watch?v=UUtU3WVB144\n\nCode/Graphics: Flopine\nCode/Graphics: Lsdlive\nMusic: Triace\nhttps://www.shadertoy.com/view/wdBGWD","likes":0,"published":null,"tags":["tunnel"," raymarch"," 4k"," demoscene"]},"ver":null,"info":{"Name":"Mist by Ohno! - part2","id":"849ee204c5b54807ad51ee4604bfd9fc","date":null,"viewed":0,"name":"Mist by Ohno! - part2","description":"This is my part for \"Mist\" by Ohno, a 4 kilobytes demo released at the Cookie 2018.\n\npouet: http://www.pouet.net/prod.php?which=79350\nyoutube: https://www.youtube.com/watch?v=UUtU3WVB144\n\nCode/Graphics: Flopine\nCode/Graphics: Lsdlive\nMusic: Triace\nhttps://www.shadertoy.com/view/wdBGWD","likes":0,"published":null,"tags":["tunnel"," raymarch"," 4k"," demoscene"]},"renderpass":[{"Code":"/*\r\n\r\n@lsdlive\r\nCC-BY-NC-SA\r\n\r\nThis is my part for \"Mist\" by Ohno, a 4 kilobytes demo released at the Cookie 2018.\r\n\r\npouet: http://www.pouet.net/prod.php?which=79350\r\nyoutube: https://www.youtube.com/watch?v=UUtU3WVB144\r\n\r\nCode/Graphics: Flopine\r\nCode/Graphics: Lsdlive\r\nMusic: Triace from Desire\r\n\r\nPart1 from Flopine here: https://www.shadertoy.com/view/tdBGWD\r\n\r\nInformation about my process for making this demo here:\r\nhttps://twitter.com/lsdlive/status/1090627411379716096\r\n\r\n*/\r\n\r\nfloat time = 0.;\r\n\r\nfloat random(vec2 uv) {\r\n\treturn fract(sin(dot(uv, vec2(12.2544, 35.1571))) * 5418.548416);\r\n}\r\n\r\nmat2 r2d(float a) {\r\n\tfloat c = cos(a), s = sin(a);\r\n\t// Explained here why you still get an anti-clockwise rotation with this matrix:\r\n\t// https://www.shadertoy.com/view/wdB3DW\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\nvec3 re(vec3 p, float d) {\r\n\treturn mod(p - d * .5, d) - d * .5;\r\n}\r\n\r\nvoid amod2(inout vec2 p, float d) {\r\n\t// should be atan(p.y, p.x) but I had this function for a while\r\n\t// and putting parameters like this add a PI/6 rotation.\r\n\tfloat a = re(vec3(atan(p.x, p.y)), d).x; \r\n\tp = vec2(cos(a), sin(a)) * length(p);\r\n}\r\n\r\nvoid mo(inout vec2 p, vec2 d) {\r\n\tp = abs(p) - d;\r\n\tif (p.y > p.x)p = p.yx;\r\n}\r\n\r\nvec3 get_cam(vec3 ro, vec3 ta, vec2 uv) {\r\n\tvec3 fwd = normalize(ta - ro);\r\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\r\n\r\n\t//vec3 right = normalize(vec3(-fwd.z, 0, fwd.x));\r\n\treturn normalize(fwd + right * uv.x + cross(right, fwd) * uv.y);\r\n}\r\n\r\n// signed cube\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat cube(vec3 p, vec3 b) {\r\n\tb = abs(p) - b;\r\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\r\n}\r\n\r\n// iq's signed cross sc() - http://iquilezles.org/www/articles/menger/menger.htm\r\nfloat sc(vec3 p, float d) {\r\n\tp = abs(p);\r\n\tp = max(p, p.yzx);\r\n\treturn min(p.x, min(p.y, p.z)) - d;\r\n}\r\n\r\n\r\n////////////////////////// SHADER LSDLIVE //////////////////////////\r\n\r\nfloat prim(vec3 p) {\r\n\r\n\tp.xy *= r2d(3.14 * .5 + p.z * .1); // .1\r\n\r\n\tamod2(p.xy, 6.28 / 3.); // 3.\r\n\tp.x = abs(p.x) - 9.; // 9.\r\n\r\n\tp.xy *= r2d(p.z * .2); // .2\r\n\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(\r\n\t\t\tmix(10., 5., smoothstep(59.5, 61.5, time)), // T4\r\n\t\t\t3.,\r\n\t\t\tsmoothstep(77.5, 77.75, time)) // T8\r\n\t); // 3.\r\n\tmo(p.xy, vec2(2.)); // 2.\r\n\r\n\tp.x = abs(p.x) - .6; // .6\r\n\treturn length(p.xy) - .2;//- smoothstep(80., 87., time)*(.5+.5*sin(time)); // .2\r\n}\r\n\r\nfloat g = 0.; // glow\r\nfloat de(vec3 p) {\r\n\r\n\tif (time > 109.2) {\r\n\t\tmo(p.xy, vec2(.2));\r\n\t\tp.x -= 10.;\r\n\t}\r\n\r\n\tif (time > 101.4) {\r\n\t\tp.xy *= r2d(time*.2);\r\n\t}\r\n\r\n\tif (time > 106.5) {\r\n\t\tmo(p.xy, vec2(5. + sin(time)*3.*cos(time*.5), 0.));\r\n\t}\r\n\r\n\tif (time > 104.) {\r\n\t\tamod2(p.xy, 6.28 / 3.);\r\n\t\tp.x += 5.;\r\n\t}\r\n\r\n\tif (time > 101.4) {\r\n\t\tmo(p.xy, vec2(2. + sin(time)*3.*cos(time*.5), 0.));\r\n\t}\r\n\r\n\tp.xy *= r2d(time * .05); // .05\r\n\r\n\tp.xy *= r2d(p.z *\r\n\t\tmix(.05, .002, step(89.5, time)) // P2 - T11\r\n\t); // .05 & .002\r\n\r\n\tp.x += sin(time) * smoothstep(77., 82., time);\r\n\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(\r\n\t\t\tmix(1., 2., smoothstep(63.5, 68.5, time)), // T6\r\n\t\t\t5.,\r\n\t\t\tsmoothstep(72., 73.5, time)) // T7\r\n\t); // 5.\r\n\tp.x -= 21.; // 21.\r\n\r\n\tvec3 q = p;\r\n\r\n\tp.xy *= r2d(p.z * .1); // .1\r\n\r\n\tamod2(p.xy, 6.28 / 3.); // 3.\r\n\tp.x = abs(p.x) -\r\n\t\tmix(20., 5., smoothstep(49.5, 55., time)) // T2\r\n\t\t; // 5.\r\n\r\n\tp.xy *= r2d(p.z *\r\n\t\tmix(1., .2, smoothstep(77.5, 77.75, time)) // T8b\r\n\t); // .2\r\n\r\n\tp.z = re(p.zzz, 3.).x; // 3.\r\n\r\n\tp.x = abs(p.x);\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(6., 3., smoothstep(77.75, 78.5, time)) // T10\r\n\t); // 3.\r\n\tfloat sc1 = sc(p,\r\n\t\tmix(8., 1., smoothstep(45.5, 51., time)) // T1\r\n\t); // 1.\r\n\r\n\tamod2(p.xz, 6.28 /\r\n\t\tmix(3., 8., smoothstep(61.5, 65.5, time)) // T5\r\n\t); // 8.\r\n\tmo(p.xz, vec2(.1)); // .1\r\n\r\n\tp.x = abs(p.x) - 1.;// 1.\r\n\r\n\tfloat d = cube(p, vec3(.2, 10, 1)); // fractal primitive: cube substracted by a signed cross\r\n\td = max(d, -sc1) -\r\n\t\tmix(.01, 2., smoothstep(56., 58.5, time)) // T3\r\n\t\t; // 2.\r\n\r\n\r\n\tg += .006 / (.01 + d * d); // first layer of glow\r\n\r\n\td = min(d, prim(q)); // add twisted cylinders\r\n\r\n\tg += .004 / (.013 + d * d); // second layer of glow (after the union of two geometries)\r\n\r\n\treturn d;\r\n}\r\n\r\n\r\n////////////////////////// RAYMARCHING FUNCTIONS //////////////////////////\r\n\r\n\r\nvec3 raymarch_lsdlive(vec3 ro, vec3 rd, vec2 uv) {\r\n\tvec3 p;\r\n\tfloat t = 0., ri;\r\n\r\n\tfloat dither = random(uv);\r\n\r\n\tfor (float i = 0.; i < 1.; i += .02) {// 50 iterations to keep it \"fast\"\r\n\t\tri = i;\r\n\t\tp = ro + rd * t;\r\n\t\tfloat d = de(p);\r\n\t\td *= 1. + dither * .05; // avoid banding & add a nice \"artistic\" little noise to the rendering (leon gave us this trick)\r\n\t\td = max(abs(d), .002); // phantom mode trick from aiekick https://www.shadertoy.com/view/MtScWW\r\n\t\tt += d * .5;\r\n\t}\r\n\r\n\t// Shading: uv, iteration & glow:\r\n\tvec3 c = mix(vec3(.9, .8, .6), vec3(.1, .1, .2), length(uv) + ri);\r\n\tc.r += sin(p.z * .1) * .2;\r\n\tc += g * .035; // glow trick from balkhan https://www.shadertoy.com/view/4t2yW1\r\n\r\n\treturn c;\r\n}\r\n\r\n// borrowed from (mmerchante) : https://www.shadertoy.com/view/MltcWs\r\nvoid glitch(inout vec2 uv, float start_time_stamp, float end_time_stamp)\r\n{\r\n\tint offset = int(floor(time)*2.) + int((uv.x + uv.y) * 8.0);\r\n\tfloat res = mix(10., 100.0, random(vec2(offset)));\r\n\r\n\t// glitch pixellate\r\n\tif (time > start_time_stamp && time <= end_time_stamp) uv = floor(uv * res) / res;\r\n\r\n\tint seedX = int(gl_FragCoord.x + time) / 32;\r\n\tint seedY = int(gl_FragCoord.y + time) / 32;\r\n\tint seed = mod(time, 2.) > 1. ? seedX : seedY;\r\n\r\n\r\n\t// glitch splitter\r\n\tuv.x += (random(vec2(seed)) * 2.0 - 1.0)\r\n\t\t* step(random(vec2(seed)), pow(sin(time * 4.), 7.0))\r\n\t\t* random(vec2(seed))\r\n\t\t* step(start_time_stamp, time)\r\n\t\t* (1. - step(end_time_stamp, time));\r\n}\r\n\r\n////////////////////////// MAIN FUNCTION //////////////////////////\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\r\n\r\n\t/* just code for the shadertoy port */\r\n\ttime = mod(iTime, 43. + 10.4);\r\n\ttime = time + 45.;\r\n\tif (time > 88. && time <= 98.6) // 98.\r\n\t\ttime += 10.6;\r\n\r\n\r\n\t// added glitch\r\n\tglitch(uv, 0., 2.);\r\n\r\n\tglitch(uv, 98., 99.);\r\n\t// lsdlive 2nd part\r\n\tglitch(uv, 100.5, 101.5);\r\n\tglitch(uv, 103., 104.);\r\n\tglitch(uv, 105.5, 106.5);\r\n\r\n\tvec3 lsd_ro = vec3(0, 0, -4. + time * 8.);\r\n\tvec3 lsd_target = vec3(0., 0., time * 8.);\r\n\tvec3 lsd_cam = get_cam(lsd_ro, lsd_target, uv);\r\n\r\n\tvec3 col = vec3(0.);\r\n\r\n\tif (time > 45. && time <= 88.) // 43 seconds\r\n\t\tcol = raymarch_lsdlive(lsd_ro, lsd_cam, uv);\r\n\r\n\tif (time > 98.6 && time <= 109.) // 10.4 seconds\r\n\t\tcol = raymarch_lsdlive(lsd_ro, lsd_cam, uv);\r\n\r\n\r\n\t// vignetting (iq)\r\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\r\n\r\n\t// fading out - end of the demo\r\n\t//col *= 1. - smoothstep(120., 125., time);\r\n\r\n\tfragColor = vec4(col, 1.);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n\r\n@lsdlive\r\nCC-BY-NC-SA\r\n\r\nThis is my part for \"Mist\" by Ohno, a 4 kilobytes demo released at the Cookie 2018.\r\n\r\npouet: http://www.pouet.net/prod.php?which=79350\r\nyoutube: https://www.youtube.com/watch?v=UUtU3WVB144\r\n\r\nCode/Graphics: Flopine\r\nCode/Graphics: Lsdlive\r\nMusic: Triace from Desire\r\n\r\nPart1 from Flopine here: https://www.shadertoy.com/view/tdBGWD\r\n\r\nInformation about my process for making this demo here:\r\nhttps://twitter.com/lsdlive/status/1090627411379716096\r\n\r\n*/\r\n\r\nfloat time = 0.;\r\n\r\nfloat random(vec2 uv) {\r\n\treturn fract(sin(dot(uv, vec2(12.2544, 35.1571))) * 5418.548416);\r\n}\r\n\r\nmat2 r2d(float a) {\r\n\tfloat c = cos(a), s = sin(a);\r\n\t// Explained here why you still get an anti-clockwise rotation with this matrix:\r\n\t// https://www.shadertoy.com/view/wdB3DW\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\nvec3 re(vec3 p, float d) {\r\n\treturn mod(p - d * .5, d) - d * .5;\r\n}\r\n\r\nvoid amod2(inout vec2 p, float d) {\r\n\t// should be atan(p.y, p.x) but I had this function for a while\r\n\t// and putting parameters like this add a PI/6 rotation.\r\n\tfloat a = re(vec3(atan(p.x, p.y)), d).x; \r\n\tp = vec2(cos(a), sin(a)) * length(p);\r\n}\r\n\r\nvoid mo(inout vec2 p, vec2 d) {\r\n\tp = abs(p) - d;\r\n\tif (p.y > p.x)p = p.yx;\r\n}\r\n\r\nvec3 get_cam(vec3 ro, vec3 ta, vec2 uv) {\r\n\tvec3 fwd = normalize(ta - ro);\r\n\tvec3 right = normalize(cross(fwd, vec3(0, 1, 0)));\r\n\r\n\t//vec3 right = normalize(vec3(-fwd.z, 0, fwd.x));\r\n\treturn normalize(fwd + right * uv.x + cross(right, fwd) * uv.y);\r\n}\r\n\r\n// signed cube\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat cube(vec3 p, vec3 b) {\r\n\tb = abs(p) - b;\r\n\treturn min(max(b.x, max(b.y, b.z)), 0.) + length(max(b, 0.));\r\n}\r\n\r\n// iq's signed cross sc() - http://iquilezles.org/www/articles/menger/menger.htm\r\nfloat sc(vec3 p, float d) {\r\n\tp = abs(p);\r\n\tp = max(p, p.yzx);\r\n\treturn min(p.x, min(p.y, p.z)) - d;\r\n}\r\n\r\n\r\n////////////////////////// SHADER LSDLIVE //////////////////////////\r\n\r\nfloat prim(vec3 p) {\r\n\r\n\tp.xy *= r2d(3.14 * .5 + p.z * .1); // .1\r\n\r\n\tamod2(p.xy, 6.28 / 3.); // 3.\r\n\tp.x = abs(p.x) - 9.; // 9.\r\n\r\n\tp.xy *= r2d(p.z * .2); // .2\r\n\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(\r\n\t\t\tmix(10., 5., smoothstep(59.5, 61.5, time)), // T4\r\n\t\t\t3.,\r\n\t\t\tsmoothstep(77.5, 77.75, time)) // T8\r\n\t); // 3.\r\n\tmo(p.xy, vec2(2.)); // 2.\r\n\r\n\tp.x = abs(p.x) - .6; // .6\r\n\treturn length(p.xy) - .2;//- smoothstep(80., 87., time)*(.5+.5*sin(time)); // .2\r\n}\r\n\r\nfloat g = 0.; // glow\r\nfloat de(vec3 p) {\r\n\r\n\tif (time > 109.2) {\r\n\t\tmo(p.xy, vec2(.2));\r\n\t\tp.x -= 10.;\r\n\t}\r\n\r\n\tif (time > 101.4) {\r\n\t\tp.xy *= r2d(time*.2);\r\n\t}\r\n\r\n\tif (time > 106.5) {\r\n\t\tmo(p.xy, vec2(5. + sin(time)*3.*cos(time*.5), 0.));\r\n\t}\r\n\r\n\tif (time > 104.) {\r\n\t\tamod2(p.xy, 6.28 / 3.);\r\n\t\tp.x += 5.;\r\n\t}\r\n\r\n\tif (time > 101.4) {\r\n\t\tmo(p.xy, vec2(2. + sin(time)*3.*cos(time*.5), 0.));\r\n\t}\r\n\r\n\tp.xy *= r2d(time * .05); // .05\r\n\r\n\tp.xy *= r2d(p.z *\r\n\t\tmix(.05, .002, step(89.5, time)) // P2 - T11\r\n\t); // .05 & .002\r\n\r\n\tp.x += sin(time) * smoothstep(77., 82., time);\r\n\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(\r\n\t\t\tmix(1., 2., smoothstep(63.5, 68.5, time)), // T6\r\n\t\t\t5.,\r\n\t\t\tsmoothstep(72., 73.5, time)) // T7\r\n\t); // 5.\r\n\tp.x -= 21.; // 21.\r\n\r\n\tvec3 q = p;\r\n\r\n\tp.xy *= r2d(p.z * .1); // .1\r\n\r\n\tamod2(p.xy, 6.28 / 3.); // 3.\r\n\tp.x = abs(p.x) -\r\n\t\tmix(20., 5., smoothstep(49.5, 55., time)) // T2\r\n\t\t; // 5.\r\n\r\n\tp.xy *= r2d(p.z *\r\n\t\tmix(1., .2, smoothstep(77.5, 77.75, time)) // T8b\r\n\t); // .2\r\n\r\n\tp.z = re(p.zzz, 3.).x; // 3.\r\n\r\n\tp.x = abs(p.x);\r\n\tamod2(p.xy, 6.28 /\r\n\t\tmix(6., 3., smoothstep(77.75, 78.5, time)) // T10\r\n\t); // 3.\r\n\tfloat sc1 = sc(p,\r\n\t\tmix(8., 1., smoothstep(45.5, 51., time)) // T1\r\n\t); // 1.\r\n\r\n\tamod2(p.xz, 6.28 /\r\n\t\tmix(3., 8., smoothstep(61.5, 65.5, time)) // T5\r\n\t); // 8.\r\n\tmo(p.xz, vec2(.1)); // .1\r\n\r\n\tp.x = abs(p.x) - 1.;// 1.\r\n\r\n\tfloat d = cube(p, vec3(.2, 10, 1)); // fractal primitive: cube substracted by a signed cross\r\n\td = max(d, -sc1) -\r\n\t\tmix(.01, 2., smoothstep(56., 58.5, time)) // T3\r\n\t\t; // 2.\r\n\r\n\r\n\tg += .006 / (.01 + d * d); // first layer of glow\r\n\r\n\td = min(d, prim(q)); // add twisted cylinders\r\n\r\n\tg += .004 / (.013 + d * d); // second layer of glow (after the union of two geometries)\r\n\r\n\treturn d;\r\n}\r\n\r\n\r\n////////////////////////// RAYMARCHING FUNCTIONS //////////////////////////\r\n\r\n\r\nvec3 raymarch_lsdlive(vec3 ro, vec3 rd, vec2 uv) {\r\n\tvec3 p;\r\n\tfloat t = 0., ri;\r\n\r\n\tfloat dither = random(uv);\r\n\r\n\tfor (float i = 0.; i < 1.; i += .02) {// 50 iterations to keep it \"fast\"\r\n\t\tri = i;\r\n\t\tp = ro + rd * t;\r\n\t\tfloat d = de(p);\r\n\t\td *= 1. + dither * .05; // avoid banding & add a nice \"artistic\" little noise to the rendering (leon gave us this trick)\r\n\t\td = max(abs(d), .002); // phantom mode trick from aiekick https://www.shadertoy.com/view/MtScWW\r\n\t\tt += d * .5;\r\n\t}\r\n\r\n\t// Shading: uv, iteration & glow:\r\n\tvec3 c = mix(vec3(.9, .8, .6), vec3(.1, .1, .2), length(uv) + ri);\r\n\tc.r += sin(p.z * .1) * .2;\r\n\tc += g * .035; // glow trick from balkhan https://www.shadertoy.com/view/4t2yW1\r\n\r\n\treturn c;\r\n}\r\n\r\n// borrowed from (mmerchante) : https://www.shadertoy.com/view/MltcWs\r\nvoid glitch(inout vec2 uv, float start_time_stamp, float end_time_stamp)\r\n{\r\n\tint offset = int(floor(time)*2.) + int((uv.x + uv.y) * 8.0);\r\n\tfloat res = mix(10., 100.0, random(vec2(offset)));\r\n\r\n\t// glitch pixellate\r\n\tif (time > start_time_stamp && time <= end_time_stamp) uv = floor(uv * res) / res;\r\n\r\n\tint seedX = int(gl_FragCoord.x + time) / 32;\r\n\tint seedY = int(gl_FragCoord.y + time) / 32;\r\n\tint seed = mod(time, 2.) > 1. ? seedX : seedY;\r\n\r\n\r\n\t// glitch splitter\r\n\tuv.x += (random(vec2(seed)) * 2.0 - 1.0)\r\n\t\t* step(random(vec2(seed)), pow(sin(time * 4.), 7.0))\r\n\t\t* random(vec2(seed))\r\n\t\t* step(start_time_stamp, time)\r\n\t\t* (1. - step(end_time_stamp, time));\r\n}\r\n\r\n////////////////////////// MAIN FUNCTION //////////////////////////\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\r\n\r\n\t/* just code for the shadertoy port */\r\n\ttime = mod(iTime, 43. + 10.4);\r\n\ttime = time + 45.;\r\n\tif (time > 88. && time <= 98.6) // 98.\r\n\t\ttime += 10.6;\r\n\r\n\r\n\t// added glitch\r\n\tglitch(uv, 0., 2.);\r\n\r\n\tglitch(uv, 98., 99.);\r\n\t// lsdlive 2nd part\r\n\tglitch(uv, 100.5, 101.5);\r\n\tglitch(uv, 103., 104.);\r\n\tglitch(uv, 105.5, 106.5);\r\n\r\n\tvec3 lsd_ro = vec3(0, 0, -4. + time * 8.);\r\n\tvec3 lsd_target = vec3(0., 0., time * 8.);\r\n\tvec3 lsd_cam = get_cam(lsd_ro, lsd_target, uv);\r\n\r\n\tvec3 col = vec3(0.);\r\n\r\n\tif (time > 45. && time <= 88.) // 43 seconds\r\n\t\tcol = raymarch_lsdlive(lsd_ro, lsd_cam, uv);\r\n\r\n\tif (time > 98.6 && time <= 109.) // 10.4 seconds\r\n\t\tcol = raymarch_lsdlive(lsd_ro, lsd_cam, uv);\r\n\r\n\r\n\t// vignetting (iq)\r\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\r\n\r\n\t// fading out - end of the demo\r\n\t//col *= 1. - smoothstep(120., 125., time);\r\n\r\n\tfragColor = vec4(col, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Moon craters","id":"3dd2b8aeda434ee7ac8f0e4cccb86100","date":null,"viewed":0,"name":"Moon craters","description":"Trying to mimic a moon surface with craters ","likes":0,"published":null,"tags":["3d"," moon"," craters"]},"ver":null,"info":{"Name":"Moon craters","id":"3dd2b8aeda434ee7ac8f0e4cccb86100","date":null,"viewed":0,"name":"Moon craters","description":"Trying to mimic a moon surface with craters ","likes":0,"published":null,"tags":["3d"," moon"," craters"]},"renderpass":[{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Mountains. By David Hoskins - 2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/4slGD4\r\n// A ray-marched version of my terrain renderer which uses\r\n// streaming texture normals for speed:-\r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// It uses binary subdivision to accurately find the height map.\r\n// Lots of thanks to Inigo and his noise functions!\r\n\r\n// Video of my OpenGL version that \r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// Stereo version code thanks to Croqueteer :)\r\n//#define STEREO \r\n\r\nfloat treeLine = 0.0;\r\nfloat treeCol = 0.0;\r\n\r\n\r\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\r\nvec3 sunColour = vec3(1.0, .9, .83);\r\nfloat specular = 0.0;\r\nvec3 cameraPos;\r\nfloat ambient;\r\nvec2 add = vec2(1.0, 0.0);\r\n#define HASHSCALE1 .1031\r\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\r\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\r\n\r\n// This peturbs the fractal positions for each iteration down...\r\n// Helps make nice twisted landscapes...\r\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\r\n\r\n// Alternative rotation:-\r\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\r\n\r\n\r\n//  1 out, 2 in...\r\nfloat Hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n\r\n}\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    \r\n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\r\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Noise2( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y * 57.0;\r\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\r\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Trees(vec2 p)\r\n{\r\n\t\r\n \t//return (texture(iChannel1,0.04*p).x * treeLine);\r\n    return Noise(p*13.0)*treeLine;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Low def version for ray-marching through the height field...\r\n// Thanks to IQ for all the noise stuff...\r\n\r\nfloat Terrain( in vec2 p)\r\n{\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\t\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Map to lower resolution for height field mapping for Scene function...\r\nfloat Map(in vec3 p)\r\n{\r\n\tfloat h = Terrain(p.xz);\r\n\t\t\r\n\r\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\r\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\r\n\ttreeCol = Trees(p.xz);\r\n\th += treeCol;\r\n\t\r\n    return p.y - h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// High def version only used for grabbing normal information.\r\nfloat Terrain2( in vec2 p)\r\n{\r\n\t// There's some real magic numbers in here! \r\n\t// The Noise calls add large mountain ranges for more variation over distances...\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\t\r\n\r\n\ttreeCol = Trees(p);\r\n\tf += treeCol;\r\n\tif (treeCol > 0.0) return f;\r\n\r\n\t\r\n\t// That's the last of the low resolution, now go down further for the Normal data...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\t\r\n\t\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw *= 0.5;\r\n\t\txy *= 2.7;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Simply Perlin clouds that fade to the horizon...\r\n// 200 units above the ground...\r\nvec3 GetClouds(in vec3 sky, in vec3 rd)\r\n{\r\n\tif (rd.y < 0.01) return sky;\r\n\tfloat v = (200.0-cameraPos.y)/rd.y;\r\n\trd.xz *= v;\r\n\trd.xz += cameraPos.xz;\r\n\trd.xz *= .010;\r\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\r\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\r\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\r\n\r\n\treturn sky;\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\r\n\tvec3  sky = vec3(v*sunColour.x*0.4+0.18, v*sunColour.y*0.4+0.22, v*sunColour.z*0.4+.4);\r\n\t// Wide glare effect...\r\n\tsky = sky + sunColour * pow(sunAmount, 6.5)*.32;\r\n\t// Actual sun...\r\n\tsky = sky+ sunColour * min(pow(sunAmount, 1150.0), .3)*.65;\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge mountains into the sky background for correct disappearance...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = exp(-dis* 0.00005);\r\n\treturn mix(GetSky(dir), rgb, fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tfloat c = max(h, 0.0)+ambient;\r\n\tmat = mat * sunColour * c ;\r\n\t// Specular...\r\n\tif (h > 0.0)\r\n\t{\r\n\t\tvec3 R = reflect(sunLight, normal);\r\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\r\n\t\tmat = mix(mat, sunColour, specAmount);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Hack the height, position, and normal data to create the coloured landscape\r\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\r\n{\r\n\tvec3 mat;\r\n\tspecular = .0;\r\n\tambient = .1;\r\n\tvec3 dir = normalize(pos-cameraPos);\r\n\t\r\n\tvec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\r\n\r\n\tfloat disSqrd = dis * dis;// Squaring it gives better distance scales.\r\n\r\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\r\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\r\n\tf *= .55;\r\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\r\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\r\n\t// Should have used smoothstep to add colours, but left it using 'if' for sanity...\r\n\tif (normal.y < .5)\r\n\t{\r\n\t\tfloat v = normal.y;\r\n\t\tfloat c = (.5-normal.y) * 4.0;\r\n\t\tc = clamp(c*c, 0.1, 1.0);\r\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\r\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\r\n\t\tmat = mix(mat, vec3(.4*f), c);\r\n\t\tspecular+=.1;\r\n\t}\r\n\r\n\t// Grass. Use the normal to decide when to plonk grass down...\r\n\tif (matPos.y < 45.35 && normal.y > .65)\r\n\t{\r\n\r\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\r\n\t\tm *= (normal.y- 0.65)*.6;\r\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\r\n\t}\r\n\r\n\tif (treeCol > 0.0)\r\n\t{\r\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\r\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\r\n\t\tspecular = .0;\r\n\t}\r\n\t\r\n\t// Snow topped mountains...\r\n\tif (matPos.y > 80.0 && normal.y > .42)\r\n\t{\r\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\r\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\r\n\t\tspecular += snow;\r\n\t\tambient+=snow *.3;\r\n\t}\r\n\t// Beach effect...\r\n\tif (matPos.y < 1.45)\r\n\t{\r\n\t\tif (normal.y > .4)\r\n\t\t{\r\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\r\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\r\n\t\t\tfloat t = (normal.y-.4);\r\n\t\t\tt = (t*t);\r\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\r\n\t\t}\r\n\t\t// Cheap under water darkening...it's wet after all...\r\n\t\tif (matPos.y < 0.0)\r\n\t\t{\r\n\t\t\tmat *= .2;\r\n\t\t}\r\n\t}\r\n\r\n\tDoLighting(mat, pos, normal,dir, disSqrd);\r\n\t\r\n\t// Do the water...\r\n\tif (matPos.y < 0.0)\r\n\t{\r\n\t\t// Pull back along the ray direction to get water surface point at y = 0.0 ...\r\n\t\tfloat time = (iTime)*.03;\r\n\t\tvec3 watPos = matPos;\r\n\t\twatPos += -dir * (watPos.y/dir.y);\r\n\t\t// Make some dodgy waves...\r\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\r\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\r\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\r\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\r\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\r\n\t\tnor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\r\n\t\t// Mix it in at depth transparancy to give beach cues..\r\n        tx = watPos.y-matPos.y;\r\n\t\tmat = mix(mat, GetClouds(GetSky(nor)*vec3(.3,.3,.5), nor)*.1+vec3(.0,.02,.03), clamp((tx)*.4, .6, 1.));\r\n\t\t// Add some extra water glint...\r\n        //mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*texture(iChannel1, watPos.xz*.1, -2.).x, 0.,1.0);\r\n        mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*Noise2(watPos.xz*.1).x, 0.,1.0);\r\n\t\tfloat sunAmount = max( dot(nor, sunLight), 0.0 );\r\n\t\tmat = mat + sunColour * pow(sunAmount, 228.5)*.6;\r\n        vec3 temp = (watPos-cameraPos*2.)*.5;\r\n        disSqrd = dot(temp, temp);\r\n\t}\r\n\tmat = ApplyFog(mat, disSqrd, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\r\n{\r\n\t// Home in on the surface by dividing by two and split...\r\n    float halfwayT;\r\n  \r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n\r\n        halfwayT = dot(t, vec2(.5));\r\n        float d = Map(rO + halfwayT*rD); \r\n         t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.5, d));\r\n\r\n    }\r\n\treturn halfwayT;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, in vec2 fragCoord )\r\n{\r\n    float t = 1. + Hash12(fragCoord.xy)*5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.0;\r\n\tbool fin = false;\r\n\tbool res = false;\r\n\tvec2 distances;\r\n\tfor( int j=0; j< 150; j++ )\r\n\t{\r\n\t\tif (fin || t > 240.0) break;\r\n\t\tvec3 p = rO + t*rD;\r\n\t\t//if (t > 240.0 || p.y > 195.0) break;\r\n\t\tfloat h = Map(p); // ...Get this positions height mapping.\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h < 0.5)\r\n\t\t{\r\n\t\t\tfin = true;\r\n\t\t\tdistances = vec2(oldT, t);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// Delta ray advance - a fudge between the height returned\r\n\t\t// and the distance already travelled.\r\n\t\t// It's a really fiddly compromise between speed and accuracy\r\n\t\t// Too large a step and the tops of ridges get missed.\r\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\r\n\r\n\treturn fin;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\tfloat m = 1.0+(iMouse.x/iResolution.x)*300.0;\r\n\tt = (iTime*1.5+m+657.0)*.006 + t;\r\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\r\n\treturn vec3(35.0-p.x, 0.6, 4108.0+p.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Some would say, most of the magic is done in post! :D\r\nvec3 PostEffects(vec3 rgb, vec2 uv)\r\n{\r\n\t//#define CONTRAST 1.1\r\n\t//#define SATURATION 1.12\r\n\t//#define BRIGHTNESS 1.3\r\n\t//rgb = pow(abs(rgb), vec3(0.45));\r\n\t//rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\r\n\t//rgb = clamp(rgb+hash12(fragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = xy * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\t// Use several forward heights, of decreasing influence with distance from the camera.\r\n\tfloat h = 0.0;\r\n\tfloat f = 1.0;\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\r\n\t\tf -= .1;\r\n\t}\r\n\tcameraPos.xz = CameraPath(0.0).xz;\r\n\tcamTar.xyz\t = CameraPath(.005).xyz;\r\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.5+sin(iTime*5.)*.5);\r\n\t\r\n\tfloat roll = 0.15*sin(iTime*.2);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .45*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tif( !Scene(cameraPos,rd, distance, fragCoord) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky value...\r\n\t\tcol = GetSky(rd);\r\n\t\tcol = GetClouds(col, rd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * rd;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, nor, distance);\r\n\t}\r\n\r\n\tcol = PostEffects(col, uv);\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"// Mountains. By David Hoskins - 2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/4slGD4\r\n// A ray-marched version of my terrain renderer which uses\r\n// streaming texture normals for speed:-\r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// It uses binary subdivision to accurately find the height map.\r\n// Lots of thanks to Inigo and his noise functions!\r\n\r\n// Video of my OpenGL version that \r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// Stereo version code thanks to Croqueteer :)\r\n//#define STEREO \r\n\r\nfloat treeLine = 0.0;\r\nfloat treeCol = 0.0;\r\n\r\n\r\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\r\nvec3 sunColour = vec3(1.0, .9, .83);\r\nfloat specular = 0.0;\r\nvec3 cameraPos;\r\nfloat ambient;\r\nvec2 add = vec2(1.0, 0.0);\r\n#define HASHSCALE1 .1031\r\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\r\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\r\n\r\n// This peturbs the fractal positions for each iteration down...\r\n// Helps make nice twisted landscapes...\r\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\r\n\r\n// Alternative rotation:-\r\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\r\n\r\n\r\n//  1 out, 2 in...\r\nfloat Hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n\r\n}\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    \r\n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\r\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Noise2( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y * 57.0;\r\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\r\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Trees(vec2 p)\r\n{\r\n\t\r\n \t//return (texture(iChannel1,0.04*p).x * treeLine);\r\n    return Noise(p*13.0)*treeLine;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Low def version for ray-marching through the height field...\r\n// Thanks to IQ for all the noise stuff...\r\n\r\nfloat Terrain( in vec2 p)\r\n{\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\t\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Map to lower resolution for height field mapping for Scene function...\r\nfloat Map(in vec3 p)\r\n{\r\n\tfloat h = Terrain(p.xz);\r\n\t\t\r\n\r\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\r\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\r\n\ttreeCol = Trees(p.xz);\r\n\th += treeCol;\r\n\t\r\n    return p.y - h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// High def version only used for grabbing normal information.\r\nfloat Terrain2( in vec2 p)\r\n{\r\n\t// There's some real magic numbers in here! \r\n\t// The Noise calls add large mountain ranges for more variation over distances...\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\t\r\n\r\n\ttreeCol = Trees(p);\r\n\tf += treeCol;\r\n\tif (treeCol > 0.0) return f;\r\n\r\n\t\r\n\t// That's the last of the low resolution, now go down further for the Normal data...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\t\r\n\t\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw *= 0.5;\r\n\t\txy *= 2.7;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Simply Perlin clouds that fade to the horizon...\r\n// 200 units above the ground...\r\nvec3 GetClouds(in vec3 sky, in vec3 rd)\r\n{\r\n\tif (rd.y < 0.01) return sky;\r\n\tfloat v = (200.0-cameraPos.y)/rd.y;\r\n\trd.xz *= v;\r\n\trd.xz += cameraPos.xz;\r\n\trd.xz *= .010;\r\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\r\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\r\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\r\n\r\n\treturn sky;\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\r\n\tvec3  sky = vec3(v*sunColour.x*0.4+0.18, v*sunColour.y*0.4+0.22, v*sunColour.z*0.4+.4);\r\n\t// Wide glare effect...\r\n\tsky = sky + sunColour * pow(sunAmount, 6.5)*.32;\r\n\t// Actual sun...\r\n\tsky = sky+ sunColour * min(pow(sunAmount, 1150.0), .3)*.65;\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge mountains into the sky background for correct disappearance...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = exp(-dis* 0.00005);\r\n\treturn mix(GetSky(dir), rgb, fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tfloat c = max(h, 0.0)+ambient;\r\n\tmat = mat * sunColour * c ;\r\n\t// Specular...\r\n\tif (h > 0.0)\r\n\t{\r\n\t\tvec3 R = reflect(sunLight, normal);\r\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\r\n\t\tmat = mix(mat, sunColour, specAmount);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Hack the height, position, and normal data to create the coloured landscape\r\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\r\n{\r\n\tvec3 mat;\r\n\tspecular = .0;\r\n\tambient = .1;\r\n\tvec3 dir = normalize(pos-cameraPos);\r\n\t\r\n\tvec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\r\n\r\n\tfloat disSqrd = dis * dis;// Squaring it gives better distance scales.\r\n\r\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\r\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\r\n\tf *= .55;\r\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\r\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\r\n\t// Should have used smoothstep to add colours, but left it using 'if' for sanity...\r\n\tif (normal.y < .5)\r\n\t{\r\n\t\tfloat v = normal.y;\r\n\t\tfloat c = (.5-normal.y) * 4.0;\r\n\t\tc = clamp(c*c, 0.1, 1.0);\r\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\r\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\r\n\t\tmat = mix(mat, vec3(.4*f), c);\r\n\t\tspecular+=.1;\r\n\t}\r\n\r\n\t// Grass. Use the normal to decide when to plonk grass down...\r\n\tif (matPos.y < 45.35 && normal.y > .65)\r\n\t{\r\n\r\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\r\n\t\tm *= (normal.y- 0.65)*.6;\r\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\r\n\t}\r\n\r\n\tif (treeCol > 0.0)\r\n\t{\r\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\r\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\r\n\t\tspecular = .0;\r\n\t}\r\n\t\r\n\t// Snow topped mountains...\r\n\tif (matPos.y > 80.0 && normal.y > .42)\r\n\t{\r\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\r\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\r\n\t\tspecular += snow;\r\n\t\tambient+=snow *.3;\r\n\t}\r\n\t// Beach effect...\r\n\tif (matPos.y < 1.45)\r\n\t{\r\n\t\tif (normal.y > .4)\r\n\t\t{\r\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\r\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\r\n\t\t\tfloat t = (normal.y-.4);\r\n\t\t\tt = (t*t);\r\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\r\n\t\t}\r\n\t\t// Cheap under water darkening...it's wet after all...\r\n\t\tif (matPos.y < 0.0)\r\n\t\t{\r\n\t\t\tmat *= .2;\r\n\t\t}\r\n\t}\r\n\r\n\tDoLighting(mat, pos, normal,dir, disSqrd);\r\n\t\r\n\t// Do the water...\r\n\tif (matPos.y < 0.0)\r\n\t{\r\n\t\t// Pull back along the ray direction to get water surface point at y = 0.0 ...\r\n\t\tfloat time = (iTime)*.03;\r\n\t\tvec3 watPos = matPos;\r\n\t\twatPos += -dir * (watPos.y/dir.y);\r\n\t\t// Make some dodgy waves...\r\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\r\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\r\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\r\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\r\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\r\n\t\tnor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\r\n\t\t// Mix it in at depth transparancy to give beach cues..\r\n        tx = watPos.y-matPos.y;\r\n\t\tmat = mix(mat, GetClouds(GetSky(nor)*vec3(.3,.3,.5), nor)*.1+vec3(.0,.02,.03), clamp((tx)*.4, .6, 1.));\r\n\t\t// Add some extra water glint...\r\n        //mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*texture(iChannel1, watPos.xz*.1, -2.).x, 0.,1.0);\r\n        mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*Noise2(watPos.xz*.1).x, 0.,1.0);\r\n\t\tfloat sunAmount = max( dot(nor, sunLight), 0.0 );\r\n\t\tmat = mat + sunColour * pow(sunAmount, 228.5)*.6;\r\n        vec3 temp = (watPos-cameraPos*2.)*.5;\r\n        disSqrd = dot(temp, temp);\r\n\t}\r\n\tmat = ApplyFog(mat, disSqrd, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\r\n{\r\n\t// Home in on the surface by dividing by two and split...\r\n    float halfwayT;\r\n  \r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n\r\n        halfwayT = dot(t, vec2(.5));\r\n        float d = Map(rO + halfwayT*rD); \r\n         t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.5, d));\r\n\r\n    }\r\n\treturn halfwayT;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, in vec2 fragCoord )\r\n{\r\n    float t = 1. + Hash12(fragCoord.xy)*5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.0;\r\n\tbool fin = false;\r\n\tbool res = false;\r\n\tvec2 distances;\r\n\tfor( int j=0; j< 150; j++ )\r\n\t{\r\n\t\tif (fin || t > 240.0) break;\r\n\t\tvec3 p = rO + t*rD;\r\n\t\t//if (t > 240.0 || p.y > 195.0) break;\r\n\t\tfloat h = Map(p); // ...Get this positions height mapping.\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h < 0.5)\r\n\t\t{\r\n\t\t\tfin = true;\r\n\t\t\tdistances = vec2(oldT, t);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// Delta ray advance - a fudge between the height returned\r\n\t\t// and the distance already travelled.\r\n\t\t// It's a really fiddly compromise between speed and accuracy\r\n\t\t// Too large a step and the tops of ridges get missed.\r\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\r\n\r\n\treturn fin;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\tfloat m = 1.0+(iMouse.x/iResolution.x)*300.0;\r\n\tt = (iTime*1.5+m+657.0)*.006 + t;\r\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\r\n\treturn vec3(35.0-p.x, 0.6, 4108.0+p.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Some would say, most of the magic is done in post! :D\r\nvec3 PostEffects(vec3 rgb, vec2 uv)\r\n{\r\n\t//#define CONTRAST 1.1\r\n\t//#define SATURATION 1.12\r\n\t//#define BRIGHTNESS 1.3\r\n\t//rgb = pow(abs(rgb), vec3(0.45));\r\n\t//rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\r\n\t//rgb = clamp(rgb+hash12(fragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = xy * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\t// Use several forward heights, of decreasing influence with distance from the camera.\r\n\tfloat h = 0.0;\r\n\tfloat f = 1.0;\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\r\n\t\tf -= .1;\r\n\t}\r\n\tcameraPos.xz = CameraPath(0.0).xz;\r\n\tcamTar.xyz\t = CameraPath(.005).xyz;\r\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.5+sin(iTime*5.)*.5);\r\n\t\r\n\tfloat roll = 0.15*sin(iTime*.2);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .45*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tif( !Scene(cameraPos,rd, distance, fragCoord) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky value...\r\n\t\tcol = GetSky(rd);\r\n\t\tcol = GetClouds(col, rd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * rd;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, nor, distance);\r\n\t}\r\n\r\n\tcol = PostEffects(col, uv);\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Mountains","id":"36a1dde4bd2a4a07a31b340d345849c6","date":null,"viewed":0,"name":"Mountains","description":"A Shader version of my terrain renderer:-\nhttp://www.youtube.com/watch?v=qzkBnCBpQAM\nUSE MOUSE > TO SHIFT TIME\n\n\nVideo of my OpenGL version that uses streaming texture normals for speed...\nhttp://www.youtube.com/watch?v=qzkBnCBpQAM\nhttps://www.shadertoy.com/view/4slGD4","likes":0,"published":null,"tags":["raymarching"," terrain"," landscape"," mountains"," vr"," soundcloud"]},"ver":null,"info":{"Name":"Mountains","id":"36a1dde4bd2a4a07a31b340d345849c6","date":null,"viewed":0,"name":"Mountains","description":"A Shader version of my terrain renderer:-\nhttp://www.youtube.com/watch?v=qzkBnCBpQAM\nUSE MOUSE > TO SHIFT TIME\n\n\nVideo of my OpenGL version that uses streaming texture normals for speed...\nhttp://www.youtube.com/watch?v=qzkBnCBpQAM\nhttps://www.shadertoy.com/view/4slGD4","likes":0,"published":null,"tags":["raymarching"," terrain"," landscape"," mountains"," vr"," soundcloud"]},"renderpass":[{"Code":"// Mountains. By David Hoskins - 2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/4slGD4\r\n// A ray-marched version of my terrain renderer which uses\r\n// streaming texture normals for speed:-\r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// It uses binary subdivision to accurately find the height map.\r\n// Lots of thanks to Inigo and his noise functions!\r\n\r\n// Video of my OpenGL version that \r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// Stereo version code thanks to Croqueteer :)\r\n//#define STEREO \r\n\r\nfloat treeLine = 0.0;\r\nfloat treeCol = 0.0;\r\n\r\n\r\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\r\nvec3 sunColour = vec3(1.0, .9, .83);\r\nfloat specular = 0.0;\r\nvec3 cameraPos;\r\nfloat ambient;\r\nvec2 add = vec2(1.0, 0.0);\r\n#define HASHSCALE1 .1031\r\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\r\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\r\n\r\n// This peturbs the fractal positions for each iteration down...\r\n// Helps make nice twisted landscapes...\r\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\r\n\r\n// Alternative rotation:-\r\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\r\n\r\n\r\n//  1 out, 2 in...\r\nfloat Hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n\r\n}\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    \r\n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\r\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Noise2( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y * 57.0;\r\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\r\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Trees(vec2 p)\r\n{\r\n\t\r\n \t//return (texture(iChannel1,0.04*p).x * treeLine);\r\n    return Noise(p*13.0)*treeLine;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Low def version for ray-marching through the height field...\r\n// Thanks to IQ for all the noise stuff...\r\n\r\nfloat Terrain( in vec2 p)\r\n{\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\t\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Map to lower resolution for height field mapping for Scene function...\r\nfloat Map(in vec3 p)\r\n{\r\n\tfloat h = Terrain(p.xz);\r\n\t\t\r\n\r\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\r\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\r\n\ttreeCol = Trees(p.xz);\r\n\th += treeCol;\r\n\t\r\n    return p.y - h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// High def version only used for grabbing normal information.\r\nfloat Terrain2( in vec2 p)\r\n{\r\n\t// There's some real magic numbers in here! \r\n\t// The Noise calls add large mountain ranges for more variation over distances...\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\t\r\n\r\n\ttreeCol = Trees(p);\r\n\tf += treeCol;\r\n\tif (treeCol > 0.0) return f;\r\n\r\n\t\r\n\t// That's the last of the low resolution, now go down further for the Normal data...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\t\r\n\t\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw *= 0.5;\r\n\t\txy *= 2.7;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Simply Perlin clouds that fade to the horizon...\r\n// 200 units above the ground...\r\nvec3 GetClouds(in vec3 sky, in vec3 rd)\r\n{\r\n\tif (rd.y < 0.01) return sky;\r\n\tfloat v = (200.0-cameraPos.y)/rd.y;\r\n\trd.xz *= v;\r\n\trd.xz += cameraPos.xz;\r\n\trd.xz *= .010;\r\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\r\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\r\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\r\n\r\n\treturn sky;\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\r\n\tvec3  sky = vec3(v*sunColour.x*0.4+0.18, v*sunColour.y*0.4+0.22, v*sunColour.z*0.4+.4);\r\n\t// Wide glare effect...\r\n\tsky = sky + sunColour * pow(sunAmount, 6.5)*.32;\r\n\t// Actual sun...\r\n\tsky = sky+ sunColour * min(pow(sunAmount, 1150.0), .3)*.65;\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge mountains into the sky background for correct disappearance...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = exp(-dis* 0.00005);\r\n\treturn mix(GetSky(dir), rgb, fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tfloat c = max(h, 0.0)+ambient;\r\n\tmat = mat * sunColour * c ;\r\n\t// Specular...\r\n\tif (h > 0.0)\r\n\t{\r\n\t\tvec3 R = reflect(sunLight, normal);\r\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\r\n\t\tmat = mix(mat, sunColour, specAmount);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Hack the height, position, and normal data to create the coloured landscape\r\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\r\n{\r\n\tvec3 mat;\r\n\tspecular = .0;\r\n\tambient = .1;\r\n\tvec3 dir = normalize(pos-cameraPos);\r\n\t\r\n\tvec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\r\n\r\n\tfloat disSqrd = dis * dis;// Squaring it gives better distance scales.\r\n\r\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\r\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\r\n\tf *= .55;\r\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\r\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\r\n\t// Should have used smoothstep to add colours, but left it using 'if' for sanity...\r\n\tif (normal.y < .5)\r\n\t{\r\n\t\tfloat v = normal.y;\r\n\t\tfloat c = (.5-normal.y) * 4.0;\r\n\t\tc = clamp(c*c, 0.1, 1.0);\r\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\r\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\r\n\t\tmat = mix(mat, vec3(.4*f), c);\r\n\t\tspecular+=.1;\r\n\t}\r\n\r\n\t// Grass. Use the normal to decide when to plonk grass down...\r\n\tif (matPos.y < 45.35 && normal.y > .65)\r\n\t{\r\n\r\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\r\n\t\tm *= (normal.y- 0.65)*.6;\r\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\r\n\t}\r\n\r\n\tif (treeCol > 0.0)\r\n\t{\r\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\r\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\r\n\t\tspecular = .0;\r\n\t}\r\n\t\r\n\t// Snow topped mountains...\r\n\tif (matPos.y > 80.0 && normal.y > .42)\r\n\t{\r\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\r\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\r\n\t\tspecular += snow;\r\n\t\tambient+=snow *.3;\r\n\t}\r\n\t// Beach effect...\r\n\tif (matPos.y < 1.45)\r\n\t{\r\n\t\tif (normal.y > .4)\r\n\t\t{\r\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\r\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\r\n\t\t\tfloat t = (normal.y-.4);\r\n\t\t\tt = (t*t);\r\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\r\n\t\t}\r\n\t\t// Cheap under water darkening...it's wet after all...\r\n\t\tif (matPos.y < 0.0)\r\n\t\t{\r\n\t\t\tmat *= .2;\r\n\t\t}\r\n\t}\r\n\r\n\tDoLighting(mat, pos, normal,dir, disSqrd);\r\n\t\r\n\t// Do the water...\r\n\tif (matPos.y < 0.0)\r\n\t{\r\n\t\t// Pull back along the ray direction to get water surface point at y = 0.0 ...\r\n\t\tfloat time = (iTime)*.03;\r\n\t\tvec3 watPos = matPos;\r\n\t\twatPos += -dir * (watPos.y/dir.y);\r\n\t\t// Make some dodgy waves...\r\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\r\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\r\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\r\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\r\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\r\n\t\tnor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\r\n\t\t// Mix it in at depth transparancy to give beach cues..\r\n        tx = watPos.y-matPos.y;\r\n\t\tmat = mix(mat, GetClouds(GetSky(nor)*vec3(.3,.3,.5), nor)*.1+vec3(.0,.02,.03), clamp((tx)*.4, .6, 1.));\r\n\t\t// Add some extra water glint...\r\n        //mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*texture(iChannel1, watPos.xz*.1, -2.).x, 0.,1.0);\r\n        mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*Noise2(watPos.xz*.1).x, 0.,1.0);\r\n\t\tfloat sunAmount = max( dot(nor, sunLight), 0.0 );\r\n\t\tmat = mat + sunColour * pow(sunAmount, 228.5)*.6;\r\n        vec3 temp = (watPos-cameraPos*2.)*.5;\r\n        disSqrd = dot(temp, temp);\r\n\t}\r\n\tmat = ApplyFog(mat, disSqrd, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\r\n{\r\n\t// Home in on the surface by dividing by two and split...\r\n    float halfwayT;\r\n  \r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n\r\n        halfwayT = dot(t, vec2(.5));\r\n        float d = Map(rO + halfwayT*rD); \r\n         t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.5, d));\r\n\r\n    }\r\n\treturn halfwayT;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, in vec2 fragCoord )\r\n{\r\n    float t = 1. + Hash12(fragCoord.xy)*5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.0;\r\n\tbool fin = false;\r\n\tbool res = false;\r\n\tvec2 distances;\r\n\tfor( int j=0; j< 150; j++ )\r\n\t{\r\n\t\tif (fin || t > 240.0) break;\r\n\t\tvec3 p = rO + t*rD;\r\n\t\t//if (t > 240.0 || p.y > 195.0) break;\r\n\t\tfloat h = Map(p); // ...Get this positions height mapping.\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h < 0.5)\r\n\t\t{\r\n\t\t\tfin = true;\r\n\t\t\tdistances = vec2(oldT, t);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// Delta ray advance - a fudge between the height returned\r\n\t\t// and the distance already travelled.\r\n\t\t// It's a really fiddly compromise between speed and accuracy\r\n\t\t// Too large a step and the tops of ridges get missed.\r\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\r\n\r\n\treturn fin;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\tfloat m = 1.0+(iMouse.x/iResolution.x)*300.0;\r\n\tt = (iTime*1.5+m+657.0)*.006 + t;\r\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\r\n\treturn vec3(35.0-p.x, 0.6, 4108.0+p.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Some would say, most of the magic is done in post! :D\r\nvec3 PostEffects(vec3 rgb, vec2 uv)\r\n{\r\n\t//#define CONTRAST 1.1\r\n\t//#define SATURATION 1.12\r\n\t//#define BRIGHTNESS 1.3\r\n\t//rgb = pow(abs(rgb), vec3(0.45));\r\n\t//rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\r\n\t//rgb = clamp(rgb+hash12(fragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = xy * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\t// Use several forward heights, of decreasing influence with distance from the camera.\r\n\tfloat h = 0.0;\r\n\tfloat f = 1.0;\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\r\n\t\tf -= .1;\r\n\t}\r\n\tcameraPos.xz = CameraPath(0.0).xz;\r\n\tcamTar.xyz\t = CameraPath(.005).xyz;\r\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.5+sin(iTime*5.)*.5);\r\n\t\r\n\tfloat roll = 0.15*sin(iTime*.2);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .45*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tif( !Scene(cameraPos,rd, distance, fragCoord) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky value...\r\n\t\tcol = GetSky(rd);\r\n\t\tcol = GetClouds(col, rd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * rd;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, nor, distance);\r\n\t}\r\n\r\n\tcol = PostEffects(col, uv);\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"// Mountains. By David Hoskins - 2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/4slGD4\r\n// A ray-marched version of my terrain renderer which uses\r\n// streaming texture normals for speed:-\r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// It uses binary subdivision to accurately find the height map.\r\n// Lots of thanks to Inigo and his noise functions!\r\n\r\n// Video of my OpenGL version that \r\n// http://www.youtube.com/watch?v=qzkBnCBpQAM\r\n\r\n// Stereo version code thanks to Croqueteer :)\r\n//#define STEREO \r\n\r\nfloat treeLine = 0.0;\r\nfloat treeCol = 0.0;\r\n\r\n\r\nvec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.48 ) );\r\nvec3 sunColour = vec3(1.0, .9, .83);\r\nfloat specular = 0.0;\r\nvec3 cameraPos;\r\nfloat ambient;\r\nvec2 add = vec2(1.0, 0.0);\r\n#define HASHSCALE1 .1031\r\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\r\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\r\n\r\n// This peturbs the fractal positions for each iteration down...\r\n// Helps make nice twisted landscapes...\r\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\r\n\r\n// Alternative rotation:-\r\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\r\n\r\n\r\n//  1 out, 2 in...\r\nfloat Hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n\r\n}\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    \r\n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\r\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Noise2( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y * 57.0;\r\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\r\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Trees(vec2 p)\r\n{\r\n\t\r\n \t//return (texture(iChannel1,0.04*p).x * treeLine);\r\n    return Noise(p*13.0)*treeLine;\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Low def version for ray-marching through the height field...\r\n// Thanks to IQ for all the noise stuff...\r\n\r\nfloat Terrain( in vec2 p)\r\n{\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\t\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Map to lower resolution for height field mapping for Scene function...\r\nfloat Map(in vec3 p)\r\n{\r\n\tfloat h = Terrain(p.xz);\r\n\t\t\r\n\r\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\r\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\r\n\ttreeCol = Trees(p.xz);\r\n\th += treeCol;\r\n\t\r\n    return p.y - h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// High def version only used for grabbing normal information.\r\nfloat Terrain2( in vec2 p)\r\n{\r\n\t// There's some real magic numbers in here! \r\n\t// The Noise calls add large mountain ranges for more variation over distances...\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\t\r\n\r\n\ttreeCol = Trees(p);\r\n\tf += treeCol;\r\n\tif (treeCol > 0.0) return f;\r\n\r\n\t\r\n\t// That's the last of the low resolution, now go down further for the Normal data...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\t\r\n\t\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw *= 0.5;\r\n\t\txy *= 2.7;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Simply Perlin clouds that fade to the horizon...\r\n// 200 units above the ground...\r\nvec3 GetClouds(in vec3 sky, in vec3 rd)\r\n{\r\n\tif (rd.y < 0.01) return sky;\r\n\tfloat v = (200.0-cameraPos.y)/rd.y;\r\n\trd.xz *= v;\r\n\trd.xz += cameraPos.xz;\r\n\trd.xz *= .010;\r\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\r\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\r\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\r\n\r\n\treturn sky;\r\n}\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\r\n\tvec3  sky = vec3(v*sunColour.x*0.4+0.18, v*sunColour.y*0.4+0.22, v*sunColour.z*0.4+.4);\r\n\t// Wide glare effect...\r\n\tsky = sky + sunColour * pow(sunAmount, 6.5)*.32;\r\n\t// Actual sun...\r\n\tsky = sky+ sunColour * min(pow(sunAmount, 1150.0), .3)*.65;\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge mountains into the sky background for correct disappearance...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = exp(-dis* 0.00005);\r\n\treturn mix(GetSky(dir), rgb, fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tfloat c = max(h, 0.0)+ambient;\r\n\tmat = mat * sunColour * c ;\r\n\t// Specular...\r\n\tif (h > 0.0)\r\n\t{\r\n\t\tvec3 R = reflect(sunLight, normal);\r\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\r\n\t\tmat = mix(mat, sunColour, specAmount);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Hack the height, position, and normal data to create the coloured landscape\r\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\r\n{\r\n\tvec3 mat;\r\n\tspecular = .0;\r\n\tambient = .1;\r\n\tvec3 dir = normalize(pos-cameraPos);\r\n\t\r\n\tvec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\r\n\r\n\tfloat disSqrd = dis * dis;// Squaring it gives better distance scales.\r\n\r\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\r\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\r\n\tf *= .55;\r\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\r\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\r\n\t// Should have used smoothstep to add colours, but left it using 'if' for sanity...\r\n\tif (normal.y < .5)\r\n\t{\r\n\t\tfloat v = normal.y;\r\n\t\tfloat c = (.5-normal.y) * 4.0;\r\n\t\tc = clamp(c*c, 0.1, 1.0);\r\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\r\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\r\n\t\tmat = mix(mat, vec3(.4*f), c);\r\n\t\tspecular+=.1;\r\n\t}\r\n\r\n\t// Grass. Use the normal to decide when to plonk grass down...\r\n\tif (matPos.y < 45.35 && normal.y > .65)\r\n\t{\r\n\r\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\r\n\t\tm *= (normal.y- 0.65)*.6;\r\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\r\n\t}\r\n\r\n\tif (treeCol > 0.0)\r\n\t{\r\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\r\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\r\n\t\tspecular = .0;\r\n\t}\r\n\t\r\n\t// Snow topped mountains...\r\n\tif (matPos.y > 80.0 && normal.y > .42)\r\n\t{\r\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\r\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\r\n\t\tspecular += snow;\r\n\t\tambient+=snow *.3;\r\n\t}\r\n\t// Beach effect...\r\n\tif (matPos.y < 1.45)\r\n\t{\r\n\t\tif (normal.y > .4)\r\n\t\t{\r\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\r\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\r\n\t\t\tfloat t = (normal.y-.4);\r\n\t\t\tt = (t*t);\r\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\r\n\t\t}\r\n\t\t// Cheap under water darkening...it's wet after all...\r\n\t\tif (matPos.y < 0.0)\r\n\t\t{\r\n\t\t\tmat *= .2;\r\n\t\t}\r\n\t}\r\n\r\n\tDoLighting(mat, pos, normal,dir, disSqrd);\r\n\t\r\n\t// Do the water...\r\n\tif (matPos.y < 0.0)\r\n\t{\r\n\t\t// Pull back along the ray direction to get water surface point at y = 0.0 ...\r\n\t\tfloat time = (iTime)*.03;\r\n\t\tvec3 watPos = matPos;\r\n\t\twatPos += -dir * (watPos.y/dir.y);\r\n\t\t// Make some dodgy waves...\r\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\r\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\r\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\r\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\r\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\r\n\t\tnor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\r\n\t\t// Mix it in at depth transparancy to give beach cues..\r\n        tx = watPos.y-matPos.y;\r\n\t\tmat = mix(mat, GetClouds(GetSky(nor)*vec3(.3,.3,.5), nor)*.1+vec3(.0,.02,.03), clamp((tx)*.4, .6, 1.));\r\n\t\t// Add some extra water glint...\r\n        //mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*texture(iChannel1, watPos.xz*.1, -2.).x, 0.,1.0);\r\n        mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*Noise2(watPos.xz*.1).x, 0.,1.0);\r\n\t\tfloat sunAmount = max( dot(nor, sunLight), 0.0 );\r\n\t\tmat = mat + sunColour * pow(sunAmount, 228.5)*.6;\r\n        vec3 temp = (watPos-cameraPos*2.)*.5;\r\n        disSqrd = dot(temp, temp);\r\n\t}\r\n\tmat = ApplyFog(mat, disSqrd, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\r\n{\r\n\t// Home in on the surface by dividing by two and split...\r\n    float halfwayT;\r\n  \r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n\r\n        halfwayT = dot(t, vec2(.5));\r\n        float d = Map(rO + halfwayT*rD); \r\n         t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.5, d));\r\n\r\n    }\r\n\treturn halfwayT;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, in vec2 fragCoord )\r\n{\r\n    float t = 1. + Hash12(fragCoord.xy)*5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.0;\r\n\tbool fin = false;\r\n\tbool res = false;\r\n\tvec2 distances;\r\n\tfor( int j=0; j< 150; j++ )\r\n\t{\r\n\t\tif (fin || t > 240.0) break;\r\n\t\tvec3 p = rO + t*rD;\r\n\t\t//if (t > 240.0 || p.y > 195.0) break;\r\n\t\tfloat h = Map(p); // ...Get this positions height mapping.\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h < 0.5)\r\n\t\t{\r\n\t\t\tfin = true;\r\n\t\t\tdistances = vec2(oldT, t);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// Delta ray advance - a fudge between the height returned\r\n\t\t// and the distance already travelled.\r\n\t\t// It's a really fiddly compromise between speed and accuracy\r\n\t\t// Too large a step and the tops of ridges get missed.\r\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\r\n\r\n\treturn fin;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\tfloat m = 1.0+(iMouse.x/iResolution.x)*300.0;\r\n\tt = (iTime*1.5+m+657.0)*.006 + t;\r\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\r\n\treturn vec3(35.0-p.x, 0.6, 4108.0+p.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Some would say, most of the magic is done in post! :D\r\nvec3 PostEffects(vec3 rgb, vec2 uv)\r\n{\r\n\t//#define CONTRAST 1.1\r\n\t//#define SATURATION 1.12\r\n\t//#define BRIGHTNESS 1.3\r\n\t//rgb = pow(abs(rgb), vec3(0.45));\r\n\t//rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\r\n\t//rgb = clamp(rgb+hash12(fragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = xy * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\t// Use several forward heights, of decreasing influence with distance from the camera.\r\n\tfloat h = 0.0;\r\n\tfloat f = 1.0;\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\r\n\t\tf -= .1;\r\n\t}\r\n\tcameraPos.xz = CameraPath(0.0).xz;\r\n\tcamTar.xyz\t = CameraPath(.005).xyz;\r\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.5+sin(iTime*5.)*.5);\r\n\t\r\n\tfloat roll = 0.15*sin(iTime*.2);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .45*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tif( !Scene(cameraPos,rd, distance, fragCoord) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky value...\r\n\t\tcol = GetSky(rd);\r\n\t\tcol = GetClouds(col, rd);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * rd;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, nor, distance);\r\n\t}\r\n\r\n\tcol = PostEffects(col, uv);\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// see also full black body spectrum: https://www.shadertoy.com/view/4tdGWM\r\n// deeper in fluids: https://www.shadertoy.com/view/XldGDM\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n    U /= iResolution.xy;\r\n    float y = 2.* U.y; \r\n    \r\n    O = \r\n    // secret 1 for natural colors for luminous phenomena:\r\n    // - real-life color spectrum is never zero in any channel\r\n    // - intensities are 0 to infinity\r\n    // - captors (camera,eye) saturates early\r\n\ty > 1. ? vec4(1,1./4.,1./16.,1) * exp(4.*U.x - 1.)  // i.e. exp(T) * exp(-z)\r\n\r\n    // secret 2 for natural colors for volumetric phenomena:\r\n    // - transparency decrease as the power of distance ( T^l )\r\n    // - T value varies with frequency ( i.e. color channel )\r\n    // - real life transparency is never exactly 1 at any frequency\r\n   : pow(vec4(.1, .7, .8, 1), vec4(4.*U.x));\r\n        \r\n    \r\n}","inputs":[],"outputs":[],"code":"// see also full black body spectrum: https://www.shadertoy.com/view/4tdGWM\r\n// deeper in fluids: https://www.shadertoy.com/view/XldGDM\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n    U /= iResolution.xy;\r\n    float y = 2.* U.y; \r\n    \r\n    O = \r\n    // secret 1 for natural colors for luminous phenomena:\r\n    // - real-life color spectrum is never zero in any channel\r\n    // - intensities are 0 to infinity\r\n    // - captors (camera,eye) saturates early\r\n\ty > 1. ? vec4(1,1./4.,1./16.,1) * exp(4.*U.x - 1.)  // i.e. exp(T) * exp(-z)\r\n\r\n    // secret 2 for natural colors for volumetric phenomena:\r\n    // - transparency decrease as the power of distance ( T^l )\r\n    // - T value varies with frequency ( i.e. color channel )\r\n    // - real life transparency is never exactly 1 at any frequency\r\n   : pow(vec4(.1, .7, .8, 1), vec4(4.*U.x));\r\n        \r\n    \r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"natural colors (fire, water,...) ","id":"bbd447266c924ea1abaaa7ea51aac8e4","date":null,"viewed":0,"name":"natural colors (fire, water,...) ","description":".non-linearity creates variations of chrominance\nsimple natural ones:  saturation (clamp) and multiplication (pow, exp)\nhttps://www.shadertoy.com/view/MlcGD7","likes":0,"published":null,"tags":["tutorial"," color"," sky"," blackbody"]},"ver":null,"info":{"Name":"natural colors (fire, water,...) ","id":"bbd447266c924ea1abaaa7ea51aac8e4","date":null,"viewed":0,"name":"natural colors (fire, water,...) ","description":".non-linearity creates variations of chrominance\nsimple natural ones:  saturation (clamp) and multiplication (pow, exp)\nhttps://www.shadertoy.com/view/MlcGD7","likes":0,"published":null,"tags":["tutorial"," color"," sky"," blackbody"]},"renderpass":[{"Code":"// see also full black body spectrum: https://www.shadertoy.com/view/4tdGWM\r\n// deeper in fluids: https://www.shadertoy.com/view/XldGDM\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n    U /= iResolution.xy;\r\n    float y = 2.* U.y; \r\n    \r\n    O = \r\n    // secret 1 for natural colors for luminous phenomena:\r\n    // - real-life color spectrum is never zero in any channel\r\n    // - intensities are 0 to infinity\r\n    // - captors (camera,eye) saturates early\r\n\ty > 1. ? vec4(1,1./4.,1./16.,1) * exp(4.*U.x - 1.)  // i.e. exp(T) * exp(-z)\r\n\r\n    // secret 2 for natural colors for volumetric phenomena:\r\n    // - transparency decrease as the power of distance ( T^l )\r\n    // - T value varies with frequency ( i.e. color channel )\r\n    // - real life transparency is never exactly 1 at any frequency\r\n   : pow(vec4(.1, .7, .8, 1), vec4(4.*U.x));\r\n        \r\n    \r\n}","inputs":[],"outputs":[],"code":"// see also full black body spectrum: https://www.shadertoy.com/view/4tdGWM\r\n// deeper in fluids: https://www.shadertoy.com/view/XldGDM\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n    U /= iResolution.xy;\r\n    float y = 2.* U.y; \r\n    \r\n    O = \r\n    // secret 1 for natural colors for luminous phenomena:\r\n    // - real-life color spectrum is never zero in any channel\r\n    // - intensities are 0 to infinity\r\n    // - captors (camera,eye) saturates early\r\n\ty > 1. ? vec4(1,1./4.,1./16.,1) * exp(4.*U.x - 1.)  // i.e. exp(T) * exp(-z)\r\n\r\n    // secret 2 for natural colors for volumetric phenomena:\r\n    // - transparency decrease as the power of distance ( T^l )\r\n    // - T value varies with frequency ( i.e. color channel )\r\n    // - real life transparency is never exactly 1 at any frequency\r\n   : pow(vec4(.1, .7, .8, 1), vec4(4.*U.x));\r\n        \r\n    \r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// --- adapted from 3D noise of inigo quilez \r\n// https://www.shadertoy.com/view/XslGRr\r\n\r\n#define FULL_PROCEDURAL\r\n#ifdef FULL_PROCEDURAL\r\n\r\n// hash based 3d value noise\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n#else\r\n\r\n// LUT based 3d value noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\n#define mynoise(q) (1.-abs(2.*noise(q)-1.))\r\n\r\nfloat fbm( in vec3 q )\r\n{\r\n\tfloat f;\r\n    f  = 0.5000*mynoise( q ); q = q*2.02;\r\n    f += 0.2500*mynoise( q ); q = q*2.03;\r\n    f += 0.1250*mynoise( q ); q = q*2.01;\r\n    f += 0.0625*mynoise( q );\r\n\treturn f;\r\n}\r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel1,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// shape\r\nvec4 map( in vec3 p )\r\n{\r\n\t\r\n\tfloat l = length(p);\r\n\t\r\n\t// profile: \r\n\t//    dens max on sphere shell l = 1\r\n\t//    density slope stiffer inside (shockwave)\r\n\tfloat d = 1. - l;\r\n    if (d>0.) d = -3.*d;\r\n\t// d = -sqrt(-d);\r\n\t\r\n\t// add noise to profile.\r\n\t// noise = supercondensed \"fire\" fbm \r\n\tfloat n = pow(fbm(p),4.);\r\n\td += 2.5 * n;\r\n\r\n\t// volume cut, for debug\r\n\tif (key_toggle(32.))  if (p.x>0.) d = 0.;\r\n\t\r\n\tvec4 res;\r\n\tres.w = clamp(d, 0., 1. ); // density\r\n\t// color: orange on the shell then darkening red\r\n\tres.xyz = vec3(1./pow(l*1.,1.),.6/pow(l,3.),0.); \r\n\t// transparent blue inside\r\n\tif (!key_toggle(66.)) \r\n\t\tif ((l<1.) && (res.w==0.)) res += vec4(0.,0.,1.,.1);\r\n\t\r\n\treturn clamp(res, 0.0, 1.0 );;\r\n}\r\n\r\n\r\n\r\nvec4 raymarch( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 sum = vec4(0, 0, 0, 0);\r\n\r\n\tfloat t = 0.0;\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\tif( sum.a > 0.99 ) continue;\r\n\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tvec4 col = map( pos ); // .w = density\r\n\t\t\r\n\tif (key_toggle(79.))  // Ombrage\r\n\t{\r\n\t\tvec3 sundir = -normalize(pos); // vec3(-1.0,0.0,0.0);\r\n#define EPS .3\t\r\n\t\tfloat dif = (col.w - map(pos+EPS*sundir).w)/EPS; // grad(dens).L\r\n\r\n\t\tcol.xyz *= .5+.5*clamp(.5*dif, 0.,1.);\r\n\t}\r\n\t\t\r\n\t\tcol.a *= 0.35;\r\n\t\tcol.rgb *= col.a;\r\n\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\t\tt += max(0.1,0.025*t);\r\n\t}\r\n\r\n\tsum.xyz /= (0.001+sum.w);\r\n\r\n\treturn clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = 2.*(fragCoord.xy / iResolution.y -vec2(.8,.7));\r\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\r\n    \r\n    // camera\r\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\r\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\r\n\r\n\t\r\n    vec4 col = raymarch( ro, rd );\r\n\r\n\tvec4 sky;\r\n\t//sky = vec4(1.,1.,1.,1.); \r\n\tsky = vec4(.1,.0,.0,1.);\r\n    fragColor = mix(sky,col,col.w);\r\n}\r\n","inputs":[],"outputs":[],"code":"// --- adapted from 3D noise of inigo quilez \r\n// https://www.shadertoy.com/view/XslGRr\r\n\r\n#define FULL_PROCEDURAL\r\n#ifdef FULL_PROCEDURAL\r\n\r\n// hash based 3d value noise\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n#else\r\n\r\n// LUT based 3d value noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\n#define mynoise(q) (1.-abs(2.*noise(q)-1.))\r\n\r\nfloat fbm( in vec3 q )\r\n{\r\n\tfloat f;\r\n    f  = 0.5000*mynoise( q ); q = q*2.02;\r\n    f += 0.2500*mynoise( q ); q = q*2.03;\r\n    f += 0.1250*mynoise( q ); q = q*2.01;\r\n    f += 0.0625*mynoise( q );\r\n\treturn f;\r\n}\r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel1,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// shape\r\nvec4 map( in vec3 p )\r\n{\r\n\t\r\n\tfloat l = length(p);\r\n\t\r\n\t// profile: \r\n\t//    dens max on sphere shell l = 1\r\n\t//    density slope stiffer inside (shockwave)\r\n\tfloat d = 1. - l;\r\n    if (d>0.) d = -3.*d;\r\n\t// d = -sqrt(-d);\r\n\t\r\n\t// add noise to profile.\r\n\t// noise = supercondensed \"fire\" fbm \r\n\tfloat n = pow(fbm(p),4.);\r\n\td += 2.5 * n;\r\n\r\n\t// volume cut, for debug\r\n\tif (key_toggle(32.))  if (p.x>0.) d = 0.;\r\n\t\r\n\tvec4 res;\r\n\tres.w = clamp(d, 0., 1. ); // density\r\n\t// color: orange on the shell then darkening red\r\n\tres.xyz = vec3(1./pow(l*1.,1.),.6/pow(l,3.),0.); \r\n\t// transparent blue inside\r\n\tif (!key_toggle(66.)) \r\n\t\tif ((l<1.) && (res.w==0.)) res += vec4(0.,0.,1.,.1);\r\n\t\r\n\treturn clamp(res, 0.0, 1.0 );;\r\n}\r\n\r\n\r\n\r\nvec4 raymarch( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 sum = vec4(0, 0, 0, 0);\r\n\r\n\tfloat t = 0.0;\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\tif( sum.a > 0.99 ) continue;\r\n\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tvec4 col = map( pos ); // .w = density\r\n\t\t\r\n\tif (key_toggle(79.))  // Ombrage\r\n\t{\r\n\t\tvec3 sundir = -normalize(pos); // vec3(-1.0,0.0,0.0);\r\n#define EPS .3\t\r\n\t\tfloat dif = (col.w - map(pos+EPS*sundir).w)/EPS; // grad(dens).L\r\n\r\n\t\tcol.xyz *= .5+.5*clamp(.5*dif, 0.,1.);\r\n\t}\r\n\t\t\r\n\t\tcol.a *= 0.35;\r\n\t\tcol.rgb *= col.a;\r\n\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\t\tt += max(0.1,0.025*t);\r\n\t}\r\n\r\n\tsum.xyz /= (0.001+sum.w);\r\n\r\n\treturn clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = 2.*(fragCoord.xy / iResolution.y -vec2(.8,.7));\r\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\r\n    \r\n    // camera\r\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\r\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\r\n\r\n\t\r\n    vec4 col = raymarch( ro, rd );\r\n\r\n\tvec4 sky;\r\n\t//sky = vec4(1.,1.,1.,1.); \r\n\tsky = vec4(.1,.0,.0,1.);\r\n    fragColor = mix(sky,col,col.w);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"nebula2","id":"c368cc9712214ffcbf65556854a9646a","date":null,"viewed":0,"name":"nebula2","description":"rendering of a nebula.\nSPACE: toggle volume cut.\nB: toggle blue center \nO:  toggle shadowing\nhttps://www.shadertoy.com/view/4dBGDR","likes":0,"published":null,"tags":["volumelighting"]},"ver":null,"info":{"Name":"nebula2","id":"c368cc9712214ffcbf65556854a9646a","date":null,"viewed":0,"name":"nebula2","description":"rendering of a nebula.\nSPACE: toggle volume cut.\nB: toggle blue center \nO:  toggle shadowing\nhttps://www.shadertoy.com/view/4dBGDR","likes":0,"published":null,"tags":["volumelighting"]},"renderpass":[{"Code":"// --- adapted from 3D noise of inigo quilez \r\n// https://www.shadertoy.com/view/XslGRr\r\n\r\n#define FULL_PROCEDURAL\r\n#ifdef FULL_PROCEDURAL\r\n\r\n// hash based 3d value noise\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n#else\r\n\r\n// LUT based 3d value noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\n#define mynoise(q) (1.-abs(2.*noise(q)-1.))\r\n\r\nfloat fbm( in vec3 q )\r\n{\r\n\tfloat f;\r\n    f  = 0.5000*mynoise( q ); q = q*2.02;\r\n    f += 0.2500*mynoise( q ); q = q*2.03;\r\n    f += 0.1250*mynoise( q ); q = q*2.01;\r\n    f += 0.0625*mynoise( q );\r\n\treturn f;\r\n}\r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel1,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// shape\r\nvec4 map( in vec3 p )\r\n{\r\n\t\r\n\tfloat l = length(p);\r\n\t\r\n\t// profile: \r\n\t//    dens max on sphere shell l = 1\r\n\t//    density slope stiffer inside (shockwave)\r\n\tfloat d = 1. - l;\r\n    if (d>0.) d = -3.*d;\r\n\t// d = -sqrt(-d);\r\n\t\r\n\t// add noise to profile.\r\n\t// noise = supercondensed \"fire\" fbm \r\n\tfloat n = pow(fbm(p),4.);\r\n\td += 2.5 * n;\r\n\r\n\t// volume cut, for debug\r\n\tif (key_toggle(32.))  if (p.x>0.) d = 0.;\r\n\t\r\n\tvec4 res;\r\n\tres.w = clamp(d, 0., 1. ); // density\r\n\t// color: orange on the shell then darkening red\r\n\tres.xyz = vec3(1./pow(l*1.,1.),.6/pow(l,3.),0.); \r\n\t// transparent blue inside\r\n\tif (!key_toggle(66.)) \r\n\t\tif ((l<1.) && (res.w==0.)) res += vec4(0.,0.,1.,.1);\r\n\t\r\n\treturn clamp(res, 0.0, 1.0 );;\r\n}\r\n\r\n\r\n\r\nvec4 raymarch( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 sum = vec4(0, 0, 0, 0);\r\n\r\n\tfloat t = 0.0;\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\tif( sum.a > 0.99 ) continue;\r\n\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tvec4 col = map( pos ); // .w = density\r\n\t\t\r\n\tif (key_toggle(79.))  // Ombrage\r\n\t{\r\n\t\tvec3 sundir = -normalize(pos); // vec3(-1.0,0.0,0.0);\r\n#define EPS .3\t\r\n\t\tfloat dif = (col.w - map(pos+EPS*sundir).w)/EPS; // grad(dens).L\r\n\r\n\t\tcol.xyz *= .5+.5*clamp(.5*dif, 0.,1.);\r\n\t}\r\n\t\t\r\n\t\tcol.a *= 0.35;\r\n\t\tcol.rgb *= col.a;\r\n\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\t\tt += max(0.1,0.025*t);\r\n\t}\r\n\r\n\tsum.xyz /= (0.001+sum.w);\r\n\r\n\treturn clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = 2.*(fragCoord.xy / iResolution.y -vec2(.8,.7));\r\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\r\n    \r\n    // camera\r\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\r\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\r\n\r\n\t\r\n    vec4 col = raymarch( ro, rd );\r\n\r\n\tvec4 sky;\r\n\t//sky = vec4(1.,1.,1.,1.); \r\n\tsky = vec4(.1,.0,.0,1.);\r\n    fragColor = mix(sky,col,col.w);\r\n}\r\n","inputs":[],"outputs":[],"code":"// --- adapted from 3D noise of inigo quilez \r\n// https://www.shadertoy.com/view/XslGRr\r\n\r\n#define FULL_PROCEDURAL\r\n#ifdef FULL_PROCEDURAL\r\n\r\n// hash based 3d value noise\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n#else\r\n\r\n// LUT based 3d value noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\n#define mynoise(q) (1.-abs(2.*noise(q)-1.))\r\n\r\nfloat fbm( in vec3 q )\r\n{\r\n\tfloat f;\r\n    f  = 0.5000*mynoise( q ); q = q*2.02;\r\n    f += 0.2500*mynoise( q ); q = q*2.03;\r\n    f += 0.1250*mynoise( q ); q = q*2.01;\r\n    f += 0.0625*mynoise( q );\r\n\treturn f;\r\n}\r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel1,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// shape\r\nvec4 map( in vec3 p )\r\n{\r\n\t\r\n\tfloat l = length(p);\r\n\t\r\n\t// profile: \r\n\t//    dens max on sphere shell l = 1\r\n\t//    density slope stiffer inside (shockwave)\r\n\tfloat d = 1. - l;\r\n    if (d>0.) d = -3.*d;\r\n\t// d = -sqrt(-d);\r\n\t\r\n\t// add noise to profile.\r\n\t// noise = supercondensed \"fire\" fbm \r\n\tfloat n = pow(fbm(p),4.);\r\n\td += 2.5 * n;\r\n\r\n\t// volume cut, for debug\r\n\tif (key_toggle(32.))  if (p.x>0.) d = 0.;\r\n\t\r\n\tvec4 res;\r\n\tres.w = clamp(d, 0., 1. ); // density\r\n\t// color: orange on the shell then darkening red\r\n\tres.xyz = vec3(1./pow(l*1.,1.),.6/pow(l,3.),0.); \r\n\t// transparent blue inside\r\n\tif (!key_toggle(66.)) \r\n\t\tif ((l<1.) && (res.w==0.)) res += vec4(0.,0.,1.,.1);\r\n\t\r\n\treturn clamp(res, 0.0, 1.0 );;\r\n}\r\n\r\n\r\n\r\nvec4 raymarch( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 sum = vec4(0, 0, 0, 0);\r\n\r\n\tfloat t = 0.0;\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\tif( sum.a > 0.99 ) continue;\r\n\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tvec4 col = map( pos ); // .w = density\r\n\t\t\r\n\tif (key_toggle(79.))  // Ombrage\r\n\t{\r\n\t\tvec3 sundir = -normalize(pos); // vec3(-1.0,0.0,0.0);\r\n#define EPS .3\t\r\n\t\tfloat dif = (col.w - map(pos+EPS*sundir).w)/EPS; // grad(dens).L\r\n\r\n\t\tcol.xyz *= .5+.5*clamp(.5*dif, 0.,1.);\r\n\t}\r\n\t\t\r\n\t\tcol.a *= 0.35;\r\n\t\tcol.rgb *= col.a;\r\n\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\t\tt += max(0.1,0.025*t);\r\n\t}\r\n\r\n\tsum.xyz /= (0.001+sum.w);\r\n\r\n\treturn clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = 2.*(fragCoord.xy / iResolution.y -vec2(.8,.7));\r\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\r\n    \r\n    // camera\r\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\r\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\r\n\r\n\t\r\n    vec4 col = raymarch( ro, rd );\r\n\r\n\tvec4 sky;\r\n\t//sky = vec4(1.,1.,1.,1.); \r\n\tsky = vec4(.1,.0,.0,1.);\r\n    fragColor = mix(sky,col,col.w);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Noise animation - Electric\r\n// by nimitz (stormoid.com) (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//The domain is displaced by two fbm calls one for each axis.\r\n//Turbulent fbm (aka ridged) is used for better effect.\r\n\r\n#define time iTime*0.15\r\n#define tau 6.2831853\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\n//float noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat fbm(in vec2 p)\r\n{\t\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 6.;i++)\r\n\t{\r\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\r\n\t\tz = z*2.;\r\n\t\tp = p*2.;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\nfloat dualfbm(in vec2 p)\r\n{\r\n    //get two rotated fbm calls and displace the domain\r\n\tvec2 p2 = p*.7;\r\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\r\n\tbasis = (basis-.5)*.2;\r\n\tp += basis;\r\n\t\r\n\t//coloring\r\n\treturn fbm(p*makem2(time*0.2));\r\n}\r\n\r\nfloat circ(vec2 p) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(sqrt(r));\r\n\treturn abs(mod(r*4.,tau)-3.14)*3.+.2;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//setup system\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*=4.;\r\n\t\r\n    float rz = dualfbm(p);\r\n\t\r\n\t//rings\r\n\tp /= exp(mod(time*10.,3.14159));\r\n\trz *= pow(abs((0.1-circ(p))),.9);\r\n\t\r\n\t//final color\r\n\tvec3 col = vec3(.2,0.1,0.4)/rz;\r\n\tcol=pow(abs(col),vec3(.99));\r\n\tfragColor = vec4(col,1.);\r\n}","inputs":[],"outputs":[],"code":"// Noise animation - Electric\r\n// by nimitz (stormoid.com) (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//The domain is displaced by two fbm calls one for each axis.\r\n//Turbulent fbm (aka ridged) is used for better effect.\r\n\r\n#define time iTime*0.15\r\n#define tau 6.2831853\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\n//float noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat fbm(in vec2 p)\r\n{\t\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 6.;i++)\r\n\t{\r\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\r\n\t\tz = z*2.;\r\n\t\tp = p*2.;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\nfloat dualfbm(in vec2 p)\r\n{\r\n    //get two rotated fbm calls and displace the domain\r\n\tvec2 p2 = p*.7;\r\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\r\n\tbasis = (basis-.5)*.2;\r\n\tp += basis;\r\n\t\r\n\t//coloring\r\n\treturn fbm(p*makem2(time*0.2));\r\n}\r\n\r\nfloat circ(vec2 p) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(sqrt(r));\r\n\treturn abs(mod(r*4.,tau)-3.14)*3.+.2;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//setup system\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*=4.;\r\n\t\r\n    float rz = dualfbm(p);\r\n\t\r\n\t//rings\r\n\tp /= exp(mod(time*10.,3.14159));\r\n\trz *= pow(abs((0.1-circ(p))),.9);\r\n\t\r\n\t//final color\r\n\tvec3 col = vec3(.2,0.1,0.4)/rz;\r\n\tcol=pow(abs(col),vec3(.99));\r\n\tfragColor = vec4(col,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Noise animation - Electric","id":"04b4a594e57d4039bb1b975953e370ec","date":null,"viewed":0,"name":"Noise animation - Electric","description":"Playing with different ways of animating noise. In this version, the domain is displaced by two random fbm noise calls (one for each axis).\nhttps://www.shadertoy.com/view/ldlXRS","likes":0,"published":null,"tags":["procedural"," 2d"," noise"]},"ver":null,"info":{"Name":"Noise animation - Electric","id":"04b4a594e57d4039bb1b975953e370ec","date":null,"viewed":0,"name":"Noise animation - Electric","description":"Playing with different ways of animating noise. In this version, the domain is displaced by two random fbm noise calls (one for each axis).\nhttps://www.shadertoy.com/view/ldlXRS","likes":0,"published":null,"tags":["procedural"," 2d"," noise"]},"renderpass":[{"Code":"// Noise animation - Electric\r\n// by nimitz (stormoid.com) (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//The domain is displaced by two fbm calls one for each axis.\r\n//Turbulent fbm (aka ridged) is used for better effect.\r\n\r\n#define time iTime*0.15\r\n#define tau 6.2831853\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\n//float noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat fbm(in vec2 p)\r\n{\t\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 6.;i++)\r\n\t{\r\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\r\n\t\tz = z*2.;\r\n\t\tp = p*2.;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\nfloat dualfbm(in vec2 p)\r\n{\r\n    //get two rotated fbm calls and displace the domain\r\n\tvec2 p2 = p*.7;\r\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\r\n\tbasis = (basis-.5)*.2;\r\n\tp += basis;\r\n\t\r\n\t//coloring\r\n\treturn fbm(p*makem2(time*0.2));\r\n}\r\n\r\nfloat circ(vec2 p) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(sqrt(r));\r\n\treturn abs(mod(r*4.,tau)-3.14)*3.+.2;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//setup system\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*=4.;\r\n\t\r\n    float rz = dualfbm(p);\r\n\t\r\n\t//rings\r\n\tp /= exp(mod(time*10.,3.14159));\r\n\trz *= pow(abs((0.1-circ(p))),.9);\r\n\t\r\n\t//final color\r\n\tvec3 col = vec3(.2,0.1,0.4)/rz;\r\n\tcol=pow(abs(col),vec3(.99));\r\n\tfragColor = vec4(col,1.);\r\n}","inputs":[],"outputs":[],"code":"// Noise animation - Electric\r\n// by nimitz (stormoid.com) (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//The domain is displaced by two fbm calls one for each axis.\r\n//Turbulent fbm (aka ridged) is used for better effect.\r\n\r\n#define time iTime*0.15\r\n#define tau 6.2831853\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\n//float noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat fbm(in vec2 p)\r\n{\t\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 6.;i++)\r\n\t{\r\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\r\n\t\tz = z*2.;\r\n\t\tp = p*2.;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\nfloat dualfbm(in vec2 p)\r\n{\r\n    //get two rotated fbm calls and displace the domain\r\n\tvec2 p2 = p*.7;\r\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\r\n\tbasis = (basis-.5)*.2;\r\n\tp += basis;\r\n\t\r\n\t//coloring\r\n\treturn fbm(p*makem2(time*0.2));\r\n}\r\n\r\nfloat circ(vec2 p) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(sqrt(r));\r\n\treturn abs(mod(r*4.,tau)-3.14)*3.+.2;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//setup system\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*=4.;\r\n\t\r\n    float rz = dualfbm(p);\r\n\t\r\n\t//rings\r\n\tp /= exp(mod(time*10.,3.14159));\r\n\trz *= pow(abs((0.1-circ(p))),.9);\r\n\t\r\n\t//final color\r\n\tvec3 col = vec3(.2,0.1,0.4)/rz;\r\n\tcol=pow(abs(col),vec3(.99));\r\n\tfragColor = vec4(col,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Noise animation - Flow\r\n// 2014 by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/MdlXRS\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n\r\n//Somewhat inspired by the concepts behind \"flow noise\"\r\n//every octave of noise is modulated separately\r\n//with displacement using a rotated vector field\r\n\r\n//normalization is used to created \"swirls\"\r\n//usually not a good idea, depending on the type of noise\r\n//you are going for.\r\n\r\n//Sinus ridged fbm is used for better effect.\r\n\r\n#define time iTime*0.1\r\n#define tau 6.2831853\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\nfloat noise( in vec2 x ){return value_noise(x*12.);}\r\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat grid(vec2 p)\r\n{\r\n\tfloat s = sin(p.x)*cos(p.y);\r\n\treturn s;\r\n}\r\n\r\nfloat flow(in vec2 p)\r\n{\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 7.;i++ )\r\n\t{\r\n\t\tbp += time*1.5;\r\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\r\n\t\tgr = normalize(gr)*0.4;\r\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\r\n\t\tp += gr*0.5;\r\n\t\t\r\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) /z;\r\n\t\t\r\n\t\tp = mix(bp,p,.5);\r\n\t\tz *= 1.7;\r\n\t\tp *= 2.5;\r\n\t\tp*=m2;\r\n\t\tbp *= 2.5;\r\n\t\tbp*=m2;\r\n\t}\r\n\treturn rz;\t\r\n}\r\n\r\nfloat spiral(vec2 p,float scl) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(r);\r\n\tfloat a = atan(p.y, p.x);\r\n\treturn abs(mod(scl*(r-2./scl*a),tau)-1.)*2.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*= 3.;\r\n\tfloat rz = flow(p);\r\n\tp /= exp(mod(time*3.,2.1));\r\n\trz *= (6.-spiral(p,3.))*.9;\r\n\tvec3 col = vec3(.2,0.07,0.01)/rz;\r\n\tcol=pow(abs(col),vec3(1.01));\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Noise animation - Flow\r\n// 2014 by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/MdlXRS\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n\r\n//Somewhat inspired by the concepts behind \"flow noise\"\r\n//every octave of noise is modulated separately\r\n//with displacement using a rotated vector field\r\n\r\n//normalization is used to created \"swirls\"\r\n//usually not a good idea, depending on the type of noise\r\n//you are going for.\r\n\r\n//Sinus ridged fbm is used for better effect.\r\n\r\n#define time iTime*0.1\r\n#define tau 6.2831853\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\nfloat noise( in vec2 x ){return value_noise(x*12.);}\r\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat grid(vec2 p)\r\n{\r\n\tfloat s = sin(p.x)*cos(p.y);\r\n\treturn s;\r\n}\r\n\r\nfloat flow(in vec2 p)\r\n{\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 7.;i++ )\r\n\t{\r\n\t\tbp += time*1.5;\r\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\r\n\t\tgr = normalize(gr)*0.4;\r\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\r\n\t\tp += gr*0.5;\r\n\t\t\r\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) /z;\r\n\t\t\r\n\t\tp = mix(bp,p,.5);\r\n\t\tz *= 1.7;\r\n\t\tp *= 2.5;\r\n\t\tp*=m2;\r\n\t\tbp *= 2.5;\r\n\t\tbp*=m2;\r\n\t}\r\n\treturn rz;\t\r\n}\r\n\r\nfloat spiral(vec2 p,float scl) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(r);\r\n\tfloat a = atan(p.y, p.x);\r\n\treturn abs(mod(scl*(r-2./scl*a),tau)-1.)*2.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*= 3.;\r\n\tfloat rz = flow(p);\r\n\tp /= exp(mod(time*3.,2.1));\r\n\trz *= (6.-spiral(p,3.))*.9;\r\n\tvec3 col = vec3(.2,0.07,0.01)/rz;\r\n\tcol=pow(abs(col),vec3(1.01));\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Noise animation - Flow","id":"7780d394fe074db1959978331a7d2da1","date":null,"viewed":0,"name":"Noise animation - Flow","description":"Playing with different ways of animating noise. In this version, the noise is made using a technique similar to \"flow noise\" (maybe it even qualifies as flow noise)\nhttps://www.shadertoy.com/view/MdlXRS","likes":0,"published":null,"tags":["procedural"," 2d"," noise"]},"ver":null,"info":{"Name":"Noise animation - Flow","id":"7780d394fe074db1959978331a7d2da1","date":null,"viewed":0,"name":"Noise animation - Flow","description":"Playing with different ways of animating noise. In this version, the noise is made using a technique similar to \"flow noise\" (maybe it even qualifies as flow noise)\nhttps://www.shadertoy.com/view/MdlXRS","likes":0,"published":null,"tags":["procedural"," 2d"," noise"]},"renderpass":[{"Code":"// Noise animation - Flow\r\n// 2014 by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/MdlXRS\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n\r\n//Somewhat inspired by the concepts behind \"flow noise\"\r\n//every octave of noise is modulated separately\r\n//with displacement using a rotated vector field\r\n\r\n//normalization is used to created \"swirls\"\r\n//usually not a good idea, depending on the type of noise\r\n//you are going for.\r\n\r\n//Sinus ridged fbm is used for better effect.\r\n\r\n#define time iTime*0.1\r\n#define tau 6.2831853\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\nfloat noise( in vec2 x ){return value_noise(x*12.);}\r\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat grid(vec2 p)\r\n{\r\n\tfloat s = sin(p.x)*cos(p.y);\r\n\treturn s;\r\n}\r\n\r\nfloat flow(in vec2 p)\r\n{\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 7.;i++ )\r\n\t{\r\n\t\tbp += time*1.5;\r\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\r\n\t\tgr = normalize(gr)*0.4;\r\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\r\n\t\tp += gr*0.5;\r\n\t\t\r\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) /z;\r\n\t\t\r\n\t\tp = mix(bp,p,.5);\r\n\t\tz *= 1.7;\r\n\t\tp *= 2.5;\r\n\t\tp*=m2;\r\n\t\tbp *= 2.5;\r\n\t\tbp*=m2;\r\n\t}\r\n\treturn rz;\t\r\n}\r\n\r\nfloat spiral(vec2 p,float scl) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(r);\r\n\tfloat a = atan(p.y, p.x);\r\n\treturn abs(mod(scl*(r-2./scl*a),tau)-1.)*2.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*= 3.;\r\n\tfloat rz = flow(p);\r\n\tp /= exp(mod(time*3.,2.1));\r\n\trz *= (6.-spiral(p,3.))*.9;\r\n\tvec3 col = vec3(.2,0.07,0.01)/rz;\r\n\tcol=pow(abs(col),vec3(1.01));\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Noise animation - Flow\r\n// 2014 by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/MdlXRS\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n\r\n//Somewhat inspired by the concepts behind \"flow noise\"\r\n//every octave of noise is modulated separately\r\n//with displacement using a rotated vector field\r\n\r\n//normalization is used to created \"swirls\"\r\n//usually not a good idea, depending on the type of noise\r\n//you are going for.\r\n\r\n//Sinus ridged fbm is used for better effect.\r\n\r\n#define time iTime*0.1\r\n#define tau 6.2831853\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\nfloat noise( in vec2 x ){return value_noise(x*12.);}\r\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat grid(vec2 p)\r\n{\r\n\tfloat s = sin(p.x)*cos(p.y);\r\n\treturn s;\r\n}\r\n\r\nfloat flow(in vec2 p)\r\n{\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 7.;i++ )\r\n\t{\r\n\t\tbp += time*1.5;\r\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\r\n\t\tgr = normalize(gr)*0.4;\r\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\r\n\t\tp += gr*0.5;\r\n\t\t\r\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) /z;\r\n\t\t\r\n\t\tp = mix(bp,p,.5);\r\n\t\tz *= 1.7;\r\n\t\tp *= 2.5;\r\n\t\tp*=m2;\r\n\t\tbp *= 2.5;\r\n\t\tbp*=m2;\r\n\t}\r\n\treturn rz;\t\r\n}\r\n\r\nfloat spiral(vec2 p,float scl) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(r);\r\n\tfloat a = atan(p.y, p.x);\r\n\treturn abs(mod(scl*(r-2./scl*a),tau)-1.)*2.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*= 3.;\r\n\tfloat rz = flow(p);\r\n\tp /= exp(mod(time*3.,2.1));\r\n\trz *= (6.-spiral(p,3.))*.9;\r\n\tvec3 col = vec3(.2,0.07,0.01)/rz;\r\n\tcol=pow(abs(col),vec3(1.01));\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define SAMPLE 200      // per 1x1 pixel bin\r\n#define STEP 32.        // bin width\r\n#define LAZZY 1         // lazzy exact noise evaluation\r\n#define SMOOTH 0.       // smooth histogramm on 3 values.  0. / 1. / sub-relaxation\r\n#define NOISE_SRC 1  \t// 0: texture 1: math\r\n\r\n\r\n#define NOISE_TYPE 1    // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n\r\n#define ANIM 1          \r\n#define PI 3.14159\r\n\r\nfloat t;\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n#if NOISE_SRC==0\r\n\treturn texture(iChannel0,vec2(n,n/256.)).r;\r\n#elif NOISE_SRC==1\r\n\treturn fract(sin(n-765.36334)*43758.5453);\r\n#endif\r\n   \r\n    \r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE_TYPE==1\r\n\treturn res;\r\n#elif NOISE_TYPE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE_TYPE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n// for noise to be thresholded, we not always need to compute high freq\r\n\r\nfloat fbm_lazzy( vec3 p , float v0, float v1) // v0,v1: min/max thresholds\r\n{\r\n    float v01 = .5*(v0+v1), dv = .5*(v1-v0);\r\n\tfloat s=1.,f,r=1.,t;\r\n\t\r\n\t              s*=.5; f  = s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.02; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.03; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r;\r\n\tp = m*p*2.01; s*=.5; f += s*noise( p );\r\n\r\n    return f;\r\n}\r\n\r\n\r\n// calc histogramm of noise\r\n\r\nfloat histogramm(vec2 uv) {\r\n\tfloat dx = dFdx(uv.x)*STEP;   // slice size\r\n\tfloat s = 0., q=0., n;\r\n#if ANIM\r\n  float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\t\r\n\tfor (int j=0; j<= SAMPLE; j++)\r\n\t{\r\n\t\tfloat y = float(j)/float(SAMPLE);\r\n#if !LAZZY\r\n\t\tn = fbm(8.*vec3(0.,y,t));\r\n#else\r\n\t\tn = fbm_lazzy(8.*vec3(0.,y,t), uv.x, uv.x+dx);\r\n#endif\r\n\r\n\t\tif (abs(n-uv.x) < .5*dx) s++;\r\n\t\tq++;\r\n\t}\r\n\treturn .1*s/(q*dx);\r\n}\r\n\r\n\r\n// smmothing using hardware derivatives. if SMOOTH <1, sub-relaxation\r\n\r\nfloat smoothf(float v)\r\n{\r\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\r\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\r\n\r\n\treturn v + SMOOTH*(vx+vy)/3.;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    FragCoord=fragCoord;\r\n\tvec3 col=vec3(0.);\r\n\tif (uv.y < exp(-.5*pow((uv.x-.5)/.15,2.))*.5) col = vec3(0.,0.,.5);\r\n\tif (mod(uv.y,.1)<=1./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.y,.5)<=4./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.x,.1)<=1./iResolution.x) col = vec3(1.,0.,0.);\r\n\tif (mod(uv.x,.5)<=4./iResolution.x) col = vec3(1.,0.,0.);\r\n\t\r\n\t\r\n\tfloat t = histogramm(uv);\r\n\t\r\n\tif (SMOOTH != 0.) t = smoothf(t);  // average with neightboor pixels\r\n\tif (t > uv.y)  col=vec3(1.);\t\t     // draw bar\r\n\t\r\n\tfragColor = vec4(col,1.); \r\n}\r\n","inputs":[],"outputs":[],"code":"#define SAMPLE 200      // per 1x1 pixel bin\r\n#define STEP 32.        // bin width\r\n#define LAZZY 1         // lazzy exact noise evaluation\r\n#define SMOOTH 0.       // smooth histogramm on 3 values.  0. / 1. / sub-relaxation\r\n#define NOISE_SRC 1  \t// 0: texture 1: math\r\n\r\n\r\n#define NOISE_TYPE 1    // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n\r\n#define ANIM 1          \r\n#define PI 3.14159\r\n\r\nfloat t;\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n#if NOISE_SRC==0\r\n\treturn texture(iChannel0,vec2(n,n/256.)).r;\r\n#elif NOISE_SRC==1\r\n\treturn fract(sin(n-765.36334)*43758.5453);\r\n#endif\r\n   \r\n    \r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE_TYPE==1\r\n\treturn res;\r\n#elif NOISE_TYPE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE_TYPE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n// for noise to be thresholded, we not always need to compute high freq\r\n\r\nfloat fbm_lazzy( vec3 p , float v0, float v1) // v0,v1: min/max thresholds\r\n{\r\n    float v01 = .5*(v0+v1), dv = .5*(v1-v0);\r\n\tfloat s=1.,f,r=1.,t;\r\n\t\r\n\t              s*=.5; f  = s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.02; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.03; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r;\r\n\tp = m*p*2.01; s*=.5; f += s*noise( p );\r\n\r\n    return f;\r\n}\r\n\r\n\r\n// calc histogramm of noise\r\n\r\nfloat histogramm(vec2 uv) {\r\n\tfloat dx = dFdx(uv.x)*STEP;   // slice size\r\n\tfloat s = 0., q=0., n;\r\n#if ANIM\r\n  float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\t\r\n\tfor (int j=0; j<= SAMPLE; j++)\r\n\t{\r\n\t\tfloat y = float(j)/float(SAMPLE);\r\n#if !LAZZY\r\n\t\tn = fbm(8.*vec3(0.,y,t));\r\n#else\r\n\t\tn = fbm_lazzy(8.*vec3(0.,y,t), uv.x, uv.x+dx);\r\n#endif\r\n\r\n\t\tif (abs(n-uv.x) < .5*dx) s++;\r\n\t\tq++;\r\n\t}\r\n\treturn .1*s/(q*dx);\r\n}\r\n\r\n\r\n// smmothing using hardware derivatives. if SMOOTH <1, sub-relaxation\r\n\r\nfloat smoothf(float v)\r\n{\r\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\r\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\r\n\r\n\treturn v + SMOOTH*(vx+vy)/3.;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    FragCoord=fragCoord;\r\n\tvec3 col=vec3(0.);\r\n\tif (uv.y < exp(-.5*pow((uv.x-.5)/.15,2.))*.5) col = vec3(0.,0.,.5);\r\n\tif (mod(uv.y,.1)<=1./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.y,.5)<=4./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.x,.1)<=1./iResolution.x) col = vec3(1.,0.,0.);\r\n\tif (mod(uv.x,.5)<=4./iResolution.x) col = vec3(1.,0.,0.);\r\n\t\r\n\t\r\n\tfloat t = histogramm(uv);\r\n\t\r\n\tif (SMOOTH != 0.) t = smoothf(t);  // average with neightboor pixels\r\n\tif (t > uv.y)  col=vec3(1.);\t\t     // draw bar\r\n\t\r\n\tfragColor = vec4(col,1.); \r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"noise histogramm 2","id":"e41919e0fd744327ada0b1108b8953de","date":null,"viewed":0,"name":"noise histogramm 2","description":"Evaluates histogramm of Perlin noise algorithms.\nIn theory fbm should be Gaussian...\nTry larger STEP to better average.\nhttps://www.shadertoy.com/view/XdXSR8","likes":0,"published":null,"tags":["noise"," perlin"," histogramm"]},"ver":null,"info":{"Name":"noise histogramm 2","id":"e41919e0fd744327ada0b1108b8953de","date":null,"viewed":0,"name":"noise histogramm 2","description":"Evaluates histogramm of Perlin noise algorithms.\nIn theory fbm should be Gaussian...\nTry larger STEP to better average.\nhttps://www.shadertoy.com/view/XdXSR8","likes":0,"published":null,"tags":["noise"," perlin"," histogramm"]},"renderpass":[{"Code":"#define SAMPLE 200      // per 1x1 pixel bin\r\n#define STEP 32.        // bin width\r\n#define LAZZY 1         // lazzy exact noise evaluation\r\n#define SMOOTH 0.       // smooth histogramm on 3 values.  0. / 1. / sub-relaxation\r\n#define NOISE_SRC 1  \t// 0: texture 1: math\r\n\r\n\r\n#define NOISE_TYPE 1    // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n\r\n#define ANIM 1          \r\n#define PI 3.14159\r\n\r\nfloat t;\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n#if NOISE_SRC==0\r\n\treturn texture(iChannel0,vec2(n,n/256.)).r;\r\n#elif NOISE_SRC==1\r\n\treturn fract(sin(n-765.36334)*43758.5453);\r\n#endif\r\n   \r\n    \r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE_TYPE==1\r\n\treturn res;\r\n#elif NOISE_TYPE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE_TYPE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n// for noise to be thresholded, we not always need to compute high freq\r\n\r\nfloat fbm_lazzy( vec3 p , float v0, float v1) // v0,v1: min/max thresholds\r\n{\r\n    float v01 = .5*(v0+v1), dv = .5*(v1-v0);\r\n\tfloat s=1.,f,r=1.,t;\r\n\t\r\n\t              s*=.5; f  = s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.02; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.03; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r;\r\n\tp = m*p*2.01; s*=.5; f += s*noise( p );\r\n\r\n    return f;\r\n}\r\n\r\n\r\n// calc histogramm of noise\r\n\r\nfloat histogramm(vec2 uv) {\r\n\tfloat dx = dFdx(uv.x)*STEP;   // slice size\r\n\tfloat s = 0., q=0., n;\r\n#if ANIM\r\n  float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\t\r\n\tfor (int j=0; j<= SAMPLE; j++)\r\n\t{\r\n\t\tfloat y = float(j)/float(SAMPLE);\r\n#if !LAZZY\r\n\t\tn = fbm(8.*vec3(0.,y,t));\r\n#else\r\n\t\tn = fbm_lazzy(8.*vec3(0.,y,t), uv.x, uv.x+dx);\r\n#endif\r\n\r\n\t\tif (abs(n-uv.x) < .5*dx) s++;\r\n\t\tq++;\r\n\t}\r\n\treturn .1*s/(q*dx);\r\n}\r\n\r\n\r\n// smmothing using hardware derivatives. if SMOOTH <1, sub-relaxation\r\n\r\nfloat smoothf(float v)\r\n{\r\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\r\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\r\n\r\n\treturn v + SMOOTH*(vx+vy)/3.;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    FragCoord=fragCoord;\r\n\tvec3 col=vec3(0.);\r\n\tif (uv.y < exp(-.5*pow((uv.x-.5)/.15,2.))*.5) col = vec3(0.,0.,.5);\r\n\tif (mod(uv.y,.1)<=1./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.y,.5)<=4./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.x,.1)<=1./iResolution.x) col = vec3(1.,0.,0.);\r\n\tif (mod(uv.x,.5)<=4./iResolution.x) col = vec3(1.,0.,0.);\r\n\t\r\n\t\r\n\tfloat t = histogramm(uv);\r\n\t\r\n\tif (SMOOTH != 0.) t = smoothf(t);  // average with neightboor pixels\r\n\tif (t > uv.y)  col=vec3(1.);\t\t     // draw bar\r\n\t\r\n\tfragColor = vec4(col,1.); \r\n}\r\n","inputs":[],"outputs":[],"code":"#define SAMPLE 200      // per 1x1 pixel bin\r\n#define STEP 32.        // bin width\r\n#define LAZZY 1         // lazzy exact noise evaluation\r\n#define SMOOTH 0.       // smooth histogramm on 3 values.  0. / 1. / sub-relaxation\r\n#define NOISE_SRC 1  \t// 0: texture 1: math\r\n\r\n\r\n#define NOISE_TYPE 1    // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n\r\n#define ANIM 1          \r\n#define PI 3.14159\r\n\r\nfloat t;\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n#if NOISE_SRC==0\r\n\treturn texture(iChannel0,vec2(n,n/256.)).r;\r\n#elif NOISE_SRC==1\r\n\treturn fract(sin(n-765.36334)*43758.5453);\r\n#endif\r\n   \r\n    \r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE_TYPE==1\r\n\treturn res;\r\n#elif NOISE_TYPE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE_TYPE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n// for noise to be thresholded, we not always need to compute high freq\r\n\r\nfloat fbm_lazzy( vec3 p , float v0, float v1) // v0,v1: min/max thresholds\r\n{\r\n    float v01 = .5*(v0+v1), dv = .5*(v1-v0);\r\n\tfloat s=1.,f,r=1.,t;\r\n\t\r\n\t              s*=.5; f  = s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.02; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.03; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r;\r\n\tp = m*p*2.01; s*=.5; f += s*noise( p );\r\n\r\n    return f;\r\n}\r\n\r\n\r\n// calc histogramm of noise\r\n\r\nfloat histogramm(vec2 uv) {\r\n\tfloat dx = dFdx(uv.x)*STEP;   // slice size\r\n\tfloat s = 0., q=0., n;\r\n#if ANIM\r\n  float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\t\r\n\tfor (int j=0; j<= SAMPLE; j++)\r\n\t{\r\n\t\tfloat y = float(j)/float(SAMPLE);\r\n#if !LAZZY\r\n\t\tn = fbm(8.*vec3(0.,y,t));\r\n#else\r\n\t\tn = fbm_lazzy(8.*vec3(0.,y,t), uv.x, uv.x+dx);\r\n#endif\r\n\r\n\t\tif (abs(n-uv.x) < .5*dx) s++;\r\n\t\tq++;\r\n\t}\r\n\treturn .1*s/(q*dx);\r\n}\r\n\r\n\r\n// smmothing using hardware derivatives. if SMOOTH <1, sub-relaxation\r\n\r\nfloat smoothf(float v)\r\n{\r\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\r\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\r\n\r\n\treturn v + SMOOTH*(vx+vy)/3.;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    FragCoord=fragCoord;\r\n\tvec3 col=vec3(0.);\r\n\tif (uv.y < exp(-.5*pow((uv.x-.5)/.15,2.))*.5) col = vec3(0.,0.,.5);\r\n\tif (mod(uv.y,.1)<=1./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.y,.5)<=4./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.x,.1)<=1./iResolution.x) col = vec3(1.,0.,0.);\r\n\tif (mod(uv.x,.5)<=4./iResolution.x) col = vec3(1.,0.,0.);\r\n\t\r\n\t\r\n\tfloat t = histogramm(uv);\r\n\t\r\n\tif (SMOOTH != 0.) t = smoothf(t);  // average with neightboor pixels\r\n\tif (t > uv.y)  col=vec3(1.);\t\t     // draw bar\r\n\t\r\n\tfragColor = vec4(col,1.); \r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Noise-Based Procedural Flame","id":"Wtc3RB","date":"0","viewed":0,"name":"Noise-Based Procedural Flame","description":"\u8FC7\u7A0B\u6027\u706B\u7130","likes":0,"published":"Private","tags":["procedural","noise","flame"]},"ver":"0.1","info":{"Name":"Noise-Based Procedural Flame","id":"Wtc3RB","date":"0","viewed":0,"name":"Noise-Based Procedural Flame","description":"\u8FC7\u7A0B\u6027\u706B\u7130","likes":0,"published":"Private","tags":["procedural","noise","flame"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"float hash(float n)\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise(vec2 p)\r\n{\r\n    return hash(p.x + p.y*57.0);\r\n}\r\n\r\nfloat valnoise(vec2 p)\r\n{\r\n    vec2 c=floor(p);\r\n    vec2 f=smoothstep(0.,1.,fract(p));\r\n    return mix (mix(noise(c+vec2(0,0)), noise(c+vec2(1,0)), f.x),\r\n                mix(noise(c+vec2(0,1)), noise(c+vec2(1,1)), f.x), f.y);\r\n}\r\n\r\nfloat time;\r\n\r\nvec2 t;\r\n\r\nfloat ti;\r\nfloat col=1e3,col2=1e3,col3=1e3;\r\n\r\n// Signed distance field function.\r\nfloat f(vec3 p)\r\n{\r\n    col3=p.y-(.5+.5*cos(p.x*2.))*.1;\r\n\r\n    float d=max(col3,length(p.xz)-5.5);\r\n    float s=1.,ss=1.6;\r\n    \r\n    // Tangent vectors for the branch local coordinate system.\r\n    vec3 w=normalize(vec3(-.8+cos(iTime/30.)*.01,1.2,-1.));\r\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\r\n\r\n    int j=int(min(floor(ti-1.),7.));\r\n\r\n    float scale=min(.3+ti/6.,1.);\r\n    p/=scale;\r\n\r\n    // Evaluate the tree branches, which are just space-folded cylinders.\r\n    for(int i=0;\r\n        d=min(d,scale*max(p.y-1.,max(-p.y,length(p.xz)-.1/(p.y+.7)))/s),\r\n        p.xz=abs(p.xz),\r\n        p.y-=1.,\r\n        i<j;\r\n        p*=mat3(u,normalize(cross(u,w)),w), // Rotate in to the local space of a branch.\r\n        p*=ss,\r\n        s*=ss,\r\n        ++i);\r\n\r\n    return min(d,col=max(0.,length(p)-.25)/s);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n\r\n    t=(uv*2.-1.)*.5;\r\n    t.x*=iResolution.x/iResolution.y;\r\n\r\n    time=140.;\r\n\r\n    // Timing value used in the original demo.\r\n    ti=max(0.,time)/3.;\r\n    ti=noise(floor(gl_FragCoord.xy))+(floor(ti)+clamp(fract(ti)*2.,0.,1.));\r\n    ti=floor(ti);\r\n\r\n    float zoom=1.5;\r\n    vec2 filmoffset=vec2(0);\r\n\r\n    // Set up camera and primary ray.\r\n    vec3 ro=vec3(-2.5+cos(iTime/4.),.1+cos(ti*17.)*.1+iMouse.y/iResolution.y*2.,3.5);\r\n    vec3 rd=normalize(vec3(t.xy+filmoffset,zoom));\r\n    if(ti==10.)ro.y+=2.;\r\n    vec3 camtarget=vec3(0,1.3,0);\r\n\r\n    vec3 w=normalize(camtarget-ro);\r\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\r\n    vec3 v=normalize(cross(w,-u));\r\n\r\n    rd=mat3(u,v,w)*rd;\r\n\r\n    fragColor.rgb=vec3(.8,.8,1.)/6.;\r\n    float s=20.;\r\n\r\n    // Signed distance field raymarch.\r\n    float t=0.,d=0.;\r\n    for(int i=0;i<100;++i)\r\n    {\r\n        d=f(ro+rd*t);\r\n        if(d<1e-3)break;\r\n        t+=d;\r\n        if(t>10.)return;\r\n    }\r\n\r\n    // Colourise ground, branch/trunk, or cherry blossom.\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        fragColor.rgb=vec3(.75,.6,.4)/1.5;\r\n        if(col<2e-3)fragColor.rgb=vec3(1.,.7,.8);\r\n        if(col3<2e-2&&(ti<17.||ti>22.))fragColor.rgb=vec3(.5,1.,.6)/3.;\r\n    }\r\n\r\n    // Lighting.\r\n    vec3 ld=normalize(vec3(1.,3.+cos(ti)/2.,1.+sin(ti*3.)/2.));\r\n    float e=1e-2;\r\n    float d2=f(ro+rd*t+ld*e);\r\n    float l=max(0.,(d2-d)/e);\r\n\r\n    float d3=f(ro+rd*t+vec3(0,1,0)*e);\r\n    float l2=max(0.,.5+.5*(d3-d)/e);\r\n\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        if(ti>12.&&ti<22.)\r\n            if(col2<1e-2||d3+d2/7.>0.0017&&pow(valnoise(rp.xz*8.),2.)>abs(ti-18.)/5.)fragColor.rgb=vec3(.65);\r\n    }\r\n\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        if(ti>12.&&ti<17.)\r\n            if(col2<1e-2||d3+d2/7.>0.0017&&valnoise(rp.xz*8.)<(ti-12.)/3.)fragColor.rgb=vec3(.65);\r\n    }\r\n\r\n    vec3 rp=ro+rd*(t-1e-3);\r\n\r\n    // Directional shadow.\r\n    t=0.1;\r\n    float sh=1.;\r\n    for(int i=0;i<30;++i)\r\n    {\r\n        d=f(rp+ld*t)+.01;\r\n        sh=min(sh,d*50.+0.3);\r\n        if(d<1e-4)break;\r\n        t+=d;\r\n    }\r\n\r\n    fragColor.rgb*=1.*sh*(.2+.8*l)*vec3(1.,1.,.9)*.7+l2*vec3(.85,.85,1.)*.4;\r\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\r\n}","inputs":[],"outputs":[],"code":"float hash(float n)\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise(vec2 p)\r\n{\r\n    return hash(p.x + p.y*57.0);\r\n}\r\n\r\nfloat valnoise(vec2 p)\r\n{\r\n    vec2 c=floor(p);\r\n    vec2 f=smoothstep(0.,1.,fract(p));\r\n    return mix (mix(noise(c+vec2(0,0)), noise(c+vec2(1,0)), f.x),\r\n                mix(noise(c+vec2(0,1)), noise(c+vec2(1,1)), f.x), f.y);\r\n}\r\n\r\nfloat time;\r\n\r\nvec2 t;\r\n\r\nfloat ti;\r\nfloat col=1e3,col2=1e3,col3=1e3;\r\n\r\n// Signed distance field function.\r\nfloat f(vec3 p)\r\n{\r\n    col3=p.y-(.5+.5*cos(p.x*2.))*.1;\r\n\r\n    float d=max(col3,length(p.xz)-5.5);\r\n    float s=1.,ss=1.6;\r\n    \r\n    // Tangent vectors for the branch local coordinate system.\r\n    vec3 w=normalize(vec3(-.8+cos(iTime/30.)*.01,1.2,-1.));\r\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\r\n\r\n    int j=int(min(floor(ti-1.),7.));\r\n\r\n    float scale=min(.3+ti/6.,1.);\r\n    p/=scale;\r\n\r\n    // Evaluate the tree branches, which are just space-folded cylinders.\r\n    for(int i=0;\r\n        d=min(d,scale*max(p.y-1.,max(-p.y,length(p.xz)-.1/(p.y+.7)))/s),\r\n        p.xz=abs(p.xz),\r\n        p.y-=1.,\r\n        i<j;\r\n        p*=mat3(u,normalize(cross(u,w)),w), // Rotate in to the local space of a branch.\r\n        p*=ss,\r\n        s*=ss,\r\n        ++i);\r\n\r\n    return min(d,col=max(0.,length(p)-.25)/s);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n\r\n    t=(uv*2.-1.)*.5;\r\n    t.x*=iResolution.x/iResolution.y;\r\n\r\n    time=140.;\r\n\r\n    // Timing value used in the original demo.\r\n    ti=max(0.,time)/3.;\r\n    ti=noise(floor(gl_FragCoord.xy))+(floor(ti)+clamp(fract(ti)*2.,0.,1.));\r\n    ti=floor(ti);\r\n\r\n    float zoom=1.5;\r\n    vec2 filmoffset=vec2(0);\r\n\r\n    // Set up camera and primary ray.\r\n    vec3 ro=vec3(-2.5+cos(iTime/4.),.1+cos(ti*17.)*.1+iMouse.y/iResolution.y*2.,3.5);\r\n    vec3 rd=normalize(vec3(t.xy+filmoffset,zoom));\r\n    if(ti==10.)ro.y+=2.;\r\n    vec3 camtarget=vec3(0,1.3,0);\r\n\r\n    vec3 w=normalize(camtarget-ro);\r\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\r\n    vec3 v=normalize(cross(w,-u));\r\n\r\n    rd=mat3(u,v,w)*rd;\r\n\r\n    fragColor.rgb=vec3(.8,.8,1.)/6.;\r\n    float s=20.;\r\n\r\n    // Signed distance field raymarch.\r\n    float t=0.,d=0.;\r\n    for(int i=0;i<100;++i)\r\n    {\r\n        d=f(ro+rd*t);\r\n        if(d<1e-3)break;\r\n        t+=d;\r\n        if(t>10.)return;\r\n    }\r\n\r\n    // Colourise ground, branch/trunk, or cherry blossom.\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        fragColor.rgb=vec3(.75,.6,.4)/1.5;\r\n        if(col<2e-3)fragColor.rgb=vec3(1.,.7,.8);\r\n        if(col3<2e-2&&(ti<17.||ti>22.))fragColor.rgb=vec3(.5,1.,.6)/3.;\r\n    }\r\n\r\n    // Lighting.\r\n    vec3 ld=normalize(vec3(1.,3.+cos(ti)/2.,1.+sin(ti*3.)/2.));\r\n    float e=1e-2;\r\n    float d2=f(ro+rd*t+ld*e);\r\n    float l=max(0.,(d2-d)/e);\r\n\r\n    float d3=f(ro+rd*t+vec3(0,1,0)*e);\r\n    float l2=max(0.,.5+.5*(d3-d)/e);\r\n\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        if(ti>12.&&ti<22.)\r\n            if(col2<1e-2||d3+d2/7.>0.0017&&pow(valnoise(rp.xz*8.),2.)>abs(ti-18.)/5.)fragColor.rgb=vec3(.65);\r\n    }\r\n\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        if(ti>12.&&ti<17.)\r\n            if(col2<1e-2||d3+d2/7.>0.0017&&valnoise(rp.xz*8.)<(ti-12.)/3.)fragColor.rgb=vec3(.65);\r\n    }\r\n\r\n    vec3 rp=ro+rd*(t-1e-3);\r\n\r\n    // Directional shadow.\r\n    t=0.1;\r\n    float sh=1.;\r\n    for(int i=0;i<30;++i)\r\n    {\r\n        d=f(rp+ld*t)+.01;\r\n        sh=min(sh,d*50.+0.3);\r\n        if(d<1e-4)break;\r\n        t+=d;\r\n    }\r\n\r\n    fragColor.rgb*=1.*sh*(.2+.8*l)*vec3(1.,1.,.9)*.7+l2*vec3(.85,.85,1.)*.4;\r\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Ohanami Stipple","id":"90add3ec88e142609c2a0eb91b0f4133","date":null,"viewed":0,"name":"Ohanami Stipple","description":"This is a port of the code from the \"Ohanami\" 4kb demo: https://www.pouet.net/prod.php?which=71888\nThe code has been left in the minified state, mostly because I don't have the un-minified version of the code anymore. \nUse mouse Y to change camera tilt.\nhttps://www.shadertoy.com/view/4tVcWR","likes":0,"published":null,"tags":["tree"," paint"," pointilism"," blossom"]},"ver":null,"info":{"Name":"Ohanami Stipple","id":"90add3ec88e142609c2a0eb91b0f4133","date":null,"viewed":0,"name":"Ohanami Stipple","description":"This is a port of the code from the \"Ohanami\" 4kb demo: https://www.pouet.net/prod.php?which=71888\nThe code has been left in the minified state, mostly because I don't have the un-minified version of the code anymore. \nUse mouse Y to change camera tilt.\nhttps://www.shadertoy.com/view/4tVcWR","likes":0,"published":null,"tags":["tree"," paint"," pointilism"," blossom"]},"renderpass":[{"Code":"float hash(float n)\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise(vec2 p)\r\n{\r\n    return hash(p.x + p.y*57.0);\r\n}\r\n\r\nfloat valnoise(vec2 p)\r\n{\r\n    vec2 c=floor(p);\r\n    vec2 f=smoothstep(0.,1.,fract(p));\r\n    return mix (mix(noise(c+vec2(0,0)), noise(c+vec2(1,0)), f.x),\r\n                mix(noise(c+vec2(0,1)), noise(c+vec2(1,1)), f.x), f.y);\r\n}\r\n\r\nfloat time;\r\n\r\nvec2 t;\r\n\r\nfloat ti;\r\nfloat col=1e3,col2=1e3,col3=1e3;\r\n\r\n// Signed distance field function.\r\nfloat f(vec3 p)\r\n{\r\n    col3=p.y-(.5+.5*cos(p.x*2.))*.1;\r\n\r\n    float d=max(col3,length(p.xz)-5.5);\r\n    float s=1.,ss=1.6;\r\n    \r\n    // Tangent vectors for the branch local coordinate system.\r\n    vec3 w=normalize(vec3(-.8+cos(iTime/30.)*.01,1.2,-1.));\r\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\r\n\r\n    int j=int(min(floor(ti-1.),7.));\r\n\r\n    float scale=min(.3+ti/6.,1.);\r\n    p/=scale;\r\n\r\n    // Evaluate the tree branches, which are just space-folded cylinders.\r\n    for(int i=0;\r\n        d=min(d,scale*max(p.y-1.,max(-p.y,length(p.xz)-.1/(p.y+.7)))/s),\r\n        p.xz=abs(p.xz),\r\n        p.y-=1.,\r\n        i<j;\r\n        p*=mat3(u,normalize(cross(u,w)),w), // Rotate in to the local space of a branch.\r\n        p*=ss,\r\n        s*=ss,\r\n        ++i);\r\n\r\n    return min(d,col=max(0.,length(p)-.25)/s);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n\r\n    t=(uv*2.-1.)*.5;\r\n    t.x*=iResolution.x/iResolution.y;\r\n\r\n    time=140.;\r\n\r\n    // Timing value used in the original demo.\r\n    ti=max(0.,time)/3.;\r\n    ti=noise(floor(gl_FragCoord.xy))+(floor(ti)+clamp(fract(ti)*2.,0.,1.));\r\n    ti=floor(ti);\r\n\r\n    float zoom=1.5;\r\n    vec2 filmoffset=vec2(0);\r\n\r\n    // Set up camera and primary ray.\r\n    vec3 ro=vec3(-2.5+cos(iTime/4.),.1+cos(ti*17.)*.1+iMouse.y/iResolution.y*2.,3.5);\r\n    vec3 rd=normalize(vec3(t.xy+filmoffset,zoom));\r\n    if(ti==10.)ro.y+=2.;\r\n    vec3 camtarget=vec3(0,1.3,0);\r\n\r\n    vec3 w=normalize(camtarget-ro);\r\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\r\n    vec3 v=normalize(cross(w,-u));\r\n\r\n    rd=mat3(u,v,w)*rd;\r\n\r\n    fragColor.rgb=vec3(.8,.8,1.)/6.;\r\n    float s=20.;\r\n\r\n    // Signed distance field raymarch.\r\n    float t=0.,d=0.;\r\n    for(int i=0;i<100;++i)\r\n    {\r\n        d=f(ro+rd*t);\r\n        if(d<1e-3)break;\r\n        t+=d;\r\n        if(t>10.)return;\r\n    }\r\n\r\n    // Colourise ground, branch/trunk, or cherry blossom.\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        fragColor.rgb=vec3(.75,.6,.4)/1.5;\r\n        if(col<2e-3)fragColor.rgb=vec3(1.,.7,.8);\r\n        if(col3<2e-2&&(ti<17.||ti>22.))fragColor.rgb=vec3(.5,1.,.6)/3.;\r\n    }\r\n\r\n    // Lighting.\r\n    vec3 ld=normalize(vec3(1.,3.+cos(ti)/2.,1.+sin(ti*3.)/2.));\r\n    float e=1e-2;\r\n    float d2=f(ro+rd*t+ld*e);\r\n    float l=max(0.,(d2-d)/e);\r\n\r\n    float d3=f(ro+rd*t+vec3(0,1,0)*e);\r\n    float l2=max(0.,.5+.5*(d3-d)/e);\r\n\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        if(ti>12.&&ti<22.)\r\n            if(col2<1e-2||d3+d2/7.>0.0017&&pow(valnoise(rp.xz*8.),2.)>abs(ti-18.)/5.)fragColor.rgb=vec3(.65);\r\n    }\r\n\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        if(ti>12.&&ti<17.)\r\n            if(col2<1e-2||d3+d2/7.>0.0017&&valnoise(rp.xz*8.)<(ti-12.)/3.)fragColor.rgb=vec3(.65);\r\n    }\r\n\r\n    vec3 rp=ro+rd*(t-1e-3);\r\n\r\n    // Directional shadow.\r\n    t=0.1;\r\n    float sh=1.;\r\n    for(int i=0;i<30;++i)\r\n    {\r\n        d=f(rp+ld*t)+.01;\r\n        sh=min(sh,d*50.+0.3);\r\n        if(d<1e-4)break;\r\n        t+=d;\r\n    }\r\n\r\n    fragColor.rgb*=1.*sh*(.2+.8*l)*vec3(1.,1.,.9)*.7+l2*vec3(.85,.85,1.)*.4;\r\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\r\n}","inputs":[],"outputs":[],"code":"float hash(float n)\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise(vec2 p)\r\n{\r\n    return hash(p.x + p.y*57.0);\r\n}\r\n\r\nfloat valnoise(vec2 p)\r\n{\r\n    vec2 c=floor(p);\r\n    vec2 f=smoothstep(0.,1.,fract(p));\r\n    return mix (mix(noise(c+vec2(0,0)), noise(c+vec2(1,0)), f.x),\r\n                mix(noise(c+vec2(0,1)), noise(c+vec2(1,1)), f.x), f.y);\r\n}\r\n\r\nfloat time;\r\n\r\nvec2 t;\r\n\r\nfloat ti;\r\nfloat col=1e3,col2=1e3,col3=1e3;\r\n\r\n// Signed distance field function.\r\nfloat f(vec3 p)\r\n{\r\n    col3=p.y-(.5+.5*cos(p.x*2.))*.1;\r\n\r\n    float d=max(col3,length(p.xz)-5.5);\r\n    float s=1.,ss=1.6;\r\n    \r\n    // Tangent vectors for the branch local coordinate system.\r\n    vec3 w=normalize(vec3(-.8+cos(iTime/30.)*.01,1.2,-1.));\r\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\r\n\r\n    int j=int(min(floor(ti-1.),7.));\r\n\r\n    float scale=min(.3+ti/6.,1.);\r\n    p/=scale;\r\n\r\n    // Evaluate the tree branches, which are just space-folded cylinders.\r\n    for(int i=0;\r\n        d=min(d,scale*max(p.y-1.,max(-p.y,length(p.xz)-.1/(p.y+.7)))/s),\r\n        p.xz=abs(p.xz),\r\n        p.y-=1.,\r\n        i<j;\r\n        p*=mat3(u,normalize(cross(u,w)),w), // Rotate in to the local space of a branch.\r\n        p*=ss,\r\n        s*=ss,\r\n        ++i);\r\n\r\n    return min(d,col=max(0.,length(p)-.25)/s);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n\r\n    t=(uv*2.-1.)*.5;\r\n    t.x*=iResolution.x/iResolution.y;\r\n\r\n    time=140.;\r\n\r\n    // Timing value used in the original demo.\r\n    ti=max(0.,time)/3.;\r\n    ti=noise(floor(gl_FragCoord.xy))+(floor(ti)+clamp(fract(ti)*2.,0.,1.));\r\n    ti=floor(ti);\r\n\r\n    float zoom=1.5;\r\n    vec2 filmoffset=vec2(0);\r\n\r\n    // Set up camera and primary ray.\r\n    vec3 ro=vec3(-2.5+cos(iTime/4.),.1+cos(ti*17.)*.1+iMouse.y/iResolution.y*2.,3.5);\r\n    vec3 rd=normalize(vec3(t.xy+filmoffset,zoom));\r\n    if(ti==10.)ro.y+=2.;\r\n    vec3 camtarget=vec3(0,1.3,0);\r\n\r\n    vec3 w=normalize(camtarget-ro);\r\n    vec3 u=normalize(cross(w,vec3(0,1,0)));\r\n    vec3 v=normalize(cross(w,-u));\r\n\r\n    rd=mat3(u,v,w)*rd;\r\n\r\n    fragColor.rgb=vec3(.8,.8,1.)/6.;\r\n    float s=20.;\r\n\r\n    // Signed distance field raymarch.\r\n    float t=0.,d=0.;\r\n    for(int i=0;i<100;++i)\r\n    {\r\n        d=f(ro+rd*t);\r\n        if(d<1e-3)break;\r\n        t+=d;\r\n        if(t>10.)return;\r\n    }\r\n\r\n    // Colourise ground, branch/trunk, or cherry blossom.\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        fragColor.rgb=vec3(.75,.6,.4)/1.5;\r\n        if(col<2e-3)fragColor.rgb=vec3(1.,.7,.8);\r\n        if(col3<2e-2&&(ti<17.||ti>22.))fragColor.rgb=vec3(.5,1.,.6)/3.;\r\n    }\r\n\r\n    // Lighting.\r\n    vec3 ld=normalize(vec3(1.,3.+cos(ti)/2.,1.+sin(ti*3.)/2.));\r\n    float e=1e-2;\r\n    float d2=f(ro+rd*t+ld*e);\r\n    float l=max(0.,(d2-d)/e);\r\n\r\n    float d3=f(ro+rd*t+vec3(0,1,0)*e);\r\n    float l2=max(0.,.5+.5*(d3-d)/e);\r\n\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        if(ti>12.&&ti<22.)\r\n            if(col2<1e-2||d3+d2/7.>0.0017&&pow(valnoise(rp.xz*8.),2.)>abs(ti-18.)/5.)fragColor.rgb=vec3(.65);\r\n    }\r\n\r\n    {\r\n        vec3 rp=ro+rd*t;\r\n        if(ti>12.&&ti<17.)\r\n            if(col2<1e-2||d3+d2/7.>0.0017&&valnoise(rp.xz*8.)<(ti-12.)/3.)fragColor.rgb=vec3(.65);\r\n    }\r\n\r\n    vec3 rp=ro+rd*(t-1e-3);\r\n\r\n    // Directional shadow.\r\n    t=0.1;\r\n    float sh=1.;\r\n    for(int i=0;i<30;++i)\r\n    {\r\n        d=f(rp+ld*t)+.01;\r\n        sh=min(sh,d*50.+0.3);\r\n        if(d<1e-4)break;\r\n        t+=d;\r\n    }\r\n\r\n    fragColor.rgb*=1.*sh*(.2+.8*l)*vec3(1.,1.,.9)*.7+l2*vec3(.85,.85,1.)*.4;\r\n    fragColor.rgb=clamp(fragColor.rgb,0.,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// -------------------------------------------------------------------------------------------\r\n\r\n// \"ONE WAY TRIP\" by PVM\r\n\r\n// Shadertoy version of our 4k intro entry for Evoke 2019\r\n\r\n// Code: Kali\r\n// Music: Uctumi\r\n\r\n// NOTE: Rewind the shader after it starts to correct audio sync\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// Original code without optimizations for the 4k intro and including PVM logo\r\n\r\n// global variables\r\nfloat det=.005, fin=0., time; // raymarching threshold, aux variable\r\nconst float maxdist=60.; // max distance for raymarching\r\nvec3 ldir=vec3(0.,1.,4.); // light direction (without normalization)\r\nvec3 fcol; // global for coloring\r\nvec3 suncol=vec3(2.,1.,.6); // sun color\r\n\r\n// 2D rotation functions\r\nmat2 rot2D(float a) {\r\n\tfloat s=sin(a);\r\n    float c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\n// A version with degrees used when designing the logo\r\nmat2 rot2Ddeg(float a) {\r\n\ta=radians(a);\r\n    float s=sin(a);\r\n    float c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// PVM LOGO\r\n\r\n\r\n// 2D rectangle with a tilt distortion value\r\nfloat rect(vec2 p, vec2 b, float inc) {\r\n    p.x+=p.y*inc;\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\n// 2D triangle function by iq (I think)\r\nfloat tri(vec2 p, vec2 q, float ang) {\r\n    p*=rot2Ddeg(ang);\r\n    p.x = abs(p.x);\r\n    \r\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\r\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\r\n    float s = -sign( q.y );\r\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\r\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\r\n\r\n    return -sqrt(d.x)*sign(d.y);\r\n}\r\n\r\n\r\n// Here the logo is constructed from distoted rectangles and triangles\r\nvec4 logo(vec2 uv) {\r\n    uv*=1.2;\r\n    uv.x*=1.15;\r\n    uv.y-=.6;\r\n    uv.x-=1.3;\r\n    float d=rect(uv,vec2(.045,.25),-.5);\r\n\tuv.x+=.25;\r\n    uv.y+=.01;\r\n    d=min(d,rect(uv,vec2(.045,.24),.5));\r\n\tuv.x+=.265;\r\n    uv.y-=.04;\r\n    d=min(d,rect(uv,vec2(.045,.2),-.55));\r\n\tuv.x-=.73;\r\n    uv.y-=.06;\r\n    d=min(d,rect(uv,vec2(.045,.16),.4));\r\n\tuv.x-=.105;\r\n    uv.y+=.074;\r\n    d=min(d,rect(uv,vec2(.045,.085),-.45));\r\n\tuv.x-=.105;\r\n    uv.y+=.045;\r\n    d=min(d,rect(uv,vec2(.045,.13),.45));\r\n\tuv.x-=.25;\r\n    uv.y+=.1;\r\n    d=min(d,rect(uv,vec2(.18,.03),.0));\t\r\n\tuv.x+=1.32;\r\n    uv.y-=.18;\r\n    d=min(d,rect(uv+vec2(0.0,.03),vec2(.35,.03),.0));\t\r\n    uv.x-=.5165;\r\n    uv.y+=.4;\r\n    d=min(d,tri(uv,vec2(.09,.185),0.));\r\n    uv.x-=.492;\r\n    uv.y-=.56;\r\n    d=min(d,tri(uv,vec2(.063,.14),180.));\r\n    uv.x+=.225;\r\n    uv.y-=.17;\r\n    d=min(d,tri(uv,vec2(.063,.145),180.));\r\n    uv.x-=.142;\r\n    uv.y+=.555;\r\n    d=min(d,tri(uv,vec2(.063,.145),0.));\r\n    uv.x+=.985;\r\n    uv.y+=.075;\r\n    vec2 uvd=uv-vec2(uv.y,0.);\r\n    d=min(d,tri(uvd-vec2(0.003,0.022),vec2(.04,.05),0.));\r\n    uv.x-=.16\t;\r\n    uv.y-=.63;\r\n    uvd=uv+vec2(uv.y*.4,0.);\r\n    d=min(d,tri(uvd+vec2(.03,0.),vec2(.07,.23),-145.));    \r\n   \tuvd=uv+vec2(.465,.33);\r\n    uvd*=rot2Ddeg(27.);\r\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\r\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\r\n   \tuvd=uv+vec2(-1.43,.534);\r\n    uvd*=rot2Ddeg(206.);\r\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\r\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\r\n    float s=pow(abs(d)+.9,10.);\r\n\tuvd=uv+vec2(-.28,.36);\r\n    uvd*=rot2Ddeg(50.);\r\n    d=max(d,-rect(uvd,vec2(.1,.025),.0));\r\n    // logo coloring, RGBA \r\n    float o=1.-smoothstep(0.,.01,d);\r\n    float l=1.-smoothstep(0.,.05,d);\r\n    vec3 col=mix(vec3(2.,.15,.1),vec3(1.,2.,.5),min(1.,abs(uv.y+.4)));\r\n    return vec4(col*o+.1,l);\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// FRACTAL \r\n\r\n// A bunch of sin and cos that defines the curves of the fractal path\r\n// it returns the displacement at a given point. freq was used to explore diferent scales \r\nvec3 pitpath(float ti) { \r\n\tfloat freq=.5;\r\n    ti*=freq;\r\n\tfloat x=cos(cos(ti*.35682)+ti*.2823)*cos(ti*.1322)*1.5;\r\n\tfloat y=sin(ti*.166453)*4.+cos(cos(ti*.125465)+ti*.17354)*cos(ti*.05123)*2.;\r\n\tvec3  p=vec3(x,y,ti/freq);\r\n\treturn p;\r\n}\r\n\r\n// Distance Estimation function\r\n\r\nfloat de(vec3 pos) {\r\n    float x=1.-smoothstep(5.,8.,abs(pos.x)); // aux variable used for washing the colors away from the path in the fractal\r\n\tpos.y+=.9; // offset y position for the fractal object\r\n\tpos.xy-=pitpath(pos.z).xy; // distortion of coordinates based on the path function\r\n    mat2 rot=rot2D(.5); // rotation matrix used in the fractal iteration loop\r\n    float organic=smoothstep(.5,1.,-sin(pos.z*.005)); // used for the \"organic\" part of the fractal\r\n    mat2 rot2=rot2D(organic*.4); // rotation matrix used in the fractal iteration loop, it mutates the fractal to kinda \"organic\" shapes\r\n    float fold=2.6+sin(pos.z*.01)+organic*1.5; // fold is a parameter for one of the operations inside the fractal loop\r\n    pos.x+=pow(organic,.2)*fold*.75; // x offset for the organic part\r\n    pos.y+=organic*.3; // y offset for the organic part\r\n\tpos.z=abs(5.-mod(pos.z,10.)); // tiling for repeating the fractal along the z axis\r\n    pos.x=abs(10.-mod(pos.x+10.,20.)); // tiling for reapeating along x axis\r\n\tpos.x-=fold; // x offset to center the fractal\r\n    vec4 p=vec4(pos,1.); // w value will be used for calculating the derivative\r\n    vec3 m=vec3(1000.); // for orbit trap coloring\r\n    int it=int(8.+fin*2.); // gives more iterations to the fractal at the end\r\n    // Amazing Surface fractal formula by Kali\r\n    // Derived from Mandelbox by tglad\r\n    for (int i=0; i<it; i++) {\r\n\t\tp.xz=clamp(p.xz,-vec2(fold,2.),vec2(fold,2.))*2.0-p.xz; // fold transform on xz plane\r\n\t\tp.xyz-=vec3(.5,.8,1.); // translation transform\r\n        p=p*(2.-organic*.2)/clamp(dot(p.xyz,p.xyz),.25,1.)-vec4(2.,.5,-1.,0.)*x; // scale + spheric fold + translation transform\r\n\t\t// rotation transforms\r\n        p.xy*=rot;\r\n        p.xz*=rot2; // rotations on xz and yz give the \"organic\" feel for the \"alien reefs\" part\r\n        p.yz*=rot2; \r\n        m=min(m,abs(p.xyz)); // saves the minimum value of the position during the iteration, used for \"orbit traps\" coloring\r\n    }\r\n    // fractal coloring (fcol global variable)\r\n    fcol=vec3(1.,.3,.0)*m*x; \r\n    fcol=max(fcol,length(p)*.0015*vec3(1.,.9,.8)*(1.-fin))*(1.+organic*.5);\r\n    return (max(p.x,p.y)/p.w-.025*(1.-fin))*.85; // returns the distance estimation to the fractal's surface, with some adjustment towards the end\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// RAYMARCHING\r\n\r\n// Returns the perpendicular vector to the surface at a given point\r\nvec3 normal(vec3 p) {\r\n    vec3 d=vec3(0.,det*2.,0.);\r\n\treturn normalize(vec3(de(p-d.yxx),de(p-d.xyx), de(p-d.xxy))-de(p));\r\n}\r\n\r\n\r\n// Ambient occlusion and soft shadows, classic iq's methods\r\n\r\nfloat ao(vec3 p, vec3 n) {\r\n\tfloat td=0., ao=0.;\r\n    for(int i=0; i<6; i++) {\r\n\t\ttd+=.05;\r\n\t\tfloat d=de(p-n*td);\r\n        ao+=max(0.,(td-d)/td);\r\n    }\r\n\treturn clamp(1.-ao*.1,0.,1.);\r\n}\r\n\r\n\r\nfloat shadow(vec3 p) {\r\n\tfloat sh=1.,td=.1;\r\n    for (int i=0; i<50; i++) {\r\n\t\tp+=ldir*td;\r\n        float d=de(p);\r\n\t\ttd+=d;\r\n        sh=min(sh,10.*d/td);\r\n        if (sh<.05) break;\r\n    }\r\n    return clamp(sh,0.,1.);\r\n}\r\n\r\n// Lighting\r\n\r\nvec3 shade(vec3 p, vec3 dir, vec3 n, vec3 col) {\r\n\tfloat sha=shadow(p); \r\n    float aoc=ao(p,n);\r\n    float amb=.25*aoc; // ambient light with ambient occlusion\r\n    float dif=max(0.,dot(ldir,-n))*sha; // diffuse light with shadow\r\n    vec3 ref=reflect(dir,n); // reflection vector\r\n    float spe=pow(max(0.,dot(ldir,ref)),10.)*.7*sha; // specular lights    \r\n    return col*(amb+dif)+spe*suncol; // lighting applied to the surface color\r\n}\r\n\r\n// Raymarching\r\n\r\nvec4 march(vec3 from, vec3 dir, vec3 camdir) {\r\n    // variable declarations\r\n\tvec3 p=from, col=vec3(0.1), backcol=col;\r\n    float totdist=0., d=0.,sdet, glow=0., lhit=1.;\r\n\t// the detail value is smaller towards the end as we are closer to the fractal boundary\r\n   \tdet*=1.-fin*.7;\r\n    // raymarching loop to obtain an occlusion value of the sun at the camera direction\r\n    // used for the lens flare\r\n    for (int i=0; i<70; i++) {\r\n    \tp+=d*ldir; // advance ray from camera pos to light dir\r\n        d=de(p)*2.; // distance estimation, doubled to gain performance as we don't need too much accuracy for this\r\n        lhit=min(lhit,d); // occlusion value based on how close the ray pass from the surfaces and very small if it hits \r\n        if (d<det) { // ray hits the surface, bye\r\n            break;\r\n        }\r\n    }\r\n    // main raymarching loop\r\n    for (int i=0; i<150; i++) {\r\n    \tp=from+totdist*dir; // advance ray\r\n        d=de(p); // distance estimation to fractal surface\r\n        sdet=det*(1.+totdist*.1); // makes the detail level lower for far hits \r\n        if (d<sdet||totdist>maxdist) break; // ray hits the surface or it reached the max distance defined\r\n    \ttotdist+=d; // distance accumulator  \r\n        glow++; // step counting used for glow\r\n    }\r\n    float sun=max(0.,dot(dir,ldir)); // the dot product of the cam direction and the light direction using for drawing the sun\r\n    if (d<.2) { // ray most likely hit a surface\r\n    \tp-=(sdet-d)*dir; // backstep to correct the ray position\r\n        vec3 c=fcol; // saves the color set by the de function to not get altered by the normal calculation\r\n        vec3 n=normal(p); // calculates the normal at the ray hit point\r\n        col=shade(p,dir,n,c); // sets the color and lighting\r\n    } else { // ray missed any surface, this is the background\r\n        totdist=maxdist; \r\n    \tp=from+dir*maxdist; // moves the ray to the max distance defined\r\n        // Kaliset fractal for stars and cosmic dust near the sun. \r\n        vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;\r\n        for (int i = 0; i < 10; i++) st = abs(st) / dot(st,st) - .8;\r\n        backcol+=length(st)*.015*(1.-pow(sun,3.))*(.5+abs(st.grb)*.5);\r\n        sun-=length(st)*.0017;\r\n        sun=max(0.,sun);\r\n\t\tbackcol+=pow(sun,100.)*.5; // adds sun light to the background\r\n    }\r\n    backcol+=pow(sun,20.)*suncol*.8; // sun light\r\n    float normdist=totdist/maxdist; // distance of the ray normalized from 0 to 1\r\n    col=mix(col,backcol,pow(normdist,1.5)); // mix the surface with the background in the far distance (fog)\r\n    col=max(col,col*vec3(sqrt(glow))*.13); // adds a little bit of glow\r\n\t// lens flare\r\n    vec2 pflare=dir.xy-ldir.xy;\r\n    float flare=max(0.,1.0-length(pflare))-pow(abs(1.-mod(camdir.x-atan(pflare.y,pflare.x)*5./3.14,2.)),.6);\r\n\tfloat cflare=pow(max(0.,dot(camdir,ldir)),20.)*lhit;\r\n    col+=pow(max(0.,flare),3.)*cflare*suncol;\r\n\tcol+=pow(sun,30.)*cflare;\r\n    // \"only glow\" part (at sec. 10)\r\n    col.rgb=mix(col.rgb,glow*suncol*.01+backcol,1.-smoothstep(0.,.8,abs(time-10.5)));\r\n    return vec4(col,normdist); // returns the resulting color and a normalized depth in alpha\r\n}\t//(depth was going to be used for a postprocessing shader) \r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// Camera and main function\r\n\r\n// I learnt this function from eiffie,\r\n// it takes a direction, a reference up vec3\r\n// and returns the rotation matrix to orient a vector\r\nmat3 lookat(vec3 dir, vec3 up){\r\n    dir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\r\n    return mat3(rt,cross(rt,dir),dir);\r\n}\r\n\r\n\r\n// the path of the camera at a given point of time\r\nvec3 campath(float ti) {\r\n    float start=pow(max(0.,1.-ti*.02),3.); // interpolation curve for the starting camera\r\n\tvec3 p=pitpath(ti); // path displacement of the fractal \r\n    p*=1.-start; // the camera gradually ends following the fractal when, that happens when start=0\r\n    p+=vec3(start*30.,start*25.,0.); // position offset for starting camera curve   \r\n    return p;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv=fragCoord/iResolution.xy-.5;\r\n    uv.x*=iResolution.x/iResolution.y;\r\n    vec3 dir=normalize(vec3(uv,1.)); // ray direction  \r\n\ttime=mod(iTime,162.); // time loop\r\n    fin=smoothstep(145.,147.5,time); // aux variable used for the end sequence\r\n    // camera accelerations and slow downs\r\n    float acel1=smoothstep(11.,12.,time)*7.31;\r\n    float acel2=smoothstep(99.,100.,time)*4.;\r\n    float desacel1=smoothstep(77.,78.,time)*5.;\r\n    float desacel2=fin*9.5;\r\n\tfloat tt=time;\r\n\t// freeze BW frame\r\n    if (abs(tt-25.5)<.5) tt=25.;\r\n    float acel=acel1+acel2-desacel1-desacel2;\r\n\t// time variable\r\n    float t=tt*(3.6+acel)-acel1*11.-acel2*99.+desacel1*77.+desacel2*147.5;\r\n    t+=smoothstep(125.,145.,time)*243.;\r\n    vec3 from=campath(t); // camera position\r\n    from.y-=desacel2*.035; // camera offset on 2nd slow down\r\n\tvec3 fw=normalize(campath(t+3.)-from); // camera forward direction\r\n    from.x-=fw.x*.1; // camera x offset based on the forward direction\r\n    dir=dir*lookat(fw*vec3(1.,-1.,1.),vec3(fw.x*.2,1.,0.)); // re-orientation of the ray dir with the camera fwd dir\r\n\tldir=normalize(ldir); // light dir normalization \r\n\tvec4 col=march(from, dir, fw); // get color from raymarching and background\r\n    col.rgb=mix(vec3(length(col.rgb)*.6),col.rgb,.85-step(abs(tt-25.),.1)); // BW freeze frame sequence coloring\r\n\tcol.rgb*=1.-smoothstep(25.,26.,time)+step(25.1,tt); // BW freeze frame sequence fading\r\n    col.rgb*=1.+step(abs(tt-25.),.1);\r\n    // PVM Logo color mixing\r\n    vec4 pvm=logo(uv*1.5+vec2(.9,.5))*smoothstep(1.,3.,time+uv.x*2.)*(1.-smoothstep(7.5,8.,time+uv.x*2.));\r\n    col.rgb=mix(col.rgb,pvm.rgb,pvm.a);\r\n    // fade in from black\r\n    col.rgb*=smoothstep(0.,4.,time);\r\n    // fade out to black\r\n    col.rgb*=1.-smoothstep(160.,162.,time);\r\n    fragColor = col;\r\n}","inputs":[],"outputs":[],"code":"// -------------------------------------------------------------------------------------------\r\n\r\n// \"ONE WAY TRIP\" by PVM\r\n\r\n// Shadertoy version of our 4k intro entry for Evoke 2019\r\n\r\n// Code: Kali\r\n// Music: Uctumi\r\n\r\n// NOTE: Rewind the shader after it starts to correct audio sync\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// Original code without optimizations for the 4k intro and including PVM logo\r\n\r\n// global variables\r\nfloat det=.005, fin=0., time; // raymarching threshold, aux variable\r\nconst float maxdist=60.; // max distance for raymarching\r\nvec3 ldir=vec3(0.,1.,4.); // light direction (without normalization)\r\nvec3 fcol; // global for coloring\r\nvec3 suncol=vec3(2.,1.,.6); // sun color\r\n\r\n// 2D rotation functions\r\nmat2 rot2D(float a) {\r\n\tfloat s=sin(a);\r\n    float c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\n// A version with degrees used when designing the logo\r\nmat2 rot2Ddeg(float a) {\r\n\ta=radians(a);\r\n    float s=sin(a);\r\n    float c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// PVM LOGO\r\n\r\n\r\n// 2D rectangle with a tilt distortion value\r\nfloat rect(vec2 p, vec2 b, float inc) {\r\n    p.x+=p.y*inc;\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\n// 2D triangle function by iq (I think)\r\nfloat tri(vec2 p, vec2 q, float ang) {\r\n    p*=rot2Ddeg(ang);\r\n    p.x = abs(p.x);\r\n    \r\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\r\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\r\n    float s = -sign( q.y );\r\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\r\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\r\n\r\n    return -sqrt(d.x)*sign(d.y);\r\n}\r\n\r\n\r\n// Here the logo is constructed from distoted rectangles and triangles\r\nvec4 logo(vec2 uv) {\r\n    uv*=1.2;\r\n    uv.x*=1.15;\r\n    uv.y-=.6;\r\n    uv.x-=1.3;\r\n    float d=rect(uv,vec2(.045,.25),-.5);\r\n\tuv.x+=.25;\r\n    uv.y+=.01;\r\n    d=min(d,rect(uv,vec2(.045,.24),.5));\r\n\tuv.x+=.265;\r\n    uv.y-=.04;\r\n    d=min(d,rect(uv,vec2(.045,.2),-.55));\r\n\tuv.x-=.73;\r\n    uv.y-=.06;\r\n    d=min(d,rect(uv,vec2(.045,.16),.4));\r\n\tuv.x-=.105;\r\n    uv.y+=.074;\r\n    d=min(d,rect(uv,vec2(.045,.085),-.45));\r\n\tuv.x-=.105;\r\n    uv.y+=.045;\r\n    d=min(d,rect(uv,vec2(.045,.13),.45));\r\n\tuv.x-=.25;\r\n    uv.y+=.1;\r\n    d=min(d,rect(uv,vec2(.18,.03),.0));\t\r\n\tuv.x+=1.32;\r\n    uv.y-=.18;\r\n    d=min(d,rect(uv+vec2(0.0,.03),vec2(.35,.03),.0));\t\r\n    uv.x-=.5165;\r\n    uv.y+=.4;\r\n    d=min(d,tri(uv,vec2(.09,.185),0.));\r\n    uv.x-=.492;\r\n    uv.y-=.56;\r\n    d=min(d,tri(uv,vec2(.063,.14),180.));\r\n    uv.x+=.225;\r\n    uv.y-=.17;\r\n    d=min(d,tri(uv,vec2(.063,.145),180.));\r\n    uv.x-=.142;\r\n    uv.y+=.555;\r\n    d=min(d,tri(uv,vec2(.063,.145),0.));\r\n    uv.x+=.985;\r\n    uv.y+=.075;\r\n    vec2 uvd=uv-vec2(uv.y,0.);\r\n    d=min(d,tri(uvd-vec2(0.003,0.022),vec2(.04,.05),0.));\r\n    uv.x-=.16\t;\r\n    uv.y-=.63;\r\n    uvd=uv+vec2(uv.y*.4,0.);\r\n    d=min(d,tri(uvd+vec2(.03,0.),vec2(.07,.23),-145.));    \r\n   \tuvd=uv+vec2(.465,.33);\r\n    uvd*=rot2Ddeg(27.);\r\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\r\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\r\n   \tuvd=uv+vec2(-1.43,.534);\r\n    uvd*=rot2Ddeg(206.);\r\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\r\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\r\n    float s=pow(abs(d)+.9,10.);\r\n\tuvd=uv+vec2(-.28,.36);\r\n    uvd*=rot2Ddeg(50.);\r\n    d=max(d,-rect(uvd,vec2(.1,.025),.0));\r\n    // logo coloring, RGBA \r\n    float o=1.-smoothstep(0.,.01,d);\r\n    float l=1.-smoothstep(0.,.05,d);\r\n    vec3 col=mix(vec3(2.,.15,.1),vec3(1.,2.,.5),min(1.,abs(uv.y+.4)));\r\n    return vec4(col*o+.1,l);\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// FRACTAL \r\n\r\n// A bunch of sin and cos that defines the curves of the fractal path\r\n// it returns the displacement at a given point. freq was used to explore diferent scales \r\nvec3 pitpath(float ti) { \r\n\tfloat freq=.5;\r\n    ti*=freq;\r\n\tfloat x=cos(cos(ti*.35682)+ti*.2823)*cos(ti*.1322)*1.5;\r\n\tfloat y=sin(ti*.166453)*4.+cos(cos(ti*.125465)+ti*.17354)*cos(ti*.05123)*2.;\r\n\tvec3  p=vec3(x,y,ti/freq);\r\n\treturn p;\r\n}\r\n\r\n// Distance Estimation function\r\n\r\nfloat de(vec3 pos) {\r\n    float x=1.-smoothstep(5.,8.,abs(pos.x)); // aux variable used for washing the colors away from the path in the fractal\r\n\tpos.y+=.9; // offset y position for the fractal object\r\n\tpos.xy-=pitpath(pos.z).xy; // distortion of coordinates based on the path function\r\n    mat2 rot=rot2D(.5); // rotation matrix used in the fractal iteration loop\r\n    float organic=smoothstep(.5,1.,-sin(pos.z*.005)); // used for the \"organic\" part of the fractal\r\n    mat2 rot2=rot2D(organic*.4); // rotation matrix used in the fractal iteration loop, it mutates the fractal to kinda \"organic\" shapes\r\n    float fold=2.6+sin(pos.z*.01)+organic*1.5; // fold is a parameter for one of the operations inside the fractal loop\r\n    pos.x+=pow(organic,.2)*fold*.75; // x offset for the organic part\r\n    pos.y+=organic*.3; // y offset for the organic part\r\n\tpos.z=abs(5.-mod(pos.z,10.)); // tiling for repeating the fractal along the z axis\r\n    pos.x=abs(10.-mod(pos.x+10.,20.)); // tiling for reapeating along x axis\r\n\tpos.x-=fold; // x offset to center the fractal\r\n    vec4 p=vec4(pos,1.); // w value will be used for calculating the derivative\r\n    vec3 m=vec3(1000.); // for orbit trap coloring\r\n    int it=int(8.+fin*2.); // gives more iterations to the fractal at the end\r\n    // Amazing Surface fractal formula by Kali\r\n    // Derived from Mandelbox by tglad\r\n    for (int i=0; i<it; i++) {\r\n\t\tp.xz=clamp(p.xz,-vec2(fold,2.),vec2(fold,2.))*2.0-p.xz; // fold transform on xz plane\r\n\t\tp.xyz-=vec3(.5,.8,1.); // translation transform\r\n        p=p*(2.-organic*.2)/clamp(dot(p.xyz,p.xyz),.25,1.)-vec4(2.,.5,-1.,0.)*x; // scale + spheric fold + translation transform\r\n\t\t// rotation transforms\r\n        p.xy*=rot;\r\n        p.xz*=rot2; // rotations on xz and yz give the \"organic\" feel for the \"alien reefs\" part\r\n        p.yz*=rot2; \r\n        m=min(m,abs(p.xyz)); // saves the minimum value of the position during the iteration, used for \"orbit traps\" coloring\r\n    }\r\n    // fractal coloring (fcol global variable)\r\n    fcol=vec3(1.,.3,.0)*m*x; \r\n    fcol=max(fcol,length(p)*.0015*vec3(1.,.9,.8)*(1.-fin))*(1.+organic*.5);\r\n    return (max(p.x,p.y)/p.w-.025*(1.-fin))*.85; // returns the distance estimation to the fractal's surface, with some adjustment towards the end\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// RAYMARCHING\r\n\r\n// Returns the perpendicular vector to the surface at a given point\r\nvec3 normal(vec3 p) {\r\n    vec3 d=vec3(0.,det*2.,0.);\r\n\treturn normalize(vec3(de(p-d.yxx),de(p-d.xyx), de(p-d.xxy))-de(p));\r\n}\r\n\r\n\r\n// Ambient occlusion and soft shadows, classic iq's methods\r\n\r\nfloat ao(vec3 p, vec3 n) {\r\n\tfloat td=0., ao=0.;\r\n    for(int i=0; i<6; i++) {\r\n\t\ttd+=.05;\r\n\t\tfloat d=de(p-n*td);\r\n        ao+=max(0.,(td-d)/td);\r\n    }\r\n\treturn clamp(1.-ao*.1,0.,1.);\r\n}\r\n\r\n\r\nfloat shadow(vec3 p) {\r\n\tfloat sh=1.,td=.1;\r\n    for (int i=0; i<50; i++) {\r\n\t\tp+=ldir*td;\r\n        float d=de(p);\r\n\t\ttd+=d;\r\n        sh=min(sh,10.*d/td);\r\n        if (sh<.05) break;\r\n    }\r\n    return clamp(sh,0.,1.);\r\n}\r\n\r\n// Lighting\r\n\r\nvec3 shade(vec3 p, vec3 dir, vec3 n, vec3 col) {\r\n\tfloat sha=shadow(p); \r\n    float aoc=ao(p,n);\r\n    float amb=.25*aoc; // ambient light with ambient occlusion\r\n    float dif=max(0.,dot(ldir,-n))*sha; // diffuse light with shadow\r\n    vec3 ref=reflect(dir,n); // reflection vector\r\n    float spe=pow(max(0.,dot(ldir,ref)),10.)*.7*sha; // specular lights    \r\n    return col*(amb+dif)+spe*suncol; // lighting applied to the surface color\r\n}\r\n\r\n// Raymarching\r\n\r\nvec4 march(vec3 from, vec3 dir, vec3 camdir) {\r\n    // variable declarations\r\n\tvec3 p=from, col=vec3(0.1), backcol=col;\r\n    float totdist=0., d=0.,sdet, glow=0., lhit=1.;\r\n\t// the detail value is smaller towards the end as we are closer to the fractal boundary\r\n   \tdet*=1.-fin*.7;\r\n    // raymarching loop to obtain an occlusion value of the sun at the camera direction\r\n    // used for the lens flare\r\n    for (int i=0; i<70; i++) {\r\n    \tp+=d*ldir; // advance ray from camera pos to light dir\r\n        d=de(p)*2.; // distance estimation, doubled to gain performance as we don't need too much accuracy for this\r\n        lhit=min(lhit,d); // occlusion value based on how close the ray pass from the surfaces and very small if it hits \r\n        if (d<det) { // ray hits the surface, bye\r\n            break;\r\n        }\r\n    }\r\n    // main raymarching loop\r\n    for (int i=0; i<150; i++) {\r\n    \tp=from+totdist*dir; // advance ray\r\n        d=de(p); // distance estimation to fractal surface\r\n        sdet=det*(1.+totdist*.1); // makes the detail level lower for far hits \r\n        if (d<sdet||totdist>maxdist) break; // ray hits the surface or it reached the max distance defined\r\n    \ttotdist+=d; // distance accumulator  \r\n        glow++; // step counting used for glow\r\n    }\r\n    float sun=max(0.,dot(dir,ldir)); // the dot product of the cam direction and the light direction using for drawing the sun\r\n    if (d<.2) { // ray most likely hit a surface\r\n    \tp-=(sdet-d)*dir; // backstep to correct the ray position\r\n        vec3 c=fcol; // saves the color set by the de function to not get altered by the normal calculation\r\n        vec3 n=normal(p); // calculates the normal at the ray hit point\r\n        col=shade(p,dir,n,c); // sets the color and lighting\r\n    } else { // ray missed any surface, this is the background\r\n        totdist=maxdist; \r\n    \tp=from+dir*maxdist; // moves the ray to the max distance defined\r\n        // Kaliset fractal for stars and cosmic dust near the sun. \r\n        vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;\r\n        for (int i = 0; i < 10; i++) st = abs(st) / dot(st,st) - .8;\r\n        backcol+=length(st)*.015*(1.-pow(sun,3.))*(.5+abs(st.grb)*.5);\r\n        sun-=length(st)*.0017;\r\n        sun=max(0.,sun);\r\n\t\tbackcol+=pow(sun,100.)*.5; // adds sun light to the background\r\n    }\r\n    backcol+=pow(sun,20.)*suncol*.8; // sun light\r\n    float normdist=totdist/maxdist; // distance of the ray normalized from 0 to 1\r\n    col=mix(col,backcol,pow(normdist,1.5)); // mix the surface with the background in the far distance (fog)\r\n    col=max(col,col*vec3(sqrt(glow))*.13); // adds a little bit of glow\r\n\t// lens flare\r\n    vec2 pflare=dir.xy-ldir.xy;\r\n    float flare=max(0.,1.0-length(pflare))-pow(abs(1.-mod(camdir.x-atan(pflare.y,pflare.x)*5./3.14,2.)),.6);\r\n\tfloat cflare=pow(max(0.,dot(camdir,ldir)),20.)*lhit;\r\n    col+=pow(max(0.,flare),3.)*cflare*suncol;\r\n\tcol+=pow(sun,30.)*cflare;\r\n    // \"only glow\" part (at sec. 10)\r\n    col.rgb=mix(col.rgb,glow*suncol*.01+backcol,1.-smoothstep(0.,.8,abs(time-10.5)));\r\n    return vec4(col,normdist); // returns the resulting color and a normalized depth in alpha\r\n}\t//(depth was going to be used for a postprocessing shader) \r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// Camera and main function\r\n\r\n// I learnt this function from eiffie,\r\n// it takes a direction, a reference up vec3\r\n// and returns the rotation matrix to orient a vector\r\nmat3 lookat(vec3 dir, vec3 up){\r\n    dir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\r\n    return mat3(rt,cross(rt,dir),dir);\r\n}\r\n\r\n\r\n// the path of the camera at a given point of time\r\nvec3 campath(float ti) {\r\n    float start=pow(max(0.,1.-ti*.02),3.); // interpolation curve for the starting camera\r\n\tvec3 p=pitpath(ti); // path displacement of the fractal \r\n    p*=1.-start; // the camera gradually ends following the fractal when, that happens when start=0\r\n    p+=vec3(start*30.,start*25.,0.); // position offset for starting camera curve   \r\n    return p;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv=fragCoord/iResolution.xy-.5;\r\n    uv.x*=iResolution.x/iResolution.y;\r\n    vec3 dir=normalize(vec3(uv,1.)); // ray direction  \r\n\ttime=mod(iTime,162.); // time loop\r\n    fin=smoothstep(145.,147.5,time); // aux variable used for the end sequence\r\n    // camera accelerations and slow downs\r\n    float acel1=smoothstep(11.,12.,time)*7.31;\r\n    float acel2=smoothstep(99.,100.,time)*4.;\r\n    float desacel1=smoothstep(77.,78.,time)*5.;\r\n    float desacel2=fin*9.5;\r\n\tfloat tt=time;\r\n\t// freeze BW frame\r\n    if (abs(tt-25.5)<.5) tt=25.;\r\n    float acel=acel1+acel2-desacel1-desacel2;\r\n\t// time variable\r\n    float t=tt*(3.6+acel)-acel1*11.-acel2*99.+desacel1*77.+desacel2*147.5;\r\n    t+=smoothstep(125.,145.,time)*243.;\r\n    vec3 from=campath(t); // camera position\r\n    from.y-=desacel2*.035; // camera offset on 2nd slow down\r\n\tvec3 fw=normalize(campath(t+3.)-from); // camera forward direction\r\n    from.x-=fw.x*.1; // camera x offset based on the forward direction\r\n    dir=dir*lookat(fw*vec3(1.,-1.,1.),vec3(fw.x*.2,1.,0.)); // re-orientation of the ray dir with the camera fwd dir\r\n\tldir=normalize(ldir); // light dir normalization \r\n\tvec4 col=march(from, dir, fw); // get color from raymarching and background\r\n    col.rgb=mix(vec3(length(col.rgb)*.6),col.rgb,.85-step(abs(tt-25.),.1)); // BW freeze frame sequence coloring\r\n\tcol.rgb*=1.-smoothstep(25.,26.,time)+step(25.1,tt); // BW freeze frame sequence fading\r\n    col.rgb*=1.+step(abs(tt-25.),.1);\r\n    // PVM Logo color mixing\r\n    vec4 pvm=logo(uv*1.5+vec2(.9,.5))*smoothstep(1.,3.,time+uv.x*2.)*(1.-smoothstep(7.5,8.,time+uv.x*2.));\r\n    col.rgb=mix(col.rgb,pvm.rgb,pvm.a);\r\n    // fade in from black\r\n    col.rgb*=smoothstep(0.,4.,time);\r\n    // fade out to black\r\n    col.rgb*=1.-smoothstep(160.,162.,time);\r\n    fragColor = col;\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"One Way Trip","id":"c548f3328a414007997613582689d44d","date":null,"viewed":0,"name":"One Way Trip","description":"\"One Way Trip\" by PVM\nRanked 2nd in the 4 kbytes compo at Evoke 2019, Germany.\nCode: Kali, Music: Uctumi\nYou can download Windows 4kbyte executable from: http://pungas.space/releases/pvm-owtr.zip \n+PVM Info: http://pungas.space\nhttps://www.shadertoy.com/view/WlSSWV","likes":0,"published":null,"tags":["intro"," 4k"," demoscene"]},"ver":null,"info":{"Name":"One Way Trip","id":"c548f3328a414007997613582689d44d","date":null,"viewed":0,"name":"One Way Trip","description":"\"One Way Trip\" by PVM\nRanked 2nd in the 4 kbytes compo at Evoke 2019, Germany.\nCode: Kali, Music: Uctumi\nYou can download Windows 4kbyte executable from: http://pungas.space/releases/pvm-owtr.zip \n+PVM Info: http://pungas.space\nhttps://www.shadertoy.com/view/WlSSWV","likes":0,"published":null,"tags":["intro"," 4k"," demoscene"]},"renderpass":[{"Code":"// -------------------------------------------------------------------------------------------\r\n\r\n// \"ONE WAY TRIP\" by PVM\r\n\r\n// Shadertoy version of our 4k intro entry for Evoke 2019\r\n\r\n// Code: Kali\r\n// Music: Uctumi\r\n\r\n// NOTE: Rewind the shader after it starts to correct audio sync\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// Original code without optimizations for the 4k intro and including PVM logo\r\n\r\n// global variables\r\nfloat det=.005, fin=0., time; // raymarching threshold, aux variable\r\nconst float maxdist=60.; // max distance for raymarching\r\nvec3 ldir=vec3(0.,1.,4.); // light direction (without normalization)\r\nvec3 fcol; // global for coloring\r\nvec3 suncol=vec3(2.,1.,.6); // sun color\r\n\r\n// 2D rotation functions\r\nmat2 rot2D(float a) {\r\n\tfloat s=sin(a);\r\n    float c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\n// A version with degrees used when designing the logo\r\nmat2 rot2Ddeg(float a) {\r\n\ta=radians(a);\r\n    float s=sin(a);\r\n    float c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// PVM LOGO\r\n\r\n\r\n// 2D rectangle with a tilt distortion value\r\nfloat rect(vec2 p, vec2 b, float inc) {\r\n    p.x+=p.y*inc;\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\n// 2D triangle function by iq (I think)\r\nfloat tri(vec2 p, vec2 q, float ang) {\r\n    p*=rot2Ddeg(ang);\r\n    p.x = abs(p.x);\r\n    \r\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\r\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\r\n    float s = -sign( q.y );\r\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\r\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\r\n\r\n    return -sqrt(d.x)*sign(d.y);\r\n}\r\n\r\n\r\n// Here the logo is constructed from distoted rectangles and triangles\r\nvec4 logo(vec2 uv) {\r\n    uv*=1.2;\r\n    uv.x*=1.15;\r\n    uv.y-=.6;\r\n    uv.x-=1.3;\r\n    float d=rect(uv,vec2(.045,.25),-.5);\r\n\tuv.x+=.25;\r\n    uv.y+=.01;\r\n    d=min(d,rect(uv,vec2(.045,.24),.5));\r\n\tuv.x+=.265;\r\n    uv.y-=.04;\r\n    d=min(d,rect(uv,vec2(.045,.2),-.55));\r\n\tuv.x-=.73;\r\n    uv.y-=.06;\r\n    d=min(d,rect(uv,vec2(.045,.16),.4));\r\n\tuv.x-=.105;\r\n    uv.y+=.074;\r\n    d=min(d,rect(uv,vec2(.045,.085),-.45));\r\n\tuv.x-=.105;\r\n    uv.y+=.045;\r\n    d=min(d,rect(uv,vec2(.045,.13),.45));\r\n\tuv.x-=.25;\r\n    uv.y+=.1;\r\n    d=min(d,rect(uv,vec2(.18,.03),.0));\t\r\n\tuv.x+=1.32;\r\n    uv.y-=.18;\r\n    d=min(d,rect(uv+vec2(0.0,.03),vec2(.35,.03),.0));\t\r\n    uv.x-=.5165;\r\n    uv.y+=.4;\r\n    d=min(d,tri(uv,vec2(.09,.185),0.));\r\n    uv.x-=.492;\r\n    uv.y-=.56;\r\n    d=min(d,tri(uv,vec2(.063,.14),180.));\r\n    uv.x+=.225;\r\n    uv.y-=.17;\r\n    d=min(d,tri(uv,vec2(.063,.145),180.));\r\n    uv.x-=.142;\r\n    uv.y+=.555;\r\n    d=min(d,tri(uv,vec2(.063,.145),0.));\r\n    uv.x+=.985;\r\n    uv.y+=.075;\r\n    vec2 uvd=uv-vec2(uv.y,0.);\r\n    d=min(d,tri(uvd-vec2(0.003,0.022),vec2(.04,.05),0.));\r\n    uv.x-=.16\t;\r\n    uv.y-=.63;\r\n    uvd=uv+vec2(uv.y*.4,0.);\r\n    d=min(d,tri(uvd+vec2(.03,0.),vec2(.07,.23),-145.));    \r\n   \tuvd=uv+vec2(.465,.33);\r\n    uvd*=rot2Ddeg(27.);\r\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\r\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\r\n   \tuvd=uv+vec2(-1.43,.534);\r\n    uvd*=rot2Ddeg(206.);\r\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\r\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\r\n    float s=pow(abs(d)+.9,10.);\r\n\tuvd=uv+vec2(-.28,.36);\r\n    uvd*=rot2Ddeg(50.);\r\n    d=max(d,-rect(uvd,vec2(.1,.025),.0));\r\n    // logo coloring, RGBA \r\n    float o=1.-smoothstep(0.,.01,d);\r\n    float l=1.-smoothstep(0.,.05,d);\r\n    vec3 col=mix(vec3(2.,.15,.1),vec3(1.,2.,.5),min(1.,abs(uv.y+.4)));\r\n    return vec4(col*o+.1,l);\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// FRACTAL \r\n\r\n// A bunch of sin and cos that defines the curves of the fractal path\r\n// it returns the displacement at a given point. freq was used to explore diferent scales \r\nvec3 pitpath(float ti) { \r\n\tfloat freq=.5;\r\n    ti*=freq;\r\n\tfloat x=cos(cos(ti*.35682)+ti*.2823)*cos(ti*.1322)*1.5;\r\n\tfloat y=sin(ti*.166453)*4.+cos(cos(ti*.125465)+ti*.17354)*cos(ti*.05123)*2.;\r\n\tvec3  p=vec3(x,y,ti/freq);\r\n\treturn p;\r\n}\r\n\r\n// Distance Estimation function\r\n\r\nfloat de(vec3 pos) {\r\n    float x=1.-smoothstep(5.,8.,abs(pos.x)); // aux variable used for washing the colors away from the path in the fractal\r\n\tpos.y+=.9; // offset y position for the fractal object\r\n\tpos.xy-=pitpath(pos.z).xy; // distortion of coordinates based on the path function\r\n    mat2 rot=rot2D(.5); // rotation matrix used in the fractal iteration loop\r\n    float organic=smoothstep(.5,1.,-sin(pos.z*.005)); // used for the \"organic\" part of the fractal\r\n    mat2 rot2=rot2D(organic*.4); // rotation matrix used in the fractal iteration loop, it mutates the fractal to kinda \"organic\" shapes\r\n    float fold=2.6+sin(pos.z*.01)+organic*1.5; // fold is a parameter for one of the operations inside the fractal loop\r\n    pos.x+=pow(organic,.2)*fold*.75; // x offset for the organic part\r\n    pos.y+=organic*.3; // y offset for the organic part\r\n\tpos.z=abs(5.-mod(pos.z,10.)); // tiling for repeating the fractal along the z axis\r\n    pos.x=abs(10.-mod(pos.x+10.,20.)); // tiling for reapeating along x axis\r\n\tpos.x-=fold; // x offset to center the fractal\r\n    vec4 p=vec4(pos,1.); // w value will be used for calculating the derivative\r\n    vec3 m=vec3(1000.); // for orbit trap coloring\r\n    int it=int(8.+fin*2.); // gives more iterations to the fractal at the end\r\n    // Amazing Surface fractal formula by Kali\r\n    // Derived from Mandelbox by tglad\r\n    for (int i=0; i<it; i++) {\r\n\t\tp.xz=clamp(p.xz,-vec2(fold,2.),vec2(fold,2.))*2.0-p.xz; // fold transform on xz plane\r\n\t\tp.xyz-=vec3(.5,.8,1.); // translation transform\r\n        p=p*(2.-organic*.2)/clamp(dot(p.xyz,p.xyz),.25,1.)-vec4(2.,.5,-1.,0.)*x; // scale + spheric fold + translation transform\r\n\t\t// rotation transforms\r\n        p.xy*=rot;\r\n        p.xz*=rot2; // rotations on xz and yz give the \"organic\" feel for the \"alien reefs\" part\r\n        p.yz*=rot2; \r\n        m=min(m,abs(p.xyz)); // saves the minimum value of the position during the iteration, used for \"orbit traps\" coloring\r\n    }\r\n    // fractal coloring (fcol global variable)\r\n    fcol=vec3(1.,.3,.0)*m*x; \r\n    fcol=max(fcol,length(p)*.0015*vec3(1.,.9,.8)*(1.-fin))*(1.+organic*.5);\r\n    return (max(p.x,p.y)/p.w-.025*(1.-fin))*.85; // returns the distance estimation to the fractal's surface, with some adjustment towards the end\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// RAYMARCHING\r\n\r\n// Returns the perpendicular vector to the surface at a given point\r\nvec3 normal(vec3 p) {\r\n    vec3 d=vec3(0.,det*2.,0.);\r\n\treturn normalize(vec3(de(p-d.yxx),de(p-d.xyx), de(p-d.xxy))-de(p));\r\n}\r\n\r\n\r\n// Ambient occlusion and soft shadows, classic iq's methods\r\n\r\nfloat ao(vec3 p, vec3 n) {\r\n\tfloat td=0., ao=0.;\r\n    for(int i=0; i<6; i++) {\r\n\t\ttd+=.05;\r\n\t\tfloat d=de(p-n*td);\r\n        ao+=max(0.,(td-d)/td);\r\n    }\r\n\treturn clamp(1.-ao*.1,0.,1.);\r\n}\r\n\r\n\r\nfloat shadow(vec3 p) {\r\n\tfloat sh=1.,td=.1;\r\n    for (int i=0; i<50; i++) {\r\n\t\tp+=ldir*td;\r\n        float d=de(p);\r\n\t\ttd+=d;\r\n        sh=min(sh,10.*d/td);\r\n        if (sh<.05) break;\r\n    }\r\n    return clamp(sh,0.,1.);\r\n}\r\n\r\n// Lighting\r\n\r\nvec3 shade(vec3 p, vec3 dir, vec3 n, vec3 col) {\r\n\tfloat sha=shadow(p); \r\n    float aoc=ao(p,n);\r\n    float amb=.25*aoc; // ambient light with ambient occlusion\r\n    float dif=max(0.,dot(ldir,-n))*sha; // diffuse light with shadow\r\n    vec3 ref=reflect(dir,n); // reflection vector\r\n    float spe=pow(max(0.,dot(ldir,ref)),10.)*.7*sha; // specular lights    \r\n    return col*(amb+dif)+spe*suncol; // lighting applied to the surface color\r\n}\r\n\r\n// Raymarching\r\n\r\nvec4 march(vec3 from, vec3 dir, vec3 camdir) {\r\n    // variable declarations\r\n\tvec3 p=from, col=vec3(0.1), backcol=col;\r\n    float totdist=0., d=0.,sdet, glow=0., lhit=1.;\r\n\t// the detail value is smaller towards the end as we are closer to the fractal boundary\r\n   \tdet*=1.-fin*.7;\r\n    // raymarching loop to obtain an occlusion value of the sun at the camera direction\r\n    // used for the lens flare\r\n    for (int i=0; i<70; i++) {\r\n    \tp+=d*ldir; // advance ray from camera pos to light dir\r\n        d=de(p)*2.; // distance estimation, doubled to gain performance as we don't need too much accuracy for this\r\n        lhit=min(lhit,d); // occlusion value based on how close the ray pass from the surfaces and very small if it hits \r\n        if (d<det) { // ray hits the surface, bye\r\n            break;\r\n        }\r\n    }\r\n    // main raymarching loop\r\n    for (int i=0; i<150; i++) {\r\n    \tp=from+totdist*dir; // advance ray\r\n        d=de(p); // distance estimation to fractal surface\r\n        sdet=det*(1.+totdist*.1); // makes the detail level lower for far hits \r\n        if (d<sdet||totdist>maxdist) break; // ray hits the surface or it reached the max distance defined\r\n    \ttotdist+=d; // distance accumulator  \r\n        glow++; // step counting used for glow\r\n    }\r\n    float sun=max(0.,dot(dir,ldir)); // the dot product of the cam direction and the light direction using for drawing the sun\r\n    if (d<.2) { // ray most likely hit a surface\r\n    \tp-=(sdet-d)*dir; // backstep to correct the ray position\r\n        vec3 c=fcol; // saves the color set by the de function to not get altered by the normal calculation\r\n        vec3 n=normal(p); // calculates the normal at the ray hit point\r\n        col=shade(p,dir,n,c); // sets the color and lighting\r\n    } else { // ray missed any surface, this is the background\r\n        totdist=maxdist; \r\n    \tp=from+dir*maxdist; // moves the ray to the max distance defined\r\n        // Kaliset fractal for stars and cosmic dust near the sun. \r\n        vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;\r\n        for (int i = 0; i < 10; i++) st = abs(st) / dot(st,st) - .8;\r\n        backcol+=length(st)*.015*(1.-pow(sun,3.))*(.5+abs(st.grb)*.5);\r\n        sun-=length(st)*.0017;\r\n        sun=max(0.,sun);\r\n\t\tbackcol+=pow(sun,100.)*.5; // adds sun light to the background\r\n    }\r\n    backcol+=pow(sun,20.)*suncol*.8; // sun light\r\n    float normdist=totdist/maxdist; // distance of the ray normalized from 0 to 1\r\n    col=mix(col,backcol,pow(normdist,1.5)); // mix the surface with the background in the far distance (fog)\r\n    col=max(col,col*vec3(sqrt(glow))*.13); // adds a little bit of glow\r\n\t// lens flare\r\n    vec2 pflare=dir.xy-ldir.xy;\r\n    float flare=max(0.,1.0-length(pflare))-pow(abs(1.-mod(camdir.x-atan(pflare.y,pflare.x)*5./3.14,2.)),.6);\r\n\tfloat cflare=pow(max(0.,dot(camdir,ldir)),20.)*lhit;\r\n    col+=pow(max(0.,flare),3.)*cflare*suncol;\r\n\tcol+=pow(sun,30.)*cflare;\r\n    // \"only glow\" part (at sec. 10)\r\n    col.rgb=mix(col.rgb,glow*suncol*.01+backcol,1.-smoothstep(0.,.8,abs(time-10.5)));\r\n    return vec4(col,normdist); // returns the resulting color and a normalized depth in alpha\r\n}\t//(depth was going to be used for a postprocessing shader) \r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// Camera and main function\r\n\r\n// I learnt this function from eiffie,\r\n// it takes a direction, a reference up vec3\r\n// and returns the rotation matrix to orient a vector\r\nmat3 lookat(vec3 dir, vec3 up){\r\n    dir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\r\n    return mat3(rt,cross(rt,dir),dir);\r\n}\r\n\r\n\r\n// the path of the camera at a given point of time\r\nvec3 campath(float ti) {\r\n    float start=pow(max(0.,1.-ti*.02),3.); // interpolation curve for the starting camera\r\n\tvec3 p=pitpath(ti); // path displacement of the fractal \r\n    p*=1.-start; // the camera gradually ends following the fractal when, that happens when start=0\r\n    p+=vec3(start*30.,start*25.,0.); // position offset for starting camera curve   \r\n    return p;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv=fragCoord/iResolution.xy-.5;\r\n    uv.x*=iResolution.x/iResolution.y;\r\n    vec3 dir=normalize(vec3(uv,1.)); // ray direction  \r\n\ttime=mod(iTime,162.); // time loop\r\n    fin=smoothstep(145.,147.5,time); // aux variable used for the end sequence\r\n    // camera accelerations and slow downs\r\n    float acel1=smoothstep(11.,12.,time)*7.31;\r\n    float acel2=smoothstep(99.,100.,time)*4.;\r\n    float desacel1=smoothstep(77.,78.,time)*5.;\r\n    float desacel2=fin*9.5;\r\n\tfloat tt=time;\r\n\t// freeze BW frame\r\n    if (abs(tt-25.5)<.5) tt=25.;\r\n    float acel=acel1+acel2-desacel1-desacel2;\r\n\t// time variable\r\n    float t=tt*(3.6+acel)-acel1*11.-acel2*99.+desacel1*77.+desacel2*147.5;\r\n    t+=smoothstep(125.,145.,time)*243.;\r\n    vec3 from=campath(t); // camera position\r\n    from.y-=desacel2*.035; // camera offset on 2nd slow down\r\n\tvec3 fw=normalize(campath(t+3.)-from); // camera forward direction\r\n    from.x-=fw.x*.1; // camera x offset based on the forward direction\r\n    dir=dir*lookat(fw*vec3(1.,-1.,1.),vec3(fw.x*.2,1.,0.)); // re-orientation of the ray dir with the camera fwd dir\r\n\tldir=normalize(ldir); // light dir normalization \r\n\tvec4 col=march(from, dir, fw); // get color from raymarching and background\r\n    col.rgb=mix(vec3(length(col.rgb)*.6),col.rgb,.85-step(abs(tt-25.),.1)); // BW freeze frame sequence coloring\r\n\tcol.rgb*=1.-smoothstep(25.,26.,time)+step(25.1,tt); // BW freeze frame sequence fading\r\n    col.rgb*=1.+step(abs(tt-25.),.1);\r\n    // PVM Logo color mixing\r\n    vec4 pvm=logo(uv*1.5+vec2(.9,.5))*smoothstep(1.,3.,time+uv.x*2.)*(1.-smoothstep(7.5,8.,time+uv.x*2.));\r\n    col.rgb=mix(col.rgb,pvm.rgb,pvm.a);\r\n    // fade in from black\r\n    col.rgb*=smoothstep(0.,4.,time);\r\n    // fade out to black\r\n    col.rgb*=1.-smoothstep(160.,162.,time);\r\n    fragColor = col;\r\n}","inputs":[],"outputs":[],"code":"// -------------------------------------------------------------------------------------------\r\n\r\n// \"ONE WAY TRIP\" by PVM\r\n\r\n// Shadertoy version of our 4k intro entry for Evoke 2019\r\n\r\n// Code: Kali\r\n// Music: Uctumi\r\n\r\n// NOTE: Rewind the shader after it starts to correct audio sync\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// Original code without optimizations for the 4k intro and including PVM logo\r\n\r\n// global variables\r\nfloat det=.005, fin=0., time; // raymarching threshold, aux variable\r\nconst float maxdist=60.; // max distance for raymarching\r\nvec3 ldir=vec3(0.,1.,4.); // light direction (without normalization)\r\nvec3 fcol; // global for coloring\r\nvec3 suncol=vec3(2.,1.,.6); // sun color\r\n\r\n// 2D rotation functions\r\nmat2 rot2D(float a) {\r\n\tfloat s=sin(a);\r\n    float c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\n// A version with degrees used when designing the logo\r\nmat2 rot2Ddeg(float a) {\r\n\ta=radians(a);\r\n    float s=sin(a);\r\n    float c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// PVM LOGO\r\n\r\n\r\n// 2D rectangle with a tilt distortion value\r\nfloat rect(vec2 p, vec2 b, float inc) {\r\n    p.x+=p.y*inc;\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\n// 2D triangle function by iq (I think)\r\nfloat tri(vec2 p, vec2 q, float ang) {\r\n    p*=rot2Ddeg(ang);\r\n    p.x = abs(p.x);\r\n    \r\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\r\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\r\n    float s = -sign( q.y );\r\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\r\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\r\n\r\n    return -sqrt(d.x)*sign(d.y);\r\n}\r\n\r\n\r\n// Here the logo is constructed from distoted rectangles and triangles\r\nvec4 logo(vec2 uv) {\r\n    uv*=1.2;\r\n    uv.x*=1.15;\r\n    uv.y-=.6;\r\n    uv.x-=1.3;\r\n    float d=rect(uv,vec2(.045,.25),-.5);\r\n\tuv.x+=.25;\r\n    uv.y+=.01;\r\n    d=min(d,rect(uv,vec2(.045,.24),.5));\r\n\tuv.x+=.265;\r\n    uv.y-=.04;\r\n    d=min(d,rect(uv,vec2(.045,.2),-.55));\r\n\tuv.x-=.73;\r\n    uv.y-=.06;\r\n    d=min(d,rect(uv,vec2(.045,.16),.4));\r\n\tuv.x-=.105;\r\n    uv.y+=.074;\r\n    d=min(d,rect(uv,vec2(.045,.085),-.45));\r\n\tuv.x-=.105;\r\n    uv.y+=.045;\r\n    d=min(d,rect(uv,vec2(.045,.13),.45));\r\n\tuv.x-=.25;\r\n    uv.y+=.1;\r\n    d=min(d,rect(uv,vec2(.18,.03),.0));\t\r\n\tuv.x+=1.32;\r\n    uv.y-=.18;\r\n    d=min(d,rect(uv+vec2(0.0,.03),vec2(.35,.03),.0));\t\r\n    uv.x-=.5165;\r\n    uv.y+=.4;\r\n    d=min(d,tri(uv,vec2(.09,.185),0.));\r\n    uv.x-=.492;\r\n    uv.y-=.56;\r\n    d=min(d,tri(uv,vec2(.063,.14),180.));\r\n    uv.x+=.225;\r\n    uv.y-=.17;\r\n    d=min(d,tri(uv,vec2(.063,.145),180.));\r\n    uv.x-=.142;\r\n    uv.y+=.555;\r\n    d=min(d,tri(uv,vec2(.063,.145),0.));\r\n    uv.x+=.985;\r\n    uv.y+=.075;\r\n    vec2 uvd=uv-vec2(uv.y,0.);\r\n    d=min(d,tri(uvd-vec2(0.003,0.022),vec2(.04,.05),0.));\r\n    uv.x-=.16\t;\r\n    uv.y-=.63;\r\n    uvd=uv+vec2(uv.y*.4,0.);\r\n    d=min(d,tri(uvd+vec2(.03,0.),vec2(.07,.23),-145.));    \r\n   \tuvd=uv+vec2(.465,.33);\r\n    uvd*=rot2Ddeg(27.);\r\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\r\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\r\n   \tuvd=uv+vec2(-1.43,.534);\r\n    uvd*=rot2Ddeg(206.);\r\n    uvd-=vec2(uvd.y*.5*sign(uvd.x),0.);\r\n    d=min(d,rect(uvd,vec2(.08,.03),.0));\t\r\n    float s=pow(abs(d)+.9,10.);\r\n\tuvd=uv+vec2(-.28,.36);\r\n    uvd*=rot2Ddeg(50.);\r\n    d=max(d,-rect(uvd,vec2(.1,.025),.0));\r\n    // logo coloring, RGBA \r\n    float o=1.-smoothstep(0.,.01,d);\r\n    float l=1.-smoothstep(0.,.05,d);\r\n    vec3 col=mix(vec3(2.,.15,.1),vec3(1.,2.,.5),min(1.,abs(uv.y+.4)));\r\n    return vec4(col*o+.1,l);\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// FRACTAL \r\n\r\n// A bunch of sin and cos that defines the curves of the fractal path\r\n// it returns the displacement at a given point. freq was used to explore diferent scales \r\nvec3 pitpath(float ti) { \r\n\tfloat freq=.5;\r\n    ti*=freq;\r\n\tfloat x=cos(cos(ti*.35682)+ti*.2823)*cos(ti*.1322)*1.5;\r\n\tfloat y=sin(ti*.166453)*4.+cos(cos(ti*.125465)+ti*.17354)*cos(ti*.05123)*2.;\r\n\tvec3  p=vec3(x,y,ti/freq);\r\n\treturn p;\r\n}\r\n\r\n// Distance Estimation function\r\n\r\nfloat de(vec3 pos) {\r\n    float x=1.-smoothstep(5.,8.,abs(pos.x)); // aux variable used for washing the colors away from the path in the fractal\r\n\tpos.y+=.9; // offset y position for the fractal object\r\n\tpos.xy-=pitpath(pos.z).xy; // distortion of coordinates based on the path function\r\n    mat2 rot=rot2D(.5); // rotation matrix used in the fractal iteration loop\r\n    float organic=smoothstep(.5,1.,-sin(pos.z*.005)); // used for the \"organic\" part of the fractal\r\n    mat2 rot2=rot2D(organic*.4); // rotation matrix used in the fractal iteration loop, it mutates the fractal to kinda \"organic\" shapes\r\n    float fold=2.6+sin(pos.z*.01)+organic*1.5; // fold is a parameter for one of the operations inside the fractal loop\r\n    pos.x+=pow(organic,.2)*fold*.75; // x offset for the organic part\r\n    pos.y+=organic*.3; // y offset for the organic part\r\n\tpos.z=abs(5.-mod(pos.z,10.)); // tiling for repeating the fractal along the z axis\r\n    pos.x=abs(10.-mod(pos.x+10.,20.)); // tiling for reapeating along x axis\r\n\tpos.x-=fold; // x offset to center the fractal\r\n    vec4 p=vec4(pos,1.); // w value will be used for calculating the derivative\r\n    vec3 m=vec3(1000.); // for orbit trap coloring\r\n    int it=int(8.+fin*2.); // gives more iterations to the fractal at the end\r\n    // Amazing Surface fractal formula by Kali\r\n    // Derived from Mandelbox by tglad\r\n    for (int i=0; i<it; i++) {\r\n\t\tp.xz=clamp(p.xz,-vec2(fold,2.),vec2(fold,2.))*2.0-p.xz; // fold transform on xz plane\r\n\t\tp.xyz-=vec3(.5,.8,1.); // translation transform\r\n        p=p*(2.-organic*.2)/clamp(dot(p.xyz,p.xyz),.25,1.)-vec4(2.,.5,-1.,0.)*x; // scale + spheric fold + translation transform\r\n\t\t// rotation transforms\r\n        p.xy*=rot;\r\n        p.xz*=rot2; // rotations on xz and yz give the \"organic\" feel for the \"alien reefs\" part\r\n        p.yz*=rot2; \r\n        m=min(m,abs(p.xyz)); // saves the minimum value of the position during the iteration, used for \"orbit traps\" coloring\r\n    }\r\n    // fractal coloring (fcol global variable)\r\n    fcol=vec3(1.,.3,.0)*m*x; \r\n    fcol=max(fcol,length(p)*.0015*vec3(1.,.9,.8)*(1.-fin))*(1.+organic*.5);\r\n    return (max(p.x,p.y)/p.w-.025*(1.-fin))*.85; // returns the distance estimation to the fractal's surface, with some adjustment towards the end\r\n}\r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// RAYMARCHING\r\n\r\n// Returns the perpendicular vector to the surface at a given point\r\nvec3 normal(vec3 p) {\r\n    vec3 d=vec3(0.,det*2.,0.);\r\n\treturn normalize(vec3(de(p-d.yxx),de(p-d.xyx), de(p-d.xxy))-de(p));\r\n}\r\n\r\n\r\n// Ambient occlusion and soft shadows, classic iq's methods\r\n\r\nfloat ao(vec3 p, vec3 n) {\r\n\tfloat td=0., ao=0.;\r\n    for(int i=0; i<6; i++) {\r\n\t\ttd+=.05;\r\n\t\tfloat d=de(p-n*td);\r\n        ao+=max(0.,(td-d)/td);\r\n    }\r\n\treturn clamp(1.-ao*.1,0.,1.);\r\n}\r\n\r\n\r\nfloat shadow(vec3 p) {\r\n\tfloat sh=1.,td=.1;\r\n    for (int i=0; i<50; i++) {\r\n\t\tp+=ldir*td;\r\n        float d=de(p);\r\n\t\ttd+=d;\r\n        sh=min(sh,10.*d/td);\r\n        if (sh<.05) break;\r\n    }\r\n    return clamp(sh,0.,1.);\r\n}\r\n\r\n// Lighting\r\n\r\nvec3 shade(vec3 p, vec3 dir, vec3 n, vec3 col) {\r\n\tfloat sha=shadow(p); \r\n    float aoc=ao(p,n);\r\n    float amb=.25*aoc; // ambient light with ambient occlusion\r\n    float dif=max(0.,dot(ldir,-n))*sha; // diffuse light with shadow\r\n    vec3 ref=reflect(dir,n); // reflection vector\r\n    float spe=pow(max(0.,dot(ldir,ref)),10.)*.7*sha; // specular lights    \r\n    return col*(amb+dif)+spe*suncol; // lighting applied to the surface color\r\n}\r\n\r\n// Raymarching\r\n\r\nvec4 march(vec3 from, vec3 dir, vec3 camdir) {\r\n    // variable declarations\r\n\tvec3 p=from, col=vec3(0.1), backcol=col;\r\n    float totdist=0., d=0.,sdet, glow=0., lhit=1.;\r\n\t// the detail value is smaller towards the end as we are closer to the fractal boundary\r\n   \tdet*=1.-fin*.7;\r\n    // raymarching loop to obtain an occlusion value of the sun at the camera direction\r\n    // used for the lens flare\r\n    for (int i=0; i<70; i++) {\r\n    \tp+=d*ldir; // advance ray from camera pos to light dir\r\n        d=de(p)*2.; // distance estimation, doubled to gain performance as we don't need too much accuracy for this\r\n        lhit=min(lhit,d); // occlusion value based on how close the ray pass from the surfaces and very small if it hits \r\n        if (d<det) { // ray hits the surface, bye\r\n            break;\r\n        }\r\n    }\r\n    // main raymarching loop\r\n    for (int i=0; i<150; i++) {\r\n    \tp=from+totdist*dir; // advance ray\r\n        d=de(p); // distance estimation to fractal surface\r\n        sdet=det*(1.+totdist*.1); // makes the detail level lower for far hits \r\n        if (d<sdet||totdist>maxdist) break; // ray hits the surface or it reached the max distance defined\r\n    \ttotdist+=d; // distance accumulator  \r\n        glow++; // step counting used for glow\r\n    }\r\n    float sun=max(0.,dot(dir,ldir)); // the dot product of the cam direction and the light direction using for drawing the sun\r\n    if (d<.2) { // ray most likely hit a surface\r\n    \tp-=(sdet-d)*dir; // backstep to correct the ray position\r\n        vec3 c=fcol; // saves the color set by the de function to not get altered by the normal calculation\r\n        vec3 n=normal(p); // calculates the normal at the ray hit point\r\n        col=shade(p,dir,n,c); // sets the color and lighting\r\n    } else { // ray missed any surface, this is the background\r\n        totdist=maxdist; \r\n    \tp=from+dir*maxdist; // moves the ray to the max distance defined\r\n        // Kaliset fractal for stars and cosmic dust near the sun. \r\n        vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;\r\n        for (int i = 0; i < 10; i++) st = abs(st) / dot(st,st) - .8;\r\n        backcol+=length(st)*.015*(1.-pow(sun,3.))*(.5+abs(st.grb)*.5);\r\n        sun-=length(st)*.0017;\r\n        sun=max(0.,sun);\r\n\t\tbackcol+=pow(sun,100.)*.5; // adds sun light to the background\r\n    }\r\n    backcol+=pow(sun,20.)*suncol*.8; // sun light\r\n    float normdist=totdist/maxdist; // distance of the ray normalized from 0 to 1\r\n    col=mix(col,backcol,pow(normdist,1.5)); // mix the surface with the background in the far distance (fog)\r\n    col=max(col,col*vec3(sqrt(glow))*.13); // adds a little bit of glow\r\n\t// lens flare\r\n    vec2 pflare=dir.xy-ldir.xy;\r\n    float flare=max(0.,1.0-length(pflare))-pow(abs(1.-mod(camdir.x-atan(pflare.y,pflare.x)*5./3.14,2.)),.6);\r\n\tfloat cflare=pow(max(0.,dot(camdir,ldir)),20.)*lhit;\r\n    col+=pow(max(0.,flare),3.)*cflare*suncol;\r\n\tcol+=pow(sun,30.)*cflare;\r\n    // \"only glow\" part (at sec. 10)\r\n    col.rgb=mix(col.rgb,glow*suncol*.01+backcol,1.-smoothstep(0.,.8,abs(time-10.5)));\r\n    return vec4(col,normdist); // returns the resulting color and a normalized depth in alpha\r\n}\t//(depth was going to be used for a postprocessing shader) \r\n\r\n\r\n// -------------------------------------------------------------------------------------------\r\n\r\n// Camera and main function\r\n\r\n// I learnt this function from eiffie,\r\n// it takes a direction, a reference up vec3\r\n// and returns the rotation matrix to orient a vector\r\nmat3 lookat(vec3 dir, vec3 up){\r\n    dir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\r\n    return mat3(rt,cross(rt,dir),dir);\r\n}\r\n\r\n\r\n// the path of the camera at a given point of time\r\nvec3 campath(float ti) {\r\n    float start=pow(max(0.,1.-ti*.02),3.); // interpolation curve for the starting camera\r\n\tvec3 p=pitpath(ti); // path displacement of the fractal \r\n    p*=1.-start; // the camera gradually ends following the fractal when, that happens when start=0\r\n    p+=vec3(start*30.,start*25.,0.); // position offset for starting camera curve   \r\n    return p;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv=fragCoord/iResolution.xy-.5;\r\n    uv.x*=iResolution.x/iResolution.y;\r\n    vec3 dir=normalize(vec3(uv,1.)); // ray direction  \r\n\ttime=mod(iTime,162.); // time loop\r\n    fin=smoothstep(145.,147.5,time); // aux variable used for the end sequence\r\n    // camera accelerations and slow downs\r\n    float acel1=smoothstep(11.,12.,time)*7.31;\r\n    float acel2=smoothstep(99.,100.,time)*4.;\r\n    float desacel1=smoothstep(77.,78.,time)*5.;\r\n    float desacel2=fin*9.5;\r\n\tfloat tt=time;\r\n\t// freeze BW frame\r\n    if (abs(tt-25.5)<.5) tt=25.;\r\n    float acel=acel1+acel2-desacel1-desacel2;\r\n\t// time variable\r\n    float t=tt*(3.6+acel)-acel1*11.-acel2*99.+desacel1*77.+desacel2*147.5;\r\n    t+=smoothstep(125.,145.,time)*243.;\r\n    vec3 from=campath(t); // camera position\r\n    from.y-=desacel2*.035; // camera offset on 2nd slow down\r\n\tvec3 fw=normalize(campath(t+3.)-from); // camera forward direction\r\n    from.x-=fw.x*.1; // camera x offset based on the forward direction\r\n    dir=dir*lookat(fw*vec3(1.,-1.,1.),vec3(fw.x*.2,1.,0.)); // re-orientation of the ray dir with the camera fwd dir\r\n\tldir=normalize(ldir); // light dir normalization \r\n\tvec4 col=march(from, dir, fw); // get color from raymarching and background\r\n    col.rgb=mix(vec3(length(col.rgb)*.6),col.rgb,.85-step(abs(tt-25.),.1)); // BW freeze frame sequence coloring\r\n\tcol.rgb*=1.-smoothstep(25.,26.,time)+step(25.1,tt); // BW freeze frame sequence fading\r\n    col.rgb*=1.+step(abs(tt-25.),.1);\r\n    // PVM Logo color mixing\r\n    vec4 pvm=logo(uv*1.5+vec2(.9,.5))*smoothstep(1.,3.,time+uv.x*2.)*(1.-smoothstep(7.5,8.,time+uv.x*2.));\r\n    col.rgb=mix(col.rgb,pvm.rgb,pvm.a);\r\n    // fade in from black\r\n    col.rgb*=smoothstep(0.,4.,time);\r\n    // fade out to black\r\n    col.rgb*=1.-smoothstep(160.,162.,time);\r\n    fragColor = col;\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Path to the colorful infinity","id":"b7c3b842a33a42eeb6a3da114dc57cfc","date":null,"viewed":0,"name":"Path to the colorful infinity","description":"Moving forward through layers of my \"sponge \"shader (https://www.shadertoy.com/view/MsjfDK)\r\nhttps://www.shadertoy.com/view/WtjyzR","likes":0,"published":null,"tags":["2d"," fractal"," colors"," space"," abstract"," recursive"," generative"," pseudo3d"," inversion"," layers"," symmetries"," travel"," spacefolding"]},"ver":null,"info":{"Name":"Path to the colorful infinity","id":"b7c3b842a33a42eeb6a3da114dc57cfc","date":null,"viewed":0,"name":"Path to the colorful infinity","description":"Moving forward through layers of my \"sponge \"shader (https://www.shadertoy.com/view/MsjfDK)\r\nhttps://www.shadertoy.com/view/WtjyzR","likes":0,"published":null,"tags":["2d"," fractal"," colors"," space"," abstract"," recursive"," generative"," pseudo3d"," inversion"," layers"," symmetries"," travel"," spacefolding"]},"renderpass":[{"Code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Galaxy shader\r\n//\r\n// Created by Frank Hugenroth  /frankenburgh/   07/2015\r\n// Released at nordlicht/bremen 2015\r\n\r\n#define SCREEN_EFFECT 0\r\n\r\n// random/hash function              \r\nfloat hash( float n )\r\n{\r\n  return fract(cos(n)*41415.92653);\r\n}\r\n\r\n// 2d noise function\r\nfloat noise( in vec2 x )\r\n{\r\n  vec2 p  = floor(x);\r\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\r\n  float n = p.x + p.y*57.0;\r\n\r\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n  vec3 p  = floor(x);\r\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\r\n  float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n\r\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\r\n\r\n// Fractional Brownian motion\r\nfloat fbmslow( vec3 p )\r\n{\r\n  float f = 0.5000*noise( p ); p = m*p*1.2;\r\n  f += 0.2500*noise( p ); p = m*p*1.3;\r\n  f += 0.1666*noise( p ); p = m*p*1.4;\r\n  f += 0.0834*noise( p ); p = m*p*1.84;\r\n  return f;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n  float f = 0., a = 1., s=0.;\r\n  f += a*noise( p ); p = m*p*1.149; s += a; a *= .75;\r\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\r\n  f += a*noise( p ); p = m*p*1.51; s += a; a *= .65;\r\n  f += a*noise( p ); p = m*p*1.21; s += a; a *= .35;\r\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\r\n  f += a*noise( p ); \r\n  return f/s;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime * 0.1;\r\n\r\n\tvec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\r\n\t// fade in (1=10sec), out after 8=80sec;\r\n\tfloat fade = min(1., time*1.)*min(1.,max(0., 15.-time));\r\n\t// start glow after 5=50sec\r\n\tfloat fade2= max(0., time-10.)*0.37;\r\n\tfloat glow = max(-.25,1.+pow(fade2, 10.) - 0.001*pow(fade2, 25.));\r\n\t\r\n\t\r\n\t// get camera position and view direction\r\n\tvec3 campos = vec3(500.0, 850., -.0-cos((time-1.4)/2.)*2000.); // moving\r\n\tvec3 camtar = vec3(0., 0., 0.);\r\n\t\r\n\tfloat roll = 0.34;\r\n\tvec3 cw = normalize(camtar-campos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( xy.x*cu + xy.y*cv + 1.6*cw );\r\n\r\n\tvec3 light   = normalize( vec3(  0., 0.,  0. )-campos );\r\n\tfloat sundot = clamp(dot(light,rd),0.0,1.0);\r\n\r\n\t// render sky\r\n\r\n    // galaxy center glow\r\n    vec3 col = glow*1.2*min(vec3(1.0, 1.0, 1.0), vec3(2.0,1.0,0.5)*pow( sundot, 100.0 ));\r\n    // moon haze\r\n    col += 0.3*vec3(0.8,0.9,1.2)*pow( sundot, 8.0 );\r\n\r\n\t// stars\r\n\tvec3 stars = 85.5*vec3(pow(fbmslow(rd.xyz*312.0), 7.0))*vec3(pow(fbmslow(rd.zxy*440.3), 8.0));\r\n\t\r\n\t// moving background fog\r\n    vec3 cpos = 1500.*rd + vec3(831.0-time*30., 321.0, 1000.0);\r\n    col += vec3(0.4, 0.5, 1.0) * ((fbmslow( cpos*0.0035 ) - .5));\r\n\r\n\tcpos += vec3(831.0-time*33., 321.0, 999.);\r\n    col += vec3(0.6, 0.3, 0.6) * 10.0*pow((fbmslow( cpos*0.0045 )), 10.0);\r\n\r\n\tcpos += vec3(3831.0-time*39., 221.0, 999.0);\r\n    col += 0.03*vec3(0.6, 0.0, 0.0) * 10.0*pow((fbmslow( cpos*0.0145 )), 2.0);\r\n\r\n\t// stars\r\n\tcpos = 1500.*rd + vec3(831.0, 321.0, 999.);\r\n\tcol += stars*fbm(cpos*0.0021);\r\n\t\r\n\t\r\n\t// Clouds\r\n    vec2 shift = vec2( time*100.0, time*180.0 );\r\n    vec4 sum = vec4(0,0,0,0); \r\n    float c = campos.y / rd.y; // cloud height\r\n    vec3 cpos2 = campos - c*rd;\r\n    float radius = length(cpos2.xz)/1000.0;\r\n\r\n    if (radius<1.8)\r\n    {\r\n  \t  for (int q=10; q>-10; q--) // layers\r\n      {\r\n\t\tif (sum.w>0.999) continue;\r\n        float c = (float(q)*8.-campos.y) / rd.y; // cloud height\r\n        vec3 cpos = campos + c*rd;\r\n\r\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\r\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\r\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\r\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\r\n\r\n\t\t// border\r\n \t    float radius = length(cpos.xz)/999.;\r\n\t    if (radius>1.0)\r\n\t      continue;\r\n\r\n\t\tfloat rot = 3.00*(radius)-time;\r\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\r\n \t\r\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); // cloud position\r\n\t\tcpos *= mix(0.0025, 0.0028, radius); // zoom\r\n      \tfloat alpha = smoothstep(0.50, 1.0, fbm( cpos )); // fractal cloud density\r\n\t  \talpha *= 1.3*pow(smoothstep(1.0, 0.0, radius), 0.3); // fade out disc at edges\r\n\t  \tvec3 dustcolor = mix(vec3( 2.0, 1.3, 1.0 ), vec3( 0.1,0.2,0.3 ), pow(radius, .5));\r\n      \tvec3 localcolor = mix(dustcolor, shine, alpha); // density color white->gray\r\n\t\t  \r\n\t\tfloat gstar = 2.*pow(noise( cpos*21.40 ), 22.0);\r\n\t\tfloat gstar2= 3.*pow(noise( cpos*26.55 ), 34.0);\r\n\t\tfloat gholes= 1.*pow(noise( cpos*11.55 ), 14.0);\r\n\t\tlocalcolor += vec3(1.0, 0.6, 0.3)*gstar;\r\n\t\tlocalcolor += vec3(1.0, 1.0, 0.7)*gstar2;\r\n\t\tlocalcolor -= gholes;\r\n\t\t  \r\n        alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\r\n        sum += vec4(localcolor*alpha, alpha); // sum up weightened color\r\n\t  }\r\n\t\t\r\n  \t  for (int q=0; q<20; q++) // 120 layers\r\n      {\r\n\t\tif (sum.w>0.999) continue;\r\n        float c = (float(q)*4.-campos.y) / rd.y; // cloud height\r\n        vec3 cpos = campos + c*rd;\r\n\r\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\r\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\r\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\r\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\r\n\r\n\t\t// border\r\n \t    float radius = length(cpos.xz)/200.0;\r\n\t    if (radius>1.0)\r\n\t      continue;\r\n\r\n\t\tfloat rot = 3.2*(radius)-time*1.1;\r\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\r\n \t\r\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); // cloud position\r\n      \tfloat alpha = 0.1+smoothstep(0.6, 1.0, fbm( cpos )); // fractal cloud density\r\n\t  \talpha *= 1.2*(pow(smoothstep(1.0, 0.0, radius), 0.72) - pow(smoothstep(1.0, 0.0, radius*1.875), 0.2)); // fade out disc at edges\r\n      \tvec3 localcolor = vec3(0.0, 0.0, 0.0); // density color white->gray\r\n  \r\n        alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\r\n        sum += vec4(localcolor*alpha, alpha); // sum up weightened color\r\n\t  }\r\n    }\r\n\tfloat alpha = smoothstep(1.-radius*.5, 1.0, sum.w);\r\n    sum.rgb /= sum.w+0.0001;\r\n    sum.rgb -= 0.2*vec3(0.8, 0.75, 0.7) * pow(sundot,10.0)*alpha;\r\n    sum.rgb += min(glow, 10.0)*0.2*vec3(1.2, 1.2, 1.2) * pow(sundot,5.0)*(1.0-alpha);\r\n\r\n   \tcol = mix( col, sum.rgb , sum.w);//*pow(sundot,10.0) );\r\n\r\n    // haze\r\n\tcol = fade*mix(col, vec3(0.3,0.5,.9), 29.0*(pow( sundot, 50.0 )-pow( sundot, 60.0 ))/(2.+9.*abs(rd.y)));\r\n\r\n#if SCREEN_EFFECT == 1\r\n    if (time<2.5)\r\n    {\r\n    \t// screen effect\r\n    \tfloat c = (col.r+col.g+col.b)* .3 * (.6+.3*cos(gl_FragCoord.y*1.2543)) + .1*(noise((xy+time*2.)*294.)*noise((xy-time*3.)*321.));\r\n   \t    c += max(0.,.08*sin(10.*time+xy.y*7.2543));\r\n        // flicker\r\n\t\tcol = vec3(c, c, c) * (1.-0.5*pow(noise(vec2(time*99., 0.)), 9.));\r\n    }\r\n    else\r\n    {\r\n        // bam\r\n        float c = clamp(1.-(time-2.5)*6., 0., 1. );\r\n        col = mix(col, vec3(1.,1.,1.),c);\r\n    }\r\n#endif\r\n    \r\n    // Vignetting\r\n\tvec2 xy2 = gl_FragCoord.xy / iResolution.xy;\r\n\tcol *= vec3(.5, .5, .5) + 0.25*pow(100.0*xy2.x*xy2.y*(1.0-xy2.x)*(1.0-xy2.y), .5 );\t\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Galaxy shader\r\n//\r\n// Created by Frank Hugenroth  /frankenburgh/   07/2015\r\n// Released at nordlicht/bremen 2015\r\n\r\n#define SCREEN_EFFECT 0\r\n\r\n// random/hash function              \r\nfloat hash( float n )\r\n{\r\n  return fract(cos(n)*41415.92653);\r\n}\r\n\r\n// 2d noise function\r\nfloat noise( in vec2 x )\r\n{\r\n  vec2 p  = floor(x);\r\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\r\n  float n = p.x + p.y*57.0;\r\n\r\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n  vec3 p  = floor(x);\r\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\r\n  float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n\r\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\r\n\r\n// Fractional Brownian motion\r\nfloat fbmslow( vec3 p )\r\n{\r\n  float f = 0.5000*noise( p ); p = m*p*1.2;\r\n  f += 0.2500*noise( p ); p = m*p*1.3;\r\n  f += 0.1666*noise( p ); p = m*p*1.4;\r\n  f += 0.0834*noise( p ); p = m*p*1.84;\r\n  return f;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n  float f = 0., a = 1., s=0.;\r\n  f += a*noise( p ); p = m*p*1.149; s += a; a *= .75;\r\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\r\n  f += a*noise( p ); p = m*p*1.51; s += a; a *= .65;\r\n  f += a*noise( p ); p = m*p*1.21; s += a; a *= .35;\r\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\r\n  f += a*noise( p ); \r\n  return f/s;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime * 0.1;\r\n\r\n\tvec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\r\n\t// fade in (1=10sec), out after 8=80sec;\r\n\tfloat fade = min(1., time*1.)*min(1.,max(0., 15.-time));\r\n\t// start glow after 5=50sec\r\n\tfloat fade2= max(0., time-10.)*0.37;\r\n\tfloat glow = max(-.25,1.+pow(fade2, 10.) - 0.001*pow(fade2, 25.));\r\n\t\r\n\t\r\n\t// get camera position and view direction\r\n\tvec3 campos = vec3(500.0, 850., -.0-cos((time-1.4)/2.)*2000.); // moving\r\n\tvec3 camtar = vec3(0., 0., 0.);\r\n\t\r\n\tfloat roll = 0.34;\r\n\tvec3 cw = normalize(camtar-campos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( xy.x*cu + xy.y*cv + 1.6*cw );\r\n\r\n\tvec3 light   = normalize( vec3(  0., 0.,  0. )-campos );\r\n\tfloat sundot = clamp(dot(light,rd),0.0,1.0);\r\n\r\n\t// render sky\r\n\r\n    // galaxy center glow\r\n    vec3 col = glow*1.2*min(vec3(1.0, 1.0, 1.0), vec3(2.0,1.0,0.5)*pow( sundot, 100.0 ));\r\n    // moon haze\r\n    col += 0.3*vec3(0.8,0.9,1.2)*pow( sundot, 8.0 );\r\n\r\n\t// stars\r\n\tvec3 stars = 85.5*vec3(pow(fbmslow(rd.xyz*312.0), 7.0))*vec3(pow(fbmslow(rd.zxy*440.3), 8.0));\r\n\t\r\n\t// moving background fog\r\n    vec3 cpos = 1500.*rd + vec3(831.0-time*30., 321.0, 1000.0);\r\n    col += vec3(0.4, 0.5, 1.0) * ((fbmslow( cpos*0.0035 ) - .5));\r\n\r\n\tcpos += vec3(831.0-time*33., 321.0, 999.);\r\n    col += vec3(0.6, 0.3, 0.6) * 10.0*pow((fbmslow( cpos*0.0045 )), 10.0);\r\n\r\n\tcpos += vec3(3831.0-time*39., 221.0, 999.0);\r\n    col += 0.03*vec3(0.6, 0.0, 0.0) * 10.0*pow((fbmslow( cpos*0.0145 )), 2.0);\r\n\r\n\t// stars\r\n\tcpos = 1500.*rd + vec3(831.0, 321.0, 999.);\r\n\tcol += stars*fbm(cpos*0.0021);\r\n\t\r\n\t\r\n\t// Clouds\r\n    vec2 shift = vec2( time*100.0, time*180.0 );\r\n    vec4 sum = vec4(0,0,0,0); \r\n    float c = campos.y / rd.y; // cloud height\r\n    vec3 cpos2 = campos - c*rd;\r\n    float radius = length(cpos2.xz)/1000.0;\r\n\r\n    if (radius<1.8)\r\n    {\r\n  \t  for (int q=10; q>-10; q--) // layers\r\n      {\r\n\t\tif (sum.w>0.999) continue;\r\n        float c = (float(q)*8.-campos.y) / rd.y; // cloud height\r\n        vec3 cpos = campos + c*rd;\r\n\r\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\r\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\r\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\r\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\r\n\r\n\t\t// border\r\n \t    float radius = length(cpos.xz)/999.;\r\n\t    if (radius>1.0)\r\n\t      continue;\r\n\r\n\t\tfloat rot = 3.00*(radius)-time;\r\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\r\n \t\r\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); // cloud position\r\n\t\tcpos *= mix(0.0025, 0.0028, radius); // zoom\r\n      \tfloat alpha = smoothstep(0.50, 1.0, fbm( cpos )); // fractal cloud density\r\n\t  \talpha *= 1.3*pow(smoothstep(1.0, 0.0, radius), 0.3); // fade out disc at edges\r\n\t  \tvec3 dustcolor = mix(vec3( 2.0, 1.3, 1.0 ), vec3( 0.1,0.2,0.3 ), pow(radius, .5));\r\n      \tvec3 localcolor = mix(dustcolor, shine, alpha); // density color white->gray\r\n\t\t  \r\n\t\tfloat gstar = 2.*pow(noise( cpos*21.40 ), 22.0);\r\n\t\tfloat gstar2= 3.*pow(noise( cpos*26.55 ), 34.0);\r\n\t\tfloat gholes= 1.*pow(noise( cpos*11.55 ), 14.0);\r\n\t\tlocalcolor += vec3(1.0, 0.6, 0.3)*gstar;\r\n\t\tlocalcolor += vec3(1.0, 1.0, 0.7)*gstar2;\r\n\t\tlocalcolor -= gholes;\r\n\t\t  \r\n        alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\r\n        sum += vec4(localcolor*alpha, alpha); // sum up weightened color\r\n\t  }\r\n\t\t\r\n  \t  for (int q=0; q<20; q++) // 120 layers\r\n      {\r\n\t\tif (sum.w>0.999) continue;\r\n        float c = (float(q)*4.-campos.y) / rd.y; // cloud height\r\n        vec3 cpos = campos + c*rd;\r\n\r\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\r\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\r\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\r\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\r\n\r\n\t\t// border\r\n \t    float radius = length(cpos.xz)/200.0;\r\n\t    if (radius>1.0)\r\n\t      continue;\r\n\r\n\t\tfloat rot = 3.2*(radius)-time*1.1;\r\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\r\n \t\r\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); // cloud position\r\n      \tfloat alpha = 0.1+smoothstep(0.6, 1.0, fbm( cpos )); // fractal cloud density\r\n\t  \talpha *= 1.2*(pow(smoothstep(1.0, 0.0, radius), 0.72) - pow(smoothstep(1.0, 0.0, radius*1.875), 0.2)); // fade out disc at edges\r\n      \tvec3 localcolor = vec3(0.0, 0.0, 0.0); // density color white->gray\r\n  \r\n        alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\r\n        sum += vec4(localcolor*alpha, alpha); // sum up weightened color\r\n\t  }\r\n    }\r\n\tfloat alpha = smoothstep(1.-radius*.5, 1.0, sum.w);\r\n    sum.rgb /= sum.w+0.0001;\r\n    sum.rgb -= 0.2*vec3(0.8, 0.75, 0.7) * pow(sundot,10.0)*alpha;\r\n    sum.rgb += min(glow, 10.0)*0.2*vec3(1.2, 1.2, 1.2) * pow(sundot,5.0)*(1.0-alpha);\r\n\r\n   \tcol = mix( col, sum.rgb , sum.w);//*pow(sundot,10.0) );\r\n\r\n    // haze\r\n\tcol = fade*mix(col, vec3(0.3,0.5,.9), 29.0*(pow( sundot, 50.0 )-pow( sundot, 60.0 ))/(2.+9.*abs(rd.y)));\r\n\r\n#if SCREEN_EFFECT == 1\r\n    if (time<2.5)\r\n    {\r\n    \t// screen effect\r\n    \tfloat c = (col.r+col.g+col.b)* .3 * (.6+.3*cos(gl_FragCoord.y*1.2543)) + .1*(noise((xy+time*2.)*294.)*noise((xy-time*3.)*321.));\r\n   \t    c += max(0.,.08*sin(10.*time+xy.y*7.2543));\r\n        // flicker\r\n\t\tcol = vec3(c, c, c) * (1.-0.5*pow(noise(vec2(time*99., 0.)), 9.));\r\n    }\r\n    else\r\n    {\r\n        // bam\r\n        float c = clamp(1.-(time-2.5)*6., 0., 1. );\r\n        col = mix(col, vec3(1.,1.,1.),c);\r\n    }\r\n#endif\r\n    \r\n    // Vignetting\r\n\tvec2 xy2 = gl_FragCoord.xy / iResolution.xy;\r\n\tcol *= vec3(.5, .5, .5) + 0.25*pow(100.0*xy2.x*xy2.y*(1.0-xy2.x)*(1.0-xy2.y), .5 );\t\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Pegasus Galaxy","id":"f306c2cde3564613b977e7d9cb29f302","date":null,"viewed":0,"name":"Pegasus Galaxy","description":"Galaxy shader from Pegasus 4k Intro\n4kb executable: http://www.pouet.net/prod.php?which=65859\nhttps://www.youtube.com/watch?v=3pXhImWoNsw\nhttps://www.shadertoy.com/view/lty3Rt","likes":0,"published":null,"tags":["clouds"," space"," galaxy"," stars"," demsoscene"," nebular"]},"ver":null,"info":{"Name":"Pegasus Galaxy","id":"f306c2cde3564613b977e7d9cb29f302","date":null,"viewed":0,"name":"Pegasus Galaxy","description":"Galaxy shader from Pegasus 4k Intro\n4kb executable: http://www.pouet.net/prod.php?which=65859\nhttps://www.youtube.com/watch?v=3pXhImWoNsw\nhttps://www.shadertoy.com/view/lty3Rt","likes":0,"published":null,"tags":["clouds"," space"," galaxy"," stars"," demsoscene"," nebular"]},"renderpass":[{"Code":"// Galaxy shader\r\n//\r\n// Created by Frank Hugenroth  /frankenburgh/   07/2015\r\n// Released at nordlicht/bremen 2015\r\n\r\n#define SCREEN_EFFECT 0\r\n\r\n// random/hash function              \r\nfloat hash( float n )\r\n{\r\n  return fract(cos(n)*41415.92653);\r\n}\r\n\r\n// 2d noise function\r\nfloat noise( in vec2 x )\r\n{\r\n  vec2 p  = floor(x);\r\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\r\n  float n = p.x + p.y*57.0;\r\n\r\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n  vec3 p  = floor(x);\r\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\r\n  float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n\r\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\r\n\r\n// Fractional Brownian motion\r\nfloat fbmslow( vec3 p )\r\n{\r\n  float f = 0.5000*noise( p ); p = m*p*1.2;\r\n  f += 0.2500*noise( p ); p = m*p*1.3;\r\n  f += 0.1666*noise( p ); p = m*p*1.4;\r\n  f += 0.0834*noise( p ); p = m*p*1.84;\r\n  return f;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n  float f = 0., a = 1., s=0.;\r\n  f += a*noise( p ); p = m*p*1.149; s += a; a *= .75;\r\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\r\n  f += a*noise( p ); p = m*p*1.51; s += a; a *= .65;\r\n  f += a*noise( p ); p = m*p*1.21; s += a; a *= .35;\r\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\r\n  f += a*noise( p ); \r\n  return f/s;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime * 0.1;\r\n\r\n\tvec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\r\n\t// fade in (1=10sec), out after 8=80sec;\r\n\tfloat fade = min(1., time*1.)*min(1.,max(0., 15.-time));\r\n\t// start glow after 5=50sec\r\n\tfloat fade2= max(0., time-10.)*0.37;\r\n\tfloat glow = max(-.25,1.+pow(fade2, 10.) - 0.001*pow(fade2, 25.));\r\n\t\r\n\t\r\n\t// get camera position and view direction\r\n\tvec3 campos = vec3(500.0, 850., -.0-cos((time-1.4)/2.)*2000.); // moving\r\n\tvec3 camtar = vec3(0., 0., 0.);\r\n\t\r\n\tfloat roll = 0.34;\r\n\tvec3 cw = normalize(camtar-campos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( xy.x*cu + xy.y*cv + 1.6*cw );\r\n\r\n\tvec3 light   = normalize( vec3(  0., 0.,  0. )-campos );\r\n\tfloat sundot = clamp(dot(light,rd),0.0,1.0);\r\n\r\n\t// render sky\r\n\r\n    // galaxy center glow\r\n    vec3 col = glow*1.2*min(vec3(1.0, 1.0, 1.0), vec3(2.0,1.0,0.5)*pow( sundot, 100.0 ));\r\n    // moon haze\r\n    col += 0.3*vec3(0.8,0.9,1.2)*pow( sundot, 8.0 );\r\n\r\n\t// stars\r\n\tvec3 stars = 85.5*vec3(pow(fbmslow(rd.xyz*312.0), 7.0))*vec3(pow(fbmslow(rd.zxy*440.3), 8.0));\r\n\t\r\n\t// moving background fog\r\n    vec3 cpos = 1500.*rd + vec3(831.0-time*30., 321.0, 1000.0);\r\n    col += vec3(0.4, 0.5, 1.0) * ((fbmslow( cpos*0.0035 ) - .5));\r\n\r\n\tcpos += vec3(831.0-time*33., 321.0, 999.);\r\n    col += vec3(0.6, 0.3, 0.6) * 10.0*pow((fbmslow( cpos*0.0045 )), 10.0);\r\n\r\n\tcpos += vec3(3831.0-time*39., 221.0, 999.0);\r\n    col += 0.03*vec3(0.6, 0.0, 0.0) * 10.0*pow((fbmslow( cpos*0.0145 )), 2.0);\r\n\r\n\t// stars\r\n\tcpos = 1500.*rd + vec3(831.0, 321.0, 999.);\r\n\tcol += stars*fbm(cpos*0.0021);\r\n\t\r\n\t\r\n\t// Clouds\r\n    vec2 shift = vec2( time*100.0, time*180.0 );\r\n    vec4 sum = vec4(0,0,0,0); \r\n    float c = campos.y / rd.y; // cloud height\r\n    vec3 cpos2 = campos - c*rd;\r\n    float radius = length(cpos2.xz)/1000.0;\r\n\r\n    if (radius<1.8)\r\n    {\r\n  \t  for (int q=10; q>-10; q--) // layers\r\n      {\r\n\t\tif (sum.w>0.999) continue;\r\n        float c = (float(q)*8.-campos.y) / rd.y; // cloud height\r\n        vec3 cpos = campos + c*rd;\r\n\r\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\r\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\r\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\r\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\r\n\r\n\t\t// border\r\n \t    float radius = length(cpos.xz)/999.;\r\n\t    if (radius>1.0)\r\n\t      continue;\r\n\r\n\t\tfloat rot = 3.00*(radius)-time;\r\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\r\n \t\r\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); // cloud position\r\n\t\tcpos *= mix(0.0025, 0.0028, radius); // zoom\r\n      \tfloat alpha = smoothstep(0.50, 1.0, fbm( cpos )); // fractal cloud density\r\n\t  \talpha *= 1.3*pow(smoothstep(1.0, 0.0, radius), 0.3); // fade out disc at edges\r\n\t  \tvec3 dustcolor = mix(vec3( 2.0, 1.3, 1.0 ), vec3( 0.1,0.2,0.3 ), pow(radius, .5));\r\n      \tvec3 localcolor = mix(dustcolor, shine, alpha); // density color white->gray\r\n\t\t  \r\n\t\tfloat gstar = 2.*pow(noise( cpos*21.40 ), 22.0);\r\n\t\tfloat gstar2= 3.*pow(noise( cpos*26.55 ), 34.0);\r\n\t\tfloat gholes= 1.*pow(noise( cpos*11.55 ), 14.0);\r\n\t\tlocalcolor += vec3(1.0, 0.6, 0.3)*gstar;\r\n\t\tlocalcolor += vec3(1.0, 1.0, 0.7)*gstar2;\r\n\t\tlocalcolor -= gholes;\r\n\t\t  \r\n        alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\r\n        sum += vec4(localcolor*alpha, alpha); // sum up weightened color\r\n\t  }\r\n\t\t\r\n  \t  for (int q=0; q<20; q++) // 120 layers\r\n      {\r\n\t\tif (sum.w>0.999) continue;\r\n        float c = (float(q)*4.-campos.y) / rd.y; // cloud height\r\n        vec3 cpos = campos + c*rd;\r\n\r\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\r\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\r\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\r\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\r\n\r\n\t\t// border\r\n \t    float radius = length(cpos.xz)/200.0;\r\n\t    if (radius>1.0)\r\n\t      continue;\r\n\r\n\t\tfloat rot = 3.2*(radius)-time*1.1;\r\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\r\n \t\r\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); // cloud position\r\n      \tfloat alpha = 0.1+smoothstep(0.6, 1.0, fbm( cpos )); // fractal cloud density\r\n\t  \talpha *= 1.2*(pow(smoothstep(1.0, 0.0, radius), 0.72) - pow(smoothstep(1.0, 0.0, radius*1.875), 0.2)); // fade out disc at edges\r\n      \tvec3 localcolor = vec3(0.0, 0.0, 0.0); // density color white->gray\r\n  \r\n        alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\r\n        sum += vec4(localcolor*alpha, alpha); // sum up weightened color\r\n\t  }\r\n    }\r\n\tfloat alpha = smoothstep(1.-radius*.5, 1.0, sum.w);\r\n    sum.rgb /= sum.w+0.0001;\r\n    sum.rgb -= 0.2*vec3(0.8, 0.75, 0.7) * pow(sundot,10.0)*alpha;\r\n    sum.rgb += min(glow, 10.0)*0.2*vec3(1.2, 1.2, 1.2) * pow(sundot,5.0)*(1.0-alpha);\r\n\r\n   \tcol = mix( col, sum.rgb , sum.w);//*pow(sundot,10.0) );\r\n\r\n    // haze\r\n\tcol = fade*mix(col, vec3(0.3,0.5,.9), 29.0*(pow( sundot, 50.0 )-pow( sundot, 60.0 ))/(2.+9.*abs(rd.y)));\r\n\r\n#if SCREEN_EFFECT == 1\r\n    if (time<2.5)\r\n    {\r\n    \t// screen effect\r\n    \tfloat c = (col.r+col.g+col.b)* .3 * (.6+.3*cos(gl_FragCoord.y*1.2543)) + .1*(noise((xy+time*2.)*294.)*noise((xy-time*3.)*321.));\r\n   \t    c += max(0.,.08*sin(10.*time+xy.y*7.2543));\r\n        // flicker\r\n\t\tcol = vec3(c, c, c) * (1.-0.5*pow(noise(vec2(time*99., 0.)), 9.));\r\n    }\r\n    else\r\n    {\r\n        // bam\r\n        float c = clamp(1.-(time-2.5)*6., 0., 1. );\r\n        col = mix(col, vec3(1.,1.,1.),c);\r\n    }\r\n#endif\r\n    \r\n    // Vignetting\r\n\tvec2 xy2 = gl_FragCoord.xy / iResolution.xy;\r\n\tcol *= vec3(.5, .5, .5) + 0.25*pow(100.0*xy2.x*xy2.y*(1.0-xy2.x)*(1.0-xy2.y), .5 );\t\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Galaxy shader\r\n//\r\n// Created by Frank Hugenroth  /frankenburgh/   07/2015\r\n// Released at nordlicht/bremen 2015\r\n\r\n#define SCREEN_EFFECT 0\r\n\r\n// random/hash function              \r\nfloat hash( float n )\r\n{\r\n  return fract(cos(n)*41415.92653);\r\n}\r\n\r\n// 2d noise function\r\nfloat noise( in vec2 x )\r\n{\r\n  vec2 p  = floor(x);\r\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\r\n  float n = p.x + p.y*57.0;\r\n\r\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n  vec3 p  = floor(x);\r\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\r\n  float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n\r\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\r\n\r\n// Fractional Brownian motion\r\nfloat fbmslow( vec3 p )\r\n{\r\n  float f = 0.5000*noise( p ); p = m*p*1.2;\r\n  f += 0.2500*noise( p ); p = m*p*1.3;\r\n  f += 0.1666*noise( p ); p = m*p*1.4;\r\n  f += 0.0834*noise( p ); p = m*p*1.84;\r\n  return f;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n  float f = 0., a = 1., s=0.;\r\n  f += a*noise( p ); p = m*p*1.149; s += a; a *= .75;\r\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\r\n  f += a*noise( p ); p = m*p*1.51; s += a; a *= .65;\r\n  f += a*noise( p ); p = m*p*1.21; s += a; a *= .35;\r\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\r\n  f += a*noise( p ); \r\n  return f/s;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime * 0.1;\r\n\r\n\tvec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\r\n\t// fade in (1=10sec), out after 8=80sec;\r\n\tfloat fade = min(1., time*1.)*min(1.,max(0., 15.-time));\r\n\t// start glow after 5=50sec\r\n\tfloat fade2= max(0., time-10.)*0.37;\r\n\tfloat glow = max(-.25,1.+pow(fade2, 10.) - 0.001*pow(fade2, 25.));\r\n\t\r\n\t\r\n\t// get camera position and view direction\r\n\tvec3 campos = vec3(500.0, 850., -.0-cos((time-1.4)/2.)*2000.); // moving\r\n\tvec3 camtar = vec3(0., 0., 0.);\r\n\t\r\n\tfloat roll = 0.34;\r\n\tvec3 cw = normalize(camtar-campos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( xy.x*cu + xy.y*cv + 1.6*cw );\r\n\r\n\tvec3 light   = normalize( vec3(  0., 0.,  0. )-campos );\r\n\tfloat sundot = clamp(dot(light,rd),0.0,1.0);\r\n\r\n\t// render sky\r\n\r\n    // galaxy center glow\r\n    vec3 col = glow*1.2*min(vec3(1.0, 1.0, 1.0), vec3(2.0,1.0,0.5)*pow( sundot, 100.0 ));\r\n    // moon haze\r\n    col += 0.3*vec3(0.8,0.9,1.2)*pow( sundot, 8.0 );\r\n\r\n\t// stars\r\n\tvec3 stars = 85.5*vec3(pow(fbmslow(rd.xyz*312.0), 7.0))*vec3(pow(fbmslow(rd.zxy*440.3), 8.0));\r\n\t\r\n\t// moving background fog\r\n    vec3 cpos = 1500.*rd + vec3(831.0-time*30., 321.0, 1000.0);\r\n    col += vec3(0.4, 0.5, 1.0) * ((fbmslow( cpos*0.0035 ) - .5));\r\n\r\n\tcpos += vec3(831.0-time*33., 321.0, 999.);\r\n    col += vec3(0.6, 0.3, 0.6) * 10.0*pow((fbmslow( cpos*0.0045 )), 10.0);\r\n\r\n\tcpos += vec3(3831.0-time*39., 221.0, 999.0);\r\n    col += 0.03*vec3(0.6, 0.0, 0.0) * 10.0*pow((fbmslow( cpos*0.0145 )), 2.0);\r\n\r\n\t// stars\r\n\tcpos = 1500.*rd + vec3(831.0, 321.0, 999.);\r\n\tcol += stars*fbm(cpos*0.0021);\r\n\t\r\n\t\r\n\t// Clouds\r\n    vec2 shift = vec2( time*100.0, time*180.0 );\r\n    vec4 sum = vec4(0,0,0,0); \r\n    float c = campos.y / rd.y; // cloud height\r\n    vec3 cpos2 = campos - c*rd;\r\n    float radius = length(cpos2.xz)/1000.0;\r\n\r\n    if (radius<1.8)\r\n    {\r\n  \t  for (int q=10; q>-10; q--) // layers\r\n      {\r\n\t\tif (sum.w>0.999) continue;\r\n        float c = (float(q)*8.-campos.y) / rd.y; // cloud height\r\n        vec3 cpos = campos + c*rd;\r\n\r\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\r\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\r\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\r\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\r\n\r\n\t\t// border\r\n \t    float radius = length(cpos.xz)/999.;\r\n\t    if (radius>1.0)\r\n\t      continue;\r\n\r\n\t\tfloat rot = 3.00*(radius)-time;\r\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\r\n \t\r\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); // cloud position\r\n\t\tcpos *= mix(0.0025, 0.0028, radius); // zoom\r\n      \tfloat alpha = smoothstep(0.50, 1.0, fbm( cpos )); // fractal cloud density\r\n\t  \talpha *= 1.3*pow(smoothstep(1.0, 0.0, radius), 0.3); // fade out disc at edges\r\n\t  \tvec3 dustcolor = mix(vec3( 2.0, 1.3, 1.0 ), vec3( 0.1,0.2,0.3 ), pow(radius, .5));\r\n      \tvec3 localcolor = mix(dustcolor, shine, alpha); // density color white->gray\r\n\t\t  \r\n\t\tfloat gstar = 2.*pow(noise( cpos*21.40 ), 22.0);\r\n\t\tfloat gstar2= 3.*pow(noise( cpos*26.55 ), 34.0);\r\n\t\tfloat gholes= 1.*pow(noise( cpos*11.55 ), 14.0);\r\n\t\tlocalcolor += vec3(1.0, 0.6, 0.3)*gstar;\r\n\t\tlocalcolor += vec3(1.0, 1.0, 0.7)*gstar2;\r\n\t\tlocalcolor -= gholes;\r\n\t\t  \r\n        alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\r\n        sum += vec4(localcolor*alpha, alpha); // sum up weightened color\r\n\t  }\r\n\t\t\r\n  \t  for (int q=0; q<20; q++) // 120 layers\r\n      {\r\n\t\tif (sum.w>0.999) continue;\r\n        float c = (float(q)*4.-campos.y) / rd.y; // cloud height\r\n        vec3 cpos = campos + c*rd;\r\n\r\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\r\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\r\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\r\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\r\n\r\n\t\t// border\r\n \t    float radius = length(cpos.xz)/200.0;\r\n\t    if (radius>1.0)\r\n\t      continue;\r\n\r\n\t\tfloat rot = 3.2*(radius)-time*1.1;\r\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\r\n \t\r\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); // cloud position\r\n      \tfloat alpha = 0.1+smoothstep(0.6, 1.0, fbm( cpos )); // fractal cloud density\r\n\t  \talpha *= 1.2*(pow(smoothstep(1.0, 0.0, radius), 0.72) - pow(smoothstep(1.0, 0.0, radius*1.875), 0.2)); // fade out disc at edges\r\n      \tvec3 localcolor = vec3(0.0, 0.0, 0.0); // density color white->gray\r\n  \r\n        alpha = (1.0-sum.w)*alpha; // alpha/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\r\n        sum += vec4(localcolor*alpha, alpha); // sum up weightened color\r\n\t  }\r\n    }\r\n\tfloat alpha = smoothstep(1.-radius*.5, 1.0, sum.w);\r\n    sum.rgb /= sum.w+0.0001;\r\n    sum.rgb -= 0.2*vec3(0.8, 0.75, 0.7) * pow(sundot,10.0)*alpha;\r\n    sum.rgb += min(glow, 10.0)*0.2*vec3(1.2, 1.2, 1.2) * pow(sundot,5.0)*(1.0-alpha);\r\n\r\n   \tcol = mix( col, sum.rgb , sum.w);//*pow(sundot,10.0) );\r\n\r\n    // haze\r\n\tcol = fade*mix(col, vec3(0.3,0.5,.9), 29.0*(pow( sundot, 50.0 )-pow( sundot, 60.0 ))/(2.+9.*abs(rd.y)));\r\n\r\n#if SCREEN_EFFECT == 1\r\n    if (time<2.5)\r\n    {\r\n    \t// screen effect\r\n    \tfloat c = (col.r+col.g+col.b)* .3 * (.6+.3*cos(gl_FragCoord.y*1.2543)) + .1*(noise((xy+time*2.)*294.)*noise((xy-time*3.)*321.));\r\n   \t    c += max(0.,.08*sin(10.*time+xy.y*7.2543));\r\n        // flicker\r\n\t\tcol = vec3(c, c, c) * (1.-0.5*pow(noise(vec2(time*99., 0.)), 9.));\r\n    }\r\n    else\r\n    {\r\n        // bam\r\n        float c = clamp(1.-(time-2.5)*6., 0., 1. );\r\n        col = mix(col, vec3(1.,1.,1.),c);\r\n    }\r\n#endif\r\n    \r\n    // Vignetting\r\n\tvec2 xy2 = gl_FragCoord.xy / iResolution.xy;\r\n\tcol *= vec3(.5, .5, .5) + 0.25*pow(100.0*xy2.x*xy2.y*(1.0-xy2.x)*(1.0-xy2.y), .5 );\t\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2018\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\r\n// Youtube version: https://www.youtube.com/watch?v=q1OBrqtl7Yo\r\n\r\n#if HW_PERFORMANCE==0\r\n#define AA 1\r\n#else\r\n#define AA 2  // Change AA to 1 if it renders too slow for you\r\n#endif\r\n\r\n//#define INTERACTIVE\r\n\r\nmat3 makeBase( in vec3 w )\r\n{\r\n\tfloat k = inversesqrt(1.0-w.y*w.y);\r\n    return mat3( vec3(-w.z,0.0,w.x)*k, \r\n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\r\n                 w);\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\r\n{\r\n\tfloat b = dot( ro, rd );\r\n\tfloat c = dot( ro, ro ) - rad*rad;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt(h);\r\n\treturn vec2(-b-h,-b+h);\r\n}\r\n\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( in vec3 p, in float b, in float r )\r\n{\r\n    float h = clamp( p.z/b, 0.0, 1.0 );\r\n    return length( p - vec3(0.0,0.0,b)*h ) - r;//*(0.2+1.6*h);\r\n}\r\n\r\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\r\nvec4 inverseSF( in vec3 p, const in float n )\r\n{\r\n    const float PI = 3.14159265359;\r\n\tconst float PHI = 1.61803398875;\r\n\r\n    float phi = min(atan(p.y,p.x),PI);\r\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\r\n    float Fk  = pow(PHI,k)/sqrt(5.0);\r\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\r\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \r\n    \r\n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\r\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\r\n\r\n    float ma = 0.0;\r\n    vec4 res = vec4(0);\r\n    for( int s=0; s<4; s++ )\r\n    {\r\n        vec2 uv = vec2(s&1,s>>1);\r\n        float i = dot(F,uv+c);\r\n        float phi = 2.0*PI*fract(i*PHI);\r\n        float cT = 1.0 - (2.0*i+1.0)/n;\r\n        float sT = sqrt(1.0-cT*cT);\r\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\r\n        float a = dot(p,q);\r\n        if (a > ma)\r\n        {\r\n            ma = a;\r\n            res.xyz = q;\r\n            res.w = i;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\r\n{\r\n    float lp = length(p);\r\n    float dmin = lp-1.0;\r\n    {\r\n    vec3 w = p/lp;\r\n    vec4 fibo = inverseSF(w, 700.0);\r\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\r\n    dmin -= 0.07*hh;\r\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\r\n    }\r\n    \r\n    \r\n    float s = 1.0;\r\n    \r\n    #ifdef INTERACTIVE\r\n  //float tt = mod(iTime,5.0);\r\n    float tt = 4.0*iMouse.x/iResolution.x;\r\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\r\n    #endif\r\n    \r\n    for( int i=0; i<3; i++ )\r\n    {\r\n        float h = float(i)/float(3-1);\r\n        \r\n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\r\n        \r\n        // snap\r\n        p -= f.xyz;\r\n\r\n        // orient to surface\r\n        p = p*makeBase(f.xyz);\r\n\r\n        // scale\r\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\r\n        p *= scale;\r\n        p.xy *= 1.2;\r\n        \r\n        //translate\r\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\r\n            \r\n        // measure distance\r\n        s *= scale;\r\n        #ifdef INTERACTIVE\r\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\r\n        #else\r\n        float d = sdCapsule( p, -6.0, 0.42 );\r\n        #endif\r\n        d /= s;\r\n\r\n        if( d<dmin )\r\n        {\r\n            if( doColor )\r\n            {\r\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\r\n\r\n                if( i==0 ) \r\n                {\r\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall\r\n                  //color.xyz = vec3(0.4,0.8,0.1);         // summer\r\n                  //color.xyz = vec3(0.4,0.4,0.8);         // winter\r\n                }\r\n\r\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\r\n                color.xyz = max(color.xyz,0.0);\r\n            }\r\n            dmin = d;\r\n        }\r\n        else\r\n        {\r\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\r\n        }\r\n    }\r\n    \r\n    return dmin;\r\n}\r\n\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcNormal( in vec3 pos, in float ep )\r\n{\r\n    vec4 kk;\r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773;\r\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\r\n#else\r\n    // prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*ep, kk, false);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n    \r\n}\r\n\r\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\r\n{\r\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n    tmin = max(tmin,bound.x);\r\n    tmax = min(tmax,bound.y);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = tmin;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n    \tvec4 kk;\r\n\t\tfloat h = map( ro + rd*t, kk, false );\r\n        res = min( res, k*h/t );\r\n        t += clamp( h, 0.02, 0.20 );\r\n        if( res<0.005 || t>tmax ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\r\n{\r\n    vec4 kk;\r\n    float t = tmin;\r\n\tfor( int i=0; i<512; i++ )\r\n    {\r\n\t\tvec3 p = ro + t*rd;\r\n        float h = map(p,kk,false);\r\n\t\tif( abs(h)<(0.15*t/iResolution.x) ) break;\r\n\t\tt += h*0.5;\r\n        if( t>tmax ) return -1.0;;\r\n\t}\r\n    //if( t>tmax ) t=-1.0;\r\n\r\n    return t;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float an = (iTime-10.0)*0.05;\r\n    \r\n    // camera\t\r\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\r\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\r\n    // camera-to-world rotation\r\n    mat3 ca = makeBase( normalize(ta-ro) );\r\n\r\n    // render    \r\n    vec3 tot = vec3(0.0);\r\n    \r\n    #if AA>1\r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n        #else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n        #endif\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\r\n    \r\n        // background\r\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\r\n\r\n        // bounding volume\r\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n\t\tif( bound.x>0.0 )\r\n        {\r\n        // raycast\r\n        float t = raycast(ro, rd, bound.x, bound.y );\r\n        if( t>0.0 )\r\n        {\r\n            // local geometry            \r\n            vec3 pos = ro + t*rd;\r\n        \tvec3 nor = calcNormal(pos, 0.01);\r\n            vec3 upp = normalize(pos);\r\n            \r\n            // color and occlusion\r\n            vec4 mate; map(pos, mate, true);\r\n            \r\n            // lighting            \r\n            col = vec3(0.0);\r\n        \r\n            // key ligh\r\n            {\r\n                // dif\r\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\r\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\r\n\t\t\t\t// spec\r\n                vec3 hal = normalize(lig-rd);\r\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\r\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\r\n                fre = 0.2 + 0.8*pow(fre,5.0);\r\n                spe *= spe;\r\n                spe *= spe;\r\n                spe *= spe;\r\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\r\n            }\r\n\r\n            // back light\r\n           \t{\r\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\r\n            }\r\n\r\n            // dome light\r\n            {\r\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\r\n                #if 0\r\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\r\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\r\n                #else\r\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\r\n                #endif\r\n            }\r\n            \r\n            // fake sss\r\n            {\r\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\r\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\r\n            }\r\n            \r\n            // grade/sss\r\n            {\r\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\r\n            }\r\n            \r\n            // exposure control\r\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\r\n            \r\n            // display fake occlusion\r\n            //col = mate.www;\r\n        }\r\n        }\r\n    \r\n \r\n        // gamma\r\n        col = pow( col, vec3(0.4545) );\r\n    \r\n        tot += col;\r\n    #if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n    #endif\r\n\r\n    // vignetting\r\n \tvec2 q = fragCoord/iResolution.xy;\r\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2018\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\r\n// Youtube version: https://www.youtube.com/watch?v=q1OBrqtl7Yo\r\n\r\n#if HW_PERFORMANCE==0\r\n#define AA 1\r\n#else\r\n#define AA 2  // Change AA to 1 if it renders too slow for you\r\n#endif\r\n\r\n//#define INTERACTIVE\r\n\r\nmat3 makeBase( in vec3 w )\r\n{\r\n\tfloat k = inversesqrt(1.0-w.y*w.y);\r\n    return mat3( vec3(-w.z,0.0,w.x)*k, \r\n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\r\n                 w);\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\r\n{\r\n\tfloat b = dot( ro, rd );\r\n\tfloat c = dot( ro, ro ) - rad*rad;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt(h);\r\n\treturn vec2(-b-h,-b+h);\r\n}\r\n\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( in vec3 p, in float b, in float r )\r\n{\r\n    float h = clamp( p.z/b, 0.0, 1.0 );\r\n    return length( p - vec3(0.0,0.0,b)*h ) - r;//*(0.2+1.6*h);\r\n}\r\n\r\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\r\nvec4 inverseSF( in vec3 p, const in float n )\r\n{\r\n    const float PI = 3.14159265359;\r\n\tconst float PHI = 1.61803398875;\r\n\r\n    float phi = min(atan(p.y,p.x),PI);\r\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\r\n    float Fk  = pow(PHI,k)/sqrt(5.0);\r\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\r\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \r\n    \r\n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\r\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\r\n\r\n    float ma = 0.0;\r\n    vec4 res = vec4(0);\r\n    for( int s=0; s<4; s++ )\r\n    {\r\n        vec2 uv = vec2(s&1,s>>1);\r\n        float i = dot(F,uv+c);\r\n        float phi = 2.0*PI*fract(i*PHI);\r\n        float cT = 1.0 - (2.0*i+1.0)/n;\r\n        float sT = sqrt(1.0-cT*cT);\r\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\r\n        float a = dot(p,q);\r\n        if (a > ma)\r\n        {\r\n            ma = a;\r\n            res.xyz = q;\r\n            res.w = i;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\r\n{\r\n    float lp = length(p);\r\n    float dmin = lp-1.0;\r\n    {\r\n    vec3 w = p/lp;\r\n    vec4 fibo = inverseSF(w, 700.0);\r\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\r\n    dmin -= 0.07*hh;\r\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\r\n    }\r\n    \r\n    \r\n    float s = 1.0;\r\n    \r\n    #ifdef INTERACTIVE\r\n  //float tt = mod(iTime,5.0);\r\n    float tt = 4.0*iMouse.x/iResolution.x;\r\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\r\n    #endif\r\n    \r\n    for( int i=0; i<3; i++ )\r\n    {\r\n        float h = float(i)/float(3-1);\r\n        \r\n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\r\n        \r\n        // snap\r\n        p -= f.xyz;\r\n\r\n        // orient to surface\r\n        p = p*makeBase(f.xyz);\r\n\r\n        // scale\r\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\r\n        p *= scale;\r\n        p.xy *= 1.2;\r\n        \r\n        //translate\r\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\r\n            \r\n        // measure distance\r\n        s *= scale;\r\n        #ifdef INTERACTIVE\r\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\r\n        #else\r\n        float d = sdCapsule( p, -6.0, 0.42 );\r\n        #endif\r\n        d /= s;\r\n\r\n        if( d<dmin )\r\n        {\r\n            if( doColor )\r\n            {\r\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\r\n\r\n                if( i==0 ) \r\n                {\r\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall\r\n                  //color.xyz = vec3(0.4,0.8,0.1);         // summer\r\n                  //color.xyz = vec3(0.4,0.4,0.8);         // winter\r\n                }\r\n\r\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\r\n                color.xyz = max(color.xyz,0.0);\r\n            }\r\n            dmin = d;\r\n        }\r\n        else\r\n        {\r\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\r\n        }\r\n    }\r\n    \r\n    return dmin;\r\n}\r\n\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcNormal( in vec3 pos, in float ep )\r\n{\r\n    vec4 kk;\r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773;\r\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\r\n#else\r\n    // prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*ep, kk, false);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n    \r\n}\r\n\r\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\r\n{\r\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n    tmin = max(tmin,bound.x);\r\n    tmax = min(tmax,bound.y);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = tmin;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n    \tvec4 kk;\r\n\t\tfloat h = map( ro + rd*t, kk, false );\r\n        res = min( res, k*h/t );\r\n        t += clamp( h, 0.02, 0.20 );\r\n        if( res<0.005 || t>tmax ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\r\n{\r\n    vec4 kk;\r\n    float t = tmin;\r\n\tfor( int i=0; i<512; i++ )\r\n    {\r\n\t\tvec3 p = ro + t*rd;\r\n        float h = map(p,kk,false);\r\n\t\tif( abs(h)<(0.15*t/iResolution.x) ) break;\r\n\t\tt += h*0.5;\r\n        if( t>tmax ) return -1.0;;\r\n\t}\r\n    //if( t>tmax ) t=-1.0;\r\n\r\n    return t;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float an = (iTime-10.0)*0.05;\r\n    \r\n    // camera\t\r\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\r\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\r\n    // camera-to-world rotation\r\n    mat3 ca = makeBase( normalize(ta-ro) );\r\n\r\n    // render    \r\n    vec3 tot = vec3(0.0);\r\n    \r\n    #if AA>1\r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n        #else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n        #endif\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\r\n    \r\n        // background\r\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\r\n\r\n        // bounding volume\r\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n\t\tif( bound.x>0.0 )\r\n        {\r\n        // raycast\r\n        float t = raycast(ro, rd, bound.x, bound.y );\r\n        if( t>0.0 )\r\n        {\r\n            // local geometry            \r\n            vec3 pos = ro + t*rd;\r\n        \tvec3 nor = calcNormal(pos, 0.01);\r\n            vec3 upp = normalize(pos);\r\n            \r\n            // color and occlusion\r\n            vec4 mate; map(pos, mate, true);\r\n            \r\n            // lighting            \r\n            col = vec3(0.0);\r\n        \r\n            // key ligh\r\n            {\r\n                // dif\r\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\r\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\r\n\t\t\t\t// spec\r\n                vec3 hal = normalize(lig-rd);\r\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\r\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\r\n                fre = 0.2 + 0.8*pow(fre,5.0);\r\n                spe *= spe;\r\n                spe *= spe;\r\n                spe *= spe;\r\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\r\n            }\r\n\r\n            // back light\r\n           \t{\r\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\r\n            }\r\n\r\n            // dome light\r\n            {\r\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\r\n                #if 0\r\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\r\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\r\n                #else\r\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\r\n                #endif\r\n            }\r\n            \r\n            // fake sss\r\n            {\r\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\r\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\r\n            }\r\n            \r\n            // grade/sss\r\n            {\r\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\r\n            }\r\n            \r\n            // exposure control\r\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\r\n            \r\n            // display fake occlusion\r\n            //col = mate.www;\r\n        }\r\n        }\r\n    \r\n \r\n        // gamma\r\n        col = pow( col, vec3(0.4545) );\r\n    \r\n        tot += col;\r\n    #if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n    #endif\r\n\r\n    // vignetting\r\n \tvec2 q = fragCoord/iResolution.xy;\r\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Planet Fall","id":"d724204b01764542b01c2a1224d01441","date":null,"viewed":0,"name":"Planet Fall","description":"Pretty much a modification to Klems' shader https://www.shadertoy.com/view/XlcfRs. Make AA 1 in line 7 if it renders too slow for you","likes":0,"published":null,"tags":["3d"," raymarching"," fractal"," distancefield"," sdf"]},"ver":null,"info":{"Name":"Planet Fall","id":"d724204b01764542b01c2a1224d01441","date":null,"viewed":0,"name":"Planet Fall","description":"Pretty much a modification to Klems' shader https://www.shadertoy.com/view/XlcfRs. Make AA 1 in line 7 if it renders too slow for you","likes":0,"published":null,"tags":["3d"," raymarching"," fractal"," distancefield"," sdf"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2018\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\r\n// Youtube version: https://www.youtube.com/watch?v=q1OBrqtl7Yo\r\n\r\n#if HW_PERFORMANCE==0\r\n#define AA 1\r\n#else\r\n#define AA 2  // Change AA to 1 if it renders too slow for you\r\n#endif\r\n\r\n//#define INTERACTIVE\r\n\r\nmat3 makeBase( in vec3 w )\r\n{\r\n\tfloat k = inversesqrt(1.0-w.y*w.y);\r\n    return mat3( vec3(-w.z,0.0,w.x)*k, \r\n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\r\n                 w);\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\r\n{\r\n\tfloat b = dot( ro, rd );\r\n\tfloat c = dot( ro, ro ) - rad*rad;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt(h);\r\n\treturn vec2(-b-h,-b+h);\r\n}\r\n\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( in vec3 p, in float b, in float r )\r\n{\r\n    float h = clamp( p.z/b, 0.0, 1.0 );\r\n    return length( p - vec3(0.0,0.0,b)*h ) - r;//*(0.2+1.6*h);\r\n}\r\n\r\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\r\nvec4 inverseSF( in vec3 p, const in float n )\r\n{\r\n    const float PI = 3.14159265359;\r\n\tconst float PHI = 1.61803398875;\r\n\r\n    float phi = min(atan(p.y,p.x),PI);\r\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\r\n    float Fk  = pow(PHI,k)/sqrt(5.0);\r\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\r\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \r\n    \r\n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\r\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\r\n\r\n    float ma = 0.0;\r\n    vec4 res = vec4(0);\r\n    for( int s=0; s<4; s++ )\r\n    {\r\n        vec2 uv = vec2(s&1,s>>1);\r\n        float i = dot(F,uv+c);\r\n        float phi = 2.0*PI*fract(i*PHI);\r\n        float cT = 1.0 - (2.0*i+1.0)/n;\r\n        float sT = sqrt(1.0-cT*cT);\r\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\r\n        float a = dot(p,q);\r\n        if (a > ma)\r\n        {\r\n            ma = a;\r\n            res.xyz = q;\r\n            res.w = i;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\r\n{\r\n    float lp = length(p);\r\n    float dmin = lp-1.0;\r\n    {\r\n    vec3 w = p/lp;\r\n    vec4 fibo = inverseSF(w, 700.0);\r\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\r\n    dmin -= 0.07*hh;\r\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\r\n    }\r\n    \r\n    \r\n    float s = 1.0;\r\n    \r\n    #ifdef INTERACTIVE\r\n  //float tt = mod(iTime,5.0);\r\n    float tt = 4.0*iMouse.x/iResolution.x;\r\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\r\n    #endif\r\n    \r\n    for( int i=0; i<3; i++ )\r\n    {\r\n        float h = float(i)/float(3-1);\r\n        \r\n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\r\n        \r\n        // snap\r\n        p -= f.xyz;\r\n\r\n        // orient to surface\r\n        p = p*makeBase(f.xyz);\r\n\r\n        // scale\r\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\r\n        p *= scale;\r\n        p.xy *= 1.2;\r\n        \r\n        //translate\r\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\r\n            \r\n        // measure distance\r\n        s *= scale;\r\n        #ifdef INTERACTIVE\r\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\r\n        #else\r\n        float d = sdCapsule( p, -6.0, 0.42 );\r\n        #endif\r\n        d /= s;\r\n\r\n        if( d<dmin )\r\n        {\r\n            if( doColor )\r\n            {\r\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\r\n\r\n                if( i==0 ) \r\n                {\r\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall\r\n                  //color.xyz = vec3(0.4,0.8,0.1);         // summer\r\n                  //color.xyz = vec3(0.4,0.4,0.8);         // winter\r\n                }\r\n\r\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\r\n                color.xyz = max(color.xyz,0.0);\r\n            }\r\n            dmin = d;\r\n        }\r\n        else\r\n        {\r\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\r\n        }\r\n    }\r\n    \r\n    return dmin;\r\n}\r\n\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcNormal( in vec3 pos, in float ep )\r\n{\r\n    vec4 kk;\r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773;\r\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\r\n#else\r\n    // prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*ep, kk, false);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n    \r\n}\r\n\r\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\r\n{\r\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n    tmin = max(tmin,bound.x);\r\n    tmax = min(tmax,bound.y);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = tmin;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n    \tvec4 kk;\r\n\t\tfloat h = map( ro + rd*t, kk, false );\r\n        res = min( res, k*h/t );\r\n        t += clamp( h, 0.02, 0.20 );\r\n        if( res<0.005 || t>tmax ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\r\n{\r\n    vec4 kk;\r\n    float t = tmin;\r\n\tfor( int i=0; i<512; i++ )\r\n    {\r\n\t\tvec3 p = ro + t*rd;\r\n        float h = map(p,kk,false);\r\n\t\tif( abs(h)<(0.15*t/iResolution.x) ) break;\r\n\t\tt += h*0.5;\r\n        if( t>tmax ) return -1.0;;\r\n\t}\r\n    //if( t>tmax ) t=-1.0;\r\n\r\n    return t;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float an = (iTime-10.0)*0.05;\r\n    \r\n    // camera\t\r\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\r\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\r\n    // camera-to-world rotation\r\n    mat3 ca = makeBase( normalize(ta-ro) );\r\n\r\n    // render    \r\n    vec3 tot = vec3(0.0);\r\n    \r\n    #if AA>1\r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n        #else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n        #endif\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\r\n    \r\n        // background\r\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\r\n\r\n        // bounding volume\r\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n\t\tif( bound.x>0.0 )\r\n        {\r\n        // raycast\r\n        float t = raycast(ro, rd, bound.x, bound.y );\r\n        if( t>0.0 )\r\n        {\r\n            // local geometry            \r\n            vec3 pos = ro + t*rd;\r\n        \tvec3 nor = calcNormal(pos, 0.01);\r\n            vec3 upp = normalize(pos);\r\n            \r\n            // color and occlusion\r\n            vec4 mate; map(pos, mate, true);\r\n            \r\n            // lighting            \r\n            col = vec3(0.0);\r\n        \r\n            // key ligh\r\n            {\r\n                // dif\r\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\r\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\r\n\t\t\t\t// spec\r\n                vec3 hal = normalize(lig-rd);\r\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\r\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\r\n                fre = 0.2 + 0.8*pow(fre,5.0);\r\n                spe *= spe;\r\n                spe *= spe;\r\n                spe *= spe;\r\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\r\n            }\r\n\r\n            // back light\r\n           \t{\r\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\r\n            }\r\n\r\n            // dome light\r\n            {\r\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\r\n                #if 0\r\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\r\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\r\n                #else\r\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\r\n                #endif\r\n            }\r\n            \r\n            // fake sss\r\n            {\r\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\r\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\r\n            }\r\n            \r\n            // grade/sss\r\n            {\r\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\r\n            }\r\n            \r\n            // exposure control\r\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\r\n            \r\n            // display fake occlusion\r\n            //col = mate.www;\r\n        }\r\n        }\r\n    \r\n \r\n        // gamma\r\n        col = pow( col, vec3(0.4545) );\r\n    \r\n        tot += col;\r\n    #if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n    #endif\r\n\r\n    // vignetting\r\n \tvec2 q = fragCoord/iResolution.xy;\r\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2018\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\r\n// Youtube version: https://www.youtube.com/watch?v=q1OBrqtl7Yo\r\n\r\n#if HW_PERFORMANCE==0\r\n#define AA 1\r\n#else\r\n#define AA 2  // Change AA to 1 if it renders too slow for you\r\n#endif\r\n\r\n//#define INTERACTIVE\r\n\r\nmat3 makeBase( in vec3 w )\r\n{\r\n\tfloat k = inversesqrt(1.0-w.y*w.y);\r\n    return mat3( vec3(-w.z,0.0,w.x)*k, \r\n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\r\n                 w);\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\r\n{\r\n\tfloat b = dot( ro, rd );\r\n\tfloat c = dot( ro, ro ) - rad*rad;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt(h);\r\n\treturn vec2(-b-h,-b+h);\r\n}\r\n\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( in vec3 p, in float b, in float r )\r\n{\r\n    float h = clamp( p.z/b, 0.0, 1.0 );\r\n    return length( p - vec3(0.0,0.0,b)*h ) - r;//*(0.2+1.6*h);\r\n}\r\n\r\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\r\nvec4 inverseSF( in vec3 p, const in float n )\r\n{\r\n    const float PI = 3.14159265359;\r\n\tconst float PHI = 1.61803398875;\r\n\r\n    float phi = min(atan(p.y,p.x),PI);\r\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\r\n    float Fk  = pow(PHI,k)/sqrt(5.0);\r\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\r\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \r\n    \r\n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\r\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\r\n\r\n    float ma = 0.0;\r\n    vec4 res = vec4(0);\r\n    for( int s=0; s<4; s++ )\r\n    {\r\n        vec2 uv = vec2(s&1,s>>1);\r\n        float i = dot(F,uv+c);\r\n        float phi = 2.0*PI*fract(i*PHI);\r\n        float cT = 1.0 - (2.0*i+1.0)/n;\r\n        float sT = sqrt(1.0-cT*cT);\r\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\r\n        float a = dot(p,q);\r\n        if (a > ma)\r\n        {\r\n            ma = a;\r\n            res.xyz = q;\r\n            res.w = i;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\r\n{\r\n    float lp = length(p);\r\n    float dmin = lp-1.0;\r\n    {\r\n    vec3 w = p/lp;\r\n    vec4 fibo = inverseSF(w, 700.0);\r\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\r\n    dmin -= 0.07*hh;\r\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\r\n    }\r\n    \r\n    \r\n    float s = 1.0;\r\n    \r\n    #ifdef INTERACTIVE\r\n  //float tt = mod(iTime,5.0);\r\n    float tt = 4.0*iMouse.x/iResolution.x;\r\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\r\n    #endif\r\n    \r\n    for( int i=0; i<3; i++ )\r\n    {\r\n        float h = float(i)/float(3-1);\r\n        \r\n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\r\n        \r\n        // snap\r\n        p -= f.xyz;\r\n\r\n        // orient to surface\r\n        p = p*makeBase(f.xyz);\r\n\r\n        // scale\r\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\r\n        p *= scale;\r\n        p.xy *= 1.2;\r\n        \r\n        //translate\r\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\r\n            \r\n        // measure distance\r\n        s *= scale;\r\n        #ifdef INTERACTIVE\r\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\r\n        #else\r\n        float d = sdCapsule( p, -6.0, 0.42 );\r\n        #endif\r\n        d /= s;\r\n\r\n        if( d<dmin )\r\n        {\r\n            if( doColor )\r\n            {\r\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\r\n\r\n                if( i==0 ) \r\n                {\r\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall\r\n                  //color.xyz = vec3(0.4,0.8,0.1);         // summer\r\n                  //color.xyz = vec3(0.4,0.4,0.8);         // winter\r\n                }\r\n\r\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\r\n                color.xyz = max(color.xyz,0.0);\r\n            }\r\n            dmin = d;\r\n        }\r\n        else\r\n        {\r\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\r\n        }\r\n    }\r\n    \r\n    return dmin;\r\n}\r\n\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcNormal( in vec3 pos, in float ep )\r\n{\r\n    vec4 kk;\r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773;\r\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\r\n#else\r\n    // prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*ep, kk, false);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n    \r\n}\r\n\r\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\r\n{\r\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n    tmin = max(tmin,bound.x);\r\n    tmax = min(tmax,bound.y);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = tmin;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n    \tvec4 kk;\r\n\t\tfloat h = map( ro + rd*t, kk, false );\r\n        res = min( res, k*h/t );\r\n        t += clamp( h, 0.02, 0.20 );\r\n        if( res<0.005 || t>tmax ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\r\n{\r\n    vec4 kk;\r\n    float t = tmin;\r\n\tfor( int i=0; i<512; i++ )\r\n    {\r\n\t\tvec3 p = ro + t*rd;\r\n        float h = map(p,kk,false);\r\n\t\tif( abs(h)<(0.15*t/iResolution.x) ) break;\r\n\t\tt += h*0.5;\r\n        if( t>tmax ) return -1.0;;\r\n\t}\r\n    //if( t>tmax ) t=-1.0;\r\n\r\n    return t;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float an = (iTime-10.0)*0.05;\r\n    \r\n    // camera\t\r\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\r\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\r\n    // camera-to-world rotation\r\n    mat3 ca = makeBase( normalize(ta-ro) );\r\n\r\n    // render    \r\n    vec3 tot = vec3(0.0);\r\n    \r\n    #if AA>1\r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n        #else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n        #endif\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\r\n    \r\n        // background\r\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\r\n\r\n        // bounding volume\r\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n\t\tif( bound.x>0.0 )\r\n        {\r\n        // raycast\r\n        float t = raycast(ro, rd, bound.x, bound.y );\r\n        if( t>0.0 )\r\n        {\r\n            // local geometry            \r\n            vec3 pos = ro + t*rd;\r\n        \tvec3 nor = calcNormal(pos, 0.01);\r\n            vec3 upp = normalize(pos);\r\n            \r\n            // color and occlusion\r\n            vec4 mate; map(pos, mate, true);\r\n            \r\n            // lighting            \r\n            col = vec3(0.0);\r\n        \r\n            // key ligh\r\n            {\r\n                // dif\r\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\r\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\r\n\t\t\t\t// spec\r\n                vec3 hal = normalize(lig-rd);\r\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\r\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\r\n                fre = 0.2 + 0.8*pow(fre,5.0);\r\n                spe *= spe;\r\n                spe *= spe;\r\n                spe *= spe;\r\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\r\n            }\r\n\r\n            // back light\r\n           \t{\r\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\r\n            }\r\n\r\n            // dome light\r\n            {\r\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\r\n                #if 0\r\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\r\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\r\n                #else\r\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\r\n                #endif\r\n            }\r\n            \r\n            // fake sss\r\n            {\r\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\r\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\r\n            }\r\n            \r\n            // grade/sss\r\n            {\r\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\r\n            }\r\n            \r\n            // exposure control\r\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\r\n            \r\n            // display fake occlusion\r\n            //col = mate.www;\r\n        }\r\n        }\r\n    \r\n \r\n        // gamma\r\n        col = pow( col, vec3(0.4545) );\r\n    \r\n        tot += col;\r\n    #if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n    #endif\r\n\r\n    // vignetting\r\n \tvec2 q = fragCoord/iResolution.xy;\r\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Planet Shadertoy. Created by Reinder Nijhoff 2015\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/4tjGRh\r\n//\r\n// It uses code from the following shaders:\r\n//\r\n// Wet stone by TDM\r\n// Atmospheric Scattering by GLtracy\r\n// Seascape by TDM\r\n// Elevated and Terrain Tubes by IQ\r\n// LLamels by Eiffie\r\n// Lens flare by Musk\r\n// \r\n\r\n//#define HIGH_QUALITY\r\n//#define MED_QUALITY\r\n//#define LOW_QUALITY\r\n#define VERY_LOW_QUALITY\r\n\r\nconst float PI = 3.14159265359;\r\nconst float DEG_TO_RAD = (PI / 180.0);\r\nconst float MAX = 10000.0;\r\n\r\nconst float EARTH_RADIUS = 1000.;\r\nconst float EARTH_ATMOSPHERE = 5.;\r\nconst float EARTH_CLOUDS = 1.;\r\n\r\nconst float RING_INNER_RADIUS = 1500.;\r\nconst float RING_OUTER_RADIUS = 2300.;\r\nconst float RING_HEIGHT = 2.;\r\n\r\n#ifdef HIGH_QUALITY\r\n    const int   SEA_NUM_STEPS = 7;\r\n    const int\tTERRAIN_NUM_STEPS = 140;\r\n    const int   ASTEROID_NUM_STEPS = 11;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\r\n    const int   RING_VOXEL_STEPS = 25;\r\n    const float ASTEROID_MAX_DISTANCE = 1.1; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\r\n\r\n    #define DISPLAY_LLAMEL\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n#endif\r\n\r\n#ifdef MED_QUALITY\r\n    const int   SEA_NUM_STEPS = 6;\r\n    const int\tTERRAIN_NUM_STEPS = 100;\r\n    const int   ASTEROID_NUM_STEPS = 10;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\r\n    const int   RING_VOXEL_STEPS = 24;\r\n    const float ASTEROID_MAX_DISTANCE = 1.; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n#endif\r\n\r\n#ifdef LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 5;\r\n    const int\tTERRAIN_NUM_STEPS = 75;\r\n    const int   ASTEROID_NUM_STEPS = 9;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\r\n    const int   RING_VOXEL_STEPS = 20;\r\n    const float ASTEROID_MAX_DISTANCE = .85; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\r\n#endif\r\n\r\n#ifdef VERY_LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 4;\r\n    const int\tTERRAIN_NUM_STEPS = 60;\r\n    const int   ASTEROID_NUM_STEPS = 7;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\r\n    const int   RING_VOXEL_STEPS = 16;\r\n    const float ASTEROID_MAX_DISTANCE = .67; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\r\n\t#define HIDE_TERRAIN\r\n#endif\r\n\r\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\r\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\r\n\r\nfloat time;\r\n\r\n//-----------------------------------------------------\r\n// Noise functions\r\n//-----------------------------------------------------\r\n\r\nfloat hash( const in float n ) {\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\nfloat hash( const in vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat hash( const in vec3 p ) {\r\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nvec3 hash31( const in float p) {\r\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\r\n    return fract(sin(h)*43758.543123);\r\n}\r\nvec3 hash33( const in vec3 p) {\r\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\r\n}\r\n\r\nfloat noise( const in  float p ) {    \r\n    float i = floor( p );\r\n    float f = fract( p );\t\r\n\tfloat u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\r\n}\r\n\r\nfloat noise( const in  vec2 p ) {    \r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat noise( const in  vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\r\n}\r\n\r\nfloat tri( const in vec2 p ) {\r\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\r\n   \r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( in vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); \r\n    \r\n#ifndef LOW_QUALITY\r\n#ifndef VERY_LOW_QUALITY\r\n    p = m2*p*2.01;\r\n    f += 0.0625*noise( p );\r\n#endif\r\n#endif\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm( const in vec3 p, const in float a, const in float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < FBM_STEPS; i++) {\r\n        float n = pow(noise(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lightning functions\r\n//-----------------------------------------------------\r\n\r\nfloat diffuse( const in vec3 n, const in vec3 l) { \r\n    return clamp(dot(n,l),0.,1.);\r\n}\r\n\r\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\r\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Math functions\r\n//-----------------------------------------------------\r\n\r\nvec2 rotate(float angle, vec2 v) {\r\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\r\n}\r\n\r\nfloat boolSub(float a,float b) { \r\n    return max(a,-b); \r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Intersection functions (by iq)\r\n//-----------------------------------------------------\r\n\r\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\r\n    return (pos-sph.xyz)/sph.w;\r\n}\r\n\r\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return -1.0;\r\n\treturn -b - sqrt( h );\r\n}\r\n\r\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return -MAX;\r\n\treturn -b + sqrt( d );\r\n}\r\n\r\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\r\n\td = sqrt( d );\r\n\treturn vec2( -b - d, -b + d );\r\n}\r\n\r\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\r\n    return obj.xyz;\r\n}\r\n\r\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\r\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Wet stone by TDM\r\n// \r\n// https://www.shadertoy.com/view/ldSSzV\r\n//-----------------------------------------------------\r\n\r\nconst float ASTEROID_TRESHOLD \t= 0.001;\r\nconst float ASTEROID_EPSILON \t= 1e-6;\r\nconst float ASTEROID_DISPLACEMENT = 0.1;\r\nconst float ASTEROID_RADIUS = 0.13;\r\n\r\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\r\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\r\n\r\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \r\n    float d = sphere(p,ASTEROID_RADIUS);    \r\n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\r\n        float ii = float(i)+id.x;\r\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( xyangle, ro.xy );\r\n    \r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( yzangle, ro.yz );\r\n}\r\n\r\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( -yzangle, ro.yz );\r\n\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( -xyangle, ro.xy );  \r\n}\r\n\r\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\r\n    asteroidTransForm( p, id );\r\n    \r\n    vec3 n;\r\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\r\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\r\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\r\n    n = normalize(n-asteroidMapDetailed(p, id));\r\n    \r\n    asteroidUnTransForm( n, id );\r\n    return n;\r\n}\r\n\r\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\r\n    asteroidTransForm( ori, id );\r\n    asteroidTransForm( dir, id );\r\n    \r\n    vec2 td = vec2(0,1);\r\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\r\n        td.y = asteroidMap(ori + dir * td.x, id);\r\n        td.x += td.y;\r\n    }\r\n    return td;\r\n}\r\n\r\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nconst float RING_DETAIL_DISTANCE = 40.;\r\nconst float RING_VOXEL_STEP_SIZE = .03;\r\n\r\nvec3 ringShadowColor( const in vec3 ro ) {\r\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\r\n        return vec3(0.);\r\n    }\r\n    return vec3(1.);\r\n}\r\n\r\nbool ringMap( const in vec3 ro ) {\r\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\r\n}\r\n\r\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \r\n// find startpoint \r\n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\r\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\r\n    \r\n    float d = min( max(d1,0.), max(d2,0.) );\r\n   \r\n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\r\n        return vec4( 0. );\r\n    } else {\r\n        vec3 ros = ro + rd*d;\r\n\r\n        // avoid precision problems..\r\n        vec2 mroxy = mod(ros.xy, vec2(10.));\r\n        vec2 roxy = ros.xy - mroxy;\r\n        ros.xy -= roxy;\r\n        ros /= RING_VOXEL_STEP_SIZE;\r\n        //ros.xy -= vec2(.013,.112)*time*.5;\r\n\r\n        vec3 pos = floor(ros);\r\n        vec3 ri = 1.0/rd;\r\n        vec3 rs = sign(rd);\r\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\r\n\r\n        float alpha = 0., dint;\r\n        vec3 offset = vec3(0), id, asteroidro;\r\n        vec2 asteroid = vec2(0);\r\n\r\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\r\n            if( ringMap(pos) ) {\r\n                id = hash33(pos);\r\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\r\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\r\n\r\n                if( dint > 0. ) {\r\n                    asteroidro = ros+rd*dint-(pos+offset);\r\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\r\n\r\n                    if( asteroid.y < .1 ) {\r\n                        alpha = 1.;\r\n                        break;\t    \r\n                    }\r\n                }\r\n\r\n            }\r\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\r\n            dis += mm * rs * ri;\r\n            pos += mm * rs;\r\n        }\r\n\r\n        if( alpha > 0. ) {       \r\n            vec3 intersection = ros + rd*(asteroid.x+dint);\r\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\r\n\r\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\r\n\r\n            intersection *= RING_VOXEL_STEP_SIZE;\r\n            intersection.xy += roxy;\r\n          //  col *= ringShadowColor( intersection );\r\n\r\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. ) {\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n        } else {\r\n            return 0.;\r\n        }\r\n    } else {\r\n\t    return 0.;\r\n    }\r\n}\r\n\r\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. && d < maxd ) {\r\n        maxd = d;\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\r\n            \r\n            col *= ringShadowColor( intersection );\r\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\r\n\t\t\tcol *= SUN_COLOR;\r\n            return vec4( col, dens );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    } else {\r\n\t    return vec4(0.);\r\n    }\r\n}\r\n\r\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    vec4 far = renderRingFar( ro, rd, maxd );\r\n    float l = length( ro.xy );\r\n\r\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \r\n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \r\n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\r\n     \t\r\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\r\n        far.xyz *= detail;    \r\n    }\r\n    \r\n\t// are asteroids neaded ?\r\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \r\n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \r\n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\r\n        \r\n        vec4 near = renderRingNear( ro, rd );\r\n        far = mix( far, near, near.w );\r\n        maxd=0.;\r\n    }\r\n            \r\n    return far;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Stars (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderStars( const in vec3 rd ) {\r\n\tvec3 rds = rd;\r\n\tvec3 col = vec3(0);\r\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\r\n    \r\n    vec2 xy = vec2(rds.y * v, rds.x * v);\r\n    float s = noise(rds*134.);\r\n    \r\n    s += noise(rds*470.);\r\n    s = pow(s,19.0) * 0.00001;\r\n    if (s > 0.5) {\r\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \r\n        col += backStars;\r\n    }\r\n\treturn   vec4( col, 1 ); \r\n} \r\n\r\n//-----------------------------------------------------\r\n// Atmospheric Scattering by GLtracy\r\n// \r\n// https://www.shadertoy.com/view/lslXDr\r\n//-----------------------------------------------------\r\n\r\nconst float ATMOSPHERE_K_R = 0.166;\r\nconst float ATMOSPHERE_K_M = 0.0025;\r\nconst float ATMOSPHERE_E = 12.3;\r\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\r\nconst float ATMOSPHERE_G_M = -0.85;\r\n\r\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\r\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\r\n\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\r\n\r\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\r\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\r\n\r\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\r\n\tfloat gg = g * g;\r\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\r\n\tfloat b = 1.0 + gg - 2.0 * g * c;\r\n    \r\n\tb *= sqrt( b );\r\n\tb *= 2.0 + gg;\t\r\n\t\r\n\treturn 1.5 * a / b;\r\n}\r\n\r\nfloat atmosphericPhaseReyleigh( float cc ) {\r\n\treturn 0.75 * ( 1.0 + cc );\r\n}\r\n\r\nfloat atmosphericDensity( vec3 p ){\r\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\r\n}\r\n\r\nfloat atmosphericOptic( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n    float sumdensity = 0.;\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\r\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\r\n\t\tfloat dens = atmosphericDensity( v );\r\n  \r\n\t    float m = MAX;\r\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \r\n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\r\n \t\tsumdensity += dens;\r\n        \r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \r\n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\r\n}\r\n\r\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\r\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\r\n\t    float m = MAX;\r\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\r\n}\r\n\r\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \r\n    // inside or outside atmosphere?\r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\r\n        \r\n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\r\n        if( d < e.y ) {\r\n            e.y = d;\r\n        }\r\n\t\td = e.y;\r\n\t    e.x = 0.;\r\n        \r\n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\r\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\r\n\t\t}\r\n    } else {\r\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\r\n        \r\n        if ( e.x > e.y ) {\r\n        \td = MAX;\r\n\t\t\treturn vec4(0.);\r\n\t\t}\r\n\t\td = e.y = min( e.y, f.x );\r\n    }\r\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n    e.x = 0.;\r\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Seascape by TDM\r\n// \r\n// https://www.shadertoy.com/view/Ms2SD1\r\n//-----------------------------------------------------\r\n\r\nconst int   SEA_ITER_GEOMETRY = 3;\r\nconst int   SEA_ITER_FRAGMENT = 5;\r\n\r\nconst float SEA_EPSILON\t= 1e-3;\r\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\r\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\r\nfloat       SEA_TIME;\r\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\nfloat seaOctave( in vec2 uv, const in float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat seaMap(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat seaMapHigh(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \r\n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \r\n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \r\n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\r\n    \r\n    color += upc*SEA_WATER_COLOR * (att * 0.18);\r\n    color += sunc * vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\r\n    vec3 n;\r\n    n.y = seaMapHigh(p);    \r\n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = seaMap(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = seaMap(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = seaMap(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 seaTransform( in vec3 x ) {\r\n    x.yz = rotate( 0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvec3 seaUntransform( in vec3 x ) {\r\n    x.yz = rotate( -0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \r\n    vec3 p,\r\n    rom = seaTransform(ro),\r\n    rdm = seaTransform(rd);\r\n    \r\n    rom.y -= EARTH_RADIUS;\r\n    rom *= 1000.;\r\n    rom.xz += vec2(3.1,.2)*time;\r\n\r\n    SEA_TIME = time * SEA_SPEED;\r\n    \r\n    seaHeightMapTracing(rom,rdm,p);\r\n    float squareddist = dot(p - rom, p-rom );\r\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\r\n    \r\n    n = seaUntransform(n);\r\n    \r\n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Terrain based on Elevated and Terrain Tubes by IQ\r\n//\r\n// https://www.shadertoy.com/view/MdX3Rr\r\n// https://www.shadertoy.com/view/4sjXzG\r\n//-----------------------------------------------------\r\n\r\n#ifndef HIDE_TERRAIN\r\n\r\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\r\n\r\nfloat terrainLow( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<2; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMed( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<6; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n            \r\n    return t*33.0;\r\n}\r\n\r\nfloat terrainHigh( vec2 p ) {\r\n    vec2 q = p;\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<7; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n    \r\n    t += t*0.015*fbm( q );\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMap( const in vec3 pos ) {\r\n\treturn pos.y - terrainMed(pos.xz);  \r\n}\r\n\r\nfloat terrainMapH( const in vec3 pos ) {\r\n    float y = terrainHigh(pos.xz);\r\n    float h = pos.y - y;\r\n    return h;\r\n}\r\n\r\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\r\n    float t = tmin;\r\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\r\n        vec3 pos = ro + t*rd;\r\n        float res = terrainMap( pos );\r\n        if( res<(0.001*t) || t>tmax  ) break;\r\n        t += res*.9;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\r\n\tvec2  eps = vec2(150.0,0.0);\r\n    float h1 = terrainMed( ro.xz );\r\n    float h2 = terrainLow( ro.xz );\r\n    \r\n    float d1 = 10.0;\r\n    float d2 = 80.0;\r\n    float d3 = 200.0;\r\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\r\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\r\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\r\n\r\n    return min(min(s1,s2),s3);\r\n}\r\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\r\n\r\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\r\n}\r\n\r\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\r\n\tfloat e = 0.005*t;\r\n    vec2  eps = vec2(e,0.0);\r\n    float h = terrainMed( pos.xz );\r\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\r\n}\r\n\r\nvec3 terrainTransform( in vec3 x ) {\r\n    x.zy = rotate( -.83, x.zy );\r\n    return x;\r\n}\r\n\r\nvec3 terrainUntransform( in vec3 x ) {\r\n    x.zy = rotate( .83, x.zy );\r\n    return x;\r\n}\r\n\r\n\r\nfloat llamelTime;\r\nconst float llamelScale = 5.;\r\n\r\nvec3 llamelPosition() {\r\n    llamelTime = time*2.5;\r\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\r\n    return vec3( pos.x, terrainMed( pos ), pos.y );\r\n}\r\n\r\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \r\n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\r\n    float dif = diffuse( n, sunDirection );\r\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\r\n    float sha = terrainCalcShadow( pos, sunDirection );\r\n    float amb = clamp( n.y,0.0,1.0);\r\n        \r\n    vec3 lin  = vec3(0.0);\r\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\r\n    lin += 0.2*amb*upc;\r\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\r\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\r\n}\r\n\r\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    vec3 nor = terrainCalcNormalHigh( pos, t );\r\n    vec3 sor = terrainCalcNormalMed( pos, t );\r\n        \r\n    float spec = 0.005;\r\n\r\n#ifdef DISPLAY_TERRAIN_DETAIL\r\n    float no = noise(5.*fbm(1.11*pos.xz));\r\n#else\r\n    const float no = 0.;\r\n#endif\r\n    float r = .5+.5*fbm(.95*pos.xz);\r\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\r\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\r\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\r\n    col *= .88+.12*no;\r\n        \r\n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\r\n    float sf = fwidth(s) * 1.5;\r\n    s = smoothstep(0.84-sf, 0.84+sf, s );\r\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\r\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\r\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\r\n\r\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\r\n\r\n#ifdef DISPLAY_LLAMEL\r\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\r\n#endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 terrainTransformRo( const in vec3 ro ) {\r\n    vec3 rom = terrainTransform(ro);\r\n    rom.y -= EARTH_RADIUS - 100.;\r\n    rom.xz *= 5.;\r\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \r\n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\r\n    return rom;\r\n}\r\n\r\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \r\n    vec3 p,\r\n    rom = terrainTransformRo(ro),\r\n    rdm = terrainTransform(rd);\r\n        \r\n    float tmin = 10.0;\r\n    float tmax = 3200.0;\r\n    \r\n    float res = terrainIntersect( rom, rdm, tmin, tmax );\r\n    \r\n    if( res > tmax ) {\r\n        res = -1.;\r\n    } else {\r\n        vec3 pos =  rom+rdm*res;\r\n        n = terrainCalcNormalMed( pos, res );\r\n        n = terrainUntransform( n );\r\n        \r\n        intersection = ro+rd*res/100.;\r\n    }\r\n    return vec4(res, rom+rdm*res);\r\n}\r\n\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// LLamels by Eiffie\r\n//\r\n// https://www.shadertoy.com/view/ltsGz4\r\n//-----------------------------------------------------\r\n#ifdef DISPLAY_LLAMEL\r\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\r\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\r\n}\r\n\r\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\r\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\r\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\r\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\r\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\r\n\tu=p-j0;q=j1-j0;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\r\n\tu=p-j1;q=j2-j1;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\r\n\tu=p-j2;q=j3-j2;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\r\n}\r\n\r\nfloat llamelMap(in vec3 p) {\r\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\r\n\tp.y += 0.25*llamelScale;\r\n    p.xz -= 0.5*llamelScale;\r\n    p.xz = vec2(-p.z, p.x);\r\n    vec3 pori = p;\r\n        \r\n    p /= llamelScale;\r\n    \r\n\tvec2 c=floor(p.xz);\r\n\tp.xz=fract(p.xz)-vec2(0.5);\r\n    p.y -= p.x*.04*llamelScale;\r\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\r\n\r\n    float b=0.83-abs(p.z);\r\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\r\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\r\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\r\n\tp.y-=0.03;\r\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\r\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\r\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\r\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\r\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\r\n\ta=max(abs(p.z),p.y)+0.05;\r\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\r\n}\r\n\r\nvec3 llamelGetNormal( in vec3 ro ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001;\r\n\r\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\r\n}\r\n\r\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    ro -= llamelPosition();\r\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\r\n\tfor(int i=0;i<36;i++){\r\n\t\tt+=d=llamelMap(ro+rd*t);\r\n\t\tif(d<dm){dm=d;tm=t;}\r\n\t\tif(t>1000.0 || d<0.00001)break;\r\n\t}\r\n\tdm=max(0.0,dm);\r\n    if( dm < .02 ) {\r\n        vec3 col = vec3(0.45,.30,0.15)*.2;\r\n        vec3 pos = ro + rd*tm;\r\n        vec3 nor = llamelGetNormal( pos );\r\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \r\n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\r\n    }\r\n    \r\n    return vec4(0.);\r\n}\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// Clouds (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \r\n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\r\n\tvec3 intersection = ro+rd*d;\r\n    vec3 cint = intersection*0.009;\r\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\r\n\r\n    cint.xy = rotate( rot, cint.xy );\r\n\r\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\r\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\r\n\r\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\r\n\r\n#ifdef DISPLAY_CLOUDS_DETAIL\r\n    if( d < 200. ) {\r\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\r\n    }\r\n#endif\r\n\r\n    shadow = clamp(1.-clouds, 0., 1.);\r\n\r\n    clouds = clamp(clouds, 0., 1.);\r\n    clouds *= clouds;\r\n    clouds *= smoothstep(0.,0.4,d);\r\n\r\n    vec3 clbasecolor = vec3(1.);\r\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\r\n    clcol += .3*clbasecolor*sunColor;\r\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \r\n    \r\n    return vec4( clcol, clouds );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Planet (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\r\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n\r\n    vec3 intersection = ro + rd*d;\r\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n    vec4 res;\r\n\r\n#ifndef HIDE_TERRAIN\r\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \r\n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\r\n#endif\r\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \r\n    float mixDetailColor = 0.;\r\n        \r\n\tif( d < 0. || d > maxd) {\r\n#ifndef HIDE_TERRAIN\r\n        if( renderTerrainDetail ) {\r\n       \t\tintersection = ro;\r\n            n = normalize( ro );\r\n        } else { \t       \r\n\t        return vec4(0);\r\n        }\r\n#else \r\n      \treturn vec4(0.);\r\n#endif\r\n\t}\r\n    if( d > 0. ) {\r\n\t    maxd = d;\r\n    }\r\n    float att = 0.;\r\n    \r\n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\r\n    \r\n    float dm = MAX, e = 0.;\r\n    vec3 col, detailCol, nDetail;\r\n    \r\n    // normal and intersection \r\n#ifndef HIDE_TERRAIN\r\n    if( renderTerrainDetail ) {   \r\n        res = renderTerrain( ro, rd, intersection, nDetail );\r\n        if( res.x < 0. && d < 0. ) {\r\n\t        return vec4(0);\r\n        }\r\n        if( res.x >= 0. ) {\r\n            maxd = pow(res.x/4000.,4.)*50.;\r\n            e = -10.;\r\n        }\r\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\r\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\r\n    } else \r\n#endif        \r\n    if( renderSeaDetail ) {    \r\n        float attsea, mf = smoothstep(.5,1.,d);\r\n\r\n        renderSea( ro, rd, nDetail, attsea );\r\n\r\n        n = normalize(mix( nDetail, n, mf ));\r\n        att = mix( attsea, att, mf );\r\n    } else {\r\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\r\n#ifndef HIDE_TERRAIN\r\n        if( d < 1500. ) {\r\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\r\n        }\r\n#endif  \r\n    }\r\n    \r\n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \r\n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \r\n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \r\n                 \r\n    // color  \r\n#ifndef HIDE_TERRAIN\r\n    if(renderTerrainDetail ) {\r\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\r\n\t\td = 0.;\r\n    }   \r\n#endif\r\n     \r\n    if( mixDetailColor < 1. ) {\r\n        if( e < .45 ) {\r\n            // sea\r\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \r\n        } else {\r\n            // planet (land) far\r\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\r\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\r\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\r\n\r\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\r\n            vec3 landColor2 = RING_COLOR_1 * land2;\r\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\r\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\r\n\r\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\r\n#ifdef HIGH_QUALITY\r\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\r\n#endif\r\n        }\r\n    }\r\n    \r\n    if( mixDetailColor > 0. ) {\r\n        col = mix( col, detailCol, mixDetailColor );\r\n    }\r\n        \r\n#ifdef DISPLAY_LLAMEL\r\n    if(renderTerrainDetail ) {\r\n        vec3 rom = terrainTransformRo(ro),\r\n        rdm = terrainTransform(rd);\r\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\r\n        if( d > 0. ) {\r\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\r\n            col = mix(col, llamel.rgb, llamel.a);\r\n        }\r\n    }\r\n#endif\r\n    \r\n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\r\n    if( d > 0. ) { \r\n        float shadow;\r\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\r\n        col *= shadow; \r\n        col = mix( col, clouds.rgb, clouds.w );\r\n    }\r\n    \r\n    float m = MAX;\r\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\r\n\r\n \treturn vec4( col, 1. ); \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lens flare by musk\r\n//\r\n// https://www.shadertoy.com/view/4sX3Rs\r\n//-----------------------------------------------------\r\n\r\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\r\n\tc = c*.5 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// cameraPath\r\n//-----------------------------------------------------\r\n\r\nvec3 pro, pta, pup;\r\nfloat dro, dta, dup;\r\n\r\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\r\n    if( t >= prevt && t <= prevt+duration ) {\r\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\r\n    }\r\n    prev = dest;\r\n    prevt += duration;\r\n}\r\n\r\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\r\n#ifndef HIDE_TERRAIN\r\n    time = t = mod( t, 92. );\r\n#else\r\n    time = t = mod( t, 66. );\r\n#endif\r\n    dro = dta = dup = 0.;\r\n\r\n    pro = ro = vec3(900. ,7000. ,1500. );\r\n    pta = ta = vec3(    0. ,    0. ,   0. );\r\n    pup = up = vec3(    0. ,    0.4,   1. ); \r\n   \r\n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\r\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \r\n \r\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\r\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\r\n\r\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\r\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\r\n    \r\n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7.,roe, pro, dro );\r\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\r\n    camint( up, t, 6., upe, pup, dup );\r\n        \r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n    \r\n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\r\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\r\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \r\n#ifndef HIDE_TERRAIN    \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7., roe, pro, dro );\r\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\r\n    camint( up, t, 2., upe, pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\r\n    camint( ro, t, 4.,roe, pro, dro );\r\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\r\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\r\n#endif    \r\n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\r\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \r\n    \r\n    up = normalize( up );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// mainImage\r\n//-----------------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    \r\n    vec3 col;\r\n    \r\n// black bands\r\n    vec2 bandy = vec2(.1,.9);\r\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\r\n        col = vec3(0.);\r\n    } else {\r\n        // camera\r\n        vec3 ro, ta, up;\r\n        cameraPath( iTime*.7, ro, ta, up );\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,up) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        float maxd = MAX;  \r\n        col = renderStars( rd ).xyz;\r\n\r\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \r\n        if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n        float atmosphered = maxd;\r\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n        vec4 ring = renderRing( ro, rd, maxd );\r\n        if( ring.w > 0. && atmosphered < maxd ) {\r\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \r\n        }\r\n        col = col * (1.-ring.w ) + ring.xyz;\r\n\r\n#ifdef DISPLAY_CLOUDS\r\n        float lro = length(ro);\r\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\r\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \r\n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \r\n\r\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\r\n                // clouds\r\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\r\n                if( d < maxd ) {\r\n                    float shadow;\r\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\r\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\r\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\r\n                }\r\n            }\r\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\r\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\r\n        }\r\n#endif \r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);      \r\n\r\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\r\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\r\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\r\n\r\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\r\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \r\n    }\r\n    fragColor = vec4( col ,1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n    float maxd = MAX;  \r\n    time = iTime * .7;\r\n    \r\n    rd = rd.xzy;\r\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\r\n    \r\n    vec3 col = renderStars( rd ).xyz;\r\n\r\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \r\n    if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n    float atmosphered = maxd;\r\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n    vec4 ring = renderRing( ro, rd, maxd );\r\n    col = col * (1.-ring.w ) + ring.xyz;\r\n    \r\n    // post processing\r\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n    col *= vec3(1.,0.99,0.95);   \r\n    col = clamp(1.06*col-0.03, 0., 1.);      \r\n    fragColor = vec4( col ,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Planet Shadertoy. Created by Reinder Nijhoff 2015\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/4tjGRh\r\n//\r\n// It uses code from the following shaders:\r\n//\r\n// Wet stone by TDM\r\n// Atmospheric Scattering by GLtracy\r\n// Seascape by TDM\r\n// Elevated and Terrain Tubes by IQ\r\n// LLamels by Eiffie\r\n// Lens flare by Musk\r\n// \r\n\r\n//#define HIGH_QUALITY\r\n//#define MED_QUALITY\r\n//#define LOW_QUALITY\r\n#define VERY_LOW_QUALITY\r\n\r\nconst float PI = 3.14159265359;\r\nconst float DEG_TO_RAD = (PI / 180.0);\r\nconst float MAX = 10000.0;\r\n\r\nconst float EARTH_RADIUS = 1000.;\r\nconst float EARTH_ATMOSPHERE = 5.;\r\nconst float EARTH_CLOUDS = 1.;\r\n\r\nconst float RING_INNER_RADIUS = 1500.;\r\nconst float RING_OUTER_RADIUS = 2300.;\r\nconst float RING_HEIGHT = 2.;\r\n\r\n#ifdef HIGH_QUALITY\r\n    const int   SEA_NUM_STEPS = 7;\r\n    const int\tTERRAIN_NUM_STEPS = 140;\r\n    const int   ASTEROID_NUM_STEPS = 11;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\r\n    const int   RING_VOXEL_STEPS = 25;\r\n    const float ASTEROID_MAX_DISTANCE = 1.1; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\r\n\r\n    #define DISPLAY_LLAMEL\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n#endif\r\n\r\n#ifdef MED_QUALITY\r\n    const int   SEA_NUM_STEPS = 6;\r\n    const int\tTERRAIN_NUM_STEPS = 100;\r\n    const int   ASTEROID_NUM_STEPS = 10;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\r\n    const int   RING_VOXEL_STEPS = 24;\r\n    const float ASTEROID_MAX_DISTANCE = 1.; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n#endif\r\n\r\n#ifdef LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 5;\r\n    const int\tTERRAIN_NUM_STEPS = 75;\r\n    const int   ASTEROID_NUM_STEPS = 9;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\r\n    const int   RING_VOXEL_STEPS = 20;\r\n    const float ASTEROID_MAX_DISTANCE = .85; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\r\n#endif\r\n\r\n#ifdef VERY_LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 4;\r\n    const int\tTERRAIN_NUM_STEPS = 60;\r\n    const int   ASTEROID_NUM_STEPS = 7;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\r\n    const int   RING_VOXEL_STEPS = 16;\r\n    const float ASTEROID_MAX_DISTANCE = .67; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\r\n\t#define HIDE_TERRAIN\r\n#endif\r\n\r\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\r\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\r\n\r\nfloat time;\r\n\r\n//-----------------------------------------------------\r\n// Noise functions\r\n//-----------------------------------------------------\r\n\r\nfloat hash( const in float n ) {\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\nfloat hash( const in vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat hash( const in vec3 p ) {\r\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nvec3 hash31( const in float p) {\r\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\r\n    return fract(sin(h)*43758.543123);\r\n}\r\nvec3 hash33( const in vec3 p) {\r\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\r\n}\r\n\r\nfloat noise( const in  float p ) {    \r\n    float i = floor( p );\r\n    float f = fract( p );\t\r\n\tfloat u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\r\n}\r\n\r\nfloat noise( const in  vec2 p ) {    \r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat noise( const in  vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\r\n}\r\n\r\nfloat tri( const in vec2 p ) {\r\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\r\n   \r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( in vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); \r\n    \r\n#ifndef LOW_QUALITY\r\n#ifndef VERY_LOW_QUALITY\r\n    p = m2*p*2.01;\r\n    f += 0.0625*noise( p );\r\n#endif\r\n#endif\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm( const in vec3 p, const in float a, const in float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < FBM_STEPS; i++) {\r\n        float n = pow(noise(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lightning functions\r\n//-----------------------------------------------------\r\n\r\nfloat diffuse( const in vec3 n, const in vec3 l) { \r\n    return clamp(dot(n,l),0.,1.);\r\n}\r\n\r\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\r\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Math functions\r\n//-----------------------------------------------------\r\n\r\nvec2 rotate(float angle, vec2 v) {\r\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\r\n}\r\n\r\nfloat boolSub(float a,float b) { \r\n    return max(a,-b); \r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Intersection functions (by iq)\r\n//-----------------------------------------------------\r\n\r\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\r\n    return (pos-sph.xyz)/sph.w;\r\n}\r\n\r\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return -1.0;\r\n\treturn -b - sqrt( h );\r\n}\r\n\r\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return -MAX;\r\n\treturn -b + sqrt( d );\r\n}\r\n\r\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\r\n\td = sqrt( d );\r\n\treturn vec2( -b - d, -b + d );\r\n}\r\n\r\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\r\n    return obj.xyz;\r\n}\r\n\r\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\r\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Wet stone by TDM\r\n// \r\n// https://www.shadertoy.com/view/ldSSzV\r\n//-----------------------------------------------------\r\n\r\nconst float ASTEROID_TRESHOLD \t= 0.001;\r\nconst float ASTEROID_EPSILON \t= 1e-6;\r\nconst float ASTEROID_DISPLACEMENT = 0.1;\r\nconst float ASTEROID_RADIUS = 0.13;\r\n\r\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\r\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\r\n\r\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \r\n    float d = sphere(p,ASTEROID_RADIUS);    \r\n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\r\n        float ii = float(i)+id.x;\r\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( xyangle, ro.xy );\r\n    \r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( yzangle, ro.yz );\r\n}\r\n\r\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( -yzangle, ro.yz );\r\n\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( -xyangle, ro.xy );  \r\n}\r\n\r\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\r\n    asteroidTransForm( p, id );\r\n    \r\n    vec3 n;\r\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\r\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\r\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\r\n    n = normalize(n-asteroidMapDetailed(p, id));\r\n    \r\n    asteroidUnTransForm( n, id );\r\n    return n;\r\n}\r\n\r\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\r\n    asteroidTransForm( ori, id );\r\n    asteroidTransForm( dir, id );\r\n    \r\n    vec2 td = vec2(0,1);\r\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\r\n        td.y = asteroidMap(ori + dir * td.x, id);\r\n        td.x += td.y;\r\n    }\r\n    return td;\r\n}\r\n\r\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nconst float RING_DETAIL_DISTANCE = 40.;\r\nconst float RING_VOXEL_STEP_SIZE = .03;\r\n\r\nvec3 ringShadowColor( const in vec3 ro ) {\r\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\r\n        return vec3(0.);\r\n    }\r\n    return vec3(1.);\r\n}\r\n\r\nbool ringMap( const in vec3 ro ) {\r\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\r\n}\r\n\r\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \r\n// find startpoint \r\n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\r\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\r\n    \r\n    float d = min( max(d1,0.), max(d2,0.) );\r\n   \r\n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\r\n        return vec4( 0. );\r\n    } else {\r\n        vec3 ros = ro + rd*d;\r\n\r\n        // avoid precision problems..\r\n        vec2 mroxy = mod(ros.xy, vec2(10.));\r\n        vec2 roxy = ros.xy - mroxy;\r\n        ros.xy -= roxy;\r\n        ros /= RING_VOXEL_STEP_SIZE;\r\n        //ros.xy -= vec2(.013,.112)*time*.5;\r\n\r\n        vec3 pos = floor(ros);\r\n        vec3 ri = 1.0/rd;\r\n        vec3 rs = sign(rd);\r\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\r\n\r\n        float alpha = 0., dint;\r\n        vec3 offset = vec3(0), id, asteroidro;\r\n        vec2 asteroid = vec2(0);\r\n\r\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\r\n            if( ringMap(pos) ) {\r\n                id = hash33(pos);\r\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\r\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\r\n\r\n                if( dint > 0. ) {\r\n                    asteroidro = ros+rd*dint-(pos+offset);\r\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\r\n\r\n                    if( asteroid.y < .1 ) {\r\n                        alpha = 1.;\r\n                        break;\t    \r\n                    }\r\n                }\r\n\r\n            }\r\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\r\n            dis += mm * rs * ri;\r\n            pos += mm * rs;\r\n        }\r\n\r\n        if( alpha > 0. ) {       \r\n            vec3 intersection = ros + rd*(asteroid.x+dint);\r\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\r\n\r\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\r\n\r\n            intersection *= RING_VOXEL_STEP_SIZE;\r\n            intersection.xy += roxy;\r\n          //  col *= ringShadowColor( intersection );\r\n\r\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. ) {\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n        } else {\r\n            return 0.;\r\n        }\r\n    } else {\r\n\t    return 0.;\r\n    }\r\n}\r\n\r\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. && d < maxd ) {\r\n        maxd = d;\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\r\n            \r\n            col *= ringShadowColor( intersection );\r\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\r\n\t\t\tcol *= SUN_COLOR;\r\n            return vec4( col, dens );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    } else {\r\n\t    return vec4(0.);\r\n    }\r\n}\r\n\r\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    vec4 far = renderRingFar( ro, rd, maxd );\r\n    float l = length( ro.xy );\r\n\r\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \r\n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \r\n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\r\n     \t\r\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\r\n        far.xyz *= detail;    \r\n    }\r\n    \r\n\t// are asteroids neaded ?\r\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \r\n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \r\n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\r\n        \r\n        vec4 near = renderRingNear( ro, rd );\r\n        far = mix( far, near, near.w );\r\n        maxd=0.;\r\n    }\r\n            \r\n    return far;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Stars (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderStars( const in vec3 rd ) {\r\n\tvec3 rds = rd;\r\n\tvec3 col = vec3(0);\r\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\r\n    \r\n    vec2 xy = vec2(rds.y * v, rds.x * v);\r\n    float s = noise(rds*134.);\r\n    \r\n    s += noise(rds*470.);\r\n    s = pow(s,19.0) * 0.00001;\r\n    if (s > 0.5) {\r\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \r\n        col += backStars;\r\n    }\r\n\treturn   vec4( col, 1 ); \r\n} \r\n\r\n//-----------------------------------------------------\r\n// Atmospheric Scattering by GLtracy\r\n// \r\n// https://www.shadertoy.com/view/lslXDr\r\n//-----------------------------------------------------\r\n\r\nconst float ATMOSPHERE_K_R = 0.166;\r\nconst float ATMOSPHERE_K_M = 0.0025;\r\nconst float ATMOSPHERE_E = 12.3;\r\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\r\nconst float ATMOSPHERE_G_M = -0.85;\r\n\r\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\r\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\r\n\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\r\n\r\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\r\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\r\n\r\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\r\n\tfloat gg = g * g;\r\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\r\n\tfloat b = 1.0 + gg - 2.0 * g * c;\r\n    \r\n\tb *= sqrt( b );\r\n\tb *= 2.0 + gg;\t\r\n\t\r\n\treturn 1.5 * a / b;\r\n}\r\n\r\nfloat atmosphericPhaseReyleigh( float cc ) {\r\n\treturn 0.75 * ( 1.0 + cc );\r\n}\r\n\r\nfloat atmosphericDensity( vec3 p ){\r\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\r\n}\r\n\r\nfloat atmosphericOptic( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n    float sumdensity = 0.;\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\r\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\r\n\t\tfloat dens = atmosphericDensity( v );\r\n  \r\n\t    float m = MAX;\r\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \r\n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\r\n \t\tsumdensity += dens;\r\n        \r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \r\n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\r\n}\r\n\r\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\r\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\r\n\t    float m = MAX;\r\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\r\n}\r\n\r\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \r\n    // inside or outside atmosphere?\r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\r\n        \r\n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\r\n        if( d < e.y ) {\r\n            e.y = d;\r\n        }\r\n\t\td = e.y;\r\n\t    e.x = 0.;\r\n        \r\n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\r\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\r\n\t\t}\r\n    } else {\r\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\r\n        \r\n        if ( e.x > e.y ) {\r\n        \td = MAX;\r\n\t\t\treturn vec4(0.);\r\n\t\t}\r\n\t\td = e.y = min( e.y, f.x );\r\n    }\r\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n    e.x = 0.;\r\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Seascape by TDM\r\n// \r\n// https://www.shadertoy.com/view/Ms2SD1\r\n//-----------------------------------------------------\r\n\r\nconst int   SEA_ITER_GEOMETRY = 3;\r\nconst int   SEA_ITER_FRAGMENT = 5;\r\n\r\nconst float SEA_EPSILON\t= 1e-3;\r\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\r\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\r\nfloat       SEA_TIME;\r\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\nfloat seaOctave( in vec2 uv, const in float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat seaMap(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat seaMapHigh(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \r\n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \r\n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \r\n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\r\n    \r\n    color += upc*SEA_WATER_COLOR * (att * 0.18);\r\n    color += sunc * vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\r\n    vec3 n;\r\n    n.y = seaMapHigh(p);    \r\n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = seaMap(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = seaMap(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = seaMap(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 seaTransform( in vec3 x ) {\r\n    x.yz = rotate( 0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvec3 seaUntransform( in vec3 x ) {\r\n    x.yz = rotate( -0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \r\n    vec3 p,\r\n    rom = seaTransform(ro),\r\n    rdm = seaTransform(rd);\r\n    \r\n    rom.y -= EARTH_RADIUS;\r\n    rom *= 1000.;\r\n    rom.xz += vec2(3.1,.2)*time;\r\n\r\n    SEA_TIME = time * SEA_SPEED;\r\n    \r\n    seaHeightMapTracing(rom,rdm,p);\r\n    float squareddist = dot(p - rom, p-rom );\r\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\r\n    \r\n    n = seaUntransform(n);\r\n    \r\n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Terrain based on Elevated and Terrain Tubes by IQ\r\n//\r\n// https://www.shadertoy.com/view/MdX3Rr\r\n// https://www.shadertoy.com/view/4sjXzG\r\n//-----------------------------------------------------\r\n\r\n#ifndef HIDE_TERRAIN\r\n\r\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\r\n\r\nfloat terrainLow( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<2; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMed( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<6; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n            \r\n    return t*33.0;\r\n}\r\n\r\nfloat terrainHigh( vec2 p ) {\r\n    vec2 q = p;\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<7; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n    \r\n    t += t*0.015*fbm( q );\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMap( const in vec3 pos ) {\r\n\treturn pos.y - terrainMed(pos.xz);  \r\n}\r\n\r\nfloat terrainMapH( const in vec3 pos ) {\r\n    float y = terrainHigh(pos.xz);\r\n    float h = pos.y - y;\r\n    return h;\r\n}\r\n\r\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\r\n    float t = tmin;\r\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\r\n        vec3 pos = ro + t*rd;\r\n        float res = terrainMap( pos );\r\n        if( res<(0.001*t) || t>tmax  ) break;\r\n        t += res*.9;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\r\n\tvec2  eps = vec2(150.0,0.0);\r\n    float h1 = terrainMed( ro.xz );\r\n    float h2 = terrainLow( ro.xz );\r\n    \r\n    float d1 = 10.0;\r\n    float d2 = 80.0;\r\n    float d3 = 200.0;\r\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\r\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\r\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\r\n\r\n    return min(min(s1,s2),s3);\r\n}\r\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\r\n\r\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\r\n}\r\n\r\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\r\n\tfloat e = 0.005*t;\r\n    vec2  eps = vec2(e,0.0);\r\n    float h = terrainMed( pos.xz );\r\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\r\n}\r\n\r\nvec3 terrainTransform( in vec3 x ) {\r\n    x.zy = rotate( -.83, x.zy );\r\n    return x;\r\n}\r\n\r\nvec3 terrainUntransform( in vec3 x ) {\r\n    x.zy = rotate( .83, x.zy );\r\n    return x;\r\n}\r\n\r\n\r\nfloat llamelTime;\r\nconst float llamelScale = 5.;\r\n\r\nvec3 llamelPosition() {\r\n    llamelTime = time*2.5;\r\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\r\n    return vec3( pos.x, terrainMed( pos ), pos.y );\r\n}\r\n\r\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \r\n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\r\n    float dif = diffuse( n, sunDirection );\r\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\r\n    float sha = terrainCalcShadow( pos, sunDirection );\r\n    float amb = clamp( n.y,0.0,1.0);\r\n        \r\n    vec3 lin  = vec3(0.0);\r\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\r\n    lin += 0.2*amb*upc;\r\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\r\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\r\n}\r\n\r\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    vec3 nor = terrainCalcNormalHigh( pos, t );\r\n    vec3 sor = terrainCalcNormalMed( pos, t );\r\n        \r\n    float spec = 0.005;\r\n\r\n#ifdef DISPLAY_TERRAIN_DETAIL\r\n    float no = noise(5.*fbm(1.11*pos.xz));\r\n#else\r\n    const float no = 0.;\r\n#endif\r\n    float r = .5+.5*fbm(.95*pos.xz);\r\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\r\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\r\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\r\n    col *= .88+.12*no;\r\n        \r\n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\r\n    float sf = fwidth(s) * 1.5;\r\n    s = smoothstep(0.84-sf, 0.84+sf, s );\r\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\r\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\r\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\r\n\r\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\r\n\r\n#ifdef DISPLAY_LLAMEL\r\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\r\n#endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 terrainTransformRo( const in vec3 ro ) {\r\n    vec3 rom = terrainTransform(ro);\r\n    rom.y -= EARTH_RADIUS - 100.;\r\n    rom.xz *= 5.;\r\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \r\n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\r\n    return rom;\r\n}\r\n\r\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \r\n    vec3 p,\r\n    rom = terrainTransformRo(ro),\r\n    rdm = terrainTransform(rd);\r\n        \r\n    float tmin = 10.0;\r\n    float tmax = 3200.0;\r\n    \r\n    float res = terrainIntersect( rom, rdm, tmin, tmax );\r\n    \r\n    if( res > tmax ) {\r\n        res = -1.;\r\n    } else {\r\n        vec3 pos =  rom+rdm*res;\r\n        n = terrainCalcNormalMed( pos, res );\r\n        n = terrainUntransform( n );\r\n        \r\n        intersection = ro+rd*res/100.;\r\n    }\r\n    return vec4(res, rom+rdm*res);\r\n}\r\n\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// LLamels by Eiffie\r\n//\r\n// https://www.shadertoy.com/view/ltsGz4\r\n//-----------------------------------------------------\r\n#ifdef DISPLAY_LLAMEL\r\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\r\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\r\n}\r\n\r\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\r\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\r\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\r\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\r\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\r\n\tu=p-j0;q=j1-j0;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\r\n\tu=p-j1;q=j2-j1;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\r\n\tu=p-j2;q=j3-j2;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\r\n}\r\n\r\nfloat llamelMap(in vec3 p) {\r\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\r\n\tp.y += 0.25*llamelScale;\r\n    p.xz -= 0.5*llamelScale;\r\n    p.xz = vec2(-p.z, p.x);\r\n    vec3 pori = p;\r\n        \r\n    p /= llamelScale;\r\n    \r\n\tvec2 c=floor(p.xz);\r\n\tp.xz=fract(p.xz)-vec2(0.5);\r\n    p.y -= p.x*.04*llamelScale;\r\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\r\n\r\n    float b=0.83-abs(p.z);\r\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\r\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\r\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\r\n\tp.y-=0.03;\r\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\r\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\r\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\r\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\r\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\r\n\ta=max(abs(p.z),p.y)+0.05;\r\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\r\n}\r\n\r\nvec3 llamelGetNormal( in vec3 ro ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001;\r\n\r\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\r\n}\r\n\r\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    ro -= llamelPosition();\r\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\r\n\tfor(int i=0;i<36;i++){\r\n\t\tt+=d=llamelMap(ro+rd*t);\r\n\t\tif(d<dm){dm=d;tm=t;}\r\n\t\tif(t>1000.0 || d<0.00001)break;\r\n\t}\r\n\tdm=max(0.0,dm);\r\n    if( dm < .02 ) {\r\n        vec3 col = vec3(0.45,.30,0.15)*.2;\r\n        vec3 pos = ro + rd*tm;\r\n        vec3 nor = llamelGetNormal( pos );\r\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \r\n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\r\n    }\r\n    \r\n    return vec4(0.);\r\n}\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// Clouds (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \r\n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\r\n\tvec3 intersection = ro+rd*d;\r\n    vec3 cint = intersection*0.009;\r\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\r\n\r\n    cint.xy = rotate( rot, cint.xy );\r\n\r\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\r\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\r\n\r\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\r\n\r\n#ifdef DISPLAY_CLOUDS_DETAIL\r\n    if( d < 200. ) {\r\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\r\n    }\r\n#endif\r\n\r\n    shadow = clamp(1.-clouds, 0., 1.);\r\n\r\n    clouds = clamp(clouds, 0., 1.);\r\n    clouds *= clouds;\r\n    clouds *= smoothstep(0.,0.4,d);\r\n\r\n    vec3 clbasecolor = vec3(1.);\r\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\r\n    clcol += .3*clbasecolor*sunColor;\r\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \r\n    \r\n    return vec4( clcol, clouds );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Planet (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\r\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n\r\n    vec3 intersection = ro + rd*d;\r\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n    vec4 res;\r\n\r\n#ifndef HIDE_TERRAIN\r\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \r\n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\r\n#endif\r\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \r\n    float mixDetailColor = 0.;\r\n        \r\n\tif( d < 0. || d > maxd) {\r\n#ifndef HIDE_TERRAIN\r\n        if( renderTerrainDetail ) {\r\n       \t\tintersection = ro;\r\n            n = normalize( ro );\r\n        } else { \t       \r\n\t        return vec4(0);\r\n        }\r\n#else \r\n      \treturn vec4(0.);\r\n#endif\r\n\t}\r\n    if( d > 0. ) {\r\n\t    maxd = d;\r\n    }\r\n    float att = 0.;\r\n    \r\n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\r\n    \r\n    float dm = MAX, e = 0.;\r\n    vec3 col, detailCol, nDetail;\r\n    \r\n    // normal and intersection \r\n#ifndef HIDE_TERRAIN\r\n    if( renderTerrainDetail ) {   \r\n        res = renderTerrain( ro, rd, intersection, nDetail );\r\n        if( res.x < 0. && d < 0. ) {\r\n\t        return vec4(0);\r\n        }\r\n        if( res.x >= 0. ) {\r\n            maxd = pow(res.x/4000.,4.)*50.;\r\n            e = -10.;\r\n        }\r\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\r\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\r\n    } else \r\n#endif        \r\n    if( renderSeaDetail ) {    \r\n        float attsea, mf = smoothstep(.5,1.,d);\r\n\r\n        renderSea( ro, rd, nDetail, attsea );\r\n\r\n        n = normalize(mix( nDetail, n, mf ));\r\n        att = mix( attsea, att, mf );\r\n    } else {\r\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\r\n#ifndef HIDE_TERRAIN\r\n        if( d < 1500. ) {\r\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\r\n        }\r\n#endif  \r\n    }\r\n    \r\n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \r\n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \r\n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \r\n                 \r\n    // color  \r\n#ifndef HIDE_TERRAIN\r\n    if(renderTerrainDetail ) {\r\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\r\n\t\td = 0.;\r\n    }   \r\n#endif\r\n     \r\n    if( mixDetailColor < 1. ) {\r\n        if( e < .45 ) {\r\n            // sea\r\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \r\n        } else {\r\n            // planet (land) far\r\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\r\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\r\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\r\n\r\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\r\n            vec3 landColor2 = RING_COLOR_1 * land2;\r\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\r\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\r\n\r\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\r\n#ifdef HIGH_QUALITY\r\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\r\n#endif\r\n        }\r\n    }\r\n    \r\n    if( mixDetailColor > 0. ) {\r\n        col = mix( col, detailCol, mixDetailColor );\r\n    }\r\n        \r\n#ifdef DISPLAY_LLAMEL\r\n    if(renderTerrainDetail ) {\r\n        vec3 rom = terrainTransformRo(ro),\r\n        rdm = terrainTransform(rd);\r\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\r\n        if( d > 0. ) {\r\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\r\n            col = mix(col, llamel.rgb, llamel.a);\r\n        }\r\n    }\r\n#endif\r\n    \r\n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\r\n    if( d > 0. ) { \r\n        float shadow;\r\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\r\n        col *= shadow; \r\n        col = mix( col, clouds.rgb, clouds.w );\r\n    }\r\n    \r\n    float m = MAX;\r\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\r\n\r\n \treturn vec4( col, 1. ); \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lens flare by musk\r\n//\r\n// https://www.shadertoy.com/view/4sX3Rs\r\n//-----------------------------------------------------\r\n\r\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\r\n\tc = c*.5 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// cameraPath\r\n//-----------------------------------------------------\r\n\r\nvec3 pro, pta, pup;\r\nfloat dro, dta, dup;\r\n\r\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\r\n    if( t >= prevt && t <= prevt+duration ) {\r\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\r\n    }\r\n    prev = dest;\r\n    prevt += duration;\r\n}\r\n\r\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\r\n#ifndef HIDE_TERRAIN\r\n    time = t = mod( t, 92. );\r\n#else\r\n    time = t = mod( t, 66. );\r\n#endif\r\n    dro = dta = dup = 0.;\r\n\r\n    pro = ro = vec3(900. ,7000. ,1500. );\r\n    pta = ta = vec3(    0. ,    0. ,   0. );\r\n    pup = up = vec3(    0. ,    0.4,   1. ); \r\n   \r\n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\r\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \r\n \r\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\r\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\r\n\r\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\r\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\r\n    \r\n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7.,roe, pro, dro );\r\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\r\n    camint( up, t, 6., upe, pup, dup );\r\n        \r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n    \r\n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\r\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\r\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \r\n#ifndef HIDE_TERRAIN    \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7., roe, pro, dro );\r\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\r\n    camint( up, t, 2., upe, pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\r\n    camint( ro, t, 4.,roe, pro, dro );\r\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\r\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\r\n#endif    \r\n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\r\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \r\n    \r\n    up = normalize( up );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// mainImage\r\n//-----------------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    \r\n    vec3 col;\r\n    \r\n// black bands\r\n    vec2 bandy = vec2(.1,.9);\r\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\r\n        col = vec3(0.);\r\n    } else {\r\n        // camera\r\n        vec3 ro, ta, up;\r\n        cameraPath( iTime*.7, ro, ta, up );\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,up) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        float maxd = MAX;  \r\n        col = renderStars( rd ).xyz;\r\n\r\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \r\n        if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n        float atmosphered = maxd;\r\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n        vec4 ring = renderRing( ro, rd, maxd );\r\n        if( ring.w > 0. && atmosphered < maxd ) {\r\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \r\n        }\r\n        col = col * (1.-ring.w ) + ring.xyz;\r\n\r\n#ifdef DISPLAY_CLOUDS\r\n        float lro = length(ro);\r\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\r\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \r\n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \r\n\r\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\r\n                // clouds\r\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\r\n                if( d < maxd ) {\r\n                    float shadow;\r\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\r\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\r\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\r\n                }\r\n            }\r\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\r\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\r\n        }\r\n#endif \r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);      \r\n\r\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\r\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\r\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\r\n\r\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\r\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \r\n    }\r\n    fragColor = vec4( col ,1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n    float maxd = MAX;  \r\n    time = iTime * .7;\r\n    \r\n    rd = rd.xzy;\r\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\r\n    \r\n    vec3 col = renderStars( rd ).xyz;\r\n\r\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \r\n    if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n    float atmosphered = maxd;\r\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n    vec4 ring = renderRing( ro, rd, maxd );\r\n    col = col * (1.-ring.w ) + ring.xyz;\r\n    \r\n    // post processing\r\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n    col *= vec3(1.,0.99,0.95);   \r\n    col = clamp(1.06*col-0.03, 0., 1.);      \r\n    fragColor = vec4( col ,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Planet Shadertoy","id":"83057a172f5245499c274f0e948a36f5","date":null,"viewed":0,"name":"Planet Shadertoy","description":"A seamless space-to-surface flight. This is a tribute to all the great shaders on Shadertoy! Use chrome without angle (or a Mac) and run this shader on med, or high settings (line 4 or 5) to get the full shader and the detail I was aiming for.\r\nhttps://www.shadertoy.com/view/4tjGRh","likes":0,"published":null,"tags":["terrain"," sea"," space"," ocean"," planet"," shadertoy"," vr"," asteroids"]},"ver":null,"info":{"Name":"Planet Shadertoy","id":"83057a172f5245499c274f0e948a36f5","date":null,"viewed":0,"name":"Planet Shadertoy","description":"A seamless space-to-surface flight. This is a tribute to all the great shaders on Shadertoy! Use chrome without angle (or a Mac) and run this shader on med, or high settings (line 4 or 5) to get the full shader and the detail I was aiming for.\r\nhttps://www.shadertoy.com/view/4tjGRh","likes":0,"published":null,"tags":["terrain"," sea"," space"," ocean"," planet"," shadertoy"," vr"," asteroids"]},"renderpass":[{"Code":"// Planet Shadertoy. Created by Reinder Nijhoff 2015\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/4tjGRh\r\n//\r\n// It uses code from the following shaders:\r\n//\r\n// Wet stone by TDM\r\n// Atmospheric Scattering by GLtracy\r\n// Seascape by TDM\r\n// Elevated and Terrain Tubes by IQ\r\n// LLamels by Eiffie\r\n// Lens flare by Musk\r\n// \r\n\r\n//#define HIGH_QUALITY\r\n//#define MED_QUALITY\r\n//#define LOW_QUALITY\r\n#define VERY_LOW_QUALITY\r\n\r\nconst float PI = 3.14159265359;\r\nconst float DEG_TO_RAD = (PI / 180.0);\r\nconst float MAX = 10000.0;\r\n\r\nconst float EARTH_RADIUS = 1000.;\r\nconst float EARTH_ATMOSPHERE = 5.;\r\nconst float EARTH_CLOUDS = 1.;\r\n\r\nconst float RING_INNER_RADIUS = 1500.;\r\nconst float RING_OUTER_RADIUS = 2300.;\r\nconst float RING_HEIGHT = 2.;\r\n\r\n#ifdef HIGH_QUALITY\r\n    const int   SEA_NUM_STEPS = 7;\r\n    const int\tTERRAIN_NUM_STEPS = 140;\r\n    const int   ASTEROID_NUM_STEPS = 11;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\r\n    const int   RING_VOXEL_STEPS = 25;\r\n    const float ASTEROID_MAX_DISTANCE = 1.1; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\r\n\r\n    #define DISPLAY_LLAMEL\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n#endif\r\n\r\n#ifdef MED_QUALITY\r\n    const int   SEA_NUM_STEPS = 6;\r\n    const int\tTERRAIN_NUM_STEPS = 100;\r\n    const int   ASTEROID_NUM_STEPS = 10;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\r\n    const int   RING_VOXEL_STEPS = 24;\r\n    const float ASTEROID_MAX_DISTANCE = 1.; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n#endif\r\n\r\n#ifdef LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 5;\r\n    const int\tTERRAIN_NUM_STEPS = 75;\r\n    const int   ASTEROID_NUM_STEPS = 9;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\r\n    const int   RING_VOXEL_STEPS = 20;\r\n    const float ASTEROID_MAX_DISTANCE = .85; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\r\n#endif\r\n\r\n#ifdef VERY_LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 4;\r\n    const int\tTERRAIN_NUM_STEPS = 60;\r\n    const int   ASTEROID_NUM_STEPS = 7;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\r\n    const int   RING_VOXEL_STEPS = 16;\r\n    const float ASTEROID_MAX_DISTANCE = .67; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\r\n\t#define HIDE_TERRAIN\r\n#endif\r\n\r\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\r\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\r\n\r\nfloat time;\r\n\r\n//-----------------------------------------------------\r\n// Noise functions\r\n//-----------------------------------------------------\r\n\r\nfloat hash( const in float n ) {\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\nfloat hash( const in vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat hash( const in vec3 p ) {\r\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nvec3 hash31( const in float p) {\r\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\r\n    return fract(sin(h)*43758.543123);\r\n}\r\nvec3 hash33( const in vec3 p) {\r\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\r\n}\r\n\r\nfloat noise( const in  float p ) {    \r\n    float i = floor( p );\r\n    float f = fract( p );\t\r\n\tfloat u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\r\n}\r\n\r\nfloat noise( const in  vec2 p ) {    \r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat noise( const in  vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\r\n}\r\n\r\nfloat tri( const in vec2 p ) {\r\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\r\n   \r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( in vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); \r\n    \r\n#ifndef LOW_QUALITY\r\n#ifndef VERY_LOW_QUALITY\r\n    p = m2*p*2.01;\r\n    f += 0.0625*noise( p );\r\n#endif\r\n#endif\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm( const in vec3 p, const in float a, const in float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < FBM_STEPS; i++) {\r\n        float n = pow(noise(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lightning functions\r\n//-----------------------------------------------------\r\n\r\nfloat diffuse( const in vec3 n, const in vec3 l) { \r\n    return clamp(dot(n,l),0.,1.);\r\n}\r\n\r\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\r\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Math functions\r\n//-----------------------------------------------------\r\n\r\nvec2 rotate(float angle, vec2 v) {\r\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\r\n}\r\n\r\nfloat boolSub(float a,float b) { \r\n    return max(a,-b); \r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Intersection functions (by iq)\r\n//-----------------------------------------------------\r\n\r\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\r\n    return (pos-sph.xyz)/sph.w;\r\n}\r\n\r\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return -1.0;\r\n\treturn -b - sqrt( h );\r\n}\r\n\r\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return -MAX;\r\n\treturn -b + sqrt( d );\r\n}\r\n\r\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\r\n\td = sqrt( d );\r\n\treturn vec2( -b - d, -b + d );\r\n}\r\n\r\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\r\n    return obj.xyz;\r\n}\r\n\r\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\r\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Wet stone by TDM\r\n// \r\n// https://www.shadertoy.com/view/ldSSzV\r\n//-----------------------------------------------------\r\n\r\nconst float ASTEROID_TRESHOLD \t= 0.001;\r\nconst float ASTEROID_EPSILON \t= 1e-6;\r\nconst float ASTEROID_DISPLACEMENT = 0.1;\r\nconst float ASTEROID_RADIUS = 0.13;\r\n\r\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\r\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\r\n\r\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \r\n    float d = sphere(p,ASTEROID_RADIUS);    \r\n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\r\n        float ii = float(i)+id.x;\r\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( xyangle, ro.xy );\r\n    \r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( yzangle, ro.yz );\r\n}\r\n\r\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( -yzangle, ro.yz );\r\n\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( -xyangle, ro.xy );  \r\n}\r\n\r\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\r\n    asteroidTransForm( p, id );\r\n    \r\n    vec3 n;\r\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\r\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\r\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\r\n    n = normalize(n-asteroidMapDetailed(p, id));\r\n    \r\n    asteroidUnTransForm( n, id );\r\n    return n;\r\n}\r\n\r\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\r\n    asteroidTransForm( ori, id );\r\n    asteroidTransForm( dir, id );\r\n    \r\n    vec2 td = vec2(0,1);\r\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\r\n        td.y = asteroidMap(ori + dir * td.x, id);\r\n        td.x += td.y;\r\n    }\r\n    return td;\r\n}\r\n\r\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nconst float RING_DETAIL_DISTANCE = 40.;\r\nconst float RING_VOXEL_STEP_SIZE = .03;\r\n\r\nvec3 ringShadowColor( const in vec3 ro ) {\r\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\r\n        return vec3(0.);\r\n    }\r\n    return vec3(1.);\r\n}\r\n\r\nbool ringMap( const in vec3 ro ) {\r\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\r\n}\r\n\r\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \r\n// find startpoint \r\n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\r\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\r\n    \r\n    float d = min( max(d1,0.), max(d2,0.) );\r\n   \r\n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\r\n        return vec4( 0. );\r\n    } else {\r\n        vec3 ros = ro + rd*d;\r\n\r\n        // avoid precision problems..\r\n        vec2 mroxy = mod(ros.xy, vec2(10.));\r\n        vec2 roxy = ros.xy - mroxy;\r\n        ros.xy -= roxy;\r\n        ros /= RING_VOXEL_STEP_SIZE;\r\n        //ros.xy -= vec2(.013,.112)*time*.5;\r\n\r\n        vec3 pos = floor(ros);\r\n        vec3 ri = 1.0/rd;\r\n        vec3 rs = sign(rd);\r\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\r\n\r\n        float alpha = 0., dint;\r\n        vec3 offset = vec3(0), id, asteroidro;\r\n        vec2 asteroid = vec2(0);\r\n\r\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\r\n            if( ringMap(pos) ) {\r\n                id = hash33(pos);\r\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\r\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\r\n\r\n                if( dint > 0. ) {\r\n                    asteroidro = ros+rd*dint-(pos+offset);\r\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\r\n\r\n                    if( asteroid.y < .1 ) {\r\n                        alpha = 1.;\r\n                        break;\t    \r\n                    }\r\n                }\r\n\r\n            }\r\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\r\n            dis += mm * rs * ri;\r\n            pos += mm * rs;\r\n        }\r\n\r\n        if( alpha > 0. ) {       \r\n            vec3 intersection = ros + rd*(asteroid.x+dint);\r\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\r\n\r\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\r\n\r\n            intersection *= RING_VOXEL_STEP_SIZE;\r\n            intersection.xy += roxy;\r\n          //  col *= ringShadowColor( intersection );\r\n\r\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. ) {\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n        } else {\r\n            return 0.;\r\n        }\r\n    } else {\r\n\t    return 0.;\r\n    }\r\n}\r\n\r\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. && d < maxd ) {\r\n        maxd = d;\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\r\n            \r\n            col *= ringShadowColor( intersection );\r\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\r\n\t\t\tcol *= SUN_COLOR;\r\n            return vec4( col, dens );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    } else {\r\n\t    return vec4(0.);\r\n    }\r\n}\r\n\r\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    vec4 far = renderRingFar( ro, rd, maxd );\r\n    float l = length( ro.xy );\r\n\r\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \r\n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \r\n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\r\n     \t\r\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\r\n        far.xyz *= detail;    \r\n    }\r\n    \r\n\t// are asteroids neaded ?\r\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \r\n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \r\n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\r\n        \r\n        vec4 near = renderRingNear( ro, rd );\r\n        far = mix( far, near, near.w );\r\n        maxd=0.;\r\n    }\r\n            \r\n    return far;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Stars (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderStars( const in vec3 rd ) {\r\n\tvec3 rds = rd;\r\n\tvec3 col = vec3(0);\r\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\r\n    \r\n    vec2 xy = vec2(rds.y * v, rds.x * v);\r\n    float s = noise(rds*134.);\r\n    \r\n    s += noise(rds*470.);\r\n    s = pow(s,19.0) * 0.00001;\r\n    if (s > 0.5) {\r\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \r\n        col += backStars;\r\n    }\r\n\treturn   vec4( col, 1 ); \r\n} \r\n\r\n//-----------------------------------------------------\r\n// Atmospheric Scattering by GLtracy\r\n// \r\n// https://www.shadertoy.com/view/lslXDr\r\n//-----------------------------------------------------\r\n\r\nconst float ATMOSPHERE_K_R = 0.166;\r\nconst float ATMOSPHERE_K_M = 0.0025;\r\nconst float ATMOSPHERE_E = 12.3;\r\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\r\nconst float ATMOSPHERE_G_M = -0.85;\r\n\r\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\r\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\r\n\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\r\n\r\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\r\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\r\n\r\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\r\n\tfloat gg = g * g;\r\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\r\n\tfloat b = 1.0 + gg - 2.0 * g * c;\r\n    \r\n\tb *= sqrt( b );\r\n\tb *= 2.0 + gg;\t\r\n\t\r\n\treturn 1.5 * a / b;\r\n}\r\n\r\nfloat atmosphericPhaseReyleigh( float cc ) {\r\n\treturn 0.75 * ( 1.0 + cc );\r\n}\r\n\r\nfloat atmosphericDensity( vec3 p ){\r\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\r\n}\r\n\r\nfloat atmosphericOptic( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n    float sumdensity = 0.;\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\r\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\r\n\t\tfloat dens = atmosphericDensity( v );\r\n  \r\n\t    float m = MAX;\r\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \r\n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\r\n \t\tsumdensity += dens;\r\n        \r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \r\n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\r\n}\r\n\r\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\r\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\r\n\t    float m = MAX;\r\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\r\n}\r\n\r\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \r\n    // inside or outside atmosphere?\r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\r\n        \r\n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\r\n        if( d < e.y ) {\r\n            e.y = d;\r\n        }\r\n\t\td = e.y;\r\n\t    e.x = 0.;\r\n        \r\n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\r\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\r\n\t\t}\r\n    } else {\r\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\r\n        \r\n        if ( e.x > e.y ) {\r\n        \td = MAX;\r\n\t\t\treturn vec4(0.);\r\n\t\t}\r\n\t\td = e.y = min( e.y, f.x );\r\n    }\r\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n    e.x = 0.;\r\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Seascape by TDM\r\n// \r\n// https://www.shadertoy.com/view/Ms2SD1\r\n//-----------------------------------------------------\r\n\r\nconst int   SEA_ITER_GEOMETRY = 3;\r\nconst int   SEA_ITER_FRAGMENT = 5;\r\n\r\nconst float SEA_EPSILON\t= 1e-3;\r\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\r\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\r\nfloat       SEA_TIME;\r\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\nfloat seaOctave( in vec2 uv, const in float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat seaMap(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat seaMapHigh(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \r\n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \r\n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \r\n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\r\n    \r\n    color += upc*SEA_WATER_COLOR * (att * 0.18);\r\n    color += sunc * vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\r\n    vec3 n;\r\n    n.y = seaMapHigh(p);    \r\n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = seaMap(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = seaMap(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = seaMap(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 seaTransform( in vec3 x ) {\r\n    x.yz = rotate( 0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvec3 seaUntransform( in vec3 x ) {\r\n    x.yz = rotate( -0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \r\n    vec3 p,\r\n    rom = seaTransform(ro),\r\n    rdm = seaTransform(rd);\r\n    \r\n    rom.y -= EARTH_RADIUS;\r\n    rom *= 1000.;\r\n    rom.xz += vec2(3.1,.2)*time;\r\n\r\n    SEA_TIME = time * SEA_SPEED;\r\n    \r\n    seaHeightMapTracing(rom,rdm,p);\r\n    float squareddist = dot(p - rom, p-rom );\r\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\r\n    \r\n    n = seaUntransform(n);\r\n    \r\n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Terrain based on Elevated and Terrain Tubes by IQ\r\n//\r\n// https://www.shadertoy.com/view/MdX3Rr\r\n// https://www.shadertoy.com/view/4sjXzG\r\n//-----------------------------------------------------\r\n\r\n#ifndef HIDE_TERRAIN\r\n\r\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\r\n\r\nfloat terrainLow( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<2; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMed( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<6; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n            \r\n    return t*33.0;\r\n}\r\n\r\nfloat terrainHigh( vec2 p ) {\r\n    vec2 q = p;\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<7; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n    \r\n    t += t*0.015*fbm( q );\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMap( const in vec3 pos ) {\r\n\treturn pos.y - terrainMed(pos.xz);  \r\n}\r\n\r\nfloat terrainMapH( const in vec3 pos ) {\r\n    float y = terrainHigh(pos.xz);\r\n    float h = pos.y - y;\r\n    return h;\r\n}\r\n\r\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\r\n    float t = tmin;\r\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\r\n        vec3 pos = ro + t*rd;\r\n        float res = terrainMap( pos );\r\n        if( res<(0.001*t) || t>tmax  ) break;\r\n        t += res*.9;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\r\n\tvec2  eps = vec2(150.0,0.0);\r\n    float h1 = terrainMed( ro.xz );\r\n    float h2 = terrainLow( ro.xz );\r\n    \r\n    float d1 = 10.0;\r\n    float d2 = 80.0;\r\n    float d3 = 200.0;\r\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\r\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\r\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\r\n\r\n    return min(min(s1,s2),s3);\r\n}\r\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\r\n\r\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\r\n}\r\n\r\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\r\n\tfloat e = 0.005*t;\r\n    vec2  eps = vec2(e,0.0);\r\n    float h = terrainMed( pos.xz );\r\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\r\n}\r\n\r\nvec3 terrainTransform( in vec3 x ) {\r\n    x.zy = rotate( -.83, x.zy );\r\n    return x;\r\n}\r\n\r\nvec3 terrainUntransform( in vec3 x ) {\r\n    x.zy = rotate( .83, x.zy );\r\n    return x;\r\n}\r\n\r\n\r\nfloat llamelTime;\r\nconst float llamelScale = 5.;\r\n\r\nvec3 llamelPosition() {\r\n    llamelTime = time*2.5;\r\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\r\n    return vec3( pos.x, terrainMed( pos ), pos.y );\r\n}\r\n\r\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \r\n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\r\n    float dif = diffuse( n, sunDirection );\r\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\r\n    float sha = terrainCalcShadow( pos, sunDirection );\r\n    float amb = clamp( n.y,0.0,1.0);\r\n        \r\n    vec3 lin  = vec3(0.0);\r\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\r\n    lin += 0.2*amb*upc;\r\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\r\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\r\n}\r\n\r\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    vec3 nor = terrainCalcNormalHigh( pos, t );\r\n    vec3 sor = terrainCalcNormalMed( pos, t );\r\n        \r\n    float spec = 0.005;\r\n\r\n#ifdef DISPLAY_TERRAIN_DETAIL\r\n    float no = noise(5.*fbm(1.11*pos.xz));\r\n#else\r\n    const float no = 0.;\r\n#endif\r\n    float r = .5+.5*fbm(.95*pos.xz);\r\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\r\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\r\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\r\n    col *= .88+.12*no;\r\n        \r\n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\r\n    float sf = fwidth(s) * 1.5;\r\n    s = smoothstep(0.84-sf, 0.84+sf, s );\r\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\r\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\r\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\r\n\r\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\r\n\r\n#ifdef DISPLAY_LLAMEL\r\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\r\n#endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 terrainTransformRo( const in vec3 ro ) {\r\n    vec3 rom = terrainTransform(ro);\r\n    rom.y -= EARTH_RADIUS - 100.;\r\n    rom.xz *= 5.;\r\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \r\n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\r\n    return rom;\r\n}\r\n\r\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \r\n    vec3 p,\r\n    rom = terrainTransformRo(ro),\r\n    rdm = terrainTransform(rd);\r\n        \r\n    float tmin = 10.0;\r\n    float tmax = 3200.0;\r\n    \r\n    float res = terrainIntersect( rom, rdm, tmin, tmax );\r\n    \r\n    if( res > tmax ) {\r\n        res = -1.;\r\n    } else {\r\n        vec3 pos =  rom+rdm*res;\r\n        n = terrainCalcNormalMed( pos, res );\r\n        n = terrainUntransform( n );\r\n        \r\n        intersection = ro+rd*res/100.;\r\n    }\r\n    return vec4(res, rom+rdm*res);\r\n}\r\n\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// LLamels by Eiffie\r\n//\r\n// https://www.shadertoy.com/view/ltsGz4\r\n//-----------------------------------------------------\r\n#ifdef DISPLAY_LLAMEL\r\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\r\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\r\n}\r\n\r\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\r\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\r\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\r\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\r\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\r\n\tu=p-j0;q=j1-j0;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\r\n\tu=p-j1;q=j2-j1;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\r\n\tu=p-j2;q=j3-j2;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\r\n}\r\n\r\nfloat llamelMap(in vec3 p) {\r\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\r\n\tp.y += 0.25*llamelScale;\r\n    p.xz -= 0.5*llamelScale;\r\n    p.xz = vec2(-p.z, p.x);\r\n    vec3 pori = p;\r\n        \r\n    p /= llamelScale;\r\n    \r\n\tvec2 c=floor(p.xz);\r\n\tp.xz=fract(p.xz)-vec2(0.5);\r\n    p.y -= p.x*.04*llamelScale;\r\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\r\n\r\n    float b=0.83-abs(p.z);\r\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\r\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\r\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\r\n\tp.y-=0.03;\r\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\r\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\r\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\r\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\r\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\r\n\ta=max(abs(p.z),p.y)+0.05;\r\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\r\n}\r\n\r\nvec3 llamelGetNormal( in vec3 ro ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001;\r\n\r\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\r\n}\r\n\r\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    ro -= llamelPosition();\r\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\r\n\tfor(int i=0;i<36;i++){\r\n\t\tt+=d=llamelMap(ro+rd*t);\r\n\t\tif(d<dm){dm=d;tm=t;}\r\n\t\tif(t>1000.0 || d<0.00001)break;\r\n\t}\r\n\tdm=max(0.0,dm);\r\n    if( dm < .02 ) {\r\n        vec3 col = vec3(0.45,.30,0.15)*.2;\r\n        vec3 pos = ro + rd*tm;\r\n        vec3 nor = llamelGetNormal( pos );\r\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \r\n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\r\n    }\r\n    \r\n    return vec4(0.);\r\n}\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// Clouds (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \r\n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\r\n\tvec3 intersection = ro+rd*d;\r\n    vec3 cint = intersection*0.009;\r\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\r\n\r\n    cint.xy = rotate( rot, cint.xy );\r\n\r\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\r\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\r\n\r\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\r\n\r\n#ifdef DISPLAY_CLOUDS_DETAIL\r\n    if( d < 200. ) {\r\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\r\n    }\r\n#endif\r\n\r\n    shadow = clamp(1.-clouds, 0., 1.);\r\n\r\n    clouds = clamp(clouds, 0., 1.);\r\n    clouds *= clouds;\r\n    clouds *= smoothstep(0.,0.4,d);\r\n\r\n    vec3 clbasecolor = vec3(1.);\r\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\r\n    clcol += .3*clbasecolor*sunColor;\r\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \r\n    \r\n    return vec4( clcol, clouds );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Planet (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\r\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n\r\n    vec3 intersection = ro + rd*d;\r\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n    vec4 res;\r\n\r\n#ifndef HIDE_TERRAIN\r\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \r\n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\r\n#endif\r\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \r\n    float mixDetailColor = 0.;\r\n        \r\n\tif( d < 0. || d > maxd) {\r\n#ifndef HIDE_TERRAIN\r\n        if( renderTerrainDetail ) {\r\n       \t\tintersection = ro;\r\n            n = normalize( ro );\r\n        } else { \t       \r\n\t        return vec4(0);\r\n        }\r\n#else \r\n      \treturn vec4(0.);\r\n#endif\r\n\t}\r\n    if( d > 0. ) {\r\n\t    maxd = d;\r\n    }\r\n    float att = 0.;\r\n    \r\n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\r\n    \r\n    float dm = MAX, e = 0.;\r\n    vec3 col, detailCol, nDetail;\r\n    \r\n    // normal and intersection \r\n#ifndef HIDE_TERRAIN\r\n    if( renderTerrainDetail ) {   \r\n        res = renderTerrain( ro, rd, intersection, nDetail );\r\n        if( res.x < 0. && d < 0. ) {\r\n\t        return vec4(0);\r\n        }\r\n        if( res.x >= 0. ) {\r\n            maxd = pow(res.x/4000.,4.)*50.;\r\n            e = -10.;\r\n        }\r\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\r\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\r\n    } else \r\n#endif        \r\n    if( renderSeaDetail ) {    \r\n        float attsea, mf = smoothstep(.5,1.,d);\r\n\r\n        renderSea( ro, rd, nDetail, attsea );\r\n\r\n        n = normalize(mix( nDetail, n, mf ));\r\n        att = mix( attsea, att, mf );\r\n    } else {\r\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\r\n#ifndef HIDE_TERRAIN\r\n        if( d < 1500. ) {\r\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\r\n        }\r\n#endif  \r\n    }\r\n    \r\n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \r\n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \r\n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \r\n                 \r\n    // color  \r\n#ifndef HIDE_TERRAIN\r\n    if(renderTerrainDetail ) {\r\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\r\n\t\td = 0.;\r\n    }   \r\n#endif\r\n     \r\n    if( mixDetailColor < 1. ) {\r\n        if( e < .45 ) {\r\n            // sea\r\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \r\n        } else {\r\n            // planet (land) far\r\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\r\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\r\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\r\n\r\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\r\n            vec3 landColor2 = RING_COLOR_1 * land2;\r\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\r\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\r\n\r\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\r\n#ifdef HIGH_QUALITY\r\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\r\n#endif\r\n        }\r\n    }\r\n    \r\n    if( mixDetailColor > 0. ) {\r\n        col = mix( col, detailCol, mixDetailColor );\r\n    }\r\n        \r\n#ifdef DISPLAY_LLAMEL\r\n    if(renderTerrainDetail ) {\r\n        vec3 rom = terrainTransformRo(ro),\r\n        rdm = terrainTransform(rd);\r\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\r\n        if( d > 0. ) {\r\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\r\n            col = mix(col, llamel.rgb, llamel.a);\r\n        }\r\n    }\r\n#endif\r\n    \r\n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\r\n    if( d > 0. ) { \r\n        float shadow;\r\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\r\n        col *= shadow; \r\n        col = mix( col, clouds.rgb, clouds.w );\r\n    }\r\n    \r\n    float m = MAX;\r\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\r\n\r\n \treturn vec4( col, 1. ); \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lens flare by musk\r\n//\r\n// https://www.shadertoy.com/view/4sX3Rs\r\n//-----------------------------------------------------\r\n\r\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\r\n\tc = c*.5 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// cameraPath\r\n//-----------------------------------------------------\r\n\r\nvec3 pro, pta, pup;\r\nfloat dro, dta, dup;\r\n\r\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\r\n    if( t >= prevt && t <= prevt+duration ) {\r\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\r\n    }\r\n    prev = dest;\r\n    prevt += duration;\r\n}\r\n\r\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\r\n#ifndef HIDE_TERRAIN\r\n    time = t = mod( t, 92. );\r\n#else\r\n    time = t = mod( t, 66. );\r\n#endif\r\n    dro = dta = dup = 0.;\r\n\r\n    pro = ro = vec3(900. ,7000. ,1500. );\r\n    pta = ta = vec3(    0. ,    0. ,   0. );\r\n    pup = up = vec3(    0. ,    0.4,   1. ); \r\n   \r\n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\r\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \r\n \r\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\r\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\r\n\r\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\r\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\r\n    \r\n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7.,roe, pro, dro );\r\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\r\n    camint( up, t, 6., upe, pup, dup );\r\n        \r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n    \r\n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\r\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\r\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \r\n#ifndef HIDE_TERRAIN    \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7., roe, pro, dro );\r\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\r\n    camint( up, t, 2., upe, pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\r\n    camint( ro, t, 4.,roe, pro, dro );\r\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\r\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\r\n#endif    \r\n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\r\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \r\n    \r\n    up = normalize( up );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// mainImage\r\n//-----------------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    \r\n    vec3 col;\r\n    \r\n// black bands\r\n    vec2 bandy = vec2(.1,.9);\r\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\r\n        col = vec3(0.);\r\n    } else {\r\n        // camera\r\n        vec3 ro, ta, up;\r\n        cameraPath( iTime*.7, ro, ta, up );\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,up) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        float maxd = MAX;  \r\n        col = renderStars( rd ).xyz;\r\n\r\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \r\n        if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n        float atmosphered = maxd;\r\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n        vec4 ring = renderRing( ro, rd, maxd );\r\n        if( ring.w > 0. && atmosphered < maxd ) {\r\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \r\n        }\r\n        col = col * (1.-ring.w ) + ring.xyz;\r\n\r\n#ifdef DISPLAY_CLOUDS\r\n        float lro = length(ro);\r\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\r\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \r\n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \r\n\r\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\r\n                // clouds\r\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\r\n                if( d < maxd ) {\r\n                    float shadow;\r\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\r\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\r\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\r\n                }\r\n            }\r\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\r\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\r\n        }\r\n#endif \r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);      \r\n\r\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\r\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\r\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\r\n\r\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\r\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \r\n    }\r\n    fragColor = vec4( col ,1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n    float maxd = MAX;  \r\n    time = iTime * .7;\r\n    \r\n    rd = rd.xzy;\r\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\r\n    \r\n    vec3 col = renderStars( rd ).xyz;\r\n\r\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \r\n    if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n    float atmosphered = maxd;\r\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n    vec4 ring = renderRing( ro, rd, maxd );\r\n    col = col * (1.-ring.w ) + ring.xyz;\r\n    \r\n    // post processing\r\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n    col *= vec3(1.,0.99,0.95);   \r\n    col = clamp(1.06*col-0.03, 0., 1.);      \r\n    fragColor = vec4( col ,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Planet Shadertoy. Created by Reinder Nijhoff 2015\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/4tjGRh\r\n//\r\n// It uses code from the following shaders:\r\n//\r\n// Wet stone by TDM\r\n// Atmospheric Scattering by GLtracy\r\n// Seascape by TDM\r\n// Elevated and Terrain Tubes by IQ\r\n// LLamels by Eiffie\r\n// Lens flare by Musk\r\n// \r\n\r\n//#define HIGH_QUALITY\r\n//#define MED_QUALITY\r\n//#define LOW_QUALITY\r\n#define VERY_LOW_QUALITY\r\n\r\nconst float PI = 3.14159265359;\r\nconst float DEG_TO_RAD = (PI / 180.0);\r\nconst float MAX = 10000.0;\r\n\r\nconst float EARTH_RADIUS = 1000.;\r\nconst float EARTH_ATMOSPHERE = 5.;\r\nconst float EARTH_CLOUDS = 1.;\r\n\r\nconst float RING_INNER_RADIUS = 1500.;\r\nconst float RING_OUTER_RADIUS = 2300.;\r\nconst float RING_HEIGHT = 2.;\r\n\r\n#ifdef HIGH_QUALITY\r\n    const int   SEA_NUM_STEPS = 7;\r\n    const int\tTERRAIN_NUM_STEPS = 140;\r\n    const int   ASTEROID_NUM_STEPS = 11;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\r\n    const int   RING_VOXEL_STEPS = 25;\r\n    const float ASTEROID_MAX_DISTANCE = 1.1; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\r\n\r\n    #define DISPLAY_LLAMEL\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n#endif\r\n\r\n#ifdef MED_QUALITY\r\n    const int   SEA_NUM_STEPS = 6;\r\n    const int\tTERRAIN_NUM_STEPS = 100;\r\n    const int   ASTEROID_NUM_STEPS = 10;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\r\n    const int   RING_VOXEL_STEPS = 24;\r\n    const float ASTEROID_MAX_DISTANCE = 1.; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n#endif\r\n\r\n#ifdef LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 5;\r\n    const int\tTERRAIN_NUM_STEPS = 75;\r\n    const int   ASTEROID_NUM_STEPS = 9;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\r\n    const int   RING_VOXEL_STEPS = 20;\r\n    const float ASTEROID_MAX_DISTANCE = .85; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\r\n#endif\r\n\r\n#ifdef VERY_LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 4;\r\n    const int\tTERRAIN_NUM_STEPS = 60;\r\n    const int   ASTEROID_NUM_STEPS = 7;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\r\n    const int   RING_VOXEL_STEPS = 16;\r\n    const float ASTEROID_MAX_DISTANCE = .67; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\r\n\t#define HIDE_TERRAIN\r\n#endif\r\n\r\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\r\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\r\n\r\nfloat time;\r\n\r\n//-----------------------------------------------------\r\n// Noise functions\r\n//-----------------------------------------------------\r\n\r\nfloat hash( const in float n ) {\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\nfloat hash( const in vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat hash( const in vec3 p ) {\r\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nvec3 hash31( const in float p) {\r\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\r\n    return fract(sin(h)*43758.543123);\r\n}\r\nvec3 hash33( const in vec3 p) {\r\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\r\n}\r\n\r\nfloat noise( const in  float p ) {    \r\n    float i = floor( p );\r\n    float f = fract( p );\t\r\n\tfloat u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\r\n}\r\n\r\nfloat noise( const in  vec2 p ) {    \r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat noise( const in  vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\r\n}\r\n\r\nfloat tri( const in vec2 p ) {\r\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\r\n   \r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( in vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); \r\n    \r\n#ifndef LOW_QUALITY\r\n#ifndef VERY_LOW_QUALITY\r\n    p = m2*p*2.01;\r\n    f += 0.0625*noise( p );\r\n#endif\r\n#endif\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm( const in vec3 p, const in float a, const in float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < FBM_STEPS; i++) {\r\n        float n = pow(noise(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lightning functions\r\n//-----------------------------------------------------\r\n\r\nfloat diffuse( const in vec3 n, const in vec3 l) { \r\n    return clamp(dot(n,l),0.,1.);\r\n}\r\n\r\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\r\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Math functions\r\n//-----------------------------------------------------\r\n\r\nvec2 rotate(float angle, vec2 v) {\r\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\r\n}\r\n\r\nfloat boolSub(float a,float b) { \r\n    return max(a,-b); \r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Intersection functions (by iq)\r\n//-----------------------------------------------------\r\n\r\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\r\n    return (pos-sph.xyz)/sph.w;\r\n}\r\n\r\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return -1.0;\r\n\treturn -b - sqrt( h );\r\n}\r\n\r\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return -MAX;\r\n\treturn -b + sqrt( d );\r\n}\r\n\r\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\r\n\td = sqrt( d );\r\n\treturn vec2( -b - d, -b + d );\r\n}\r\n\r\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\r\n    return obj.xyz;\r\n}\r\n\r\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\r\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Wet stone by TDM\r\n// \r\n// https://www.shadertoy.com/view/ldSSzV\r\n//-----------------------------------------------------\r\n\r\nconst float ASTEROID_TRESHOLD \t= 0.001;\r\nconst float ASTEROID_EPSILON \t= 1e-6;\r\nconst float ASTEROID_DISPLACEMENT = 0.1;\r\nconst float ASTEROID_RADIUS = 0.13;\r\n\r\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\r\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\r\n\r\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \r\n    float d = sphere(p,ASTEROID_RADIUS);    \r\n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\r\n        float ii = float(i)+id.x;\r\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( xyangle, ro.xy );\r\n    \r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( yzangle, ro.yz );\r\n}\r\n\r\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( -yzangle, ro.yz );\r\n\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( -xyangle, ro.xy );  \r\n}\r\n\r\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\r\n    asteroidTransForm( p, id );\r\n    \r\n    vec3 n;\r\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\r\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\r\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\r\n    n = normalize(n-asteroidMapDetailed(p, id));\r\n    \r\n    asteroidUnTransForm( n, id );\r\n    return n;\r\n}\r\n\r\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\r\n    asteroidTransForm( ori, id );\r\n    asteroidTransForm( dir, id );\r\n    \r\n    vec2 td = vec2(0,1);\r\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\r\n        td.y = asteroidMap(ori + dir * td.x, id);\r\n        td.x += td.y;\r\n    }\r\n    return td;\r\n}\r\n\r\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nconst float RING_DETAIL_DISTANCE = 40.;\r\nconst float RING_VOXEL_STEP_SIZE = .03;\r\n\r\nvec3 ringShadowColor( const in vec3 ro ) {\r\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\r\n        return vec3(0.);\r\n    }\r\n    return vec3(1.);\r\n}\r\n\r\nbool ringMap( const in vec3 ro ) {\r\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\r\n}\r\n\r\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \r\n// find startpoint \r\n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\r\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\r\n    \r\n    float d = min( max(d1,0.), max(d2,0.) );\r\n   \r\n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\r\n        return vec4( 0. );\r\n    } else {\r\n        vec3 ros = ro + rd*d;\r\n\r\n        // avoid precision problems..\r\n        vec2 mroxy = mod(ros.xy, vec2(10.));\r\n        vec2 roxy = ros.xy - mroxy;\r\n        ros.xy -= roxy;\r\n        ros /= RING_VOXEL_STEP_SIZE;\r\n        //ros.xy -= vec2(.013,.112)*time*.5;\r\n\r\n        vec3 pos = floor(ros);\r\n        vec3 ri = 1.0/rd;\r\n        vec3 rs = sign(rd);\r\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\r\n\r\n        float alpha = 0., dint;\r\n        vec3 offset = vec3(0), id, asteroidro;\r\n        vec2 asteroid = vec2(0);\r\n\r\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\r\n            if( ringMap(pos) ) {\r\n                id = hash33(pos);\r\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\r\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\r\n\r\n                if( dint > 0. ) {\r\n                    asteroidro = ros+rd*dint-(pos+offset);\r\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\r\n\r\n                    if( asteroid.y < .1 ) {\r\n                        alpha = 1.;\r\n                        break;\t    \r\n                    }\r\n                }\r\n\r\n            }\r\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\r\n            dis += mm * rs * ri;\r\n            pos += mm * rs;\r\n        }\r\n\r\n        if( alpha > 0. ) {       \r\n            vec3 intersection = ros + rd*(asteroid.x+dint);\r\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\r\n\r\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\r\n\r\n            intersection *= RING_VOXEL_STEP_SIZE;\r\n            intersection.xy += roxy;\r\n          //  col *= ringShadowColor( intersection );\r\n\r\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. ) {\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n        } else {\r\n            return 0.;\r\n        }\r\n    } else {\r\n\t    return 0.;\r\n    }\r\n}\r\n\r\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. && d < maxd ) {\r\n        maxd = d;\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\r\n            \r\n            col *= ringShadowColor( intersection );\r\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\r\n\t\t\tcol *= SUN_COLOR;\r\n            return vec4( col, dens );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    } else {\r\n\t    return vec4(0.);\r\n    }\r\n}\r\n\r\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    vec4 far = renderRingFar( ro, rd, maxd );\r\n    float l = length( ro.xy );\r\n\r\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \r\n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \r\n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\r\n     \t\r\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\r\n        far.xyz *= detail;    \r\n    }\r\n    \r\n\t// are asteroids neaded ?\r\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \r\n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \r\n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\r\n        \r\n        vec4 near = renderRingNear( ro, rd );\r\n        far = mix( far, near, near.w );\r\n        maxd=0.;\r\n    }\r\n            \r\n    return far;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Stars (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderStars( const in vec3 rd ) {\r\n\tvec3 rds = rd;\r\n\tvec3 col = vec3(0);\r\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\r\n    \r\n    vec2 xy = vec2(rds.y * v, rds.x * v);\r\n    float s = noise(rds*134.);\r\n    \r\n    s += noise(rds*470.);\r\n    s = pow(s,19.0) * 0.00001;\r\n    if (s > 0.5) {\r\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \r\n        col += backStars;\r\n    }\r\n\treturn   vec4( col, 1 ); \r\n} \r\n\r\n//-----------------------------------------------------\r\n// Atmospheric Scattering by GLtracy\r\n// \r\n// https://www.shadertoy.com/view/lslXDr\r\n//-----------------------------------------------------\r\n\r\nconst float ATMOSPHERE_K_R = 0.166;\r\nconst float ATMOSPHERE_K_M = 0.0025;\r\nconst float ATMOSPHERE_E = 12.3;\r\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\r\nconst float ATMOSPHERE_G_M = -0.85;\r\n\r\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\r\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\r\n\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\r\n\r\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\r\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\r\n\r\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\r\n\tfloat gg = g * g;\r\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\r\n\tfloat b = 1.0 + gg - 2.0 * g * c;\r\n    \r\n\tb *= sqrt( b );\r\n\tb *= 2.0 + gg;\t\r\n\t\r\n\treturn 1.5 * a / b;\r\n}\r\n\r\nfloat atmosphericPhaseReyleigh( float cc ) {\r\n\treturn 0.75 * ( 1.0 + cc );\r\n}\r\n\r\nfloat atmosphericDensity( vec3 p ){\r\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\r\n}\r\n\r\nfloat atmosphericOptic( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n    float sumdensity = 0.;\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\r\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\r\n\t\tfloat dens = atmosphericDensity( v );\r\n  \r\n\t    float m = MAX;\r\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \r\n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\r\n \t\tsumdensity += dens;\r\n        \r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \r\n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\r\n}\r\n\r\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\r\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\r\n\t    float m = MAX;\r\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\r\n}\r\n\r\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \r\n    // inside or outside atmosphere?\r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\r\n        \r\n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\r\n        if( d < e.y ) {\r\n            e.y = d;\r\n        }\r\n\t\td = e.y;\r\n\t    e.x = 0.;\r\n        \r\n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\r\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\r\n\t\t}\r\n    } else {\r\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\r\n        \r\n        if ( e.x > e.y ) {\r\n        \td = MAX;\r\n\t\t\treturn vec4(0.);\r\n\t\t}\r\n\t\td = e.y = min( e.y, f.x );\r\n    }\r\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n    e.x = 0.;\r\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Seascape by TDM\r\n// \r\n// https://www.shadertoy.com/view/Ms2SD1\r\n//-----------------------------------------------------\r\n\r\nconst int   SEA_ITER_GEOMETRY = 3;\r\nconst int   SEA_ITER_FRAGMENT = 5;\r\n\r\nconst float SEA_EPSILON\t= 1e-3;\r\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\r\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\r\nfloat       SEA_TIME;\r\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\nfloat seaOctave( in vec2 uv, const in float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat seaMap(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat seaMapHigh(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \r\n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \r\n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \r\n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\r\n    \r\n    color += upc*SEA_WATER_COLOR * (att * 0.18);\r\n    color += sunc * vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\r\n    vec3 n;\r\n    n.y = seaMapHigh(p);    \r\n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = seaMap(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = seaMap(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = seaMap(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 seaTransform( in vec3 x ) {\r\n    x.yz = rotate( 0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvec3 seaUntransform( in vec3 x ) {\r\n    x.yz = rotate( -0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \r\n    vec3 p,\r\n    rom = seaTransform(ro),\r\n    rdm = seaTransform(rd);\r\n    \r\n    rom.y -= EARTH_RADIUS;\r\n    rom *= 1000.;\r\n    rom.xz += vec2(3.1,.2)*time;\r\n\r\n    SEA_TIME = time * SEA_SPEED;\r\n    \r\n    seaHeightMapTracing(rom,rdm,p);\r\n    float squareddist = dot(p - rom, p-rom );\r\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\r\n    \r\n    n = seaUntransform(n);\r\n    \r\n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Terrain based on Elevated and Terrain Tubes by IQ\r\n//\r\n// https://www.shadertoy.com/view/MdX3Rr\r\n// https://www.shadertoy.com/view/4sjXzG\r\n//-----------------------------------------------------\r\n\r\n#ifndef HIDE_TERRAIN\r\n\r\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\r\n\r\nfloat terrainLow( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<2; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMed( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<6; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n            \r\n    return t*33.0;\r\n}\r\n\r\nfloat terrainHigh( vec2 p ) {\r\n    vec2 q = p;\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<7; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n    \r\n    t += t*0.015*fbm( q );\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMap( const in vec3 pos ) {\r\n\treturn pos.y - terrainMed(pos.xz);  \r\n}\r\n\r\nfloat terrainMapH( const in vec3 pos ) {\r\n    float y = terrainHigh(pos.xz);\r\n    float h = pos.y - y;\r\n    return h;\r\n}\r\n\r\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\r\n    float t = tmin;\r\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\r\n        vec3 pos = ro + t*rd;\r\n        float res = terrainMap( pos );\r\n        if( res<(0.001*t) || t>tmax  ) break;\r\n        t += res*.9;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\r\n\tvec2  eps = vec2(150.0,0.0);\r\n    float h1 = terrainMed( ro.xz );\r\n    float h2 = terrainLow( ro.xz );\r\n    \r\n    float d1 = 10.0;\r\n    float d2 = 80.0;\r\n    float d3 = 200.0;\r\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\r\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\r\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\r\n\r\n    return min(min(s1,s2),s3);\r\n}\r\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\r\n\r\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\r\n}\r\n\r\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\r\n\tfloat e = 0.005*t;\r\n    vec2  eps = vec2(e,0.0);\r\n    float h = terrainMed( pos.xz );\r\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\r\n}\r\n\r\nvec3 terrainTransform( in vec3 x ) {\r\n    x.zy = rotate( -.83, x.zy );\r\n    return x;\r\n}\r\n\r\nvec3 terrainUntransform( in vec3 x ) {\r\n    x.zy = rotate( .83, x.zy );\r\n    return x;\r\n}\r\n\r\n\r\nfloat llamelTime;\r\nconst float llamelScale = 5.;\r\n\r\nvec3 llamelPosition() {\r\n    llamelTime = time*2.5;\r\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\r\n    return vec3( pos.x, terrainMed( pos ), pos.y );\r\n}\r\n\r\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \r\n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\r\n    float dif = diffuse( n, sunDirection );\r\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\r\n    float sha = terrainCalcShadow( pos, sunDirection );\r\n    float amb = clamp( n.y,0.0,1.0);\r\n        \r\n    vec3 lin  = vec3(0.0);\r\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\r\n    lin += 0.2*amb*upc;\r\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\r\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\r\n}\r\n\r\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    vec3 nor = terrainCalcNormalHigh( pos, t );\r\n    vec3 sor = terrainCalcNormalMed( pos, t );\r\n        \r\n    float spec = 0.005;\r\n\r\n#ifdef DISPLAY_TERRAIN_DETAIL\r\n    float no = noise(5.*fbm(1.11*pos.xz));\r\n#else\r\n    const float no = 0.;\r\n#endif\r\n    float r = .5+.5*fbm(.95*pos.xz);\r\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\r\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\r\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\r\n    col *= .88+.12*no;\r\n        \r\n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\r\n    float sf = fwidth(s) * 1.5;\r\n    s = smoothstep(0.84-sf, 0.84+sf, s );\r\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\r\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\r\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\r\n\r\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\r\n\r\n#ifdef DISPLAY_LLAMEL\r\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\r\n#endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 terrainTransformRo( const in vec3 ro ) {\r\n    vec3 rom = terrainTransform(ro);\r\n    rom.y -= EARTH_RADIUS - 100.;\r\n    rom.xz *= 5.;\r\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \r\n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\r\n    return rom;\r\n}\r\n\r\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \r\n    vec3 p,\r\n    rom = terrainTransformRo(ro),\r\n    rdm = terrainTransform(rd);\r\n        \r\n    float tmin = 10.0;\r\n    float tmax = 3200.0;\r\n    \r\n    float res = terrainIntersect( rom, rdm, tmin, tmax );\r\n    \r\n    if( res > tmax ) {\r\n        res = -1.;\r\n    } else {\r\n        vec3 pos =  rom+rdm*res;\r\n        n = terrainCalcNormalMed( pos, res );\r\n        n = terrainUntransform( n );\r\n        \r\n        intersection = ro+rd*res/100.;\r\n    }\r\n    return vec4(res, rom+rdm*res);\r\n}\r\n\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// LLamels by Eiffie\r\n//\r\n// https://www.shadertoy.com/view/ltsGz4\r\n//-----------------------------------------------------\r\n#ifdef DISPLAY_LLAMEL\r\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\r\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\r\n}\r\n\r\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\r\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\r\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\r\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\r\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\r\n\tu=p-j0;q=j1-j0;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\r\n\tu=p-j1;q=j2-j1;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\r\n\tu=p-j2;q=j3-j2;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\r\n}\r\n\r\nfloat llamelMap(in vec3 p) {\r\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\r\n\tp.y += 0.25*llamelScale;\r\n    p.xz -= 0.5*llamelScale;\r\n    p.xz = vec2(-p.z, p.x);\r\n    vec3 pori = p;\r\n        \r\n    p /= llamelScale;\r\n    \r\n\tvec2 c=floor(p.xz);\r\n\tp.xz=fract(p.xz)-vec2(0.5);\r\n    p.y -= p.x*.04*llamelScale;\r\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\r\n\r\n    float b=0.83-abs(p.z);\r\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\r\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\r\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\r\n\tp.y-=0.03;\r\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\r\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\r\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\r\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\r\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\r\n\ta=max(abs(p.z),p.y)+0.05;\r\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\r\n}\r\n\r\nvec3 llamelGetNormal( in vec3 ro ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001;\r\n\r\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\r\n}\r\n\r\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    ro -= llamelPosition();\r\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\r\n\tfor(int i=0;i<36;i++){\r\n\t\tt+=d=llamelMap(ro+rd*t);\r\n\t\tif(d<dm){dm=d;tm=t;}\r\n\t\tif(t>1000.0 || d<0.00001)break;\r\n\t}\r\n\tdm=max(0.0,dm);\r\n    if( dm < .02 ) {\r\n        vec3 col = vec3(0.45,.30,0.15)*.2;\r\n        vec3 pos = ro + rd*tm;\r\n        vec3 nor = llamelGetNormal( pos );\r\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \r\n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\r\n    }\r\n    \r\n    return vec4(0.);\r\n}\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// Clouds (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \r\n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\r\n\tvec3 intersection = ro+rd*d;\r\n    vec3 cint = intersection*0.009;\r\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\r\n\r\n    cint.xy = rotate( rot, cint.xy );\r\n\r\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\r\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\r\n\r\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\r\n\r\n#ifdef DISPLAY_CLOUDS_DETAIL\r\n    if( d < 200. ) {\r\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\r\n    }\r\n#endif\r\n\r\n    shadow = clamp(1.-clouds, 0., 1.);\r\n\r\n    clouds = clamp(clouds, 0., 1.);\r\n    clouds *= clouds;\r\n    clouds *= smoothstep(0.,0.4,d);\r\n\r\n    vec3 clbasecolor = vec3(1.);\r\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\r\n    clcol += .3*clbasecolor*sunColor;\r\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \r\n    \r\n    return vec4( clcol, clouds );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Planet (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\r\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n\r\n    vec3 intersection = ro + rd*d;\r\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n    vec4 res;\r\n\r\n#ifndef HIDE_TERRAIN\r\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \r\n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\r\n#endif\r\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \r\n    float mixDetailColor = 0.;\r\n        \r\n\tif( d < 0. || d > maxd) {\r\n#ifndef HIDE_TERRAIN\r\n        if( renderTerrainDetail ) {\r\n       \t\tintersection = ro;\r\n            n = normalize( ro );\r\n        } else { \t       \r\n\t        return vec4(0);\r\n        }\r\n#else \r\n      \treturn vec4(0.);\r\n#endif\r\n\t}\r\n    if( d > 0. ) {\r\n\t    maxd = d;\r\n    }\r\n    float att = 0.;\r\n    \r\n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\r\n    \r\n    float dm = MAX, e = 0.;\r\n    vec3 col, detailCol, nDetail;\r\n    \r\n    // normal and intersection \r\n#ifndef HIDE_TERRAIN\r\n    if( renderTerrainDetail ) {   \r\n        res = renderTerrain( ro, rd, intersection, nDetail );\r\n        if( res.x < 0. && d < 0. ) {\r\n\t        return vec4(0);\r\n        }\r\n        if( res.x >= 0. ) {\r\n            maxd = pow(res.x/4000.,4.)*50.;\r\n            e = -10.;\r\n        }\r\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\r\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\r\n    } else \r\n#endif        \r\n    if( renderSeaDetail ) {    \r\n        float attsea, mf = smoothstep(.5,1.,d);\r\n\r\n        renderSea( ro, rd, nDetail, attsea );\r\n\r\n        n = normalize(mix( nDetail, n, mf ));\r\n        att = mix( attsea, att, mf );\r\n    } else {\r\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\r\n#ifndef HIDE_TERRAIN\r\n        if( d < 1500. ) {\r\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\r\n        }\r\n#endif  \r\n    }\r\n    \r\n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \r\n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \r\n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \r\n                 \r\n    // color  \r\n#ifndef HIDE_TERRAIN\r\n    if(renderTerrainDetail ) {\r\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\r\n\t\td = 0.;\r\n    }   \r\n#endif\r\n     \r\n    if( mixDetailColor < 1. ) {\r\n        if( e < .45 ) {\r\n            // sea\r\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \r\n        } else {\r\n            // planet (land) far\r\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\r\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\r\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\r\n\r\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\r\n            vec3 landColor2 = RING_COLOR_1 * land2;\r\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\r\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\r\n\r\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\r\n#ifdef HIGH_QUALITY\r\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\r\n#endif\r\n        }\r\n    }\r\n    \r\n    if( mixDetailColor > 0. ) {\r\n        col = mix( col, detailCol, mixDetailColor );\r\n    }\r\n        \r\n#ifdef DISPLAY_LLAMEL\r\n    if(renderTerrainDetail ) {\r\n        vec3 rom = terrainTransformRo(ro),\r\n        rdm = terrainTransform(rd);\r\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\r\n        if( d > 0. ) {\r\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\r\n            col = mix(col, llamel.rgb, llamel.a);\r\n        }\r\n    }\r\n#endif\r\n    \r\n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\r\n    if( d > 0. ) { \r\n        float shadow;\r\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\r\n        col *= shadow; \r\n        col = mix( col, clouds.rgb, clouds.w );\r\n    }\r\n    \r\n    float m = MAX;\r\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\r\n\r\n \treturn vec4( col, 1. ); \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lens flare by musk\r\n//\r\n// https://www.shadertoy.com/view/4sX3Rs\r\n//-----------------------------------------------------\r\n\r\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\r\n\tc = c*.5 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// cameraPath\r\n//-----------------------------------------------------\r\n\r\nvec3 pro, pta, pup;\r\nfloat dro, dta, dup;\r\n\r\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\r\n    if( t >= prevt && t <= prevt+duration ) {\r\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\r\n    }\r\n    prev = dest;\r\n    prevt += duration;\r\n}\r\n\r\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\r\n#ifndef HIDE_TERRAIN\r\n    time = t = mod( t, 92. );\r\n#else\r\n    time = t = mod( t, 66. );\r\n#endif\r\n    dro = dta = dup = 0.;\r\n\r\n    pro = ro = vec3(900. ,7000. ,1500. );\r\n    pta = ta = vec3(    0. ,    0. ,   0. );\r\n    pup = up = vec3(    0. ,    0.4,   1. ); \r\n   \r\n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\r\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \r\n \r\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\r\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\r\n\r\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\r\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\r\n    \r\n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7.,roe, pro, dro );\r\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\r\n    camint( up, t, 6., upe, pup, dup );\r\n        \r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n    \r\n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\r\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\r\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \r\n#ifndef HIDE_TERRAIN    \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7., roe, pro, dro );\r\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\r\n    camint( up, t, 2., upe, pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\r\n    camint( ro, t, 4.,roe, pro, dro );\r\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\r\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\r\n#endif    \r\n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\r\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \r\n    \r\n    up = normalize( up );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// mainImage\r\n//-----------------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    \r\n    vec3 col;\r\n    \r\n// black bands\r\n    vec2 bandy = vec2(.1,.9);\r\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\r\n        col = vec3(0.);\r\n    } else {\r\n        // camera\r\n        vec3 ro, ta, up;\r\n        cameraPath( iTime*.7, ro, ta, up );\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,up) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        float maxd = MAX;  \r\n        col = renderStars( rd ).xyz;\r\n\r\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \r\n        if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n        float atmosphered = maxd;\r\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n        vec4 ring = renderRing( ro, rd, maxd );\r\n        if( ring.w > 0. && atmosphered < maxd ) {\r\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \r\n        }\r\n        col = col * (1.-ring.w ) + ring.xyz;\r\n\r\n#ifdef DISPLAY_CLOUDS\r\n        float lro = length(ro);\r\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\r\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \r\n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \r\n\r\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\r\n                // clouds\r\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\r\n                if( d < maxd ) {\r\n                    float shadow;\r\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\r\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\r\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\r\n                }\r\n            }\r\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\r\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\r\n        }\r\n#endif \r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);      \r\n\r\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\r\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\r\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\r\n\r\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\r\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \r\n    }\r\n    fragColor = vec4( col ,1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n    float maxd = MAX;  \r\n    time = iTime * .7;\r\n    \r\n    rd = rd.xzy;\r\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\r\n    \r\n    vec3 col = renderStars( rd ).xyz;\r\n\r\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \r\n    if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n    float atmosphered = maxd;\r\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n    vec4 ring = renderRing( ro, rd, maxd );\r\n    col = col * (1.-ring.w ) + ring.xyz;\r\n    \r\n    // post processing\r\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n    col *= vec3(1.,0.99,0.95);   \r\n    col = clamp(1.06*col-0.03, 0., 1.);      \r\n    fragColor = vec4( col ,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n    \r\n    vec3 bg = vec3(0.2,0.0,0.34);\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = bg;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += bg * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n    \r\n    vec3 bg = vec3(0.2,0.0,0.34);\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = bg;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += bg * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Playing marble","id":"86efa73517ab4d49974faa5490fa27a4","date":null,"viewed":0,"name":"Playing marble","description":"3d marble texture ","likes":0,"published":null,"tags":["3d"," fractal"," volumetric"]},"ver":null,"info":{"Name":"Playing marble","id":"86efa73517ab4d49974faa5490fa27a4","date":null,"viewed":0,"name":"Playing marble","description":"3d marble texture ","likes":0,"published":null,"tags":["3d"," fractal"," volumetric"]},"renderpass":[{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n    \r\n    vec3 bg = vec3(0.2,0.0,0.34);\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = bg;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += bg * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n    \r\n    vec3 bg = vec3(0.2,0.0,0.34);\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = bg;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += bg * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Fork of \"Playing marble\" by guil. https://shadertoy.com/view/MtX3Ws\r\n// 2020-11-15 17:52:01\r\n\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n         p =(sin(iTime*0.35432)*.7+1.5)*abs(p)/dot(p,p) -0.4 + sin(iTime*0.2443)*.3;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,2.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = vec3(0.0);//texture(iChannel0, rd).rgb;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += vec3(0.0)* fre;//texture(iChannel0, nor).rgb ;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    col.b = col.g*3.;\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","inputs":[],"outputs":[],"code":"// Fork of \"Playing marble\" by guil. https://shadertoy.com/view/MtX3Ws\r\n// 2020-11-15 17:52:01\r\n\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n         p =(sin(iTime*0.35432)*.7+1.5)*abs(p)/dot(p,p) -0.4 + sin(iTime*0.2443)*.3;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,2.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = vec3(0.0);//texture(iChannel0, rd).rgb;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += vec3(0.0)* fre;//texture(iChannel0, nor).rgb ;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    col.b = col.g*3.;\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Playing marble moving remix","id":"276bb67a76d342009b1b82a2a3992d04","date":null,"viewed":0,"name":"Playing marble moving remix","description":"3d marble texture wanted to see it morphing \nhttps://www.shadertoy.com/view/wstBRB","likes":0,"published":null,"tags":["3d"," fractal"," volumetric"]},"ver":null,"info":{"Name":"Playing marble moving remix","id":"276bb67a76d342009b1b82a2a3992d04","date":null,"viewed":0,"name":"Playing marble moving remix","description":"3d marble texture wanted to see it morphing \nhttps://www.shadertoy.com/view/wstBRB","likes":0,"published":null,"tags":["3d"," fractal"," volumetric"]},"renderpass":[{"Code":"// Fork of \"Playing marble\" by guil. https://shadertoy.com/view/MtX3Ws\r\n// 2020-11-15 17:52:01\r\n\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n         p =(sin(iTime*0.35432)*.7+1.5)*abs(p)/dot(p,p) -0.4 + sin(iTime*0.2443)*.3;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,2.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = vec3(0.0);//texture(iChannel0, rd).rgb;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += vec3(0.0)* fre;//texture(iChannel0, nor).rgb ;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    col.b = col.g*3.;\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","inputs":[],"outputs":[],"code":"// Fork of \"Playing marble\" by guil. https://shadertoy.com/view/MtX3Ws\r\n// 2020-11-15 17:52:01\r\n\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n         p =(sin(iTime*0.35432)*.7+1.5)*abs(p)/dot(p,p) -0.4 + sin(iTime*0.2443)*.3;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,2.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = vec3(0.0);//texture(iChannel0, rd).rgb;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += vec3(0.0)* fre;//texture(iChannel0, nor).rgb ;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    col.b = col.g*3.;\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Procedural Brick Texture 2D","id":"wlcGRM","date":"1576151122","viewed":55,"name":"Procedural Brick Texture 2D","description":"2D\u53CD\u952F\u9F7F\u7816\u5757\u8D34\u56FE","likes":4,"published":"Public","tags":["2d","brick","antialiase"]},"ver":"0.1","info":{"Name":"Procedural Brick Texture 2D","id":"wlcGRM","date":"1576151122","viewed":55,"name":"Procedural Brick Texture 2D","description":"2D\u53CD\u952F\u9F7F\u7816\u5757\u8D34\u56FE","likes":4,"published":"Public","tags":["2d","brick","antialiase"]},"renderpass":[{"Code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Procedural Five-Point Star","id":"3ttGDr","date":"1576051881","viewed":39,"name":"Procedural Five-Point Star","description":"\u4E94\u89D2\u661F","likes":1,"published":"Public","tags":["procedural","2d","fivepointstar"]},"ver":"0.1","info":{"Name":"Procedural Five-Point Star","id":"3ttGDr","date":"1576051881","viewed":39,"name":"Procedural Five-Point Star","description":"\u4E94\u89D2\u661F","likes":1,"published":"Public","tags":["procedural","2d","fivepointstar"]},"renderpass":[{"Code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define SCALE 1.\r\n#define LINEAR_DENSITY 1        // 0: constant\r\n#define DENS (2./SCALE)         // tau.rho\r\n#define rad (.3*SCALE )         // sphere radius\r\n#define H   (.05*SCALE)         // skin layer thickness (for linear density)\r\n#define CAMERA_DIST (SCALE)  // distance between camera and sphere center\r\n#define ANIM true               // true/false\r\n#define NOISE true              // true/false\r\n#define PI 3.14159\r\n\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    if (NOISE) cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,CAMERA_DIST);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","inputs":[],"outputs":[],"code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define SCALE 1.\r\n#define LINEAR_DENSITY 1        // 0: constant\r\n#define DENS (2./SCALE)         // tau.rho\r\n#define rad (.3*SCALE )         // sphere radius\r\n#define H   (.05*SCALE)         // skin layer thickness (for linear density)\r\n#define CAMERA_DIST (SCALE)  // distance between camera and sphere center\r\n#define ANIM true               // true/false\r\n#define NOISE true              // true/false\r\n#define PI 3.14159\r\n\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    if (NOISE) cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,CAMERA_DIST);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Pseudo-surface illumination","id":"9a04decb39e34dddb789dab27208e966","date":null,"viewed":0,"name":"Pseudo-surface illumination","description":"Pseudo-surface macrosopic reflexion due to microscopic scattering.\nhttps://www.shadertoy.com/view/MsX3DM","likes":0,"published":null,"tags":["pseudosurfaceillumination"]},"ver":null,"info":{"Name":"Pseudo-surface illumination","id":"9a04decb39e34dddb789dab27208e966","date":null,"viewed":0,"name":"Pseudo-surface illumination","description":"Pseudo-surface macrosopic reflexion due to microscopic scattering.\nhttps://www.shadertoy.com/view/MsX3DM","likes":0,"published":null,"tags":["pseudosurfaceillumination"]},"renderpass":[{"Code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define SCALE 1.\r\n#define LINEAR_DENSITY 1        // 0: constant\r\n#define DENS (2./SCALE)         // tau.rho\r\n#define rad (.3*SCALE )         // sphere radius\r\n#define H   (.05*SCALE)         // skin layer thickness (for linear density)\r\n#define CAMERA_DIST (SCALE)  // distance between camera and sphere center\r\n#define ANIM true               // true/false\r\n#define NOISE true              // true/false\r\n#define PI 3.14159\r\n\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    if (NOISE) cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,CAMERA_DIST);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","inputs":[],"outputs":[],"code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define SCALE 1.\r\n#define LINEAR_DENSITY 1        // 0: constant\r\n#define DENS (2./SCALE)         // tau.rho\r\n#define rad (.3*SCALE )         // sphere radius\r\n#define H   (.05*SCALE)         // skin layer thickness (for linear density)\r\n#define CAMERA_DIST (SCALE)  // distance between camera and sphere center\r\n#define ANIM true               // true/false\r\n#define NOISE true              // true/false\r\n#define PI 3.14159\r\n\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    if (NOISE) cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,CAMERA_DIST);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// The MIT License\r\n// Copyright \u00A9 2018 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\r\n//\r\n// List of some other 2D distances:\r\n//\r\n// Circle:               https://www.shadertoy.com/view/3ltSW2\r\n// Segment:              https://www.shadertoy.com/view/3tdSDj\r\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\r\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\r\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\r\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\r\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\r\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\r\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\r\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\r\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\r\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\r\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\r\n// Star5:                https://www.shadertoy.com/view/wlcGzB\r\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\r\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\r\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\r\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\r\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\r\n// Cross:                https://www.shadertoy.com/view/XtGfzw\r\n// Pie:                  https://www.shadertoy.com/view/3l23RK\r\n// Arc:                  https://www.shadertoy.com/view/wl23RK\r\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\r\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\r\n// Parabola Segment:     https://www.shadertoy.com/view/3lSczz\r\n// Rounded X:            https://www.shadertoy.com/view/3dKSDc\r\n// Joint:                https://www.shadertoy.com/view/WldGWM\r\n// Simple Egg:           https://www.shadertoy.com/view/Wdjfz3\r\n//\r\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\r\n\r\n\r\n\r\nfloat dot2( in vec2 v ) { return dot(v,v); }\r\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\r\n    \r\n// unsigned distance to a quadratic bezier\r\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        res = dot2(d+(c+b*t)*t);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        res = min( dot2(d+(c+b*t.x)*t.x),\r\n                   dot2(d+(c+b*t.y)*t.y) );\r\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\r\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\r\n    }\r\n    \r\n    return sqrt( res );\r\n}\r\n\r\n// signed distance to a quadratic bezier\r\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n    float sgn = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        vec2  q = d+(c+b*t)*t;\r\n        res = dot2(q);\r\n    \tsgn = cross2(c+2.0*b*t,q);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\r\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\r\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\r\n    }\r\n    \r\n    return sqrt( res )*sign(sgn);\r\n}\r\n\r\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p - a;\r\n\tvec2 ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    \r\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\r\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\r\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,1.0) );\r\n    \r\n    float d = sdBezier( p, v0,v1,v2 ); \r\n    \r\n    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\r\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,f);\r\n\tcol *= 1.0 - exp(-4.0*abs(d));\r\n\tcol *= 0.8 + 0.2*cos(140.0*d);\r\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\r\n    \r\n    if( cos(0.5*iTime)<-0.5 )\r\n    {\r\n        d = min( udSegment(p,v0,v1),\r\n                 udSegment(p,v1,v2) );\r\n        d = min( d, length(p-v0)-0.02 );\r\n        d = min( d, length(p-v1)-0.02 );\r\n        d = min( d, length(p-v2)-0.02 );\r\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\r\n    }\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// The MIT License\r\n// Copyright \u00A9 2018 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\r\n//\r\n// List of some other 2D distances:\r\n//\r\n// Circle:               https://www.shadertoy.com/view/3ltSW2\r\n// Segment:              https://www.shadertoy.com/view/3tdSDj\r\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\r\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\r\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\r\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\r\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\r\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\r\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\r\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\r\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\r\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\r\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\r\n// Star5:                https://www.shadertoy.com/view/wlcGzB\r\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\r\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\r\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\r\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\r\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\r\n// Cross:                https://www.shadertoy.com/view/XtGfzw\r\n// Pie:                  https://www.shadertoy.com/view/3l23RK\r\n// Arc:                  https://www.shadertoy.com/view/wl23RK\r\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\r\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\r\n// Parabola Segment:     https://www.shadertoy.com/view/3lSczz\r\n// Rounded X:            https://www.shadertoy.com/view/3dKSDc\r\n// Joint:                https://www.shadertoy.com/view/WldGWM\r\n// Simple Egg:           https://www.shadertoy.com/view/Wdjfz3\r\n//\r\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\r\n\r\n\r\n\r\nfloat dot2( in vec2 v ) { return dot(v,v); }\r\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\r\n    \r\n// unsigned distance to a quadratic bezier\r\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        res = dot2(d+(c+b*t)*t);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        res = min( dot2(d+(c+b*t.x)*t.x),\r\n                   dot2(d+(c+b*t.y)*t.y) );\r\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\r\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\r\n    }\r\n    \r\n    return sqrt( res );\r\n}\r\n\r\n// signed distance to a quadratic bezier\r\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n    float sgn = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        vec2  q = d+(c+b*t)*t;\r\n        res = dot2(q);\r\n    \tsgn = cross2(c+2.0*b*t,q);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\r\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\r\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\r\n    }\r\n    \r\n    return sqrt( res )*sign(sgn);\r\n}\r\n\r\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p - a;\r\n\tvec2 ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    \r\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\r\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\r\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,1.0) );\r\n    \r\n    float d = sdBezier( p, v0,v1,v2 ); \r\n    \r\n    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\r\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,f);\r\n\tcol *= 1.0 - exp(-4.0*abs(d));\r\n\tcol *= 0.8 + 0.2*cos(140.0*d);\r\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\r\n    \r\n    if( cos(0.5*iTime)<-0.5 )\r\n    {\r\n        d = min( udSegment(p,v0,v1),\r\n                 udSegment(p,v1,v2) );\r\n        d = min( d, length(p-v0)-0.02 );\r\n        d = min( d, length(p-v1)-0.02 );\r\n        d = min( d, length(p-v2)-0.02 );\r\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\r\n    }\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Quadratic Bezier - 2D Distance","id":"642aa62f032c4a7790211df6a27c0969","date":null,"viewed":0,"name":"Quadratic Bezier - 2D Distance","description":"Distance to a quadratic Bezier segment, which can be computer analytically by solving a cubic equation.","likes":0,"published":null,"tags":["2d"," distancefield"," sdf"," bezier"," cubic"," quadratic"]},"ver":null,"info":{"Name":"Quadratic Bezier - 2D Distance","id":"642aa62f032c4a7790211df6a27c0969","date":null,"viewed":0,"name":"Quadratic Bezier - 2D Distance","description":"Distance to a quadratic Bezier segment, which can be computer analytically by solving a cubic equation.","likes":0,"published":null,"tags":["2d"," distancefield"," sdf"," bezier"," cubic"," quadratic"]},"renderpass":[{"Code":"// The MIT License\r\n// Copyright \u00A9 2018 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\r\n//\r\n// List of some other 2D distances:\r\n//\r\n// Circle:               https://www.shadertoy.com/view/3ltSW2\r\n// Segment:              https://www.shadertoy.com/view/3tdSDj\r\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\r\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\r\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\r\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\r\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\r\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\r\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\r\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\r\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\r\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\r\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\r\n// Star5:                https://www.shadertoy.com/view/wlcGzB\r\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\r\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\r\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\r\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\r\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\r\n// Cross:                https://www.shadertoy.com/view/XtGfzw\r\n// Pie:                  https://www.shadertoy.com/view/3l23RK\r\n// Arc:                  https://www.shadertoy.com/view/wl23RK\r\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\r\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\r\n// Parabola Segment:     https://www.shadertoy.com/view/3lSczz\r\n// Rounded X:            https://www.shadertoy.com/view/3dKSDc\r\n// Joint:                https://www.shadertoy.com/view/WldGWM\r\n// Simple Egg:           https://www.shadertoy.com/view/Wdjfz3\r\n//\r\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\r\n\r\n\r\n\r\nfloat dot2( in vec2 v ) { return dot(v,v); }\r\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\r\n    \r\n// unsigned distance to a quadratic bezier\r\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        res = dot2(d+(c+b*t)*t);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        res = min( dot2(d+(c+b*t.x)*t.x),\r\n                   dot2(d+(c+b*t.y)*t.y) );\r\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\r\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\r\n    }\r\n    \r\n    return sqrt( res );\r\n}\r\n\r\n// signed distance to a quadratic bezier\r\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n    float sgn = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        vec2  q = d+(c+b*t)*t;\r\n        res = dot2(q);\r\n    \tsgn = cross2(c+2.0*b*t,q);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\r\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\r\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\r\n    }\r\n    \r\n    return sqrt( res )*sign(sgn);\r\n}\r\n\r\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p - a;\r\n\tvec2 ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    \r\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\r\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\r\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,1.0) );\r\n    \r\n    float d = sdBezier( p, v0,v1,v2 ); \r\n    \r\n    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\r\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,f);\r\n\tcol *= 1.0 - exp(-4.0*abs(d));\r\n\tcol *= 0.8 + 0.2*cos(140.0*d);\r\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\r\n    \r\n    if( cos(0.5*iTime)<-0.5 )\r\n    {\r\n        d = min( udSegment(p,v0,v1),\r\n                 udSegment(p,v1,v2) );\r\n        d = min( d, length(p-v0)-0.02 );\r\n        d = min( d, length(p-v1)-0.02 );\r\n        d = min( d, length(p-v2)-0.02 );\r\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\r\n    }\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// The MIT License\r\n// Copyright \u00A9 2018 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\r\n//\r\n// List of some other 2D distances:\r\n//\r\n// Circle:               https://www.shadertoy.com/view/3ltSW2\r\n// Segment:              https://www.shadertoy.com/view/3tdSDj\r\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\r\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\r\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\r\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\r\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\r\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\r\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\r\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\r\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\r\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\r\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\r\n// Star5:                https://www.shadertoy.com/view/wlcGzB\r\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\r\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\r\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\r\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\r\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\r\n// Cross:                https://www.shadertoy.com/view/XtGfzw\r\n// Pie:                  https://www.shadertoy.com/view/3l23RK\r\n// Arc:                  https://www.shadertoy.com/view/wl23RK\r\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\r\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\r\n// Parabola Segment:     https://www.shadertoy.com/view/3lSczz\r\n// Rounded X:            https://www.shadertoy.com/view/3dKSDc\r\n// Joint:                https://www.shadertoy.com/view/WldGWM\r\n// Simple Egg:           https://www.shadertoy.com/view/Wdjfz3\r\n//\r\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\r\n\r\n\r\n\r\nfloat dot2( in vec2 v ) { return dot(v,v); }\r\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\r\n    \r\n// unsigned distance to a quadratic bezier\r\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        res = dot2(d+(c+b*t)*t);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        res = min( dot2(d+(c+b*t.x)*t.x),\r\n                   dot2(d+(c+b*t.y)*t.y) );\r\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\r\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\r\n    }\r\n    \r\n    return sqrt( res );\r\n}\r\n\r\n// signed distance to a quadratic bezier\r\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n    float sgn = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        vec2  q = d+(c+b*t)*t;\r\n        res = dot2(q);\r\n    \tsgn = cross2(c+2.0*b*t,q);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\r\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\r\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\r\n    }\r\n    \r\n    return sqrt( res )*sign(sgn);\r\n}\r\n\r\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p - a;\r\n\tvec2 ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    \r\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\r\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\r\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,1.0) );\r\n    \r\n    float d = sdBezier( p, v0,v1,v2 ); \r\n    \r\n    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\r\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,f);\r\n\tcol *= 1.0 - exp(-4.0*abs(d));\r\n\tcol *= 0.8 + 0.2*cos(140.0*d);\r\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\r\n    \r\n    if( cos(0.5*iTime)<-0.5 )\r\n    {\r\n        d = min( udSegment(p,v0,v1),\r\n                 udSegment(p,v1,v2) );\r\n        d = min( d, length(p-v0)-0.02 );\r\n        d = min( d, length(p-v1)-0.02 );\r\n        d = min( d, length(p-v2)-0.02 );\r\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\r\n    }\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"float NEAR_CLIPPING_PLANE=.005;\r\nfloat FAR_CLIPPING_PLANE=1000.;\r\nint NUMBER_OF_MARCH_STEPS=500;\r\nfloat EPSILON=.1;\r\nfloat DISTANCE_BIAS=.2;\r\nfloat t = 0.;\r\n\r\nfloat fly = 1.;\r\nfloat sdSphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - (s);\r\n}\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvoid r(inout vec3 pos) {\r\n    if (pos.z < FAR_CLIPPING_PLANE) {\r\n        pR(pos.yx,cos(pos.z*.1+pos.z*.1)+t);\r\n        pR(pos.xy,0.2*sin(pos.z*.2*t*.1));\r\n    }\r\n    else pR(pos.yx,cos(pos.z*.1)+t);\r\n    \r\n}\r\n\r\nvoid r2(inout vec3 pos) {\r\n   if (pos.z < 2800.+cos(pos.z*2.1+t*5.)*10.) pR(pos.yx,cos(pos.z*cos(t*.002+sin(pos.z*.001+abs(pos.y*.0001)))*.5)+t*.05);\r\n}\r\n\r\nvoid r3(inout vec3 pos) {\r\n   pR(pos.xy,sin(pos.z*cos(t*.002+sin(pos.z*.001+(pos.z*.01)))*.5)+t*.5);\r\n}\r\n\r\nfloat celli(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\r\n\r\nfloat cellTile(in vec3 p){\r\n    vec4 d; \r\n    d.x = celli(p - vec3(.81, .62, .53));\r\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\r\n    d.y = celli(p - vec3(.39, .2, .11));\r\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\r\n    d.z = celli(p - vec3(.62, .24, .06));\r\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\r\n    d.w = celli(p - vec3(.2, .82, .64));\r\n    d.xy = min(d.xz, d.yw);\r\n    return min(d.x, d.y)*2.66; \r\n}\r\n\r\nfloat hex(vec2 p) {\r\n    p.x *= 0.57735*2.;\r\n\tp.y += mod(floor(p.x), 2.)*.5;\r\n\tp = abs((mod(p, 1.) - .5));\r\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.) - 1.);\r\n}\r\n\r\nfloat cellTile2(in vec3 p){\r\n    vec4 d; \r\n    d.x = celli(p - vec3(.81, .62, .53));\r\n    p.xy = vec2(p.y-p.x, p.y + p.x)+hex(p.xy*0.2);\r\n    d.y = celli(p - vec3(.39, .2, .11));\r\n    p.yz = vec2(p.z-p.y, p.z + p.y)+hex(p.yz*0.2);\r\n    d.z = celli(p - vec3(.62, .24, .06));\r\n    p.xz = vec2(p.z-p.x, p.z + p.x)+hex(p.xz*0.2);\r\n    d.w = celli(p - vec3(.2, .82, .64));\r\n    d.xy = min(d.xz, d.yw);\r\n    return min(d.x, d.y)*.5; \r\n}\r\nfloat bump(vec3 pos) {\r\n    float re = 0.;\r\n\tre += cellTile2(pos*.25) * cellTile2(pos*1.1) * 3. + cellTile2(pos*1.2) * cellTile2(pos*4.4) * .5;\r\n    return re;\r\n}\r\nvec3 hit;\r\n\r\nfloat sp(vec3 opos, vec3 pos) {\r\n\treturn sdSphere(cos(opos*.2),1.1+cos(pos.z*.01+cos(pos.x*1.1)*.1)*.2)*3.91;\r\n}\r\n\r\nvoid rota(inout vec3 pos) {\r\n    if (fly == 1.) r(pos);\r\n    if (fly == 0.) r2(pos);\r\n    if (fly == 2.) r3(pos);\r\n}\r\n\r\nfloat scene1(vec3 pos)\r\n{\r\n\trota(pos);\r\n    float of = .3*sin(pos.z*5.5);\r\n\treturn sp(pos - vec3(of, -of, cos(pos.z)*.5),pos);\r\n}\r\n\r\nfloat scene2(vec3 pos)\r\n{\r\n    vec3 translate = vec3(-0.5*cos(pos.z*.01), -.2*sin(.005*pos.z*cos(pos.z*4.5+pos.z*.5+pos.z*5.)*.1), 0.);\r\n\trota(pos);\r\n    hit = pos;\r\n\treturn sp(pos - translate,pos);\r\n}\r\n\r\nfloat scene(vec3 pos) {\r\n\treturn min(scene1(pos),scene2(pos));\r\n}\r\n\r\nfloat sceneb(vec3 pos) {\r\n\treturn min(scene1(pos),scene2(pos))-bump(hit+cos(pos.z*.3)*3.)*1.5;\r\n}\r\n\r\nvec2 raymarch(vec3 position, vec3 direction)\r\n{\r\n    float total_distance = NEAR_CLIPPING_PLANE;\r\n    float acc = 0.;\r\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\r\n    {\r\n        vec3 pos = position + direction * total_distance;\r\n        float result = scene(pos);\r\n        acc+=cos(result*1.)*.05;\r\n\r\n        if(result < EPSILON)\r\n        {\r\n            return vec2(total_distance, acc);\r\n        }\r\n        \r\n        total_distance += result * DISTANCE_BIAS;\r\n        \r\n        \r\n        if(total_distance > FAR_CLIPPING_PLANE)\r\n            break;\r\n    }\r\n    return vec2(FAR_CLIPPING_PLANE, acc);\r\n}\r\n\r\nvec3 nr(vec3 n) {\r\n\treturn normalize(n);\r\n}\r\n\r\nvec3 normal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3(.3,0.,0.)*EPSILON;\r\n\tvec3 nor = vec3(\r\n\t    sceneb(pos+eps.xyy) - sceneb(pos-eps.xyy),\r\n\t    sceneb(pos+eps.yxy) - sceneb(pos-eps.yxy),\r\n\t    sceneb(pos+eps.yyx) - sceneb(pos-eps.yyx) );\r\n\treturn nr(nor);\r\n}\r\n\r\n\r\n\r\nfloat orenNayarDiffuse(\r\n  vec3 lightDirection,\r\n  vec3 viewDirection,\r\n  vec3 surfaceNormal,\r\n  float roughness,\r\n  float albedo) {\r\n  \r\n  float LdotV = dot(lightDirection, viewDirection);\r\n  float NdotL = dot(lightDirection, surfaceNormal);\r\n  float NdotV = dot(surfaceNormal, viewDirection);\r\n\r\n  float s = LdotV - NdotL * NdotV;\r\n  float t = mix(1., max(NdotL, NdotV), step(0., s));\r\n\r\n  float sigma2 = roughness * roughness;\r\n  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\r\n  float B = .45 * sigma2 / (sigma2 + .09);\r\n\r\n  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;\r\n}\r\n\r\nfloat fader = 1.0;\r\nfloat fader2 = 1.0;\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 res = iResolution.xy;\r\n    // pixel coordinates\r\n    vec2 uv = (-res + 2.*(fragCoord.xy))/res.y;\r\n    \r\n    vec3 direction = nr(vec3(uv, 0.));\r\n\r\n    t = iTime+32.;\r\n    \r\n    if (fly >= 1.) t-=31.;\r\n\r\n    float cz = t*5.9;\r\n    \r\n\r\n    float FOV = t*.1;\r\n        \r\n\t    vec3 camera_origin = vec3(0., 1., cz);\r\n\tvec3 lookAt = vec3(0.,1.,cz+1.);\r\n    \r\n    vec3 forward = nr(lookAt-camera_origin);\r\n    vec3 right = nr(vec3(forward.z, 0., -forward.x ));\r\n    vec3 up = nr(cross(forward,right));\r\n\r\n    \r\n    vec3 ro = camera_origin;\r\n    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);\r\n\r\n    vec2 result = raymarch(ro, rd);\r\n            \r\n    float fog = pow(1. / (1. + result.x), .2);\r\n    \r\n    vec3 icecol = vec3(.6,.6,1.0);\r\n\tvec3 materialColor = vec3(1.3-result.x*.01*.5,.9-cos(result.x*.1)*.5,1.*.5);\r\n\r\n\tmaterialColor -= vec3(.4,4.7,8.0)*(bump(hit)+bump(hit*.2*vec3(1.,1.,4.))*1.5);\r\n    vec3 intersection = ro + rd*result.x;\r\n    \r\n    vec3 nrml = normal(intersection);\r\n    vec3 light_dir = nr(vec3(sin(result.x*.1),.3,-1.+fly));\r\n    vec3 ref = reflect( rd, nrml );\r\n\t\r\n    if (t > 85.) { materialColor=mix(materialColor,icecol,clamp((t-85.)*0.2,0.,1.8)); }\r\n\r\n    float dom = smoothstep( -.1, .9, ref.y);\r\n    float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);\r\n\r\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,.3*fly,.7*fly)-result.y*.05;\r\n    \r\n    vec3 light_color = vec3(1.);\r\n    vec3 ambient_color = light_color;\r\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\r\n    vec3 outColor = diffuseLit*fog+dom*.2+spe*.6;\r\n\tfragColor = vec4(mix(vec3(diffuse),outColor,fader), 1.)*fader2;\r\n }","inputs":[],"outputs":[],"code":"float NEAR_CLIPPING_PLANE=.005;\r\nfloat FAR_CLIPPING_PLANE=1000.;\r\nint NUMBER_OF_MARCH_STEPS=500;\r\nfloat EPSILON=.1;\r\nfloat DISTANCE_BIAS=.2;\r\nfloat t = 0.;\r\n\r\nfloat fly = 1.;\r\nfloat sdSphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - (s);\r\n}\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvoid r(inout vec3 pos) {\r\n    if (pos.z < FAR_CLIPPING_PLANE) {\r\n        pR(pos.yx,cos(pos.z*.1+pos.z*.1)+t);\r\n        pR(pos.xy,0.2*sin(pos.z*.2*t*.1));\r\n    }\r\n    else pR(pos.yx,cos(pos.z*.1)+t);\r\n    \r\n}\r\n\r\nvoid r2(inout vec3 pos) {\r\n   if (pos.z < 2800.+cos(pos.z*2.1+t*5.)*10.) pR(pos.yx,cos(pos.z*cos(t*.002+sin(pos.z*.001+abs(pos.y*.0001)))*.5)+t*.05);\r\n}\r\n\r\nvoid r3(inout vec3 pos) {\r\n   pR(pos.xy,sin(pos.z*cos(t*.002+sin(pos.z*.001+(pos.z*.01)))*.5)+t*.5);\r\n}\r\n\r\nfloat celli(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\r\n\r\nfloat cellTile(in vec3 p){\r\n    vec4 d; \r\n    d.x = celli(p - vec3(.81, .62, .53));\r\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\r\n    d.y = celli(p - vec3(.39, .2, .11));\r\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\r\n    d.z = celli(p - vec3(.62, .24, .06));\r\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\r\n    d.w = celli(p - vec3(.2, .82, .64));\r\n    d.xy = min(d.xz, d.yw);\r\n    return min(d.x, d.y)*2.66; \r\n}\r\n\r\nfloat hex(vec2 p) {\r\n    p.x *= 0.57735*2.;\r\n\tp.y += mod(floor(p.x), 2.)*.5;\r\n\tp = abs((mod(p, 1.) - .5));\r\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.) - 1.);\r\n}\r\n\r\nfloat cellTile2(in vec3 p){\r\n    vec4 d; \r\n    d.x = celli(p - vec3(.81, .62, .53));\r\n    p.xy = vec2(p.y-p.x, p.y + p.x)+hex(p.xy*0.2);\r\n    d.y = celli(p - vec3(.39, .2, .11));\r\n    p.yz = vec2(p.z-p.y, p.z + p.y)+hex(p.yz*0.2);\r\n    d.z = celli(p - vec3(.62, .24, .06));\r\n    p.xz = vec2(p.z-p.x, p.z + p.x)+hex(p.xz*0.2);\r\n    d.w = celli(p - vec3(.2, .82, .64));\r\n    d.xy = min(d.xz, d.yw);\r\n    return min(d.x, d.y)*.5; \r\n}\r\nfloat bump(vec3 pos) {\r\n    float re = 0.;\r\n\tre += cellTile2(pos*.25) * cellTile2(pos*1.1) * 3. + cellTile2(pos*1.2) * cellTile2(pos*4.4) * .5;\r\n    return re;\r\n}\r\nvec3 hit;\r\n\r\nfloat sp(vec3 opos, vec3 pos) {\r\n\treturn sdSphere(cos(opos*.2),1.1+cos(pos.z*.01+cos(pos.x*1.1)*.1)*.2)*3.91;\r\n}\r\n\r\nvoid rota(inout vec3 pos) {\r\n    if (fly == 1.) r(pos);\r\n    if (fly == 0.) r2(pos);\r\n    if (fly == 2.) r3(pos);\r\n}\r\n\r\nfloat scene1(vec3 pos)\r\n{\r\n\trota(pos);\r\n    float of = .3*sin(pos.z*5.5);\r\n\treturn sp(pos - vec3(of, -of, cos(pos.z)*.5),pos);\r\n}\r\n\r\nfloat scene2(vec3 pos)\r\n{\r\n    vec3 translate = vec3(-0.5*cos(pos.z*.01), -.2*sin(.005*pos.z*cos(pos.z*4.5+pos.z*.5+pos.z*5.)*.1), 0.);\r\n\trota(pos);\r\n    hit = pos;\r\n\treturn sp(pos - translate,pos);\r\n}\r\n\r\nfloat scene(vec3 pos) {\r\n\treturn min(scene1(pos),scene2(pos));\r\n}\r\n\r\nfloat sceneb(vec3 pos) {\r\n\treturn min(scene1(pos),scene2(pos))-bump(hit+cos(pos.z*.3)*3.)*1.5;\r\n}\r\n\r\nvec2 raymarch(vec3 position, vec3 direction)\r\n{\r\n    float total_distance = NEAR_CLIPPING_PLANE;\r\n    float acc = 0.;\r\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\r\n    {\r\n        vec3 pos = position + direction * total_distance;\r\n        float result = scene(pos);\r\n        acc+=cos(result*1.)*.05;\r\n\r\n        if(result < EPSILON)\r\n        {\r\n            return vec2(total_distance, acc);\r\n        }\r\n        \r\n        total_distance += result * DISTANCE_BIAS;\r\n        \r\n        \r\n        if(total_distance > FAR_CLIPPING_PLANE)\r\n            break;\r\n    }\r\n    return vec2(FAR_CLIPPING_PLANE, acc);\r\n}\r\n\r\nvec3 nr(vec3 n) {\r\n\treturn normalize(n);\r\n}\r\n\r\nvec3 normal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3(.3,0.,0.)*EPSILON;\r\n\tvec3 nor = vec3(\r\n\t    sceneb(pos+eps.xyy) - sceneb(pos-eps.xyy),\r\n\t    sceneb(pos+eps.yxy) - sceneb(pos-eps.yxy),\r\n\t    sceneb(pos+eps.yyx) - sceneb(pos-eps.yyx) );\r\n\treturn nr(nor);\r\n}\r\n\r\n\r\n\r\nfloat orenNayarDiffuse(\r\n  vec3 lightDirection,\r\n  vec3 viewDirection,\r\n  vec3 surfaceNormal,\r\n  float roughness,\r\n  float albedo) {\r\n  \r\n  float LdotV = dot(lightDirection, viewDirection);\r\n  float NdotL = dot(lightDirection, surfaceNormal);\r\n  float NdotV = dot(surfaceNormal, viewDirection);\r\n\r\n  float s = LdotV - NdotL * NdotV;\r\n  float t = mix(1., max(NdotL, NdotV), step(0., s));\r\n\r\n  float sigma2 = roughness * roughness;\r\n  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\r\n  float B = .45 * sigma2 / (sigma2 + .09);\r\n\r\n  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;\r\n}\r\n\r\nfloat fader = 1.0;\r\nfloat fader2 = 1.0;\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 res = iResolution.xy;\r\n    // pixel coordinates\r\n    vec2 uv = (-res + 2.*(fragCoord.xy))/res.y;\r\n    \r\n    vec3 direction = nr(vec3(uv, 0.));\r\n\r\n    t = iTime+32.;\r\n    \r\n    if (fly >= 1.) t-=31.;\r\n\r\n    float cz = t*5.9;\r\n    \r\n\r\n    float FOV = t*.1;\r\n        \r\n\t    vec3 camera_origin = vec3(0., 1., cz);\r\n\tvec3 lookAt = vec3(0.,1.,cz+1.);\r\n    \r\n    vec3 forward = nr(lookAt-camera_origin);\r\n    vec3 right = nr(vec3(forward.z, 0., -forward.x ));\r\n    vec3 up = nr(cross(forward,right));\r\n\r\n    \r\n    vec3 ro = camera_origin;\r\n    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);\r\n\r\n    vec2 result = raymarch(ro, rd);\r\n            \r\n    float fog = pow(1. / (1. + result.x), .2);\r\n    \r\n    vec3 icecol = vec3(.6,.6,1.0);\r\n\tvec3 materialColor = vec3(1.3-result.x*.01*.5,.9-cos(result.x*.1)*.5,1.*.5);\r\n\r\n\tmaterialColor -= vec3(.4,4.7,8.0)*(bump(hit)+bump(hit*.2*vec3(1.,1.,4.))*1.5);\r\n    vec3 intersection = ro + rd*result.x;\r\n    \r\n    vec3 nrml = normal(intersection);\r\n    vec3 light_dir = nr(vec3(sin(result.x*.1),.3,-1.+fly));\r\n    vec3 ref = reflect( rd, nrml );\r\n\t\r\n    if (t > 85.) { materialColor=mix(materialColor,icecol,clamp((t-85.)*0.2,0.,1.8)); }\r\n\r\n    float dom = smoothstep( -.1, .9, ref.y);\r\n    float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);\r\n\r\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,.3*fly,.7*fly)-result.y*.05;\r\n    \r\n    vec3 light_color = vec3(1.);\r\n    vec3 ambient_color = light_color;\r\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\r\n    vec3 outColor = diffuseLit*fog+dom*.2+spe*.6;\r\n\tfragColor = vec4(mix(vec3(diffuse),outColor,fader), 1.)*fader2;\r\n }","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Quadtripophobic Tentacle","id":"499b7f9d79ae4a93a2fc5c6566ff2ddf","date":null,"viewed":0,"name":"Quadtripophobic Tentacle","description":"As seen in our 4k intro \"Quadtripophobia\" by Quadtrip\nhttps://www.shadertoy.com/view/llScR1","likes":0,"published":null,"tags":["raymarching"," orennayardiffuse"]},"ver":null,"info":{"Name":"Quadtripophobic Tentacle","id":"499b7f9d79ae4a93a2fc5c6566ff2ddf","date":null,"viewed":0,"name":"Quadtripophobic Tentacle","description":"As seen in our 4k intro \"Quadtripophobia\" by Quadtrip\nhttps://www.shadertoy.com/view/llScR1","likes":0,"published":null,"tags":["raymarching"," orennayardiffuse"]},"renderpass":[{"Code":"float NEAR_CLIPPING_PLANE=.005;\r\nfloat FAR_CLIPPING_PLANE=1000.;\r\nint NUMBER_OF_MARCH_STEPS=500;\r\nfloat EPSILON=.1;\r\nfloat DISTANCE_BIAS=.2;\r\nfloat t = 0.;\r\n\r\nfloat fly = 1.;\r\nfloat sdSphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - (s);\r\n}\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvoid r(inout vec3 pos) {\r\n    if (pos.z < FAR_CLIPPING_PLANE) {\r\n        pR(pos.yx,cos(pos.z*.1+pos.z*.1)+t);\r\n        pR(pos.xy,0.2*sin(pos.z*.2*t*.1));\r\n    }\r\n    else pR(pos.yx,cos(pos.z*.1)+t);\r\n    \r\n}\r\n\r\nvoid r2(inout vec3 pos) {\r\n   if (pos.z < 2800.+cos(pos.z*2.1+t*5.)*10.) pR(pos.yx,cos(pos.z*cos(t*.002+sin(pos.z*.001+abs(pos.y*.0001)))*.5)+t*.05);\r\n}\r\n\r\nvoid r3(inout vec3 pos) {\r\n   pR(pos.xy,sin(pos.z*cos(t*.002+sin(pos.z*.001+(pos.z*.01)))*.5)+t*.5);\r\n}\r\n\r\nfloat celli(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\r\n\r\nfloat cellTile(in vec3 p){\r\n    vec4 d; \r\n    d.x = celli(p - vec3(.81, .62, .53));\r\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\r\n    d.y = celli(p - vec3(.39, .2, .11));\r\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\r\n    d.z = celli(p - vec3(.62, .24, .06));\r\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\r\n    d.w = celli(p - vec3(.2, .82, .64));\r\n    d.xy = min(d.xz, d.yw);\r\n    return min(d.x, d.y)*2.66; \r\n}\r\n\r\nfloat hex(vec2 p) {\r\n    p.x *= 0.57735*2.;\r\n\tp.y += mod(floor(p.x), 2.)*.5;\r\n\tp = abs((mod(p, 1.) - .5));\r\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.) - 1.);\r\n}\r\n\r\nfloat cellTile2(in vec3 p){\r\n    vec4 d; \r\n    d.x = celli(p - vec3(.81, .62, .53));\r\n    p.xy = vec2(p.y-p.x, p.y + p.x)+hex(p.xy*0.2);\r\n    d.y = celli(p - vec3(.39, .2, .11));\r\n    p.yz = vec2(p.z-p.y, p.z + p.y)+hex(p.yz*0.2);\r\n    d.z = celli(p - vec3(.62, .24, .06));\r\n    p.xz = vec2(p.z-p.x, p.z + p.x)+hex(p.xz*0.2);\r\n    d.w = celli(p - vec3(.2, .82, .64));\r\n    d.xy = min(d.xz, d.yw);\r\n    return min(d.x, d.y)*.5; \r\n}\r\nfloat bump(vec3 pos) {\r\n    float re = 0.;\r\n\tre += cellTile2(pos*.25) * cellTile2(pos*1.1) * 3. + cellTile2(pos*1.2) * cellTile2(pos*4.4) * .5;\r\n    return re;\r\n}\r\nvec3 hit;\r\n\r\nfloat sp(vec3 opos, vec3 pos) {\r\n\treturn sdSphere(cos(opos*.2),1.1+cos(pos.z*.01+cos(pos.x*1.1)*.1)*.2)*3.91;\r\n}\r\n\r\nvoid rota(inout vec3 pos) {\r\n    if (fly == 1.) r(pos);\r\n    if (fly == 0.) r2(pos);\r\n    if (fly == 2.) r3(pos);\r\n}\r\n\r\nfloat scene1(vec3 pos)\r\n{\r\n\trota(pos);\r\n    float of = .3*sin(pos.z*5.5);\r\n\treturn sp(pos - vec3(of, -of, cos(pos.z)*.5),pos);\r\n}\r\n\r\nfloat scene2(vec3 pos)\r\n{\r\n    vec3 translate = vec3(-0.5*cos(pos.z*.01), -.2*sin(.005*pos.z*cos(pos.z*4.5+pos.z*.5+pos.z*5.)*.1), 0.);\r\n\trota(pos);\r\n    hit = pos;\r\n\treturn sp(pos - translate,pos);\r\n}\r\n\r\nfloat scene(vec3 pos) {\r\n\treturn min(scene1(pos),scene2(pos));\r\n}\r\n\r\nfloat sceneb(vec3 pos) {\r\n\treturn min(scene1(pos),scene2(pos))-bump(hit+cos(pos.z*.3)*3.)*1.5;\r\n}\r\n\r\nvec2 raymarch(vec3 position, vec3 direction)\r\n{\r\n    float total_distance = NEAR_CLIPPING_PLANE;\r\n    float acc = 0.;\r\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\r\n    {\r\n        vec3 pos = position + direction * total_distance;\r\n        float result = scene(pos);\r\n        acc+=cos(result*1.)*.05;\r\n\r\n        if(result < EPSILON)\r\n        {\r\n            return vec2(total_distance, acc);\r\n        }\r\n        \r\n        total_distance += result * DISTANCE_BIAS;\r\n        \r\n        \r\n        if(total_distance > FAR_CLIPPING_PLANE)\r\n            break;\r\n    }\r\n    return vec2(FAR_CLIPPING_PLANE, acc);\r\n}\r\n\r\nvec3 nr(vec3 n) {\r\n\treturn normalize(n);\r\n}\r\n\r\nvec3 normal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3(.3,0.,0.)*EPSILON;\r\n\tvec3 nor = vec3(\r\n\t    sceneb(pos+eps.xyy) - sceneb(pos-eps.xyy),\r\n\t    sceneb(pos+eps.yxy) - sceneb(pos-eps.yxy),\r\n\t    sceneb(pos+eps.yyx) - sceneb(pos-eps.yyx) );\r\n\treturn nr(nor);\r\n}\r\n\r\n\r\n\r\nfloat orenNayarDiffuse(\r\n  vec3 lightDirection,\r\n  vec3 viewDirection,\r\n  vec3 surfaceNormal,\r\n  float roughness,\r\n  float albedo) {\r\n  \r\n  float LdotV = dot(lightDirection, viewDirection);\r\n  float NdotL = dot(lightDirection, surfaceNormal);\r\n  float NdotV = dot(surfaceNormal, viewDirection);\r\n\r\n  float s = LdotV - NdotL * NdotV;\r\n  float t = mix(1., max(NdotL, NdotV), step(0., s));\r\n\r\n  float sigma2 = roughness * roughness;\r\n  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\r\n  float B = .45 * sigma2 / (sigma2 + .09);\r\n\r\n  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;\r\n}\r\n\r\nfloat fader = 1.0;\r\nfloat fader2 = 1.0;\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 res = iResolution.xy;\r\n    // pixel coordinates\r\n    vec2 uv = (-res + 2.*(fragCoord.xy))/res.y;\r\n    \r\n    vec3 direction = nr(vec3(uv, 0.));\r\n\r\n    t = iTime+32.;\r\n    \r\n    if (fly >= 1.) t-=31.;\r\n\r\n    float cz = t*5.9;\r\n    \r\n\r\n    float FOV = t*.1;\r\n        \r\n\t    vec3 camera_origin = vec3(0., 1., cz);\r\n\tvec3 lookAt = vec3(0.,1.,cz+1.);\r\n    \r\n    vec3 forward = nr(lookAt-camera_origin);\r\n    vec3 right = nr(vec3(forward.z, 0., -forward.x ));\r\n    vec3 up = nr(cross(forward,right));\r\n\r\n    \r\n    vec3 ro = camera_origin;\r\n    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);\r\n\r\n    vec2 result = raymarch(ro, rd);\r\n            \r\n    float fog = pow(1. / (1. + result.x), .2);\r\n    \r\n    vec3 icecol = vec3(.6,.6,1.0);\r\n\tvec3 materialColor = vec3(1.3-result.x*.01*.5,.9-cos(result.x*.1)*.5,1.*.5);\r\n\r\n\tmaterialColor -= vec3(.4,4.7,8.0)*(bump(hit)+bump(hit*.2*vec3(1.,1.,4.))*1.5);\r\n    vec3 intersection = ro + rd*result.x;\r\n    \r\n    vec3 nrml = normal(intersection);\r\n    vec3 light_dir = nr(vec3(sin(result.x*.1),.3,-1.+fly));\r\n    vec3 ref = reflect( rd, nrml );\r\n\t\r\n    if (t > 85.) { materialColor=mix(materialColor,icecol,clamp((t-85.)*0.2,0.,1.8)); }\r\n\r\n    float dom = smoothstep( -.1, .9, ref.y);\r\n    float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);\r\n\r\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,.3*fly,.7*fly)-result.y*.05;\r\n    \r\n    vec3 light_color = vec3(1.);\r\n    vec3 ambient_color = light_color;\r\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\r\n    vec3 outColor = diffuseLit*fog+dom*.2+spe*.6;\r\n\tfragColor = vec4(mix(vec3(diffuse),outColor,fader), 1.)*fader2;\r\n }","inputs":[],"outputs":[],"code":"float NEAR_CLIPPING_PLANE=.005;\r\nfloat FAR_CLIPPING_PLANE=1000.;\r\nint NUMBER_OF_MARCH_STEPS=500;\r\nfloat EPSILON=.1;\r\nfloat DISTANCE_BIAS=.2;\r\nfloat t = 0.;\r\n\r\nfloat fly = 1.;\r\nfloat sdSphere(vec3 p, float s)\r\n{\r\n\treturn length(p) - (s);\r\n}\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvoid r(inout vec3 pos) {\r\n    if (pos.z < FAR_CLIPPING_PLANE) {\r\n        pR(pos.yx,cos(pos.z*.1+pos.z*.1)+t);\r\n        pR(pos.xy,0.2*sin(pos.z*.2*t*.1));\r\n    }\r\n    else pR(pos.yx,cos(pos.z*.1)+t);\r\n    \r\n}\r\n\r\nvoid r2(inout vec3 pos) {\r\n   if (pos.z < 2800.+cos(pos.z*2.1+t*5.)*10.) pR(pos.yx,cos(pos.z*cos(t*.002+sin(pos.z*.001+abs(pos.y*.0001)))*.5)+t*.05);\r\n}\r\n\r\nvoid r3(inout vec3 pos) {\r\n   pR(pos.xy,sin(pos.z*cos(t*.002+sin(pos.z*.001+(pos.z*.01)))*.5)+t*.5);\r\n}\r\n\r\nfloat celli(in vec3 p){ p = fract(p)-.5; return dot(p, p); }\r\n\r\nfloat cellTile(in vec3 p){\r\n    vec4 d; \r\n    d.x = celli(p - vec3(.81, .62, .53));\r\n    p.xy = vec2(p.y-p.x, p.y + p.x)*.7071;\r\n    d.y = celli(p - vec3(.39, .2, .11));\r\n    p.yz = vec2(p.z-p.y, p.z + p.y)*.7071;\r\n    d.z = celli(p - vec3(.62, .24, .06));\r\n    p.xz = vec2(p.z-p.x, p.z + p.x)*.7071;\r\n    d.w = celli(p - vec3(.2, .82, .64));\r\n    d.xy = min(d.xz, d.yw);\r\n    return min(d.x, d.y)*2.66; \r\n}\r\n\r\nfloat hex(vec2 p) {\r\n    p.x *= 0.57735*2.;\r\n\tp.y += mod(floor(p.x), 2.)*.5;\r\n\tp = abs((mod(p, 1.) - .5));\r\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.) - 1.);\r\n}\r\n\r\nfloat cellTile2(in vec3 p){\r\n    vec4 d; \r\n    d.x = celli(p - vec3(.81, .62, .53));\r\n    p.xy = vec2(p.y-p.x, p.y + p.x)+hex(p.xy*0.2);\r\n    d.y = celli(p - vec3(.39, .2, .11));\r\n    p.yz = vec2(p.z-p.y, p.z + p.y)+hex(p.yz*0.2);\r\n    d.z = celli(p - vec3(.62, .24, .06));\r\n    p.xz = vec2(p.z-p.x, p.z + p.x)+hex(p.xz*0.2);\r\n    d.w = celli(p - vec3(.2, .82, .64));\r\n    d.xy = min(d.xz, d.yw);\r\n    return min(d.x, d.y)*.5; \r\n}\r\nfloat bump(vec3 pos) {\r\n    float re = 0.;\r\n\tre += cellTile2(pos*.25) * cellTile2(pos*1.1) * 3. + cellTile2(pos*1.2) * cellTile2(pos*4.4) * .5;\r\n    return re;\r\n}\r\nvec3 hit;\r\n\r\nfloat sp(vec3 opos, vec3 pos) {\r\n\treturn sdSphere(cos(opos*.2),1.1+cos(pos.z*.01+cos(pos.x*1.1)*.1)*.2)*3.91;\r\n}\r\n\r\nvoid rota(inout vec3 pos) {\r\n    if (fly == 1.) r(pos);\r\n    if (fly == 0.) r2(pos);\r\n    if (fly == 2.) r3(pos);\r\n}\r\n\r\nfloat scene1(vec3 pos)\r\n{\r\n\trota(pos);\r\n    float of = .3*sin(pos.z*5.5);\r\n\treturn sp(pos - vec3(of, -of, cos(pos.z)*.5),pos);\r\n}\r\n\r\nfloat scene2(vec3 pos)\r\n{\r\n    vec3 translate = vec3(-0.5*cos(pos.z*.01), -.2*sin(.005*pos.z*cos(pos.z*4.5+pos.z*.5+pos.z*5.)*.1), 0.);\r\n\trota(pos);\r\n    hit = pos;\r\n\treturn sp(pos - translate,pos);\r\n}\r\n\r\nfloat scene(vec3 pos) {\r\n\treturn min(scene1(pos),scene2(pos));\r\n}\r\n\r\nfloat sceneb(vec3 pos) {\r\n\treturn min(scene1(pos),scene2(pos))-bump(hit+cos(pos.z*.3)*3.)*1.5;\r\n}\r\n\r\nvec2 raymarch(vec3 position, vec3 direction)\r\n{\r\n    float total_distance = NEAR_CLIPPING_PLANE;\r\n    float acc = 0.;\r\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\r\n    {\r\n        vec3 pos = position + direction * total_distance;\r\n        float result = scene(pos);\r\n        acc+=cos(result*1.)*.05;\r\n\r\n        if(result < EPSILON)\r\n        {\r\n            return vec2(total_distance, acc);\r\n        }\r\n        \r\n        total_distance += result * DISTANCE_BIAS;\r\n        \r\n        \r\n        if(total_distance > FAR_CLIPPING_PLANE)\r\n            break;\r\n    }\r\n    return vec2(FAR_CLIPPING_PLANE, acc);\r\n}\r\n\r\nvec3 nr(vec3 n) {\r\n\treturn normalize(n);\r\n}\r\n\r\nvec3 normal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3(.3,0.,0.)*EPSILON;\r\n\tvec3 nor = vec3(\r\n\t    sceneb(pos+eps.xyy) - sceneb(pos-eps.xyy),\r\n\t    sceneb(pos+eps.yxy) - sceneb(pos-eps.yxy),\r\n\t    sceneb(pos+eps.yyx) - sceneb(pos-eps.yyx) );\r\n\treturn nr(nor);\r\n}\r\n\r\n\r\n\r\nfloat orenNayarDiffuse(\r\n  vec3 lightDirection,\r\n  vec3 viewDirection,\r\n  vec3 surfaceNormal,\r\n  float roughness,\r\n  float albedo) {\r\n  \r\n  float LdotV = dot(lightDirection, viewDirection);\r\n  float NdotL = dot(lightDirection, surfaceNormal);\r\n  float NdotV = dot(surfaceNormal, viewDirection);\r\n\r\n  float s = LdotV - NdotL * NdotV;\r\n  float t = mix(1., max(NdotL, NdotV), step(0., s));\r\n\r\n  float sigma2 = roughness * roughness;\r\n  float A = 1. + sigma2 * (albedo / (sigma2 + .13) + .5 / (sigma2 + .33));\r\n  float B = .45 * sigma2 / (sigma2 + .09);\r\n\r\n  return albedo * max(0., NdotL) * (A + B * s / t) / 3.14159;\r\n}\r\n\r\nfloat fader = 1.0;\r\nfloat fader2 = 1.0;\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 res = iResolution.xy;\r\n    // pixel coordinates\r\n    vec2 uv = (-res + 2.*(fragCoord.xy))/res.y;\r\n    \r\n    vec3 direction = nr(vec3(uv, 0.));\r\n\r\n    t = iTime+32.;\r\n    \r\n    if (fly >= 1.) t-=31.;\r\n\r\n    float cz = t*5.9;\r\n    \r\n\r\n    float FOV = t*.1;\r\n        \r\n\t    vec3 camera_origin = vec3(0., 1., cz);\r\n\tvec3 lookAt = vec3(0.,1.,cz+1.);\r\n    \r\n    vec3 forward = nr(lookAt-camera_origin);\r\n    vec3 right = nr(vec3(forward.z, 0., -forward.x ));\r\n    vec3 up = nr(cross(forward,right));\r\n\r\n    \r\n    vec3 ro = camera_origin;\r\n    vec3 rd = nr(forward + FOV*uv.x*right + FOV*uv.y*up);\r\n\r\n    vec2 result = raymarch(ro, rd);\r\n            \r\n    float fog = pow(1. / (1. + result.x), .2);\r\n    \r\n    vec3 icecol = vec3(.6,.6,1.0);\r\n\tvec3 materialColor = vec3(1.3-result.x*.01*.5,.9-cos(result.x*.1)*.5,1.*.5);\r\n\r\n\tmaterialColor -= vec3(.4,4.7,8.0)*(bump(hit)+bump(hit*.2*vec3(1.,1.,4.))*1.5);\r\n    vec3 intersection = ro + rd*result.x;\r\n    \r\n    vec3 nrml = normal(intersection);\r\n    vec3 light_dir = nr(vec3(sin(result.x*.1),.3,-1.+fly));\r\n    vec3 ref = reflect( rd, nrml );\r\n\t\r\n    if (t > 85.) { materialColor=mix(materialColor,icecol,clamp((t-85.)*0.2,0.,1.8)); }\r\n\r\n    float dom = smoothstep( -.1, .9, ref.y);\r\n    float spe = pow(clamp( dot( ref, light_dir ), 0., 1. ),32.);\r\n\r\n    float diffuse = orenNayarDiffuse(light_dir,rd,nrml,.3*fly,.7*fly)-result.y*.05;\r\n    \r\n    vec3 light_color = vec3(1.);\r\n    vec3 ambient_color = light_color;\r\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\r\n    vec3 outColor = diffuseLit*fog+dom*.2+spe*.6;\r\n\tfragColor = vec4(mix(vec3(diffuse),outColor,fader), 1.)*fader2;\r\n }","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\r\n{\r\n    float glow = 0.06 * iResolution.y;\r\n    float twopi = 6.28318530718;\r\n    float curve = 1.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 100.0 / iResolution.x * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.25 * vscale + iResolution.y / 2.0));\r\n    float i = clamp(curve, 0.0, 1.0);\r\n    i += clamp((glow + curve) / glow, 0.0, 1.0) * 0.4 ;\r\n    return i * color;\r\n}\r\n\r\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\r\n{\r\n    float theta = atan(iResolution.y / 2.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.13 * iResolution.x);\r\n\tfloat len = iResolution.y * (10.0 + sin(theta * 20.0 + float(int(iTime * 20.0)) * -35.0)) / 11.0;\r\n    float d = max(-0.6, 1.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 2.0) + pow(abs(iResolution.y / 2.0 - ((fragCoord.y - iResolution.y / 2.0) * 4.0 + iResolution.y / 2.0)), 2.0)) / len));\r\n    return vec3(d * (1.0 + sin(theta * 10.0 + floor(iTime * 20.0) * 10.77) * 0.5), d * (1.0 + -cos(theta * 8.0 - floor(iTime * 20.0) * 8.77) * 0.5), d * (1.0 + -sin(theta * 6.0 - floor(iTime * 20.0) * 134.77) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float timescale = 4.0;\r\n\tvec3 c = vec3(0, 0, 0);\r\n    c += Strand(fragCoord, vec3(1.0, 0, 0), 0.7934 + 1.0 + sin(iTime) * 30.0, 1.0, 0.16, 10.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 0.0), 0.645 + 1.0 + sin(iTime) * 30.0, 1.5, 0.2, 10.3 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 0.0, 1.0), 0.735 + 1.0 + sin(iTime) * 30.0, 1.3, 0.19, 8.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 1.0, 0.0), 0.9245 + 1.0 + sin(iTime) * 30.0, 1.6, 0.14, 12.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 1.0), 0.7234 + 1.0 + sin(iTime) * 30.0, 1.9, 0.23, 14.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 0.0, 1.0), 0.84525 + 1.0 + sin(iTime) * 30.0, 1.2, 0.18, 9.0 * timescale);\r\n    c += clamp(Muzzle(fragCoord, timescale), 0.0, 1.0);\r\n\tfragColor = vec4(c.r, c.g, c.b, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\r\n{\r\n    float glow = 0.06 * iResolution.y;\r\n    float twopi = 6.28318530718;\r\n    float curve = 1.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 100.0 / iResolution.x * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.25 * vscale + iResolution.y / 2.0));\r\n    float i = clamp(curve, 0.0, 1.0);\r\n    i += clamp((glow + curve) / glow, 0.0, 1.0) * 0.4 ;\r\n    return i * color;\r\n}\r\n\r\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\r\n{\r\n    float theta = atan(iResolution.y / 2.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.13 * iResolution.x);\r\n\tfloat len = iResolution.y * (10.0 + sin(theta * 20.0 + float(int(iTime * 20.0)) * -35.0)) / 11.0;\r\n    float d = max(-0.6, 1.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 2.0) + pow(abs(iResolution.y / 2.0 - ((fragCoord.y - iResolution.y / 2.0) * 4.0 + iResolution.y / 2.0)), 2.0)) / len));\r\n    return vec3(d * (1.0 + sin(theta * 10.0 + floor(iTime * 20.0) * 10.77) * 0.5), d * (1.0 + -cos(theta * 8.0 - floor(iTime * 20.0) * 8.77) * 0.5), d * (1.0 + -sin(theta * 6.0 - floor(iTime * 20.0) * 134.77) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float timescale = 4.0;\r\n\tvec3 c = vec3(0, 0, 0);\r\n    c += Strand(fragCoord, vec3(1.0, 0, 0), 0.7934 + 1.0 + sin(iTime) * 30.0, 1.0, 0.16, 10.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 0.0), 0.645 + 1.0 + sin(iTime) * 30.0, 1.5, 0.2, 10.3 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 0.0, 1.0), 0.735 + 1.0 + sin(iTime) * 30.0, 1.3, 0.19, 8.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 1.0, 0.0), 0.9245 + 1.0 + sin(iTime) * 30.0, 1.6, 0.14, 12.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 1.0), 0.7234 + 1.0 + sin(iTime) * 30.0, 1.9, 0.23, 14.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 0.0, 1.0), 0.84525 + 1.0 + sin(iTime) * 30.0, 1.2, 0.18, 9.0 * timescale);\r\n    c += clamp(Muzzle(fragCoord, timescale), 0.0, 1.0);\r\n\tfragColor = vec4(c.r, c.g, c.b, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Rainbow Laser Beam","id":"8165905b573a4c9ba1035abe1d5cb7e0","date":null,"viewed":0,"name":"Rainbow Laser Beam","description":"Need to dispatch some pesky enemies with love, grace, and style? I've got just the weapon for you!\nFirst shadertoy!\nNeeds a more laser-y sound for the muzzle/emitter. Maybe sound in stereo?\nhttps://www.shadertoy.com/view/XtBXW3","likes":0,"published":null,"tags":["2d"," beam"," rainbow"]},"ver":null,"info":{"Name":"Rainbow Laser Beam","id":"8165905b573a4c9ba1035abe1d5cb7e0","date":null,"viewed":0,"name":"Rainbow Laser Beam","description":"Need to dispatch some pesky enemies with love, grace, and style? I've got just the weapon for you!\nFirst shadertoy!\nNeeds a more laser-y sound for the muzzle/emitter. Maybe sound in stereo?\nhttps://www.shadertoy.com/view/XtBXW3","likes":0,"published":null,"tags":["2d"," beam"," rainbow"]},"renderpass":[{"Code":"vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\r\n{\r\n    float glow = 0.06 * iResolution.y;\r\n    float twopi = 6.28318530718;\r\n    float curve = 1.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 100.0 / iResolution.x * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.25 * vscale + iResolution.y / 2.0));\r\n    float i = clamp(curve, 0.0, 1.0);\r\n    i += clamp((glow + curve) / glow, 0.0, 1.0) * 0.4 ;\r\n    return i * color;\r\n}\r\n\r\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\r\n{\r\n    float theta = atan(iResolution.y / 2.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.13 * iResolution.x);\r\n\tfloat len = iResolution.y * (10.0 + sin(theta * 20.0 + float(int(iTime * 20.0)) * -35.0)) / 11.0;\r\n    float d = max(-0.6, 1.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 2.0) + pow(abs(iResolution.y / 2.0 - ((fragCoord.y - iResolution.y / 2.0) * 4.0 + iResolution.y / 2.0)), 2.0)) / len));\r\n    return vec3(d * (1.0 + sin(theta * 10.0 + floor(iTime * 20.0) * 10.77) * 0.5), d * (1.0 + -cos(theta * 8.0 - floor(iTime * 20.0) * 8.77) * 0.5), d * (1.0 + -sin(theta * 6.0 - floor(iTime * 20.0) * 134.77) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float timescale = 4.0;\r\n\tvec3 c = vec3(0, 0, 0);\r\n    c += Strand(fragCoord, vec3(1.0, 0, 0), 0.7934 + 1.0 + sin(iTime) * 30.0, 1.0, 0.16, 10.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 0.0), 0.645 + 1.0 + sin(iTime) * 30.0, 1.5, 0.2, 10.3 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 0.0, 1.0), 0.735 + 1.0 + sin(iTime) * 30.0, 1.3, 0.19, 8.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 1.0, 0.0), 0.9245 + 1.0 + sin(iTime) * 30.0, 1.6, 0.14, 12.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 1.0), 0.7234 + 1.0 + sin(iTime) * 30.0, 1.9, 0.23, 14.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 0.0, 1.0), 0.84525 + 1.0 + sin(iTime) * 30.0, 1.2, 0.18, 9.0 * timescale);\r\n    c += clamp(Muzzle(fragCoord, timescale), 0.0, 1.0);\r\n\tfragColor = vec4(c.r, c.g, c.b, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\r\n{\r\n    float glow = 0.06 * iResolution.y;\r\n    float twopi = 6.28318530718;\r\n    float curve = 1.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 100.0 / iResolution.x * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.25 * vscale + iResolution.y / 2.0));\r\n    float i = clamp(curve, 0.0, 1.0);\r\n    i += clamp((glow + curve) / glow, 0.0, 1.0) * 0.4 ;\r\n    return i * color;\r\n}\r\n\r\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\r\n{\r\n    float theta = atan(iResolution.y / 2.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.13 * iResolution.x);\r\n\tfloat len = iResolution.y * (10.0 + sin(theta * 20.0 + float(int(iTime * 20.0)) * -35.0)) / 11.0;\r\n    float d = max(-0.6, 1.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 2.0) + pow(abs(iResolution.y / 2.0 - ((fragCoord.y - iResolution.y / 2.0) * 4.0 + iResolution.y / 2.0)), 2.0)) / len));\r\n    return vec3(d * (1.0 + sin(theta * 10.0 + floor(iTime * 20.0) * 10.77) * 0.5), d * (1.0 + -cos(theta * 8.0 - floor(iTime * 20.0) * 8.77) * 0.5), d * (1.0 + -sin(theta * 6.0 - floor(iTime * 20.0) * 134.77) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float timescale = 4.0;\r\n\tvec3 c = vec3(0, 0, 0);\r\n    c += Strand(fragCoord, vec3(1.0, 0, 0), 0.7934 + 1.0 + sin(iTime) * 30.0, 1.0, 0.16, 10.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 0.0), 0.645 + 1.0 + sin(iTime) * 30.0, 1.5, 0.2, 10.3 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 0.0, 1.0), 0.735 + 1.0 + sin(iTime) * 30.0, 1.3, 0.19, 8.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 1.0, 0.0), 0.9245 + 1.0 + sin(iTime) * 30.0, 1.6, 0.14, 12.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 1.0), 0.7234 + 1.0 + sin(iTime) * 30.0, 1.9, 0.23, 14.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 0.0, 1.0), 0.84525 + 1.0 + sin(iTime) * 30.0, 1.2, 0.18, 9.0 * timescale);\r\n    c += clamp(Muzzle(fragCoord, timescale), 0.0, 1.0);\r\n\tfragColor = vec4(c.r, c.g, c.b, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Raymarch in Raymarch","id":"wllXWH","date":"0","viewed":0,"name":"Raymarch in Raymarch","description":"Raymarch tutorial","likes":0,"published":"Private","tags":["raymarch"]},"ver":"0.1","info":{"Name":"Raymarch in Raymarch","id":"wllXWH","date":"0","viewed":0,"name":"Raymarch in Raymarch","description":"Raymarch tutorial","likes":0,"published":"Private","tags":["raymarch"]},"renderpass":[{"Code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"RayMarch-Primitives","id":"WllGRX","date":"0","viewed":0,"name":"RayMarch-Primitives","description":"RayMarch-Primitives","likes":0,"published":"Private","tags":["primitives"]},"ver":"0.1","info":{"Name":"RayMarch-Primitives","id":"WllGRX","date":"0","viewed":0,"name":"RayMarch-Primitives","description":"RayMarch-Primitives","likes":0,"published":"Private","tags":["primitives"]},"renderpass":[{"Code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Reflect Refract TIR Fresnel RayT","id":"ttX3Rs","date":"0","viewed":0,"name":"Reflect Refract TIR Fresnel RayT","description":"A raytracer to go along with a blog post about reflection, refraction, total internal reflection and fresnel.\r\nDrag mouse for orbit camera.\r\nPlay with #define parameters.\r\nhttp://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-inte\r\nhttps://www.shadertoy.com/view/4tyXDR","likes":0,"published":"Private","tags":["reflection"," refraction"," raytrace"," fresnel"," tir"]},"ver":"0.1","info":{"Name":"Reflect Refract TIR Fresnel RayT","id":"ttX3Rs","date":"0","viewed":0,"name":"Reflect Refract TIR Fresnel RayT","description":"A raytracer to go along with a blog post about reflection, refraction, total internal reflection and fresnel.\r\nDrag mouse for orbit camera.\r\nPlay with #define parameters.\r\nhttp://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-inte\r\nhttps://www.shadertoy.com/view/4tyXDR","likes":0,"published":"Private","tags":["reflection"," refraction"," raytrace"," fresnel"," tir"]},"renderpass":[{"Code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// glass refraction: ref: http://www.koppglass.com/blog/optical-properties-of-glass-how-light-and-glass-interact/\r\n//                        https://en.wikipedia.org/wiki/Cauchy's_equation\r\n\r\n#define sqr(x) ( (x)*(x) )\r\n\r\n// perceived colors: from https://www.shadertoy.com/view/llKSDz\r\n//                   based on h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n\r\n// Spectrum to xyz approx function from Sloan\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n   vec2 R = iResolution.xy;\r\n\tU /= R.x;\r\n                                      // various kind of glass coefficients\r\n\tfloat //B = 1.458, C = 0.00354;   //  n ~ B + C/lambda^2  https://en.wikipedia.org/wiki/Cauchy's_equation\r\n            B = 1.5046,C = 0.00420;\r\n          //B = 1.522, C = 0.00459;\r\n          //B = 1.569, C = 0.00531;\r\n          //B = 1.670, C = 0.00743;\r\n          //B = 1.728, C = 0.01342;\r\n    \r\n#if 0  // test: refraction index curve(lambda)   \r\n    O = vec4( ( B+C/sqr(0.4 +.35*U.x) -1.5 )/.05  < U.y );\r\n    O.r += .01/fract(100.*(U.y*.05+1.5));\r\n    return;\r\n#endif\r\n    \r\n#if 0  // test: perceived range of colors\r\n    l = 400. + 350.*U.x; // in nm\r\n    O = vec4( pow (.35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(l))), vec3(1./2.2) ), 1);\r\n    return;\r\n#endif\r\n\r\n    U -= .2;\r\n    float     a = atan(U.x,U.y), n,l,\r\n        a_glass = .72 - .05*(.5-.5*cos(.3*(iTime+2.5)));\r\n\r\n    if (U.y<0.) // glass part\r\n        { O = vec4(.5 + smoothstep(1./length(U)/R.x,.0,abs(3.1416+a-a_glass))); return; }\r\n\r\n    O -= O;\r\n    \r\n #define N 1.\r\n    for (float x = 0.; x<N; x++) { // optional loop to integrate on a thick source\r\n         a = atan(U.x+ .1*x/N,U.y);\r\n         n = sin(a)/sin(a_glass); // Snell-Descartes: 1.sin(a_air) = n_glass.sin(a_glass),\r\n         l = sqrt(C/(n-B));       // in micron\r\n\r\n         O += vec4( .35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(1e3*l))), 1);\r\n    }\r\n    O = vec4( pow (O/N, vec4(1./2.2) ) ); // gamma correction\r\n}","inputs":[],"outputs":[],"code":"// glass refraction: ref: http://www.koppglass.com/blog/optical-properties-of-glass-how-light-and-glass-interact/\r\n//                        https://en.wikipedia.org/wiki/Cauchy's_equation\r\n\r\n#define sqr(x) ( (x)*(x) )\r\n\r\n// perceived colors: from https://www.shadertoy.com/view/llKSDz\r\n//                   based on h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n\r\n// Spectrum to xyz approx function from Sloan\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n   vec2 R = iResolution.xy;\r\n\tU /= R.x;\r\n                                      // various kind of glass coefficients\r\n\tfloat //B = 1.458, C = 0.00354;   //  n ~ B + C/lambda^2  https://en.wikipedia.org/wiki/Cauchy's_equation\r\n            B = 1.5046,C = 0.00420;\r\n          //B = 1.522, C = 0.00459;\r\n          //B = 1.569, C = 0.00531;\r\n          //B = 1.670, C = 0.00743;\r\n          //B = 1.728, C = 0.01342;\r\n    \r\n#if 0  // test: refraction index curve(lambda)   \r\n    O = vec4( ( B+C/sqr(0.4 +.35*U.x) -1.5 )/.05  < U.y );\r\n    O.r += .01/fract(100.*(U.y*.05+1.5));\r\n    return;\r\n#endif\r\n    \r\n#if 0  // test: perceived range of colors\r\n    l = 400. + 350.*U.x; // in nm\r\n    O = vec4( pow (.35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(l))), vec3(1./2.2) ), 1);\r\n    return;\r\n#endif\r\n\r\n    U -= .2;\r\n    float     a = atan(U.x,U.y), n,l,\r\n        a_glass = .72 - .05*(.5-.5*cos(.3*(iTime+2.5)));\r\n\r\n    if (U.y<0.) // glass part\r\n        { O = vec4(.5 + smoothstep(1./length(U)/R.x,.0,abs(3.1416+a-a_glass))); return; }\r\n\r\n    O -= O;\r\n    \r\n #define N 1.\r\n    for (float x = 0.; x<N; x++) { // optional loop to integrate on a thick source\r\n         a = atan(U.x+ .1*x/N,U.y);\r\n         n = sin(a)/sin(a_glass); // Snell-Descartes: 1.sin(a_air) = n_glass.sin(a_glass),\r\n         l = sqrt(C/(n-B));       // in micron\r\n\r\n         O += vec4( .35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(1e3*l))), 1);\r\n    }\r\n    O = vec4( pow (O/N, vec4(1./2.2) ) ); // gamma correction\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"refraction (physical+perceptual) ","id":"2574f4a16f004f398153c065cbc66511","date":null,"viewed":0,"name":"refraction (physical+perceptual) ","description":"rainbow caused by glass-air interface, accounting for non-constant non-linear refractive index and perceived colors. \nhttps://www.shadertoy.com/view/llVSDz","likes":0,"published":null,"tags":["refraction"," prism"," rainbow"," dispersion"," wavelength"," cie"," xyzcolorspace"]},"ver":null,"info":{"Name":"refraction (physical+perceptual) ","id":"2574f4a16f004f398153c065cbc66511","date":null,"viewed":0,"name":"refraction (physical+perceptual) ","description":"rainbow caused by glass-air interface, accounting for non-constant non-linear refractive index and perceived colors. \nhttps://www.shadertoy.com/view/llVSDz","likes":0,"published":null,"tags":["refraction"," prism"," rainbow"," dispersion"," wavelength"," cie"," xyzcolorspace"]},"renderpass":[{"Code":"// glass refraction: ref: http://www.koppglass.com/blog/optical-properties-of-glass-how-light-and-glass-interact/\r\n//                        https://en.wikipedia.org/wiki/Cauchy's_equation\r\n\r\n#define sqr(x) ( (x)*(x) )\r\n\r\n// perceived colors: from https://www.shadertoy.com/view/llKSDz\r\n//                   based on h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n\r\n// Spectrum to xyz approx function from Sloan\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n   vec2 R = iResolution.xy;\r\n\tU /= R.x;\r\n                                      // various kind of glass coefficients\r\n\tfloat //B = 1.458, C = 0.00354;   //  n ~ B + C/lambda^2  https://en.wikipedia.org/wiki/Cauchy's_equation\r\n            B = 1.5046,C = 0.00420;\r\n          //B = 1.522, C = 0.00459;\r\n          //B = 1.569, C = 0.00531;\r\n          //B = 1.670, C = 0.00743;\r\n          //B = 1.728, C = 0.01342;\r\n    \r\n#if 0  // test: refraction index curve(lambda)   \r\n    O = vec4( ( B+C/sqr(0.4 +.35*U.x) -1.5 )/.05  < U.y );\r\n    O.r += .01/fract(100.*(U.y*.05+1.5));\r\n    return;\r\n#endif\r\n    \r\n#if 0  // test: perceived range of colors\r\n    l = 400. + 350.*U.x; // in nm\r\n    O = vec4( pow (.35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(l))), vec3(1./2.2) ), 1);\r\n    return;\r\n#endif\r\n\r\n    U -= .2;\r\n    float     a = atan(U.x,U.y), n,l,\r\n        a_glass = .72 - .05*(.5-.5*cos(.3*(iTime+2.5)));\r\n\r\n    if (U.y<0.) // glass part\r\n        { O = vec4(.5 + smoothstep(1./length(U)/R.x,.0,abs(3.1416+a-a_glass))); return; }\r\n\r\n    O -= O;\r\n    \r\n #define N 1.\r\n    for (float x = 0.; x<N; x++) { // optional loop to integrate on a thick source\r\n         a = atan(U.x+ .1*x/N,U.y);\r\n         n = sin(a)/sin(a_glass); // Snell-Descartes: 1.sin(a_air) = n_glass.sin(a_glass),\r\n         l = sqrt(C/(n-B));       // in micron\r\n\r\n         O += vec4( .35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(1e3*l))), 1);\r\n    }\r\n    O = vec4( pow (O/N, vec4(1./2.2) ) ); // gamma correction\r\n}","inputs":[],"outputs":[],"code":"// glass refraction: ref: http://www.koppglass.com/blog/optical-properties-of-glass-how-light-and-glass-interact/\r\n//                        https://en.wikipedia.org/wiki/Cauchy's_equation\r\n\r\n#define sqr(x) ( (x)*(x) )\r\n\r\n// perceived colors: from https://www.shadertoy.com/view/llKSDz\r\n//                   based on h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n\r\n// Spectrum to xyz approx function from Sloan\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n   vec2 R = iResolution.xy;\r\n\tU /= R.x;\r\n                                      // various kind of glass coefficients\r\n\tfloat //B = 1.458, C = 0.00354;   //  n ~ B + C/lambda^2  https://en.wikipedia.org/wiki/Cauchy's_equation\r\n            B = 1.5046,C = 0.00420;\r\n          //B = 1.522, C = 0.00459;\r\n          //B = 1.569, C = 0.00531;\r\n          //B = 1.670, C = 0.00743;\r\n          //B = 1.728, C = 0.01342;\r\n    \r\n#if 0  // test: refraction index curve(lambda)   \r\n    O = vec4( ( B+C/sqr(0.4 +.35*U.x) -1.5 )/.05  < U.y );\r\n    O.r += .01/fract(100.*(U.y*.05+1.5));\r\n    return;\r\n#endif\r\n    \r\n#if 0  // test: perceived range of colors\r\n    l = 400. + 350.*U.x; // in nm\r\n    O = vec4( pow (.35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(l))), vec3(1./2.2) ), 1);\r\n    return;\r\n#endif\r\n\r\n    U -= .2;\r\n    float     a = atan(U.x,U.y), n,l,\r\n        a_glass = .72 - .05*(.5-.5*cos(.3*(iTime+2.5)));\r\n\r\n    if (U.y<0.) // glass part\r\n        { O = vec4(.5 + smoothstep(1./length(U)/R.x,.0,abs(3.1416+a-a_glass))); return; }\r\n\r\n    O -= O;\r\n    \r\n #define N 1.\r\n    for (float x = 0.; x<N; x++) { // optional loop to integrate on a thick source\r\n         a = atan(U.x+ .1*x/N,U.y);\r\n         n = sin(a)/sin(a_glass); // Snell-Descartes: 1.sin(a_air) = n_glass.sin(a_glass),\r\n         l = sqrt(C/(n-B));       // in micron\r\n\r\n         O += vec4( .35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(1e3*l))), 1);\r\n    }\r\n    O = vec4( pow (O/N, vec4(1./2.2) ) ); // gamma correction\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// ***********************************************************\r\n// Alcatraz / Rhodium 4k Intro Fractalscape\r\n// by Jochen \"Virgill\" Feldk\u00F6tter\r\n//\r\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\r\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\r\n// ***********************************************************\r\n\r\nint meep =0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// \trotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n// \t3D noise function (IQ)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n    p-=ip; \r\n    vec3 s=vec3(7,157,113);\r\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p=p*p*(3.-2.*p); \r\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\r\n    h.xy=mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\n// \tkifs fractal (shane)\r\nfloat kifs(vec3 p)\r\n{\r\n    vec3 offs = vec3(1, .75, .5); \r\n    vec2 a = sin(vec2(0, 1.57) + 1.57/2.);\r\n    vec2 b = sin(vec2(0, 1.57) + 1.57/4.);\r\n    float s = 5.;// scale factor\r\n    float d = 1e5; // distance\r\n    p  = abs(fract(p*.5)*2. - 1.);\r\n    float amp = 1./s; \r\n    for(int i=0; i<5; i++)\r\n    {\r\n        // rotation\r\n       \tp.xy=mat2(a.y,-a.x,a)*p.xy;\r\n       \tp.yz=mat2(b.y,-b.x,b)*p.yz;\r\n        p=abs(p);\r\n    \tif (p.x<p.y)p.xy=p.yx;\r\n        if (p.x<p.z)p.xz=p.zx;\r\n        if (p.y<p.z)p.yz=p.zy;\r\n\t\tp = p*s + offs*(1. - s);\r\n        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);\r\n        p=abs(p);\r\n        d = min(d, max(max(p.x, p.y), p.z)*amp);\r\n        amp /= s; \r\n        // abimation\r\n        if(i==1&&p.x>(9.+1.*sin(0.209*iTime+1.))) meep = 1;\r\n    }\r\n \treturn d - 0.29;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\t\r\n// \tfractalscape \r\n    float f = -0.05-kifs(.4*p);\r\n\tif(meep==0) f+=0.002*noise(p*70.);\r\n\treturn f;\r\n}\r\n\r\n//\tnormal calculation\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps=0.0001;\r\n\tfloat d=map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\n// \tstandard sphere tracing inside and outside\r\nfloat castRayx(vec3 ro,vec3 rd) \r\n{\r\n    float function_sign=(map(ro)<0.)?-1.:1.;\r\n    float precis=.0001;\r\n    float h=precis*2.;\r\n    float t=0.;\r\n\tfor(int i=0;i<120;i++) \r\n\t{\r\n        if(abs(h)<precis||t>12.)break;\r\n\t\th=function_sign*map(ro+rd*t);\r\n        t+=h;\r\n\t}\r\n    return t;\r\n}\r\n\r\n// \trefraction\r\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\r\n{\r\n    float h=0.;\r\n    t2=2.;\r\n\tvec3 dir2=refract(dir,nor,angle);  \r\n \tfor(int i=0;i<50;i++) \r\n\t{\r\n\t\tif(abs(h)>3.) break;\r\n\t\th=map(pos+dir2*t2);\r\n\t\tt2-=h;\r\n\t}\r\n    nor2=calcNormal(pos+dir2*t2);\r\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\r\n}\r\n\r\n//\tsoftshadow (IQ)\r\nfloat softshadow(vec3 ro,vec3 rd) \r\n{\r\n    float sh=1.;\r\n    float t=.02;\r\n    float h=.0;\r\n    for(int i=0;i<22;i++)  \r\n\t{\r\n        if(t>20.)continue;\r\n        h=map(ro+rd*t);\r\n        sh=min(sh,4.*h/t);\r\n        t+=h;\r\n    }\r\n    return sh;\r\n}\r\n\r\n//\tmain function\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{    \r\n    \r\n    float bounce=abs(fract(0.05*iTime)-.5)*20.; // triangle function\r\n    meep=0;\r\n\tvec2 uv=gl_FragCoord.xy/iResolution.xy; \r\n    vec2 p=uv*2.-1.;\r\n   \r\n// \tbouncy cam every 10 seconds\r\n    float wobble=(fract(.1*(iTime-1.))>=0.9)?fract(-iTime)*0.1*sin(30.*iTime):0.;\r\n    \r\n//  camera    \r\n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, iResolution.y));\r\n//\torg (Left-Right,Down-Up,Near-Far)  \r\n    vec3 org = vec3(0,2.*wobble,-3.);  \r\n    \r\n// \tcam fractalscape\r\n   \tvec2 m = sin(vec2(0, 1.57) + iTime/8.);\r\n   \tdir.xy = mat2(m.y, -m.x, m)*dir.xy;\r\n   \tdir.xz = mat2(m.y, -m.x, m)*dir.xz;\r\n   \torg = vec3(0, 2.+wobble, 0.+8.*sin(bounce/3.));\r\n\r\n// \tstandard sphere tracing:\r\n    vec3 color = vec3(0.);\r\n    vec3 color2 = vec3(0.);\r\n    float t=castRayx(org,dir);\r\n\tvec3 pos=org+dir*t;\r\n\tvec3 nor=calcNormal(pos);\r\n\r\n// \tlighting:\r\n    vec3 lig=normalize(-pos);\r\n\r\n//\tscene depth    \r\n    float depth=clamp((1.-0.09*t),0.,1.);\r\n    vec3 pos2,nor2 =  vec3(0.);\r\n    if(t<12.0)\r\n    {\r\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.));\r\n    \tcolor2 *=clamp(softshadow(pos,lig),0.,1.);  // shadow            \t\r\n\r\n        if(meep==1) \t\t\t\t\t\t\t\t// refraction\r\n        {   \r\n        \tfloat t2;\r\n\t\t\tcolor2.r +=refr(pos,lig,dir,nor,0.91, t2, nor2)*depth;\r\n       \t\tcolor2.g +=refr(pos,lig,dir,nor,0.90, t2, nor2)*depth;\r\n       \t\tcolor2.b +=refr(pos,lig,dir,nor,0.89, t2, nor2)*depth;\r\n   \t\t\tcolor2-=clamp(.1*t2,0.,1.);\t\t\t\t// inner intensity loss\r\n        }\r\n\t}      \r\n    float tmp = 0.;\r\n    float T = 1.;\r\n\r\n//\tanimation of glow intensity    \r\n    float intensity = 0.1*-sin(.209*iTime+1.)+0.05; \r\n\tfor(int i=0; i<128; i++)\r\n\t{\r\n    \tif (i<int(1.*(t+110.))) continue;// intensity damping\r\n        float density = 0.; float nebula = noise(org+bounce);\r\n        \r\n        density=(meep==1)?intensity-map(org+.5*nor2)*nebula:.7*intensity-map(org)*nebula;\r\n\t\tif(density>0.)\r\n\t\t{\r\n\t\t\ttmp = density / 128.;\r\n            T *= 1. -tmp * 100.;\r\n\t\t\tif( T <= 0.) break;\r\n\t\t}\r\n\t\torg += dir*0.078;\r\n    }    \r\n\r\n\tvec3 basecol=vec3(1./16.,.25,1.);\t\t\t\t\r\n    T=clamp(T,0.,1.5); \r\n    color += basecol* exp(4.*(0.5-T) - 0.8);\r\n    color2*=depth;\r\n    color2+= (1.-depth)*noise(6.*dir+0.3*iTime)*.1;\t// subtle mist\r\n\r\n    \r\n//\tscene depth included in alpha channel\r\n    fragColor = vec4(vec3(1.*color+0.8*color2)*1.3,abs(0.67-depth)*2.+4.*wobble);\r\n}\r\n\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"// ***********************************************************\r\n// Alcatraz / Rhodium 4k Intro Fractalscape\r\n// by Jochen \"Virgill\" Feldk\u00F6tter\r\n//\r\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\r\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\r\n// ***********************************************************\r\n\r\nint meep =0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// \trotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n// \t3D noise function (IQ)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n    p-=ip; \r\n    vec3 s=vec3(7,157,113);\r\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p=p*p*(3.-2.*p); \r\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\r\n    h.xy=mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\n// \tkifs fractal (shane)\r\nfloat kifs(vec3 p)\r\n{\r\n    vec3 offs = vec3(1, .75, .5); \r\n    vec2 a = sin(vec2(0, 1.57) + 1.57/2.);\r\n    vec2 b = sin(vec2(0, 1.57) + 1.57/4.);\r\n    float s = 5.;// scale factor\r\n    float d = 1e5; // distance\r\n    p  = abs(fract(p*.5)*2. - 1.);\r\n    float amp = 1./s; \r\n    for(int i=0; i<5; i++)\r\n    {\r\n        // rotation\r\n       \tp.xy=mat2(a.y,-a.x,a)*p.xy;\r\n       \tp.yz=mat2(b.y,-b.x,b)*p.yz;\r\n        p=abs(p);\r\n    \tif (p.x<p.y)p.xy=p.yx;\r\n        if (p.x<p.z)p.xz=p.zx;\r\n        if (p.y<p.z)p.yz=p.zy;\r\n\t\tp = p*s + offs*(1. - s);\r\n        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);\r\n        p=abs(p);\r\n        d = min(d, max(max(p.x, p.y), p.z)*amp);\r\n        amp /= s; \r\n        // abimation\r\n        if(i==1&&p.x>(9.+1.*sin(0.209*iTime+1.))) meep = 1;\r\n    }\r\n \treturn d - 0.29;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\t\r\n// \tfractalscape \r\n    float f = -0.05-kifs(.4*p);\r\n\tif(meep==0) f+=0.002*noise(p*70.);\r\n\treturn f;\r\n}\r\n\r\n//\tnormal calculation\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps=0.0001;\r\n\tfloat d=map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\n// \tstandard sphere tracing inside and outside\r\nfloat castRayx(vec3 ro,vec3 rd) \r\n{\r\n    float function_sign=(map(ro)<0.)?-1.:1.;\r\n    float precis=.0001;\r\n    float h=precis*2.;\r\n    float t=0.;\r\n\tfor(int i=0;i<120;i++) \r\n\t{\r\n        if(abs(h)<precis||t>12.)break;\r\n\t\th=function_sign*map(ro+rd*t);\r\n        t+=h;\r\n\t}\r\n    return t;\r\n}\r\n\r\n// \trefraction\r\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\r\n{\r\n    float h=0.;\r\n    t2=2.;\r\n\tvec3 dir2=refract(dir,nor,angle);  \r\n \tfor(int i=0;i<50;i++) \r\n\t{\r\n\t\tif(abs(h)>3.) break;\r\n\t\th=map(pos+dir2*t2);\r\n\t\tt2-=h;\r\n\t}\r\n    nor2=calcNormal(pos+dir2*t2);\r\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\r\n}\r\n\r\n//\tsoftshadow (IQ)\r\nfloat softshadow(vec3 ro,vec3 rd) \r\n{\r\n    float sh=1.;\r\n    float t=.02;\r\n    float h=.0;\r\n    for(int i=0;i<22;i++)  \r\n\t{\r\n        if(t>20.)continue;\r\n        h=map(ro+rd*t);\r\n        sh=min(sh,4.*h/t);\r\n        t+=h;\r\n    }\r\n    return sh;\r\n}\r\n\r\n//\tmain function\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{    \r\n    \r\n    float bounce=abs(fract(0.05*iTime)-.5)*20.; // triangle function\r\n    meep=0;\r\n\tvec2 uv=gl_FragCoord.xy/iResolution.xy; \r\n    vec2 p=uv*2.-1.;\r\n   \r\n// \tbouncy cam every 10 seconds\r\n    float wobble=(fract(.1*(iTime-1.))>=0.9)?fract(-iTime)*0.1*sin(30.*iTime):0.;\r\n    \r\n//  camera    \r\n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, iResolution.y));\r\n//\torg (Left-Right,Down-Up,Near-Far)  \r\n    vec3 org = vec3(0,2.*wobble,-3.);  \r\n    \r\n// \tcam fractalscape\r\n   \tvec2 m = sin(vec2(0, 1.57) + iTime/8.);\r\n   \tdir.xy = mat2(m.y, -m.x, m)*dir.xy;\r\n   \tdir.xz = mat2(m.y, -m.x, m)*dir.xz;\r\n   \torg = vec3(0, 2.+wobble, 0.+8.*sin(bounce/3.));\r\n\r\n// \tstandard sphere tracing:\r\n    vec3 color = vec3(0.);\r\n    vec3 color2 = vec3(0.);\r\n    float t=castRayx(org,dir);\r\n\tvec3 pos=org+dir*t;\r\n\tvec3 nor=calcNormal(pos);\r\n\r\n// \tlighting:\r\n    vec3 lig=normalize(-pos);\r\n\r\n//\tscene depth    \r\n    float depth=clamp((1.-0.09*t),0.,1.);\r\n    vec3 pos2,nor2 =  vec3(0.);\r\n    if(t<12.0)\r\n    {\r\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.));\r\n    \tcolor2 *=clamp(softshadow(pos,lig),0.,1.);  // shadow            \t\r\n\r\n        if(meep==1) \t\t\t\t\t\t\t\t// refraction\r\n        {   \r\n        \tfloat t2;\r\n\t\t\tcolor2.r +=refr(pos,lig,dir,nor,0.91, t2, nor2)*depth;\r\n       \t\tcolor2.g +=refr(pos,lig,dir,nor,0.90, t2, nor2)*depth;\r\n       \t\tcolor2.b +=refr(pos,lig,dir,nor,0.89, t2, nor2)*depth;\r\n   \t\t\tcolor2-=clamp(.1*t2,0.,1.);\t\t\t\t// inner intensity loss\r\n        }\r\n\t}      \r\n    float tmp = 0.;\r\n    float T = 1.;\r\n\r\n//\tanimation of glow intensity    \r\n    float intensity = 0.1*-sin(.209*iTime+1.)+0.05; \r\n\tfor(int i=0; i<128; i++)\r\n\t{\r\n    \tif (i<int(1.*(t+110.))) continue;// intensity damping\r\n        float density = 0.; float nebula = noise(org+bounce);\r\n        \r\n        density=(meep==1)?intensity-map(org+.5*nor2)*nebula:.7*intensity-map(org)*nebula;\r\n\t\tif(density>0.)\r\n\t\t{\r\n\t\t\ttmp = density / 128.;\r\n            T *= 1. -tmp * 100.;\r\n\t\t\tif( T <= 0.) break;\r\n\t\t}\r\n\t\torg += dir*0.078;\r\n    }    \r\n\r\n\tvec3 basecol=vec3(1./16.,.25,1.);\t\t\t\t\r\n    T=clamp(T,0.,1.5); \r\n    color += basecol* exp(4.*(0.5-T) - 0.8);\r\n    color2*=depth;\r\n    color2+= (1.-depth)*noise(6.*dir+0.3*iTime)*.1;\t// subtle mist\r\n\r\n    \r\n//\tscene depth included in alpha channel\r\n    fragColor = vec4(vec3(1.*color+0.8*color2)*1.3,abs(0.67-depth)*2.+4.*wobble);\r\n}\r\n\r\n\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Rhodium Fractalscape","id":"989f5422d3e0476a9816b9e57fdc38b0","date":null,"viewed":0,"name":"Rhodium Fractalscape","description":"Fractalscape effect from Rhodium 4k Intro\n4kb executable: http://www.pouet.net/prod.php?which=68239\nhttps://www.youtube.com/watch?v=YK7fbtQw3ZU\nhttps://www.shadertoy.com/view/ltKGzc","likes":0,"published":null,"tags":["demoscene"," dof"," spheretracing"," kifs"," colorsplit"," crystal"]},"ver":null,"info":{"Name":"Rhodium Fractalscape","id":"989f5422d3e0476a9816b9e57fdc38b0","date":null,"viewed":0,"name":"Rhodium Fractalscape","description":"Fractalscape effect from Rhodium 4k Intro\n4kb executable: http://www.pouet.net/prod.php?which=68239\nhttps://www.youtube.com/watch?v=YK7fbtQw3ZU\nhttps://www.shadertoy.com/view/ltKGzc","likes":0,"published":null,"tags":["demoscene"," dof"," spheretracing"," kifs"," colorsplit"," crystal"]},"renderpass":[{"Code":"// ***********************************************************\r\n// Alcatraz / Rhodium 4k Intro Fractalscape\r\n// by Jochen \"Virgill\" Feldk\u00F6tter\r\n//\r\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\r\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\r\n// ***********************************************************\r\n\r\nint meep =0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// \trotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n// \t3D noise function (IQ)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n    p-=ip; \r\n    vec3 s=vec3(7,157,113);\r\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p=p*p*(3.-2.*p); \r\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\r\n    h.xy=mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\n// \tkifs fractal (shane)\r\nfloat kifs(vec3 p)\r\n{\r\n    vec3 offs = vec3(1, .75, .5); \r\n    vec2 a = sin(vec2(0, 1.57) + 1.57/2.);\r\n    vec2 b = sin(vec2(0, 1.57) + 1.57/4.);\r\n    float s = 5.;// scale factor\r\n    float d = 1e5; // distance\r\n    p  = abs(fract(p*.5)*2. - 1.);\r\n    float amp = 1./s; \r\n    for(int i=0; i<5; i++)\r\n    {\r\n        // rotation\r\n       \tp.xy=mat2(a.y,-a.x,a)*p.xy;\r\n       \tp.yz=mat2(b.y,-b.x,b)*p.yz;\r\n        p=abs(p);\r\n    \tif (p.x<p.y)p.xy=p.yx;\r\n        if (p.x<p.z)p.xz=p.zx;\r\n        if (p.y<p.z)p.yz=p.zy;\r\n\t\tp = p*s + offs*(1. - s);\r\n        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);\r\n        p=abs(p);\r\n        d = min(d, max(max(p.x, p.y), p.z)*amp);\r\n        amp /= s; \r\n        // abimation\r\n        if(i==1&&p.x>(9.+1.*sin(0.209*iTime+1.))) meep = 1;\r\n    }\r\n \treturn d - 0.29;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\t\r\n// \tfractalscape \r\n    float f = -0.05-kifs(.4*p);\r\n\tif(meep==0) f+=0.002*noise(p*70.);\r\n\treturn f;\r\n}\r\n\r\n//\tnormal calculation\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps=0.0001;\r\n\tfloat d=map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\n// \tstandard sphere tracing inside and outside\r\nfloat castRayx(vec3 ro,vec3 rd) \r\n{\r\n    float function_sign=(map(ro)<0.)?-1.:1.;\r\n    float precis=.0001;\r\n    float h=precis*2.;\r\n    float t=0.;\r\n\tfor(int i=0;i<120;i++) \r\n\t{\r\n        if(abs(h)<precis||t>12.)break;\r\n\t\th=function_sign*map(ro+rd*t);\r\n        t+=h;\r\n\t}\r\n    return t;\r\n}\r\n\r\n// \trefraction\r\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\r\n{\r\n    float h=0.;\r\n    t2=2.;\r\n\tvec3 dir2=refract(dir,nor,angle);  \r\n \tfor(int i=0;i<50;i++) \r\n\t{\r\n\t\tif(abs(h)>3.) break;\r\n\t\th=map(pos+dir2*t2);\r\n\t\tt2-=h;\r\n\t}\r\n    nor2=calcNormal(pos+dir2*t2);\r\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\r\n}\r\n\r\n//\tsoftshadow (IQ)\r\nfloat softshadow(vec3 ro,vec3 rd) \r\n{\r\n    float sh=1.;\r\n    float t=.02;\r\n    float h=.0;\r\n    for(int i=0;i<22;i++)  \r\n\t{\r\n        if(t>20.)continue;\r\n        h=map(ro+rd*t);\r\n        sh=min(sh,4.*h/t);\r\n        t+=h;\r\n    }\r\n    return sh;\r\n}\r\n\r\n//\tmain function\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{    \r\n    \r\n    float bounce=abs(fract(0.05*iTime)-.5)*20.; // triangle function\r\n    meep=0;\r\n\tvec2 uv=gl_FragCoord.xy/iResolution.xy; \r\n    vec2 p=uv*2.-1.;\r\n   \r\n// \tbouncy cam every 10 seconds\r\n    float wobble=(fract(.1*(iTime-1.))>=0.9)?fract(-iTime)*0.1*sin(30.*iTime):0.;\r\n    \r\n//  camera    \r\n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, iResolution.y));\r\n//\torg (Left-Right,Down-Up,Near-Far)  \r\n    vec3 org = vec3(0,2.*wobble,-3.);  \r\n    \r\n// \tcam fractalscape\r\n   \tvec2 m = sin(vec2(0, 1.57) + iTime/8.);\r\n   \tdir.xy = mat2(m.y, -m.x, m)*dir.xy;\r\n   \tdir.xz = mat2(m.y, -m.x, m)*dir.xz;\r\n   \torg = vec3(0, 2.+wobble, 0.+8.*sin(bounce/3.));\r\n\r\n// \tstandard sphere tracing:\r\n    vec3 color = vec3(0.);\r\n    vec3 color2 = vec3(0.);\r\n    float t=castRayx(org,dir);\r\n\tvec3 pos=org+dir*t;\r\n\tvec3 nor=calcNormal(pos);\r\n\r\n// \tlighting:\r\n    vec3 lig=normalize(-pos);\r\n\r\n//\tscene depth    \r\n    float depth=clamp((1.-0.09*t),0.,1.);\r\n    vec3 pos2,nor2 =  vec3(0.);\r\n    if(t<12.0)\r\n    {\r\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.));\r\n    \tcolor2 *=clamp(softshadow(pos,lig),0.,1.);  // shadow            \t\r\n\r\n        if(meep==1) \t\t\t\t\t\t\t\t// refraction\r\n        {   \r\n        \tfloat t2;\r\n\t\t\tcolor2.r +=refr(pos,lig,dir,nor,0.91, t2, nor2)*depth;\r\n       \t\tcolor2.g +=refr(pos,lig,dir,nor,0.90, t2, nor2)*depth;\r\n       \t\tcolor2.b +=refr(pos,lig,dir,nor,0.89, t2, nor2)*depth;\r\n   \t\t\tcolor2-=clamp(.1*t2,0.,1.);\t\t\t\t// inner intensity loss\r\n        }\r\n\t}      \r\n    float tmp = 0.;\r\n    float T = 1.;\r\n\r\n//\tanimation of glow intensity    \r\n    float intensity = 0.1*-sin(.209*iTime+1.)+0.05; \r\n\tfor(int i=0; i<128; i++)\r\n\t{\r\n    \tif (i<int(1.*(t+110.))) continue;// intensity damping\r\n        float density = 0.; float nebula = noise(org+bounce);\r\n        \r\n        density=(meep==1)?intensity-map(org+.5*nor2)*nebula:.7*intensity-map(org)*nebula;\r\n\t\tif(density>0.)\r\n\t\t{\r\n\t\t\ttmp = density / 128.;\r\n            T *= 1. -tmp * 100.;\r\n\t\t\tif( T <= 0.) break;\r\n\t\t}\r\n\t\torg += dir*0.078;\r\n    }    \r\n\r\n\tvec3 basecol=vec3(1./16.,.25,1.);\t\t\t\t\r\n    T=clamp(T,0.,1.5); \r\n    color += basecol* exp(4.*(0.5-T) - 0.8);\r\n    color2*=depth;\r\n    color2+= (1.-depth)*noise(6.*dir+0.3*iTime)*.1;\t// subtle mist\r\n\r\n    \r\n//\tscene depth included in alpha channel\r\n    fragColor = vec4(vec3(1.*color+0.8*color2)*1.3,abs(0.67-depth)*2.+4.*wobble);\r\n}\r\n\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"// ***********************************************************\r\n// Alcatraz / Rhodium 4k Intro Fractalscape\r\n// by Jochen \"Virgill\" Feldk\u00F6tter\r\n//\r\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\r\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\r\n// ***********************************************************\r\n\r\nint meep =0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// \trotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n// \t3D noise function (IQ)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n    p-=ip; \r\n    vec3 s=vec3(7,157,113);\r\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p=p*p*(3.-2.*p); \r\n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\r\n    h.xy=mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\n// \tkifs fractal (shane)\r\nfloat kifs(vec3 p)\r\n{\r\n    vec3 offs = vec3(1, .75, .5); \r\n    vec2 a = sin(vec2(0, 1.57) + 1.57/2.);\r\n    vec2 b = sin(vec2(0, 1.57) + 1.57/4.);\r\n    float s = 5.;// scale factor\r\n    float d = 1e5; // distance\r\n    p  = abs(fract(p*.5)*2. - 1.);\r\n    float amp = 1./s; \r\n    for(int i=0; i<5; i++)\r\n    {\r\n        // rotation\r\n       \tp.xy=mat2(a.y,-a.x,a)*p.xy;\r\n       \tp.yz=mat2(b.y,-b.x,b)*p.yz;\r\n        p=abs(p);\r\n    \tif (p.x<p.y)p.xy=p.yx;\r\n        if (p.x<p.z)p.xz=p.zx;\r\n        if (p.y<p.z)p.yz=p.zy;\r\n\t\tp = p*s + offs*(1. - s);\r\n        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);\r\n        p=abs(p);\r\n        d = min(d, max(max(p.x, p.y), p.z)*amp);\r\n        amp /= s; \r\n        // abimation\r\n        if(i==1&&p.x>(9.+1.*sin(0.209*iTime+1.))) meep = 1;\r\n    }\r\n \treturn d - 0.29;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\t\r\n// \tfractalscape \r\n    float f = -0.05-kifs(.4*p);\r\n\tif(meep==0) f+=0.002*noise(p*70.);\r\n\treturn f;\r\n}\r\n\r\n//\tnormal calculation\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps=0.0001;\r\n\tfloat d=map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\n// \tstandard sphere tracing inside and outside\r\nfloat castRayx(vec3 ro,vec3 rd) \r\n{\r\n    float function_sign=(map(ro)<0.)?-1.:1.;\r\n    float precis=.0001;\r\n    float h=precis*2.;\r\n    float t=0.;\r\n\tfor(int i=0;i<120;i++) \r\n\t{\r\n        if(abs(h)<precis||t>12.)break;\r\n\t\th=function_sign*map(ro+rd*t);\r\n        t+=h;\r\n\t}\r\n    return t;\r\n}\r\n\r\n// \trefraction\r\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\r\n{\r\n    float h=0.;\r\n    t2=2.;\r\n\tvec3 dir2=refract(dir,nor,angle);  \r\n \tfor(int i=0;i<50;i++) \r\n\t{\r\n\t\tif(abs(h)>3.) break;\r\n\t\th=map(pos+dir2*t2);\r\n\t\tt2-=h;\r\n\t}\r\n    nor2=calcNormal(pos+dir2*t2);\r\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\r\n}\r\n\r\n//\tsoftshadow (IQ)\r\nfloat softshadow(vec3 ro,vec3 rd) \r\n{\r\n    float sh=1.;\r\n    float t=.02;\r\n    float h=.0;\r\n    for(int i=0;i<22;i++)  \r\n\t{\r\n        if(t>20.)continue;\r\n        h=map(ro+rd*t);\r\n        sh=min(sh,4.*h/t);\r\n        t+=h;\r\n    }\r\n    return sh;\r\n}\r\n\r\n//\tmain function\r\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\r\n{    \r\n    \r\n    float bounce=abs(fract(0.05*iTime)-.5)*20.; // triangle function\r\n    meep=0;\r\n\tvec2 uv=gl_FragCoord.xy/iResolution.xy; \r\n    vec2 p=uv*2.-1.;\r\n   \r\n// \tbouncy cam every 10 seconds\r\n    float wobble=(fract(.1*(iTime-1.))>=0.9)?fract(-iTime)*0.1*sin(30.*iTime):0.;\r\n    \r\n//  camera    \r\n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -iResolution.xy, iResolution.y));\r\n//\torg (Left-Right,Down-Up,Near-Far)  \r\n    vec3 org = vec3(0,2.*wobble,-3.);  \r\n    \r\n// \tcam fractalscape\r\n   \tvec2 m = sin(vec2(0, 1.57) + iTime/8.);\r\n   \tdir.xy = mat2(m.y, -m.x, m)*dir.xy;\r\n   \tdir.xz = mat2(m.y, -m.x, m)*dir.xz;\r\n   \torg = vec3(0, 2.+wobble, 0.+8.*sin(bounce/3.));\r\n\r\n// \tstandard sphere tracing:\r\n    vec3 color = vec3(0.);\r\n    vec3 color2 = vec3(0.);\r\n    float t=castRayx(org,dir);\r\n\tvec3 pos=org+dir*t;\r\n\tvec3 nor=calcNormal(pos);\r\n\r\n// \tlighting:\r\n    vec3 lig=normalize(-pos);\r\n\r\n//\tscene depth    \r\n    float depth=clamp((1.-0.09*t),0.,1.);\r\n    vec3 pos2,nor2 =  vec3(0.);\r\n    if(t<12.0)\r\n    {\r\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.));\r\n    \tcolor2 *=clamp(softshadow(pos,lig),0.,1.);  // shadow            \t\r\n\r\n        if(meep==1) \t\t\t\t\t\t\t\t// refraction\r\n        {   \r\n        \tfloat t2;\r\n\t\t\tcolor2.r +=refr(pos,lig,dir,nor,0.91, t2, nor2)*depth;\r\n       \t\tcolor2.g +=refr(pos,lig,dir,nor,0.90, t2, nor2)*depth;\r\n       \t\tcolor2.b +=refr(pos,lig,dir,nor,0.89, t2, nor2)*depth;\r\n   \t\t\tcolor2-=clamp(.1*t2,0.,1.);\t\t\t\t// inner intensity loss\r\n        }\r\n\t}      \r\n    float tmp = 0.;\r\n    float T = 1.;\r\n\r\n//\tanimation of glow intensity    \r\n    float intensity = 0.1*-sin(.209*iTime+1.)+0.05; \r\n\tfor(int i=0; i<128; i++)\r\n\t{\r\n    \tif (i<int(1.*(t+110.))) continue;// intensity damping\r\n        float density = 0.; float nebula = noise(org+bounce);\r\n        \r\n        density=(meep==1)?intensity-map(org+.5*nor2)*nebula:.7*intensity-map(org)*nebula;\r\n\t\tif(density>0.)\r\n\t\t{\r\n\t\t\ttmp = density / 128.;\r\n            T *= 1. -tmp * 100.;\r\n\t\t\tif( T <= 0.) break;\r\n\t\t}\r\n\t\torg += dir*0.078;\r\n    }    \r\n\r\n\tvec3 basecol=vec3(1./16.,.25,1.);\t\t\t\t\r\n    T=clamp(T,0.,1.5); \r\n    color += basecol* exp(4.*(0.5-T) - 0.8);\r\n    color2*=depth;\r\n    color2+= (1.-depth)*noise(6.*dir+0.3*iTime)*.1;\t// subtle mist\r\n\r\n    \r\n//\tscene depth included in alpha channel\r\n    fragColor = vec4(vec3(1.*color+0.8*color2)*1.3,abs(0.67-depth)*2.+4.*wobble);\r\n}\r\n\r\n\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Rolling hills. By David Hoskins, November 2013.\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/Xsf3zX\r\n\r\n// v.2.00 Uses eiffie's 'Circle of Confusion' function\r\n//\t\t  for blurred ray marching into the grass.\r\n// v.1.02 Camera aberrations.\r\n// v.1.01 Added better grass, with wind movement.\r\n\r\n// For red/cyan 3D...\r\n//#define STEREO\r\n\r\n#define MOD2 vec2(3.07965, 7.4235)\r\nfloat PI  = 4.0*atan(1.0);\r\nvec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );\r\nvec3 cameraPos;\r\nvec3 sunColour = vec3(1.0, .75, .6);\r\nconst mat2 rotate2D = mat2(1.932, 1.623, -1.623, 1.952);\r\nfloat gTime = 0.0;\r\n\r\n//--------------------------------------------------------------------------\r\n// Noise functions...\r\nfloat Hash( float p )\r\n{\r\n\tvec2 p2 = fract(vec2(p) / MOD2);\r\n    p2 += dot(p2.yx, p2.xy+19.19);\r\n\treturn fract(p2.x * p2.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash(vec2 p)\r\n{\r\n\tp  = fract(p / MOD2);\r\n    p += dot(p.xy, p.yx+19.19);\r\n    return fract(p.x * p.y);\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Voronoi( in vec2 x )\r\n{\r\n\tvec2 p = floor( x );\r\n\tvec2 f = fract( x );\r\n\tfloat res=100.0,id;\r\n\tfor( int j=-1; j<=1; j++ )\r\n\tfor( int i=-1; i<=1; i++ )\r\n\t{\r\n\t\tvec2 b = vec2( float(i), float(j) );\r\n\t\tvec2 r = vec2( b ) - f  + Hash( p + b );\r\n\t\tfloat d = dot(r,r);\r\n\t\tif( d < res )\r\n\t\t{\r\n\t\t\tres = d;\r\n\t\t\tid  = Hash(p+b);\r\n\t\t}\t\t\t\r\n    }\r\n\treturn vec2(max(.4-sqrt(res), 0.0),id);\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Terrain( in vec2 p)\r\n{\r\n\tfloat type = 0.0;\r\n\tvec2 pos = p*0.003;\r\n\tfloat w = 50.0;\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tf += Noise(pos) * w;\r\n\t\tw = w * 0.62;\r\n\t\tpos *= 2.5;\r\n\t}\r\n\r\n\treturn vec2(f, type);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Map(in vec3 p)\r\n{\r\n\tvec2 h = Terrain(p.xz);\r\n    return vec2(p.y - h.x, h.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw = w*0.6;\r\n\t\txy = 2.0 * xy;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\r\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\r\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\r\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\r\n\treturn clamp(sky, 0.0, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge grass into the sky background for correct fog colouring...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = clamp(dis*dis* 0.0000012, 0.0, 1.0);\r\n\treturn mix( rgb, GetSky(dir), fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 DE(vec3 p)\r\n{\r\n\tfloat base = Terrain(p.xz).x - 1.9;\r\n\tfloat height = Noise(p.xz*2.0)*.75 + Noise(p.xz)*.35 + Noise(p.xz*.5)*.2;\r\n\t//p.y += height;\r\n\tfloat y = p.y - base-height;\r\n\ty = y*y;\r\n\tvec2 ret = Voronoi((p.xz*2.5+sin(y*4.0+p.zx*12.3)*.12+vec2(sin(iTime*2.3+1.5*p.z),sin(iTime*3.6+1.5*p.x))*y*.5));\r\n\tfloat f = ret.x * .6 + y * .58;\r\n\treturn vec3( y - f*1.4, clamp(f * 1.5, 0.0, 1.0), ret.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// eiffie's code for calculating the aperture size for a given distance...\r\nfloat CircleOfConfusion(float t)\r\n{\r\n\treturn max(t * .04, (2.0 / iResolution.y) * (1.0+t));\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Linstep(float a, float b, float t)\r\n{\r\n\treturn clamp((t-a)/(b-a),0.,1.);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)\r\n{\r\n\tfloat d = 0.0;\r\n\t// Only calculate cCoC once is enough here...\r\n\tfloat rCoC = CircleOfConfusion(dist*.3);\r\n\tfloat alpha = 0.0;\r\n\t\r\n\tvec4 col = vec4(mat*0.15, 0.0);\r\n\r\n\tfor (int i = 0; i < 15; i++)\r\n\t{\r\n\t\tif (col.w > .99) break;\r\n\t\tvec3 p = rO + rD * d;\r\n\t\t\r\n\t\tvec3 ret = DE(p);\r\n\t\tret.x += .5 * rCoC;\r\n\r\n\t\tif (ret.x < rCoC)\r\n\t\t{\r\n\t\t\talpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x);//calculate the mix like cloud density\r\n\t\t\t// Mix material with white tips for grass...\r\n\t\t\tvec3 gra = mix(mat, vec3(.35, .35, min(pow(ret.z, 4.0)*35.0, .35)), pow(ret.y, 9.0)*.7) * ret.y;\r\n\t\t\tcol += vec4(gra * alpha, alpha);\r\n\t\t}\r\n\t\td += max(ret.x * .7, .1);\r\n\t}\r\n\tif(col.w < .2)\r\n\t\tcol.xyz = vec3(0.1, .15, 0.05);\r\n\treturn col.xyz;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tmat = mat * sunColour*(max(h, 0.0)+.2);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type)\r\n{\r\n\tvec3 mat;\r\n\tif (type == 0.0)\r\n\t{\r\n\t\t// Random colour...\r\n\t\tmat = mix(vec3(.0,.3,.0), vec3(.2,.3,.0), Noise(pos.xz*.025));\r\n\t\t// Random shadows...\r\n\t\tfloat t = FractalNoise(pos.xz * .1)+.5;\r\n\t\t// Do grass blade tracing...\r\n\t\tmat = GrassBlades(pos, dir, mat, dis) * t;\r\n\t\tDoLighting(mat, pos, normal,dir, dis);\r\n\t}\r\n\tmat = ApplyFog(mat, dis, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Home in on the surface by dividing by two and split...\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\r\n{\r\n\tfloat halfwayT = 0.0;\r\n\tfor (int n = 0; n < 5; n++)\r\n\t{\r\n\t\thalfwayT = (oldT + t ) * .5;\r\n\t\tif (Map(rO + halfwayT*rD).x < .05)\r\n\t\t{\r\n\t\t\tt = halfwayT;\r\n\t\t}else\r\n\t\t{\r\n\t\t\toldT = halfwayT;\r\n\t\t}\r\n\t}\r\n\treturn t;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )\r\n{\r\n    float t = 5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.;\r\n\tvec2 h = vec2(1.0, 1.0);\r\n\tbool hit = false;\r\n\tfor( int j=0; j < 70; j++ )\r\n\t{\r\n\t    vec3 p = rO + t*rD;\r\n\t\th = Map(p); // ...Get this position's height mapping.\r\n\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h.x < 0.05)\r\n\t\t{\r\n\t\t\thit = true;\r\n            break;\r\n\t\t}\r\n\t        \r\n\t\tdelta = h.x + (t*0.03);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n    type = h.y;\r\n    resT = BinarySubdivision(rO, rD, t, oldT);\r\n\treturn hit;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\t//t = time + t;\r\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\r\n\treturn vec3(p.x+55.0,  12.0+sin(t*.3)*6.5, -94.0+p.y);\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvec3 PostEffects(vec3 rgb, vec2 xy)\r\n{\r\n\t// Gamma first...\r\n\trgb = pow(rgb, vec3(0.45));\r\n\t\r\n\t// Then...\r\n\t#define CONTRAST 1.1\r\n\t#define SATURATION 1.3\r\n\t#define BRIGHTNESS 1.3\r\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\t// Vignette...\r\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat m = (iMouse.x/iResolution.x)*300.0;\r\n\tfloat gTime = (iTime*5.0+m+2352.0)*.006;\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\t\r\n\tif (xy.y < .13 || xy.y >= .87)\r\n\t{\r\n\t\t// Top and bottom cine-crop - what a waste! :)\r\n\t\tfragColor=vec4(vec4(0.0));\r\n\t\treturn;\r\n\t}\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\tcameraPos = CameraPath(gTime + 0.0);\r\n    cameraPos.x -= 3.0;\r\n\tcamTar\t = CameraPath(gTime + .009);\r\n\tcameraPos.y += Terrain(CameraPath(gTime + .009).xz).x;\r\n\tcamTar.y = cameraPos.y;\r\n\t\r\n\tfloat roll = .4*sin(gTime+.5);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\tmat3 camMat = mat3(cu, cv, cw);\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .85*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tfloat type;\r\n\tif( !Scene(cameraPos, dir, distance, type) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky...\r\n\t\tcol = GetSky(dir);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * dir;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tvec2 p = vec2(0.1, 0.0);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\tTerrain(pos.xz).x, 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p.x,\tTerrain(pos.xz+p).x, 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain(pos.xz-p.yx).x, -p.x);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, dir, nor, distance, type);\r\n\t}\r\n\t\r\n\t// bri is the brightness of sun at the centre of the camera direction.\r\n\t// Yeah, the lens flares is not exactly subtle, but it was good fun making it.\r\n\tfloat bri = dot(cw, sunLight)*.75;\r\n\tif (bri > 0.0)\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\r\n\t\tvec2 uvT = uv-sunPos;\r\n\t\tuvT = uvT*(length(uvT));\r\n\t\tbri = pow(bri, 6.0)*.8;\r\n\r\n\t\t// glare = the red shifted blob...\r\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\r\n\t\t// glare2 is the yellow ring...\r\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, uv, -2.3);\r\n\t\t// glare3 is a purple splodge...\r\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\r\n\t\tcol += bri * vec3(1.0, 1.0, 0.2) * pow(glare2, 2.0)*2.5;\r\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.0;\r\n\t}\r\n\tcol = PostEffects(col, xy);\t\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------","inputs":[],"outputs":[],"code":"// Rolling hills. By David Hoskins, November 2013.\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/Xsf3zX\r\n\r\n// v.2.00 Uses eiffie's 'Circle of Confusion' function\r\n//\t\t  for blurred ray marching into the grass.\r\n// v.1.02 Camera aberrations.\r\n// v.1.01 Added better grass, with wind movement.\r\n\r\n// For red/cyan 3D...\r\n//#define STEREO\r\n\r\n#define MOD2 vec2(3.07965, 7.4235)\r\nfloat PI  = 4.0*atan(1.0);\r\nvec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );\r\nvec3 cameraPos;\r\nvec3 sunColour = vec3(1.0, .75, .6);\r\nconst mat2 rotate2D = mat2(1.932, 1.623, -1.623, 1.952);\r\nfloat gTime = 0.0;\r\n\r\n//--------------------------------------------------------------------------\r\n// Noise functions...\r\nfloat Hash( float p )\r\n{\r\n\tvec2 p2 = fract(vec2(p) / MOD2);\r\n    p2 += dot(p2.yx, p2.xy+19.19);\r\n\treturn fract(p2.x * p2.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash(vec2 p)\r\n{\r\n\tp  = fract(p / MOD2);\r\n    p += dot(p.xy, p.yx+19.19);\r\n    return fract(p.x * p.y);\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Voronoi( in vec2 x )\r\n{\r\n\tvec2 p = floor( x );\r\n\tvec2 f = fract( x );\r\n\tfloat res=100.0,id;\r\n\tfor( int j=-1; j<=1; j++ )\r\n\tfor( int i=-1; i<=1; i++ )\r\n\t{\r\n\t\tvec2 b = vec2( float(i), float(j) );\r\n\t\tvec2 r = vec2( b ) - f  + Hash( p + b );\r\n\t\tfloat d = dot(r,r);\r\n\t\tif( d < res )\r\n\t\t{\r\n\t\t\tres = d;\r\n\t\t\tid  = Hash(p+b);\r\n\t\t}\t\t\t\r\n    }\r\n\treturn vec2(max(.4-sqrt(res), 0.0),id);\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Terrain( in vec2 p)\r\n{\r\n\tfloat type = 0.0;\r\n\tvec2 pos = p*0.003;\r\n\tfloat w = 50.0;\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tf += Noise(pos) * w;\r\n\t\tw = w * 0.62;\r\n\t\tpos *= 2.5;\r\n\t}\r\n\r\n\treturn vec2(f, type);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Map(in vec3 p)\r\n{\r\n\tvec2 h = Terrain(p.xz);\r\n    return vec2(p.y - h.x, h.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw = w*0.6;\r\n\t\txy = 2.0 * xy;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\r\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\r\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\r\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\r\n\treturn clamp(sky, 0.0, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge grass into the sky background for correct fog colouring...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = clamp(dis*dis* 0.0000012, 0.0, 1.0);\r\n\treturn mix( rgb, GetSky(dir), fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 DE(vec3 p)\r\n{\r\n\tfloat base = Terrain(p.xz).x - 1.9;\r\n\tfloat height = Noise(p.xz*2.0)*.75 + Noise(p.xz)*.35 + Noise(p.xz*.5)*.2;\r\n\t//p.y += height;\r\n\tfloat y = p.y - base-height;\r\n\ty = y*y;\r\n\tvec2 ret = Voronoi((p.xz*2.5+sin(y*4.0+p.zx*12.3)*.12+vec2(sin(iTime*2.3+1.5*p.z),sin(iTime*3.6+1.5*p.x))*y*.5));\r\n\tfloat f = ret.x * .6 + y * .58;\r\n\treturn vec3( y - f*1.4, clamp(f * 1.5, 0.0, 1.0), ret.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// eiffie's code for calculating the aperture size for a given distance...\r\nfloat CircleOfConfusion(float t)\r\n{\r\n\treturn max(t * .04, (2.0 / iResolution.y) * (1.0+t));\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Linstep(float a, float b, float t)\r\n{\r\n\treturn clamp((t-a)/(b-a),0.,1.);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)\r\n{\r\n\tfloat d = 0.0;\r\n\t// Only calculate cCoC once is enough here...\r\n\tfloat rCoC = CircleOfConfusion(dist*.3);\r\n\tfloat alpha = 0.0;\r\n\t\r\n\tvec4 col = vec4(mat*0.15, 0.0);\r\n\r\n\tfor (int i = 0; i < 15; i++)\r\n\t{\r\n\t\tif (col.w > .99) break;\r\n\t\tvec3 p = rO + rD * d;\r\n\t\t\r\n\t\tvec3 ret = DE(p);\r\n\t\tret.x += .5 * rCoC;\r\n\r\n\t\tif (ret.x < rCoC)\r\n\t\t{\r\n\t\t\talpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x);//calculate the mix like cloud density\r\n\t\t\t// Mix material with white tips for grass...\r\n\t\t\tvec3 gra = mix(mat, vec3(.35, .35, min(pow(ret.z, 4.0)*35.0, .35)), pow(ret.y, 9.0)*.7) * ret.y;\r\n\t\t\tcol += vec4(gra * alpha, alpha);\r\n\t\t}\r\n\t\td += max(ret.x * .7, .1);\r\n\t}\r\n\tif(col.w < .2)\r\n\t\tcol.xyz = vec3(0.1, .15, 0.05);\r\n\treturn col.xyz;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tmat = mat * sunColour*(max(h, 0.0)+.2);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type)\r\n{\r\n\tvec3 mat;\r\n\tif (type == 0.0)\r\n\t{\r\n\t\t// Random colour...\r\n\t\tmat = mix(vec3(.0,.3,.0), vec3(.2,.3,.0), Noise(pos.xz*.025));\r\n\t\t// Random shadows...\r\n\t\tfloat t = FractalNoise(pos.xz * .1)+.5;\r\n\t\t// Do grass blade tracing...\r\n\t\tmat = GrassBlades(pos, dir, mat, dis) * t;\r\n\t\tDoLighting(mat, pos, normal,dir, dis);\r\n\t}\r\n\tmat = ApplyFog(mat, dis, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Home in on the surface by dividing by two and split...\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\r\n{\r\n\tfloat halfwayT = 0.0;\r\n\tfor (int n = 0; n < 5; n++)\r\n\t{\r\n\t\thalfwayT = (oldT + t ) * .5;\r\n\t\tif (Map(rO + halfwayT*rD).x < .05)\r\n\t\t{\r\n\t\t\tt = halfwayT;\r\n\t\t}else\r\n\t\t{\r\n\t\t\toldT = halfwayT;\r\n\t\t}\r\n\t}\r\n\treturn t;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )\r\n{\r\n    float t = 5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.;\r\n\tvec2 h = vec2(1.0, 1.0);\r\n\tbool hit = false;\r\n\tfor( int j=0; j < 70; j++ )\r\n\t{\r\n\t    vec3 p = rO + t*rD;\r\n\t\th = Map(p); // ...Get this position's height mapping.\r\n\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h.x < 0.05)\r\n\t\t{\r\n\t\t\thit = true;\r\n            break;\r\n\t\t}\r\n\t        \r\n\t\tdelta = h.x + (t*0.03);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n    type = h.y;\r\n    resT = BinarySubdivision(rO, rD, t, oldT);\r\n\treturn hit;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\t//t = time + t;\r\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\r\n\treturn vec3(p.x+55.0,  12.0+sin(t*.3)*6.5, -94.0+p.y);\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvec3 PostEffects(vec3 rgb, vec2 xy)\r\n{\r\n\t// Gamma first...\r\n\trgb = pow(rgb, vec3(0.45));\r\n\t\r\n\t// Then...\r\n\t#define CONTRAST 1.1\r\n\t#define SATURATION 1.3\r\n\t#define BRIGHTNESS 1.3\r\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\t// Vignette...\r\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat m = (iMouse.x/iResolution.x)*300.0;\r\n\tfloat gTime = (iTime*5.0+m+2352.0)*.006;\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\t\r\n\tif (xy.y < .13 || xy.y >= .87)\r\n\t{\r\n\t\t// Top and bottom cine-crop - what a waste! :)\r\n\t\tfragColor=vec4(vec4(0.0));\r\n\t\treturn;\r\n\t}\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\tcameraPos = CameraPath(gTime + 0.0);\r\n    cameraPos.x -= 3.0;\r\n\tcamTar\t = CameraPath(gTime + .009);\r\n\tcameraPos.y += Terrain(CameraPath(gTime + .009).xz).x;\r\n\tcamTar.y = cameraPos.y;\r\n\t\r\n\tfloat roll = .4*sin(gTime+.5);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\tmat3 camMat = mat3(cu, cv, cw);\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .85*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tfloat type;\r\n\tif( !Scene(cameraPos, dir, distance, type) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky...\r\n\t\tcol = GetSky(dir);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * dir;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tvec2 p = vec2(0.1, 0.0);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\tTerrain(pos.xz).x, 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p.x,\tTerrain(pos.xz+p).x, 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain(pos.xz-p.yx).x, -p.x);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, dir, nor, distance, type);\r\n\t}\r\n\t\r\n\t// bri is the brightness of sun at the centre of the camera direction.\r\n\t// Yeah, the lens flares is not exactly subtle, but it was good fun making it.\r\n\tfloat bri = dot(cw, sunLight)*.75;\r\n\tif (bri > 0.0)\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\r\n\t\tvec2 uvT = uv-sunPos;\r\n\t\tuvT = uvT*(length(uvT));\r\n\t\tbri = pow(bri, 6.0)*.8;\r\n\r\n\t\t// glare = the red shifted blob...\r\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\r\n\t\t// glare2 is the yellow ring...\r\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, uv, -2.3);\r\n\t\t// glare3 is a purple splodge...\r\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\r\n\t\tcol += bri * vec3(1.0, 1.0, 0.2) * pow(glare2, 2.0)*2.5;\r\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.0;\r\n\t}\r\n\tcol = PostEffects(col, xy);\t\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Rolling hills","id":"91764a58d0e34590b20f8b0b7a19ed87","date":null,"viewed":0,"name":"Rolling hills","description":"Grassy fields. Ray marches a ray to a smooth hill, then enters detailed stepping through a grass like distance, erm, field. \nNow uses eiffie's 'Circle of Confusion' function for blurred ray marching into the grass.\nThanks eiffie!\nhttps://www.shadertoy.com/view/Xsf3zX","likes":0,"published":null,"tags":["3d"," grass"," rollinghills"]},"ver":null,"info":{"Name":"Rolling hills","id":"91764a58d0e34590b20f8b0b7a19ed87","date":null,"viewed":0,"name":"Rolling hills","description":"Grassy fields. Ray marches a ray to a smooth hill, then enters detailed stepping through a grass like distance, erm, field. \nNow uses eiffie's 'Circle of Confusion' function for blurred ray marching into the grass.\nThanks eiffie!\nhttps://www.shadertoy.com/view/Xsf3zX","likes":0,"published":null,"tags":["3d"," grass"," rollinghills"]},"renderpass":[{"Code":"// Rolling hills. By David Hoskins, November 2013.\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/Xsf3zX\r\n\r\n// v.2.00 Uses eiffie's 'Circle of Confusion' function\r\n//\t\t  for blurred ray marching into the grass.\r\n// v.1.02 Camera aberrations.\r\n// v.1.01 Added better grass, with wind movement.\r\n\r\n// For red/cyan 3D...\r\n//#define STEREO\r\n\r\n#define MOD2 vec2(3.07965, 7.4235)\r\nfloat PI  = 4.0*atan(1.0);\r\nvec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );\r\nvec3 cameraPos;\r\nvec3 sunColour = vec3(1.0, .75, .6);\r\nconst mat2 rotate2D = mat2(1.932, 1.623, -1.623, 1.952);\r\nfloat gTime = 0.0;\r\n\r\n//--------------------------------------------------------------------------\r\n// Noise functions...\r\nfloat Hash( float p )\r\n{\r\n\tvec2 p2 = fract(vec2(p) / MOD2);\r\n    p2 += dot(p2.yx, p2.xy+19.19);\r\n\treturn fract(p2.x * p2.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash(vec2 p)\r\n{\r\n\tp  = fract(p / MOD2);\r\n    p += dot(p.xy, p.yx+19.19);\r\n    return fract(p.x * p.y);\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Voronoi( in vec2 x )\r\n{\r\n\tvec2 p = floor( x );\r\n\tvec2 f = fract( x );\r\n\tfloat res=100.0,id;\r\n\tfor( int j=-1; j<=1; j++ )\r\n\tfor( int i=-1; i<=1; i++ )\r\n\t{\r\n\t\tvec2 b = vec2( float(i), float(j) );\r\n\t\tvec2 r = vec2( b ) - f  + Hash( p + b );\r\n\t\tfloat d = dot(r,r);\r\n\t\tif( d < res )\r\n\t\t{\r\n\t\t\tres = d;\r\n\t\t\tid  = Hash(p+b);\r\n\t\t}\t\t\t\r\n    }\r\n\treturn vec2(max(.4-sqrt(res), 0.0),id);\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Terrain( in vec2 p)\r\n{\r\n\tfloat type = 0.0;\r\n\tvec2 pos = p*0.003;\r\n\tfloat w = 50.0;\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tf += Noise(pos) * w;\r\n\t\tw = w * 0.62;\r\n\t\tpos *= 2.5;\r\n\t}\r\n\r\n\treturn vec2(f, type);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Map(in vec3 p)\r\n{\r\n\tvec2 h = Terrain(p.xz);\r\n    return vec2(p.y - h.x, h.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw = w*0.6;\r\n\t\txy = 2.0 * xy;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\r\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\r\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\r\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\r\n\treturn clamp(sky, 0.0, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge grass into the sky background for correct fog colouring...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = clamp(dis*dis* 0.0000012, 0.0, 1.0);\r\n\treturn mix( rgb, GetSky(dir), fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 DE(vec3 p)\r\n{\r\n\tfloat base = Terrain(p.xz).x - 1.9;\r\n\tfloat height = Noise(p.xz*2.0)*.75 + Noise(p.xz)*.35 + Noise(p.xz*.5)*.2;\r\n\t//p.y += height;\r\n\tfloat y = p.y - base-height;\r\n\ty = y*y;\r\n\tvec2 ret = Voronoi((p.xz*2.5+sin(y*4.0+p.zx*12.3)*.12+vec2(sin(iTime*2.3+1.5*p.z),sin(iTime*3.6+1.5*p.x))*y*.5));\r\n\tfloat f = ret.x * .6 + y * .58;\r\n\treturn vec3( y - f*1.4, clamp(f * 1.5, 0.0, 1.0), ret.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// eiffie's code for calculating the aperture size for a given distance...\r\nfloat CircleOfConfusion(float t)\r\n{\r\n\treturn max(t * .04, (2.0 / iResolution.y) * (1.0+t));\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Linstep(float a, float b, float t)\r\n{\r\n\treturn clamp((t-a)/(b-a),0.,1.);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)\r\n{\r\n\tfloat d = 0.0;\r\n\t// Only calculate cCoC once is enough here...\r\n\tfloat rCoC = CircleOfConfusion(dist*.3);\r\n\tfloat alpha = 0.0;\r\n\t\r\n\tvec4 col = vec4(mat*0.15, 0.0);\r\n\r\n\tfor (int i = 0; i < 15; i++)\r\n\t{\r\n\t\tif (col.w > .99) break;\r\n\t\tvec3 p = rO + rD * d;\r\n\t\t\r\n\t\tvec3 ret = DE(p);\r\n\t\tret.x += .5 * rCoC;\r\n\r\n\t\tif (ret.x < rCoC)\r\n\t\t{\r\n\t\t\talpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x);//calculate the mix like cloud density\r\n\t\t\t// Mix material with white tips for grass...\r\n\t\t\tvec3 gra = mix(mat, vec3(.35, .35, min(pow(ret.z, 4.0)*35.0, .35)), pow(ret.y, 9.0)*.7) * ret.y;\r\n\t\t\tcol += vec4(gra * alpha, alpha);\r\n\t\t}\r\n\t\td += max(ret.x * .7, .1);\r\n\t}\r\n\tif(col.w < .2)\r\n\t\tcol.xyz = vec3(0.1, .15, 0.05);\r\n\treturn col.xyz;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tmat = mat * sunColour*(max(h, 0.0)+.2);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type)\r\n{\r\n\tvec3 mat;\r\n\tif (type == 0.0)\r\n\t{\r\n\t\t// Random colour...\r\n\t\tmat = mix(vec3(.0,.3,.0), vec3(.2,.3,.0), Noise(pos.xz*.025));\r\n\t\t// Random shadows...\r\n\t\tfloat t = FractalNoise(pos.xz * .1)+.5;\r\n\t\t// Do grass blade tracing...\r\n\t\tmat = GrassBlades(pos, dir, mat, dis) * t;\r\n\t\tDoLighting(mat, pos, normal,dir, dis);\r\n\t}\r\n\tmat = ApplyFog(mat, dis, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Home in on the surface by dividing by two and split...\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\r\n{\r\n\tfloat halfwayT = 0.0;\r\n\tfor (int n = 0; n < 5; n++)\r\n\t{\r\n\t\thalfwayT = (oldT + t ) * .5;\r\n\t\tif (Map(rO + halfwayT*rD).x < .05)\r\n\t\t{\r\n\t\t\tt = halfwayT;\r\n\t\t}else\r\n\t\t{\r\n\t\t\toldT = halfwayT;\r\n\t\t}\r\n\t}\r\n\treturn t;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )\r\n{\r\n    float t = 5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.;\r\n\tvec2 h = vec2(1.0, 1.0);\r\n\tbool hit = false;\r\n\tfor( int j=0; j < 70; j++ )\r\n\t{\r\n\t    vec3 p = rO + t*rD;\r\n\t\th = Map(p); // ...Get this position's height mapping.\r\n\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h.x < 0.05)\r\n\t\t{\r\n\t\t\thit = true;\r\n            break;\r\n\t\t}\r\n\t        \r\n\t\tdelta = h.x + (t*0.03);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n    type = h.y;\r\n    resT = BinarySubdivision(rO, rD, t, oldT);\r\n\treturn hit;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\t//t = time + t;\r\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\r\n\treturn vec3(p.x+55.0,  12.0+sin(t*.3)*6.5, -94.0+p.y);\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvec3 PostEffects(vec3 rgb, vec2 xy)\r\n{\r\n\t// Gamma first...\r\n\trgb = pow(rgb, vec3(0.45));\r\n\t\r\n\t// Then...\r\n\t#define CONTRAST 1.1\r\n\t#define SATURATION 1.3\r\n\t#define BRIGHTNESS 1.3\r\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\t// Vignette...\r\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat m = (iMouse.x/iResolution.x)*300.0;\r\n\tfloat gTime = (iTime*5.0+m+2352.0)*.006;\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\t\r\n\tif (xy.y < .13 || xy.y >= .87)\r\n\t{\r\n\t\t// Top and bottom cine-crop - what a waste! :)\r\n\t\tfragColor=vec4(vec4(0.0));\r\n\t\treturn;\r\n\t}\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\tcameraPos = CameraPath(gTime + 0.0);\r\n    cameraPos.x -= 3.0;\r\n\tcamTar\t = CameraPath(gTime + .009);\r\n\tcameraPos.y += Terrain(CameraPath(gTime + .009).xz).x;\r\n\tcamTar.y = cameraPos.y;\r\n\t\r\n\tfloat roll = .4*sin(gTime+.5);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\tmat3 camMat = mat3(cu, cv, cw);\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .85*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tfloat type;\r\n\tif( !Scene(cameraPos, dir, distance, type) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky...\r\n\t\tcol = GetSky(dir);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * dir;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tvec2 p = vec2(0.1, 0.0);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\tTerrain(pos.xz).x, 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p.x,\tTerrain(pos.xz+p).x, 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain(pos.xz-p.yx).x, -p.x);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, dir, nor, distance, type);\r\n\t}\r\n\t\r\n\t// bri is the brightness of sun at the centre of the camera direction.\r\n\t// Yeah, the lens flares is not exactly subtle, but it was good fun making it.\r\n\tfloat bri = dot(cw, sunLight)*.75;\r\n\tif (bri > 0.0)\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\r\n\t\tvec2 uvT = uv-sunPos;\r\n\t\tuvT = uvT*(length(uvT));\r\n\t\tbri = pow(bri, 6.0)*.8;\r\n\r\n\t\t// glare = the red shifted blob...\r\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\r\n\t\t// glare2 is the yellow ring...\r\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, uv, -2.3);\r\n\t\t// glare3 is a purple splodge...\r\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\r\n\t\tcol += bri * vec3(1.0, 1.0, 0.2) * pow(glare2, 2.0)*2.5;\r\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.0;\r\n\t}\r\n\tcol = PostEffects(col, xy);\t\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------","inputs":[],"outputs":[],"code":"// Rolling hills. By David Hoskins, November 2013.\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// https://www.shadertoy.com/view/Xsf3zX\r\n\r\n// v.2.00 Uses eiffie's 'Circle of Confusion' function\r\n//\t\t  for blurred ray marching into the grass.\r\n// v.1.02 Camera aberrations.\r\n// v.1.01 Added better grass, with wind movement.\r\n\r\n// For red/cyan 3D...\r\n//#define STEREO\r\n\r\n#define MOD2 vec2(3.07965, 7.4235)\r\nfloat PI  = 4.0*atan(1.0);\r\nvec3 sunLight  = normalize( vec3(  0.35, 0.2,  0.3 ) );\r\nvec3 cameraPos;\r\nvec3 sunColour = vec3(1.0, .75, .6);\r\nconst mat2 rotate2D = mat2(1.932, 1.623, -1.623, 1.952);\r\nfloat gTime = 0.0;\r\n\r\n//--------------------------------------------------------------------------\r\n// Noise functions...\r\nfloat Hash( float p )\r\n{\r\n\tvec2 p2 = fract(vec2(p) / MOD2);\r\n    p2 += dot(p2.yx, p2.xy+19.19);\r\n\treturn fract(p2.x * p2.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash(vec2 p)\r\n{\r\n\tp  = fract(p / MOD2);\r\n    p += dot(p.xy, p.yx+19.19);\r\n    return fract(p.x * p.y);\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0;\r\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\r\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Voronoi( in vec2 x )\r\n{\r\n\tvec2 p = floor( x );\r\n\tvec2 f = fract( x );\r\n\tfloat res=100.0,id;\r\n\tfor( int j=-1; j<=1; j++ )\r\n\tfor( int i=-1; i<=1; i++ )\r\n\t{\r\n\t\tvec2 b = vec2( float(i), float(j) );\r\n\t\tvec2 r = vec2( b ) - f  + Hash( p + b );\r\n\t\tfloat d = dot(r,r);\r\n\t\tif( d < res )\r\n\t\t{\r\n\t\t\tres = d;\r\n\t\t\tid  = Hash(p+b);\r\n\t\t}\t\t\t\r\n    }\r\n\treturn vec2(max(.4-sqrt(res), 0.0),id);\r\n}\r\n\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Terrain( in vec2 p)\r\n{\r\n\tfloat type = 0.0;\r\n\tvec2 pos = p*0.003;\r\n\tfloat w = 50.0;\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tf += Noise(pos) * w;\r\n\t\tw = w * 0.62;\r\n\t\tpos *= 2.5;\r\n\t}\r\n\r\n\treturn vec2(f, type);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Map(in vec3 p)\r\n{\r\n\tvec2 h = Terrain(p.xz);\r\n    return vec2(p.y - h.x, h.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 3; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw = w*0.6;\r\n\t\txy = 2.0 * xy;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\r\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\r\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\r\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\r\n\treturn clamp(sky, 0.0, 1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge grass into the sky background for correct fog colouring...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = clamp(dis*dis* 0.0000012, 0.0, 1.0);\r\n\treturn mix( rgb, GetSky(dir), fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 DE(vec3 p)\r\n{\r\n\tfloat base = Terrain(p.xz).x - 1.9;\r\n\tfloat height = Noise(p.xz*2.0)*.75 + Noise(p.xz)*.35 + Noise(p.xz*.5)*.2;\r\n\t//p.y += height;\r\n\tfloat y = p.y - base-height;\r\n\ty = y*y;\r\n\tvec2 ret = Voronoi((p.xz*2.5+sin(y*4.0+p.zx*12.3)*.12+vec2(sin(iTime*2.3+1.5*p.z),sin(iTime*3.6+1.5*p.x))*y*.5));\r\n\tfloat f = ret.x * .6 + y * .58;\r\n\treturn vec3( y - f*1.4, clamp(f * 1.5, 0.0, 1.0), ret.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// eiffie's code for calculating the aperture size for a given distance...\r\nfloat CircleOfConfusion(float t)\r\n{\r\n\treturn max(t * .04, (2.0 / iResolution.y) * (1.0+t));\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Linstep(float a, float b, float t)\r\n{\r\n\treturn clamp((t-a)/(b-a),0.,1.);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GrassBlades(in vec3 rO, in vec3 rD, in vec3 mat, in float dist)\r\n{\r\n\tfloat d = 0.0;\r\n\t// Only calculate cCoC once is enough here...\r\n\tfloat rCoC = CircleOfConfusion(dist*.3);\r\n\tfloat alpha = 0.0;\r\n\t\r\n\tvec4 col = vec4(mat*0.15, 0.0);\r\n\r\n\tfor (int i = 0; i < 15; i++)\r\n\t{\r\n\t\tif (col.w > .99) break;\r\n\t\tvec3 p = rO + rD * d;\r\n\t\t\r\n\t\tvec3 ret = DE(p);\r\n\t\tret.x += .5 * rCoC;\r\n\r\n\t\tif (ret.x < rCoC)\r\n\t\t{\r\n\t\t\talpha = (1.0 - col.y) * Linstep(-rCoC, rCoC, -ret.x);//calculate the mix like cloud density\r\n\t\t\t// Mix material with white tips for grass...\r\n\t\t\tvec3 gra = mix(mat, vec3(.35, .35, min(pow(ret.z, 4.0)*35.0, .35)), pow(ret.y, 9.0)*.7) * ret.y;\r\n\t\t\tcol += vec4(gra * alpha, alpha);\r\n\t\t}\r\n\t\td += max(ret.x * .7, .1);\r\n\t}\r\n\tif(col.w < .2)\r\n\t\tcol.xyz = vec3(0.1, .15, 0.05);\r\n\treturn col.xyz;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(sunLight,normal);\r\n\tmat = mat * sunColour*(max(h, 0.0)+.2);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 TerrainColour(vec3 pos, vec3 dir,  vec3 normal, float dis, float type)\r\n{\r\n\tvec3 mat;\r\n\tif (type == 0.0)\r\n\t{\r\n\t\t// Random colour...\r\n\t\tmat = mix(vec3(.0,.3,.0), vec3(.2,.3,.0), Noise(pos.xz*.025));\r\n\t\t// Random shadows...\r\n\t\tfloat t = FractalNoise(pos.xz * .1)+.5;\r\n\t\t// Do grass blade tracing...\r\n\t\tmat = GrassBlades(pos, dir, mat, dis) * t;\r\n\t\tDoLighting(mat, pos, normal,dir, dis);\r\n\t}\r\n\tmat = ApplyFog(mat, dis, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Home in on the surface by dividing by two and split...\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, float t, float oldT)\r\n{\r\n\tfloat halfwayT = 0.0;\r\n\tfor (int n = 0; n < 5; n++)\r\n\t{\r\n\t\thalfwayT = (oldT + t ) * .5;\r\n\t\tif (Map(rO + halfwayT*rD).x < .05)\r\n\t\t{\r\n\t\t\tt = halfwayT;\r\n\t\t}else\r\n\t\t{\r\n\t\t\toldT = halfwayT;\r\n\t\t}\r\n\t}\r\n\treturn t;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT, out float type )\r\n{\r\n    float t = 5.;\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.;\r\n\tvec2 h = vec2(1.0, 1.0);\r\n\tbool hit = false;\r\n\tfor( int j=0; j < 70; j++ )\r\n\t{\r\n\t    vec3 p = rO + t*rD;\r\n\t\th = Map(p); // ...Get this position's height mapping.\r\n\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h.x < 0.05)\r\n\t\t{\r\n\t\t\thit = true;\r\n            break;\r\n\t\t}\r\n\t        \r\n\t\tdelta = h.x + (t*0.03);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n    type = h.y;\r\n    resT = BinarySubdivision(rO, rD, t, oldT);\r\n\treturn hit;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\t//t = time + t;\r\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\r\n\treturn vec3(p.x+55.0,  12.0+sin(t*.3)*6.5, -94.0+p.y);\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvec3 PostEffects(vec3 rgb, vec2 xy)\r\n{\r\n\t// Gamma first...\r\n\trgb = pow(rgb, vec3(0.45));\r\n\t\r\n\t// Then...\r\n\t#define CONTRAST 1.1\r\n\t#define SATURATION 1.3\r\n\t#define BRIGHTNESS 1.3\r\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\t// Vignette...\r\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat m = (iMouse.x/iResolution.x)*300.0;\r\n\tfloat gTime = (iTime*5.0+m+2352.0)*.006;\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n\tvec3 camTar;\r\n\t\r\n\tif (xy.y < .13 || xy.y >= .87)\r\n\t{\r\n\t\t// Top and bottom cine-crop - what a waste! :)\r\n\t\tfragColor=vec4(vec4(0.0));\r\n\t\treturn;\r\n\t}\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\tcameraPos = CameraPath(gTime + 0.0);\r\n    cameraPos.x -= 3.0;\r\n\tcamTar\t = CameraPath(gTime + .009);\r\n\tcameraPos.y += Terrain(CameraPath(gTime + .009).xz).x;\r\n\tcamTar.y = cameraPos.y;\r\n\t\r\n\tfloat roll = .4*sin(gTime+.5);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\tmat3 camMat = mat3(cu, cv, cw);\r\n\r\n\t#ifdef STEREO\r\n\tcameraPos += .85*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tfloat type;\r\n\tif( !Scene(cameraPos, dir, distance, type) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky...\r\n\t\tcol = GetSky(dir);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * dir;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tvec2 p = vec2(0.1, 0.0);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\tTerrain(pos.xz).x, 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p.x,\tTerrain(pos.xz+p).x, 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain(pos.xz-p.yx).x, -p.x);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, dir, nor, distance, type);\r\n\t}\r\n\t\r\n\t// bri is the brightness of sun at the centre of the camera direction.\r\n\t// Yeah, the lens flares is not exactly subtle, but it was good fun making it.\r\n\tfloat bri = dot(cw, sunLight)*.75;\r\n\tif (bri > 0.0)\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( sunLight, cu ), dot( sunLight, cv ) );\r\n\t\tvec2 uvT = uv-sunPos;\r\n\t\tuvT = uvT*(length(uvT));\r\n\t\tbri = pow(bri, 6.0)*.8;\r\n\r\n\t\t// glare = the red shifted blob...\r\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\r\n\t\t// glare2 is the yellow ring...\r\n\t\tfloat glare2 = max(1.0-length(uvT+sunPos*.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, uv, -2.3);\r\n\t\t// glare3 is a purple splodge...\r\n\t\tfloat glare3 = max(1.0-length(uvT+sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\r\n\t\tcol += bri * vec3(1.0, 1.0, 0.2) * pow(glare2, 2.0)*2.5;\r\n\t\tcol += bri * sunColour * pow(glare3, 2.0)*3.0;\r\n\t}\r\n\tcol = PostEffects(col, xy);\t\r\n\t\r\n\t#ifdef STEREO\t\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n\t#endif\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Rose. By David Hoskins. Jan 2014.\r\n// https://www.shadertoy.com/view/ldBGDh\r\n\r\n#define PI 3.14159265359\r\n#define MOD3 vec3(.1143,.12369,.13787)\r\n\r\nvec3 sunLight  = normalize( vec3(  .8, .7,  -0.5 ) );\r\nfloat gTime = 0.0;\r\nvec2 coord;\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract(p3.x * p3.y * p3.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat HashWrap(in vec2 p)\r\n{\r\n\tp.x = mod(p.x, 10.0);\r\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract(p3.x * p3.y * p3.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise(in vec2 p)\r\n{\r\n\tvec2 f = fract(p);\r\n    p = floor(p);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = mix(mix(Hash(p),\r\n\t\t\t\t\t\tHash(p + vec2(1.0, 0.0)), f.x),\r\n\t\t\t\t\tmix(Hash(p + vec2(0.0, 1.0)),\r\n\t\t\t\t\t\tHash(p + vec2(1.0, 1.0)), f.x), f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat NoiseWrap(in vec2 p)\r\n{\r\n\tvec2 f = fract(p);\r\n    p = floor(p);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = mix(mix(HashWrap(p),\r\n\t\t\t\t\t\tHashWrap(p + vec2(1.0, 0.0)), f.x),\r\n\t\t\t\t\tmix(HashWrap(p + vec2(0.0, 1.0)),\r\n\t\t\t\t\t\tHashWrap(p + vec2(1.0, 1.0)), f.x), f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Cylinder( vec3 p, vec2 h )\r\n{\r\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Rotate2D( vec2 p, float a)\r\n{\r\n\tfloat si = sin(a);\r\n\tfloat co = cos(a);\r\n\treturn mat2(co, si, -si, co) * p;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Map(in vec3 p)\r\n{\r\n\tvec2 a;\r\n\tfloat mat = 0.0;\r\n\tfloat anim = min(sqrt(iTime*.1+0.01) +.2, 1.);\r\n\t\r\n\t// Tilt depending on height...\r\n\tfloat t = -.9+smoothstep(-50.0, -400.0, p.y*2.2);\r\n\tp.zy = Rotate2D(p.zy, t);\r\n\tfloat f = length(p*vec3(1.0, 2.5, 1.0))-50.0;\r\n\t\r\n\t// Spin faster around centre...\r\n\tfloat l = dot(p.xz, p.xz) * .0162+.5;\r\n\tt = sqrt(50.0 / (l+.5));\r\n\tp.xz = Rotate2D(p.xz, t*anim*anim);\r\n\t\r\n\t// arctan needs to wrap in the noise function...\r\n\ta.x = (atan(p.x, p.z)+PI)/ (2.0 * PI) * 10.0;\r\n\ta.y  = pow(l, .35)*11.3;\r\n\ta.y *= smoothstep(15.0/(anim*anim), 0.0, (p.y*.2+2.3)*anim);\r\n    float n = NoiseWrap(a)*40.0-23.0;\r\n\tn = n * smoothstep(85.0, 50.0, l);\r\n\tf = f + n;\r\n\tf = mix(dot(p, p)-2380.0, f, pow(anim, .05));\r\n\t\r\n\t// Stem...\r\n\tn = Cylinder(p-vec3(0.0, -100, 0.0), vec2(4.0, 100.0));\r\n\tif (n < f)\r\n\t{\r\n\t\tmat = 1.0;\r\n\t\tf = n;\r\n\t}\r\n\treturn vec2(f, mat);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat a = pow(1.0-max(rd.y, 0.0), 2.0);\r\n\tvec3 c1 = mix(vec3(0.52, .65, .65),vec3(.8), a);\r\n\tvec3 c2 = vec3(.26, .29, .24);\r\n\tfloat f = Noise(rd.xy*4.0)*.3 + Noise(rd.xy*10.0)*.1;\r\n\tfloat r = smoothstep(-0.1, .1, -rd.y-f+.2);\r\n\treturn mix(c1, c2, clamp(r, 0.0, 1.0));\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Shadow(in vec3 ro, in vec3 rd)\r\n{\r\n\tfloat res = 1.0;\r\n    float t = 2.0;\r\n\tfloat h = 0.0;\r\n    \r\n\tfor (int i = 0; i < 20; i++)\r\n\t{\r\n\t\th = Map(ro + rd * t).x;\r\n\t\tres = min(h / t, res);\r\n\t\tt += h*.02+.35;\r\n\t}\r\n\t\r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n//----------------------------------------------------------------------------------------\r\nvec3 Normal(in vec3 pos, in float t)\r\n{\r\n\tvec2  eps = vec2(.25,0.0);\r\n\tvec3 nor = vec3(Map(pos+eps.xyy).x - Map(pos-eps.xyy).x,\r\n\t\t\t\t\tMap(pos+eps.yxy).x - Map(pos-eps.yxy).x,\r\n\t\t\t\t\tMap(pos+eps.yyx).x - Map(pos-eps.yyx).x);\r\n\treturn normalize(nor);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 DoLighting(in vec3 pos, in vec3 ray, in vec3 nor, in vec2 t)\r\n{\r\n\tfloat sha = Shadow(pos, sunLight)*.9 + .1;\r\n\tvec3 mat;\r\n\tif (t.y < 0.5) \r\n\t{\r\n\t\t//pos.y *= 2.5;\r\n\t\tfloat anim = min(sqrt(iTime*.1+0.01) +.2, 1.);\r\n\t\tmat = vec3(.8, .0, .0);\r\n\t\tfloat t = -.9+smoothstep(-50.0, -400.0, pos.y*2.2);\r\n\t\tpos.zy = Rotate2D(pos.zy, t);\r\n\t\tfloat l = dot(pos.xz, pos.xz) * .0162+14.5;\r\n\t\tt = (50.0 / (l+.5));\r\n\t\tpos.xz = Rotate2D(pos.xz, t*anim);\r\n\t\tpos /= pow(anim, 1.0);\r\n\t\tmat += vec3(.3,.3,.3)*Noise(pos.xz*1.5) * anim*anim * .35;\r\n\t\tmat += vec3(.8,.5,.3)*Noise(pos.xz*.25) * clamp(l*.2-13., 0.0, 1.0);\r\n\r\n\t}else\r\n\t{\r\n\t\tmat = mix(vec3(.1, .4, .05), vec3(.0,.2, 0.0), Noise(pos.xy*vec2(1.0, .3)));\r\n\t}\r\n\t\r\n\tvec3 col = mat * max(dot(sunLight, nor), 0.0) * sha + mat*.05;\r\n\tvec3 ref = reflect(ray, nor);\r\n\tfloat spec = pow(max(dot(sunLight, ref), 0.0), 10.0);\r\n\tcol += vec3(.3, 0.15, .05) * spec * sha;\r\n\treturn clamp(col, 0.0, 1.0);\r\n}\r\n\r\n//----------------------------------------------------------------------------------------\r\nvec2 RayMarch( in vec3 ro, in vec3 rd )\r\n{\r\n    float h;\r\n    float t\t\t = 53.0 - 3.5* Hash(coord * iTime);\r\n\tvec2 res\t = vec2(200.0, -1.0);\r\n\tbool hit\t = false;\r\n\r\n\tfor( int i = 0; i < 220; i++ )\r\n    {\r\n\t\tif (!hit && t < 220.0)\r\n\t\t{\r\n\t\t\tvec2 h = Map(ro + rd * t);\r\n\t\t\tif (h.x < 0.0)\r\n\t\t\t{\r\n\t\t\t\tres = vec2(t, h.y);\r\n\t\t\t\thit = true;\r\n\t\t\t}\r\n\t\t\tt += h.x * .036 + t * .001;\r\n\t\t}\r\n    }\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\r\n\treturn vec3(p.x+420.0,  0.0, -655.0+p.y);\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvec3 PostEffects(vec3 rgb, vec2 xy)\r\n{\r\n\t// Gamma first...\r\n\trgb = pow(rgb, vec3(0.45));\r\n\t// Then saturation...\r\n\trgb = clamp(mix(  vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, 1.3), 0.0, 1.0);\r\n\t\r\n\t// Vignette...\r\n\trgb *= .4+0.4*pow(60.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3 );\t\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat gTime = -iTime-2.3;\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n    coord = fragCoord;\r\n\t\r\n\tfloat hTime = mod(gTime+1.85, 2.0);\r\n\t\r\n\tvec3 camPos = vec3(sin(gTime*.3)*50.0, -10.0, -102.0);\r\n\tvec3 camTar  = vec3(0.0, -10.0, 0.0);\r\n\r\n\tfloat roll = .2*sin(gTime*.13+1.2);\r\n\tvec3 cw = normalize(camTar-camPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 ray = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\r\n\tvec3 col;\r\n\r\n\tvec2 t = RayMarch(camPos, ray);\r\n\tif(t.y >= 0.0)\r\n\t{\r\n\t\tvec3 pos = camPos + t.x * ray;\r\n\t\tvec3 nor = Normal(pos, t.x);\r\n\t\tcol = DoLighting(pos, ray, nor, t);\r\n\t}else\r\n\t{\r\n\t\tcol = GetSky(ray);\r\n\t}\r\n\r\n\tcol = PostEffects(col, xy);\t\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------","inputs":[],"outputs":[],"code":"// Rose. By David Hoskins. Jan 2014.\r\n// https://www.shadertoy.com/view/ldBGDh\r\n\r\n#define PI 3.14159265359\r\n#define MOD3 vec3(.1143,.12369,.13787)\r\n\r\nvec3 sunLight  = normalize( vec3(  .8, .7,  -0.5 ) );\r\nfloat gTime = 0.0;\r\nvec2 coord;\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract(p3.x * p3.y * p3.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat HashWrap(in vec2 p)\r\n{\r\n\tp.x = mod(p.x, 10.0);\r\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract(p3.x * p3.y * p3.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise(in vec2 p)\r\n{\r\n\tvec2 f = fract(p);\r\n    p = floor(p);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = mix(mix(Hash(p),\r\n\t\t\t\t\t\tHash(p + vec2(1.0, 0.0)), f.x),\r\n\t\t\t\t\tmix(Hash(p + vec2(0.0, 1.0)),\r\n\t\t\t\t\t\tHash(p + vec2(1.0, 1.0)), f.x), f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat NoiseWrap(in vec2 p)\r\n{\r\n\tvec2 f = fract(p);\r\n    p = floor(p);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = mix(mix(HashWrap(p),\r\n\t\t\t\t\t\tHashWrap(p + vec2(1.0, 0.0)), f.x),\r\n\t\t\t\t\tmix(HashWrap(p + vec2(0.0, 1.0)),\r\n\t\t\t\t\t\tHashWrap(p + vec2(1.0, 1.0)), f.x), f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Cylinder( vec3 p, vec2 h )\r\n{\r\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Rotate2D( vec2 p, float a)\r\n{\r\n\tfloat si = sin(a);\r\n\tfloat co = cos(a);\r\n\treturn mat2(co, si, -si, co) * p;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Map(in vec3 p)\r\n{\r\n\tvec2 a;\r\n\tfloat mat = 0.0;\r\n\tfloat anim = min(sqrt(iTime*.1+0.01) +.2, 1.);\r\n\t\r\n\t// Tilt depending on height...\r\n\tfloat t = -.9+smoothstep(-50.0, -400.0, p.y*2.2);\r\n\tp.zy = Rotate2D(p.zy, t);\r\n\tfloat f = length(p*vec3(1.0, 2.5, 1.0))-50.0;\r\n\t\r\n\t// Spin faster around centre...\r\n\tfloat l = dot(p.xz, p.xz) * .0162+.5;\r\n\tt = sqrt(50.0 / (l+.5));\r\n\tp.xz = Rotate2D(p.xz, t*anim*anim);\r\n\t\r\n\t// arctan needs to wrap in the noise function...\r\n\ta.x = (atan(p.x, p.z)+PI)/ (2.0 * PI) * 10.0;\r\n\ta.y  = pow(l, .35)*11.3;\r\n\ta.y *= smoothstep(15.0/(anim*anim), 0.0, (p.y*.2+2.3)*anim);\r\n    float n = NoiseWrap(a)*40.0-23.0;\r\n\tn = n * smoothstep(85.0, 50.0, l);\r\n\tf = f + n;\r\n\tf = mix(dot(p, p)-2380.0, f, pow(anim, .05));\r\n\t\r\n\t// Stem...\r\n\tn = Cylinder(p-vec3(0.0, -100, 0.0), vec2(4.0, 100.0));\r\n\tif (n < f)\r\n\t{\r\n\t\tmat = 1.0;\r\n\t\tf = n;\r\n\t}\r\n\treturn vec2(f, mat);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat a = pow(1.0-max(rd.y, 0.0), 2.0);\r\n\tvec3 c1 = mix(vec3(0.52, .65, .65),vec3(.8), a);\r\n\tvec3 c2 = vec3(.26, .29, .24);\r\n\tfloat f = Noise(rd.xy*4.0)*.3 + Noise(rd.xy*10.0)*.1;\r\n\tfloat r = smoothstep(-0.1, .1, -rd.y-f+.2);\r\n\treturn mix(c1, c2, clamp(r, 0.0, 1.0));\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Shadow(in vec3 ro, in vec3 rd)\r\n{\r\n\tfloat res = 1.0;\r\n    float t = 2.0;\r\n\tfloat h = 0.0;\r\n    \r\n\tfor (int i = 0; i < 20; i++)\r\n\t{\r\n\t\th = Map(ro + rd * t).x;\r\n\t\tres = min(h / t, res);\r\n\t\tt += h*.02+.35;\r\n\t}\r\n\t\r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n//----------------------------------------------------------------------------------------\r\nvec3 Normal(in vec3 pos, in float t)\r\n{\r\n\tvec2  eps = vec2(.25,0.0);\r\n\tvec3 nor = vec3(Map(pos+eps.xyy).x - Map(pos-eps.xyy).x,\r\n\t\t\t\t\tMap(pos+eps.yxy).x - Map(pos-eps.yxy).x,\r\n\t\t\t\t\tMap(pos+eps.yyx).x - Map(pos-eps.yyx).x);\r\n\treturn normalize(nor);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 DoLighting(in vec3 pos, in vec3 ray, in vec3 nor, in vec2 t)\r\n{\r\n\tfloat sha = Shadow(pos, sunLight)*.9 + .1;\r\n\tvec3 mat;\r\n\tif (t.y < 0.5) \r\n\t{\r\n\t\t//pos.y *= 2.5;\r\n\t\tfloat anim = min(sqrt(iTime*.1+0.01) +.2, 1.);\r\n\t\tmat = vec3(.8, .0, .0);\r\n\t\tfloat t = -.9+smoothstep(-50.0, -400.0, pos.y*2.2);\r\n\t\tpos.zy = Rotate2D(pos.zy, t);\r\n\t\tfloat l = dot(pos.xz, pos.xz) * .0162+14.5;\r\n\t\tt = (50.0 / (l+.5));\r\n\t\tpos.xz = Rotate2D(pos.xz, t*anim);\r\n\t\tpos /= pow(anim, 1.0);\r\n\t\tmat += vec3(.3,.3,.3)*Noise(pos.xz*1.5) * anim*anim * .35;\r\n\t\tmat += vec3(.8,.5,.3)*Noise(pos.xz*.25) * clamp(l*.2-13., 0.0, 1.0);\r\n\r\n\t}else\r\n\t{\r\n\t\tmat = mix(vec3(.1, .4, .05), vec3(.0,.2, 0.0), Noise(pos.xy*vec2(1.0, .3)));\r\n\t}\r\n\t\r\n\tvec3 col = mat * max(dot(sunLight, nor), 0.0) * sha + mat*.05;\r\n\tvec3 ref = reflect(ray, nor);\r\n\tfloat spec = pow(max(dot(sunLight, ref), 0.0), 10.0);\r\n\tcol += vec3(.3, 0.15, .05) * spec * sha;\r\n\treturn clamp(col, 0.0, 1.0);\r\n}\r\n\r\n//----------------------------------------------------------------------------------------\r\nvec2 RayMarch( in vec3 ro, in vec3 rd )\r\n{\r\n    float h;\r\n    float t\t\t = 53.0 - 3.5* Hash(coord * iTime);\r\n\tvec2 res\t = vec2(200.0, -1.0);\r\n\tbool hit\t = false;\r\n\r\n\tfor( int i = 0; i < 220; i++ )\r\n    {\r\n\t\tif (!hit && t < 220.0)\r\n\t\t{\r\n\t\t\tvec2 h = Map(ro + rd * t);\r\n\t\t\tif (h.x < 0.0)\r\n\t\t\t{\r\n\t\t\t\tres = vec2(t, h.y);\r\n\t\t\t\thit = true;\r\n\t\t\t}\r\n\t\t\tt += h.x * .036 + t * .001;\r\n\t\t}\r\n    }\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\r\n\treturn vec3(p.x+420.0,  0.0, -655.0+p.y);\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvec3 PostEffects(vec3 rgb, vec2 xy)\r\n{\r\n\t// Gamma first...\r\n\trgb = pow(rgb, vec3(0.45));\r\n\t// Then saturation...\r\n\trgb = clamp(mix(  vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, 1.3), 0.0, 1.0);\r\n\t\r\n\t// Vignette...\r\n\trgb *= .4+0.4*pow(60.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3 );\t\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat gTime = -iTime-2.3;\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n    coord = fragCoord;\r\n\t\r\n\tfloat hTime = mod(gTime+1.85, 2.0);\r\n\t\r\n\tvec3 camPos = vec3(sin(gTime*.3)*50.0, -10.0, -102.0);\r\n\tvec3 camTar  = vec3(0.0, -10.0, 0.0);\r\n\r\n\tfloat roll = .2*sin(gTime*.13+1.2);\r\n\tvec3 cw = normalize(camTar-camPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 ray = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\r\n\tvec3 col;\r\n\r\n\tvec2 t = RayMarch(camPos, ray);\r\n\tif(t.y >= 0.0)\r\n\t{\r\n\t\tvec3 pos = camPos + t.x * ray;\r\n\t\tvec3 nor = Normal(pos, t.x);\r\n\t\tcol = DoLighting(pos, ray, nor, t);\r\n\t}else\r\n\t{\r\n\t\tcol = GetSky(ray);\r\n\t}\r\n\r\n\tcol = PostEffects(col, xy);\t\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Rose","id":"4c7511aa44b84787a3097a3a78a33082","date":null,"viewed":0,"name":"Rose","description":"I had to use an X wrapped 2D noise, so the atan result would repeat properly when passing through 360 degrees.\nhttps://www.shadertoy.com/view/ldBGDh","likes":0,"published":null,"tags":["3d"," raymarching"," flower"," rose"]},"ver":null,"info":{"Name":"Rose","id":"4c7511aa44b84787a3097a3a78a33082","date":null,"viewed":0,"name":"Rose","description":"I had to use an X wrapped 2D noise, so the atan result would repeat properly when passing through 360 degrees.\nhttps://www.shadertoy.com/view/ldBGDh","likes":0,"published":null,"tags":["3d"," raymarching"," flower"," rose"]},"renderpass":[{"Code":"// Rose. By David Hoskins. Jan 2014.\r\n// https://www.shadertoy.com/view/ldBGDh\r\n\r\n#define PI 3.14159265359\r\n#define MOD3 vec3(.1143,.12369,.13787)\r\n\r\nvec3 sunLight  = normalize( vec3(  .8, .7,  -0.5 ) );\r\nfloat gTime = 0.0;\r\nvec2 coord;\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract(p3.x * p3.y * p3.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat HashWrap(in vec2 p)\r\n{\r\n\tp.x = mod(p.x, 10.0);\r\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract(p3.x * p3.y * p3.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise(in vec2 p)\r\n{\r\n\tvec2 f = fract(p);\r\n    p = floor(p);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = mix(mix(Hash(p),\r\n\t\t\t\t\t\tHash(p + vec2(1.0, 0.0)), f.x),\r\n\t\t\t\t\tmix(Hash(p + vec2(0.0, 1.0)),\r\n\t\t\t\t\t\tHash(p + vec2(1.0, 1.0)), f.x), f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat NoiseWrap(in vec2 p)\r\n{\r\n\tvec2 f = fract(p);\r\n    p = floor(p);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = mix(mix(HashWrap(p),\r\n\t\t\t\t\t\tHashWrap(p + vec2(1.0, 0.0)), f.x),\r\n\t\t\t\t\tmix(HashWrap(p + vec2(0.0, 1.0)),\r\n\t\t\t\t\t\tHashWrap(p + vec2(1.0, 1.0)), f.x), f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Cylinder( vec3 p, vec2 h )\r\n{\r\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Rotate2D( vec2 p, float a)\r\n{\r\n\tfloat si = sin(a);\r\n\tfloat co = cos(a);\r\n\treturn mat2(co, si, -si, co) * p;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Map(in vec3 p)\r\n{\r\n\tvec2 a;\r\n\tfloat mat = 0.0;\r\n\tfloat anim = min(sqrt(iTime*.1+0.01) +.2, 1.);\r\n\t\r\n\t// Tilt depending on height...\r\n\tfloat t = -.9+smoothstep(-50.0, -400.0, p.y*2.2);\r\n\tp.zy = Rotate2D(p.zy, t);\r\n\tfloat f = length(p*vec3(1.0, 2.5, 1.0))-50.0;\r\n\t\r\n\t// Spin faster around centre...\r\n\tfloat l = dot(p.xz, p.xz) * .0162+.5;\r\n\tt = sqrt(50.0 / (l+.5));\r\n\tp.xz = Rotate2D(p.xz, t*anim*anim);\r\n\t\r\n\t// arctan needs to wrap in the noise function...\r\n\ta.x = (atan(p.x, p.z)+PI)/ (2.0 * PI) * 10.0;\r\n\ta.y  = pow(l, .35)*11.3;\r\n\ta.y *= smoothstep(15.0/(anim*anim), 0.0, (p.y*.2+2.3)*anim);\r\n    float n = NoiseWrap(a)*40.0-23.0;\r\n\tn = n * smoothstep(85.0, 50.0, l);\r\n\tf = f + n;\r\n\tf = mix(dot(p, p)-2380.0, f, pow(anim, .05));\r\n\t\r\n\t// Stem...\r\n\tn = Cylinder(p-vec3(0.0, -100, 0.0), vec2(4.0, 100.0));\r\n\tif (n < f)\r\n\t{\r\n\t\tmat = 1.0;\r\n\t\tf = n;\r\n\t}\r\n\treturn vec2(f, mat);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat a = pow(1.0-max(rd.y, 0.0), 2.0);\r\n\tvec3 c1 = mix(vec3(0.52, .65, .65),vec3(.8), a);\r\n\tvec3 c2 = vec3(.26, .29, .24);\r\n\tfloat f = Noise(rd.xy*4.0)*.3 + Noise(rd.xy*10.0)*.1;\r\n\tfloat r = smoothstep(-0.1, .1, -rd.y-f+.2);\r\n\treturn mix(c1, c2, clamp(r, 0.0, 1.0));\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Shadow(in vec3 ro, in vec3 rd)\r\n{\r\n\tfloat res = 1.0;\r\n    float t = 2.0;\r\n\tfloat h = 0.0;\r\n    \r\n\tfor (int i = 0; i < 20; i++)\r\n\t{\r\n\t\th = Map(ro + rd * t).x;\r\n\t\tres = min(h / t, res);\r\n\t\tt += h*.02+.35;\r\n\t}\r\n\t\r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n//----------------------------------------------------------------------------------------\r\nvec3 Normal(in vec3 pos, in float t)\r\n{\r\n\tvec2  eps = vec2(.25,0.0);\r\n\tvec3 nor = vec3(Map(pos+eps.xyy).x - Map(pos-eps.xyy).x,\r\n\t\t\t\t\tMap(pos+eps.yxy).x - Map(pos-eps.yxy).x,\r\n\t\t\t\t\tMap(pos+eps.yyx).x - Map(pos-eps.yyx).x);\r\n\treturn normalize(nor);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 DoLighting(in vec3 pos, in vec3 ray, in vec3 nor, in vec2 t)\r\n{\r\n\tfloat sha = Shadow(pos, sunLight)*.9 + .1;\r\n\tvec3 mat;\r\n\tif (t.y < 0.5) \r\n\t{\r\n\t\t//pos.y *= 2.5;\r\n\t\tfloat anim = min(sqrt(iTime*.1+0.01) +.2, 1.);\r\n\t\tmat = vec3(.8, .0, .0);\r\n\t\tfloat t = -.9+smoothstep(-50.0, -400.0, pos.y*2.2);\r\n\t\tpos.zy = Rotate2D(pos.zy, t);\r\n\t\tfloat l = dot(pos.xz, pos.xz) * .0162+14.5;\r\n\t\tt = (50.0 / (l+.5));\r\n\t\tpos.xz = Rotate2D(pos.xz, t*anim);\r\n\t\tpos /= pow(anim, 1.0);\r\n\t\tmat += vec3(.3,.3,.3)*Noise(pos.xz*1.5) * anim*anim * .35;\r\n\t\tmat += vec3(.8,.5,.3)*Noise(pos.xz*.25) * clamp(l*.2-13., 0.0, 1.0);\r\n\r\n\t}else\r\n\t{\r\n\t\tmat = mix(vec3(.1, .4, .05), vec3(.0,.2, 0.0), Noise(pos.xy*vec2(1.0, .3)));\r\n\t}\r\n\t\r\n\tvec3 col = mat * max(dot(sunLight, nor), 0.0) * sha + mat*.05;\r\n\tvec3 ref = reflect(ray, nor);\r\n\tfloat spec = pow(max(dot(sunLight, ref), 0.0), 10.0);\r\n\tcol += vec3(.3, 0.15, .05) * spec * sha;\r\n\treturn clamp(col, 0.0, 1.0);\r\n}\r\n\r\n//----------------------------------------------------------------------------------------\r\nvec2 RayMarch( in vec3 ro, in vec3 rd )\r\n{\r\n    float h;\r\n    float t\t\t = 53.0 - 3.5* Hash(coord * iTime);\r\n\tvec2 res\t = vec2(200.0, -1.0);\r\n\tbool hit\t = false;\r\n\r\n\tfor( int i = 0; i < 220; i++ )\r\n    {\r\n\t\tif (!hit && t < 220.0)\r\n\t\t{\r\n\t\t\tvec2 h = Map(ro + rd * t);\r\n\t\t\tif (h.x < 0.0)\r\n\t\t\t{\r\n\t\t\t\tres = vec2(t, h.y);\r\n\t\t\t\thit = true;\r\n\t\t\t}\r\n\t\t\tt += h.x * .036 + t * .001;\r\n\t\t}\r\n    }\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\r\n\treturn vec3(p.x+420.0,  0.0, -655.0+p.y);\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvec3 PostEffects(vec3 rgb, vec2 xy)\r\n{\r\n\t// Gamma first...\r\n\trgb = pow(rgb, vec3(0.45));\r\n\t// Then saturation...\r\n\trgb = clamp(mix(  vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, 1.3), 0.0, 1.0);\r\n\t\r\n\t// Vignette...\r\n\trgb *= .4+0.4*pow(60.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3 );\t\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat gTime = -iTime-2.3;\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n    coord = fragCoord;\r\n\t\r\n\tfloat hTime = mod(gTime+1.85, 2.0);\r\n\t\r\n\tvec3 camPos = vec3(sin(gTime*.3)*50.0, -10.0, -102.0);\r\n\tvec3 camTar  = vec3(0.0, -10.0, 0.0);\r\n\r\n\tfloat roll = .2*sin(gTime*.13+1.2);\r\n\tvec3 cw = normalize(camTar-camPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 ray = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\r\n\tvec3 col;\r\n\r\n\tvec2 t = RayMarch(camPos, ray);\r\n\tif(t.y >= 0.0)\r\n\t{\r\n\t\tvec3 pos = camPos + t.x * ray;\r\n\t\tvec3 nor = Normal(pos, t.x);\r\n\t\tcol = DoLighting(pos, ray, nor, t);\r\n\t}else\r\n\t{\r\n\t\tcol = GetSky(ray);\r\n\t}\r\n\r\n\tcol = PostEffects(col, xy);\t\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------","inputs":[],"outputs":[],"code":"// Rose. By David Hoskins. Jan 2014.\r\n// https://www.shadertoy.com/view/ldBGDh\r\n\r\n#define PI 3.14159265359\r\n#define MOD3 vec3(.1143,.12369,.13787)\r\n\r\nvec3 sunLight  = normalize( vec3(  .8, .7,  -0.5 ) );\r\nfloat gTime = 0.0;\r\nvec2 coord;\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Hash(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract(p3.x * p3.y * p3.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat HashWrap(in vec2 p)\r\n{\r\n\tp.x = mod(p.x, 10.0);\r\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract(p3.x * p3.y * p3.z);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Noise(in vec2 p)\r\n{\r\n\tvec2 f = fract(p);\r\n    p = floor(p);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = mix(mix(Hash(p),\r\n\t\t\t\t\t\tHash(p + vec2(1.0, 0.0)), f.x),\r\n\t\t\t\t\tmix(Hash(p + vec2(0.0, 1.0)),\r\n\t\t\t\t\t\tHash(p + vec2(1.0, 1.0)), f.x), f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat NoiseWrap(in vec2 p)\r\n{\r\n\tvec2 f = fract(p);\r\n    p = floor(p);\r\n    f = f*f*(3.0-2.0*f);\r\n    float res = mix(mix(HashWrap(p),\r\n\t\t\t\t\t\tHashWrap(p + vec2(1.0, 0.0)), f.x),\r\n\t\t\t\t\tmix(HashWrap(p + vec2(0.0, 1.0)),\r\n\t\t\t\t\t\tHashWrap(p + vec2(1.0, 1.0)), f.x), f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Cylinder( vec3 p, vec2 h )\r\n{\r\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Rotate2D( vec2 p, float a)\r\n{\r\n\tfloat si = sin(a);\r\n\tfloat co = cos(a);\r\n\treturn mat2(co, si, -si, co) * p;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec2 Map(in vec3 p)\r\n{\r\n\tvec2 a;\r\n\tfloat mat = 0.0;\r\n\tfloat anim = min(sqrt(iTime*.1+0.01) +.2, 1.);\r\n\t\r\n\t// Tilt depending on height...\r\n\tfloat t = -.9+smoothstep(-50.0, -400.0, p.y*2.2);\r\n\tp.zy = Rotate2D(p.zy, t);\r\n\tfloat f = length(p*vec3(1.0, 2.5, 1.0))-50.0;\r\n\t\r\n\t// Spin faster around centre...\r\n\tfloat l = dot(p.xz, p.xz) * .0162+.5;\r\n\tt = sqrt(50.0 / (l+.5));\r\n\tp.xz = Rotate2D(p.xz, t*anim*anim);\r\n\t\r\n\t// arctan needs to wrap in the noise function...\r\n\ta.x = (atan(p.x, p.z)+PI)/ (2.0 * PI) * 10.0;\r\n\ta.y  = pow(l, .35)*11.3;\r\n\ta.y *= smoothstep(15.0/(anim*anim), 0.0, (p.y*.2+2.3)*anim);\r\n    float n = NoiseWrap(a)*40.0-23.0;\r\n\tn = n * smoothstep(85.0, 50.0, l);\r\n\tf = f + n;\r\n\tf = mix(dot(p, p)-2380.0, f, pow(anim, .05));\r\n\t\r\n\t// Stem...\r\n\tn = Cylinder(p-vec3(0.0, -100, 0.0), vec2(4.0, 100.0));\r\n\tif (n < f)\r\n\t{\r\n\t\tmat = 1.0;\r\n\t\tf = n;\r\n\t}\r\n\treturn vec2(f, mat);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat a = pow(1.0-max(rd.y, 0.0), 2.0);\r\n\tvec3 c1 = mix(vec3(0.52, .65, .65),vec3(.8), a);\r\n\tvec3 c2 = vec3(.26, .29, .24);\r\n\tfloat f = Noise(rd.xy*4.0)*.3 + Noise(rd.xy*10.0)*.1;\r\n\tfloat r = smoothstep(-0.1, .1, -rd.y-f+.2);\r\n\treturn mix(c1, c2, clamp(r, 0.0, 1.0));\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Shadow(in vec3 ro, in vec3 rd)\r\n{\r\n\tfloat res = 1.0;\r\n    float t = 2.0;\r\n\tfloat h = 0.0;\r\n    \r\n\tfor (int i = 0; i < 20; i++)\r\n\t{\r\n\t\th = Map(ro + rd * t).x;\r\n\t\tres = min(h / t, res);\r\n\t\tt += h*.02+.35;\r\n\t}\r\n\t\r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n//----------------------------------------------------------------------------------------\r\nvec3 Normal(in vec3 pos, in float t)\r\n{\r\n\tvec2  eps = vec2(.25,0.0);\r\n\tvec3 nor = vec3(Map(pos+eps.xyy).x - Map(pos-eps.xyy).x,\r\n\t\t\t\t\tMap(pos+eps.yxy).x - Map(pos-eps.yxy).x,\r\n\t\t\t\t\tMap(pos+eps.yyx).x - Map(pos-eps.yyx).x);\r\n\treturn normalize(nor);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 DoLighting(in vec3 pos, in vec3 ray, in vec3 nor, in vec2 t)\r\n{\r\n\tfloat sha = Shadow(pos, sunLight)*.9 + .1;\r\n\tvec3 mat;\r\n\tif (t.y < 0.5) \r\n\t{\r\n\t\t//pos.y *= 2.5;\r\n\t\tfloat anim = min(sqrt(iTime*.1+0.01) +.2, 1.);\r\n\t\tmat = vec3(.8, .0, .0);\r\n\t\tfloat t = -.9+smoothstep(-50.0, -400.0, pos.y*2.2);\r\n\t\tpos.zy = Rotate2D(pos.zy, t);\r\n\t\tfloat l = dot(pos.xz, pos.xz) * .0162+14.5;\r\n\t\tt = (50.0 / (l+.5));\r\n\t\tpos.xz = Rotate2D(pos.xz, t*anim);\r\n\t\tpos /= pow(anim, 1.0);\r\n\t\tmat += vec3(.3,.3,.3)*Noise(pos.xz*1.5) * anim*anim * .35;\r\n\t\tmat += vec3(.8,.5,.3)*Noise(pos.xz*.25) * clamp(l*.2-13., 0.0, 1.0);\r\n\r\n\t}else\r\n\t{\r\n\t\tmat = mix(vec3(.1, .4, .05), vec3(.0,.2, 0.0), Noise(pos.xy*vec2(1.0, .3)));\r\n\t}\r\n\t\r\n\tvec3 col = mat * max(dot(sunLight, nor), 0.0) * sha + mat*.05;\r\n\tvec3 ref = reflect(ray, nor);\r\n\tfloat spec = pow(max(dot(sunLight, ref), 0.0), 10.0);\r\n\tcol += vec3(.3, 0.15, .05) * spec * sha;\r\n\treturn clamp(col, 0.0, 1.0);\r\n}\r\n\r\n//----------------------------------------------------------------------------------------\r\nvec2 RayMarch( in vec3 ro, in vec3 rd )\r\n{\r\n    float h;\r\n    float t\t\t = 53.0 - 3.5* Hash(coord * iTime);\r\n\tvec2 res\t = vec2(200.0, -1.0);\r\n\tbool hit\t = false;\r\n\r\n\tfor( int i = 0; i < 220; i++ )\r\n    {\r\n\t\tif (!hit && t < 220.0)\r\n\t\t{\r\n\t\t\tvec2 h = Map(ro + rd * t);\r\n\t\t\tif (h.x < 0.0)\r\n\t\t\t{\r\n\t\t\t\tres = vec2(t, h.y);\r\n\t\t\t\thit = true;\r\n\t\t\t}\r\n\t\t\tt += h.x * .036 + t * .001;\r\n\t\t}\r\n    }\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\r\n\treturn vec3(p.x+420.0,  0.0, -655.0+p.y);\r\n} \r\n\r\n//--------------------------------------------------------------------------\r\nvec3 PostEffects(vec3 rgb, vec2 xy)\r\n{\r\n\t// Gamma first...\r\n\trgb = pow(rgb, vec3(0.45));\r\n\t// Then saturation...\r\n\trgb = clamp(mix(  vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, 1.3), 0.0, 1.0);\r\n\t\r\n\t// Vignette...\r\n\trgb *= .4+0.4*pow(60.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3 );\t\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat gTime = -iTime-2.3;\r\n    vec2 xy = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(iResolution.x/iResolution.y,1.0);\r\n    coord = fragCoord;\r\n\t\r\n\tfloat hTime = mod(gTime+1.85, 2.0);\r\n\t\r\n\tvec3 camPos = vec3(sin(gTime*.3)*50.0, -10.0, -102.0);\r\n\tvec3 camTar  = vec3(0.0, -10.0, 0.0);\r\n\r\n\tfloat roll = .2*sin(gTime*.13+1.2);\r\n\tvec3 cw = normalize(camTar-camPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = cross(cw,cp);\r\n\tvec3 cv = cross(cu,cw);\r\n\tvec3 ray = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\r\n\r\n\tvec3 col;\r\n\r\n\tvec2 t = RayMarch(camPos, ray);\r\n\tif(t.y >= 0.0)\r\n\t{\r\n\t\tvec3 pos = camPos + t.x * ray;\r\n\t\tvec3 nor = Normal(pos, t.x);\r\n\t\tcol = DoLighting(pos, ray, nor, t);\r\n\t}else\r\n\t{\r\n\t\tcol = GetSky(ray);\r\n\t}\r\n\r\n\tcol = PostEffects(col, xy);\t\r\n\t\r\n\tfragColor=vec4(col,1.0);\r\n}\r\n\r\n//--------------------------------------------------------------------------","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Seascape ","id":"a9cdcf805dd04ac08fa41c537e6f2872","date":null,"viewed":0,"name":"Seascape ","description":"fully-procedural sea surface computing. without textures.\r\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape\r\nhttps://www.shadertoy.com/view/Ms2SD1","likes":0,"published":null,"tags":["procedural"," noise"," waves"," sea"," water"," subsurface"]},"ver":null,"info":{"Name":"Seascape ","id":"a9cdcf805dd04ac08fa41c537e6f2872","date":null,"viewed":0,"name":"Seascape ","description":"fully-procedural sea surface computing. without textures.\r\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape\r\nhttps://www.shadertoy.com/view/Ms2SD1","likes":0,"published":null,"tags":["procedural"," noise"," waves"," sea"," water"," subsurface"]},"renderpass":[{"Code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Skyline","id":"4a4c45e821064fbc8ce74dc30f117831","date":null,"viewed":0,"name":"Skyline","description":"I have always wanted to make a procedural city. The architecture was limited by what I could do in real-time, but I tried to give it enough complexity that it would look realistic.","likes":0,"published":null,"tags":["procedural"," raymarch"," city"," skyline"]},"ver":null,"info":{"Name":"Skyline","id":"4a4c45e821064fbc8ce74dc30f117831","date":null,"viewed":0,"name":"Skyline","description":"I have always wanted to make a procedural city. The architecture was limited by what I could do in real-time, but I tried to give it enough complexity that it would look realistic.","likes":0,"published":null,"tags":["procedural"," raymarch"," city"," skyline"]},"renderpass":[{"Code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//    \r\n// Testing Sebastian Aaltonen's soft shadow improvement\r\n//\r\n// The technique is based on estimating a better closest point in ray\r\n// at each step by triangulating from the previous march step.\r\n//\r\n// More info about the technique at slide 39 of this presentation:\r\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\r\n//\r\n// Traditional technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\n//\r\n// Go to lines 54 to compare both.\r\n\r\n\r\n// make this 1 is your machine is too slow\r\n#define AA 2\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\r\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\r\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\r\n{\r\n\tfloat res = 1.0;\r\n    float t = mint;\r\n    float ph = 1e10; // big, such that y = 0 on the first iteration\r\n    \r\n    for( int i=0; i<32; i++ )\r\n    {\r\n\t\tfloat h = map( ro + rd*t );\r\n\r\n        // traditional technique\r\n        if( technique==0 )\r\n        {\r\n        \tres = min( res, 10.0*h/t );\r\n        }\r\n        // improved technique\r\n        else\r\n        {\r\n            // use this if you are getting artifact on the first iteration, or unroll the\r\n            // first iteration out of the loop\r\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \r\n\r\n            float y = h*h/(2.0*ph);\r\n            float d = sqrt(h*h-y*y);\r\n            res = min( res, 10.0*d/max(0.0,t-y) );\r\n            ph = h;\r\n        }\r\n        \r\n        t += h;\r\n        \r\n        if( res<0.0001 || t>tmax ) break;\r\n        \r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRay( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin = 1.0;\r\n    float tmax = 20.0;\r\n   \r\n#if 1\r\n    // bounding volume\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n#endif\r\n    \r\n    float t = tmin;\r\n    for( int i=0; i<64; i++ )\r\n    {\r\n\t    float precis = 0.0005*t;\r\n\t    float res = map( ro+rd*t );\r\n        if( res<precis || t>tmax ) break;\r\n        t += res;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return t;\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.001 + 0.15*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\r\n{ \r\n    vec3  col = vec3(0.0);\r\n    float t = castRay(ro,rd);\r\n\r\n    if( t>-0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = calcNormal( pos );\r\n        \r\n        // material        \r\n\t\tvec3 mate = vec3(0.3);\r\n\r\n        // key light\r\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\r\n        vec3  hal = normalize( lig-rd );\r\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \r\n                    calcSoftshadow( pos, lig, 0.01, 3.0, technique );\r\n\r\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\r\n                    dif *\r\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\r\n\r\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\r\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\r\n        \r\n        // ambient light\r\n        float occ = calcAO( pos, nor );\r\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\r\n        \r\n        // fog\r\n        col *= exp( -0.0005*t*t*t );\r\n    }\r\n\r\n\treturn col;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // camera\t\r\n    float an = 12.0 - sin(0.1*iTime);\r\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\r\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\r\n    // camera-to-world transformation\r\n    mat3 ca = setCamera( ro, ta, 0.0 );\r\n\r\n    int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\r\n\r\n    vec3 tot = vec3(0.0);\r\n#if AA>1\r\n    for( int m=0; m<AA; m++ )\r\n    for( int n=0; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n#else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n#endif\r\n\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\r\n\r\n        // render\t\r\n        vec3 col = render( ro, rd, technique);\r\n\r\n\t\t// gamma\r\n        col = pow( col, vec3(0.4545) );\r\n\r\n        tot += col;\r\n#if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n#endif\r\n\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"//    \r\n// Testing Sebastian Aaltonen's soft shadow improvement\r\n//\r\n// The technique is based on estimating a better closest point in ray\r\n// at each step by triangulating from the previous march step.\r\n//\r\n// More info about the technique at slide 39 of this presentation:\r\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\r\n//\r\n// Traditional technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\n//\r\n// Go to lines 54 to compare both.\r\n\r\n\r\n// make this 1 is your machine is too slow\r\n#define AA 2\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\r\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\r\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\r\n{\r\n\tfloat res = 1.0;\r\n    float t = mint;\r\n    float ph = 1e10; // big, such that y = 0 on the first iteration\r\n    \r\n    for( int i=0; i<32; i++ )\r\n    {\r\n\t\tfloat h = map( ro + rd*t );\r\n\r\n        // traditional technique\r\n        if( technique==0 )\r\n        {\r\n        \tres = min( res, 10.0*h/t );\r\n        }\r\n        // improved technique\r\n        else\r\n        {\r\n            // use this if you are getting artifact on the first iteration, or unroll the\r\n            // first iteration out of the loop\r\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \r\n\r\n            float y = h*h/(2.0*ph);\r\n            float d = sqrt(h*h-y*y);\r\n            res = min( res, 10.0*d/max(0.0,t-y) );\r\n            ph = h;\r\n        }\r\n        \r\n        t += h;\r\n        \r\n        if( res<0.0001 || t>tmax ) break;\r\n        \r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRay( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin = 1.0;\r\n    float tmax = 20.0;\r\n   \r\n#if 1\r\n    // bounding volume\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n#endif\r\n    \r\n    float t = tmin;\r\n    for( int i=0; i<64; i++ )\r\n    {\r\n\t    float precis = 0.0005*t;\r\n\t    float res = map( ro+rd*t );\r\n        if( res<precis || t>tmax ) break;\r\n        t += res;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return t;\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.001 + 0.15*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\r\n{ \r\n    vec3  col = vec3(0.0);\r\n    float t = castRay(ro,rd);\r\n\r\n    if( t>-0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = calcNormal( pos );\r\n        \r\n        // material        \r\n\t\tvec3 mate = vec3(0.3);\r\n\r\n        // key light\r\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\r\n        vec3  hal = normalize( lig-rd );\r\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \r\n                    calcSoftshadow( pos, lig, 0.01, 3.0, technique );\r\n\r\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\r\n                    dif *\r\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\r\n\r\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\r\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\r\n        \r\n        // ambient light\r\n        float occ = calcAO( pos, nor );\r\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\r\n        \r\n        // fog\r\n        col *= exp( -0.0005*t*t*t );\r\n    }\r\n\r\n\treturn col;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // camera\t\r\n    float an = 12.0 - sin(0.1*iTime);\r\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\r\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\r\n    // camera-to-world transformation\r\n    mat3 ca = setCamera( ro, ta, 0.0 );\r\n\r\n    int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\r\n\r\n    vec3 tot = vec3(0.0);\r\n#if AA>1\r\n    for( int m=0; m<AA; m++ )\r\n    for( int n=0; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n#else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n#endif\r\n\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\r\n\r\n        // render\t\r\n        vec3 col = render( ro, rd, technique);\r\n\r\n\t\t// gamma\r\n        col = pow( col, vec3(0.4545) );\r\n\r\n        tot += col;\r\n#if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n#endif\r\n\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Soft Shadow Variation ","id":"17beb202be014d28a1c23695f553aa3e","date":null,"viewed":0,"name":"Soft Shadow Variation ","description":"Testing Sebastian Aaltonen's soft shadow improvement. Go to line 54 to compare with the traditional technique for soft shadows. It's very cheap and improves shadows a lot!\r\nhttps://www.shadertoy.com/view/lsKcDD","likes":0,"published":null,"tags":["3d"," raymarching"]},"ver":null,"info":{"Name":"Soft Shadow Variation ","id":"17beb202be014d28a1c23695f553aa3e","date":null,"viewed":0,"name":"Soft Shadow Variation ","description":"Testing Sebastian Aaltonen's soft shadow improvement. Go to line 54 to compare with the traditional technique for soft shadows. It's very cheap and improves shadows a lot!\r\nhttps://www.shadertoy.com/view/lsKcDD","likes":0,"published":null,"tags":["3d"," raymarching"]},"renderpass":[{"Code":"//    \r\n// Testing Sebastian Aaltonen's soft shadow improvement\r\n//\r\n// The technique is based on estimating a better closest point in ray\r\n// at each step by triangulating from the previous march step.\r\n//\r\n// More info about the technique at slide 39 of this presentation:\r\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\r\n//\r\n// Traditional technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\n//\r\n// Go to lines 54 to compare both.\r\n\r\n\r\n// make this 1 is your machine is too slow\r\n#define AA 2\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\r\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\r\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\r\n{\r\n\tfloat res = 1.0;\r\n    float t = mint;\r\n    float ph = 1e10; // big, such that y = 0 on the first iteration\r\n    \r\n    for( int i=0; i<32; i++ )\r\n    {\r\n\t\tfloat h = map( ro + rd*t );\r\n\r\n        // traditional technique\r\n        if( technique==0 )\r\n        {\r\n        \tres = min( res, 10.0*h/t );\r\n        }\r\n        // improved technique\r\n        else\r\n        {\r\n            // use this if you are getting artifact on the first iteration, or unroll the\r\n            // first iteration out of the loop\r\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \r\n\r\n            float y = h*h/(2.0*ph);\r\n            float d = sqrt(h*h-y*y);\r\n            res = min( res, 10.0*d/max(0.0,t-y) );\r\n            ph = h;\r\n        }\r\n        \r\n        t += h;\r\n        \r\n        if( res<0.0001 || t>tmax ) break;\r\n        \r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRay( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin = 1.0;\r\n    float tmax = 20.0;\r\n   \r\n#if 1\r\n    // bounding volume\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n#endif\r\n    \r\n    float t = tmin;\r\n    for( int i=0; i<64; i++ )\r\n    {\r\n\t    float precis = 0.0005*t;\r\n\t    float res = map( ro+rd*t );\r\n        if( res<precis || t>tmax ) break;\r\n        t += res;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return t;\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.001 + 0.15*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\r\n{ \r\n    vec3  col = vec3(0.0);\r\n    float t = castRay(ro,rd);\r\n\r\n    if( t>-0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = calcNormal( pos );\r\n        \r\n        // material        \r\n\t\tvec3 mate = vec3(0.3);\r\n\r\n        // key light\r\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\r\n        vec3  hal = normalize( lig-rd );\r\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \r\n                    calcSoftshadow( pos, lig, 0.01, 3.0, technique );\r\n\r\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\r\n                    dif *\r\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\r\n\r\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\r\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\r\n        \r\n        // ambient light\r\n        float occ = calcAO( pos, nor );\r\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\r\n        \r\n        // fog\r\n        col *= exp( -0.0005*t*t*t );\r\n    }\r\n\r\n\treturn col;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // camera\t\r\n    float an = 12.0 - sin(0.1*iTime);\r\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\r\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\r\n    // camera-to-world transformation\r\n    mat3 ca = setCamera( ro, ta, 0.0 );\r\n\r\n    int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\r\n\r\n    vec3 tot = vec3(0.0);\r\n#if AA>1\r\n    for( int m=0; m<AA; m++ )\r\n    for( int n=0; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n#else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n#endif\r\n\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\r\n\r\n        // render\t\r\n        vec3 col = render( ro, rd, technique);\r\n\r\n\t\t// gamma\r\n        col = pow( col, vec3(0.4545) );\r\n\r\n        tot += col;\r\n#if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n#endif\r\n\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"//    \r\n// Testing Sebastian Aaltonen's soft shadow improvement\r\n//\r\n// The technique is based on estimating a better closest point in ray\r\n// at each step by triangulating from the previous march step.\r\n//\r\n// More info about the technique at slide 39 of this presentation:\r\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\r\n//\r\n// Traditional technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\n//\r\n// Go to lines 54 to compare both.\r\n\r\n\r\n// make this 1 is your machine is too slow\r\n#define AA 2\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\r\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\r\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\r\n{\r\n\tfloat res = 1.0;\r\n    float t = mint;\r\n    float ph = 1e10; // big, such that y = 0 on the first iteration\r\n    \r\n    for( int i=0; i<32; i++ )\r\n    {\r\n\t\tfloat h = map( ro + rd*t );\r\n\r\n        // traditional technique\r\n        if( technique==0 )\r\n        {\r\n        \tres = min( res, 10.0*h/t );\r\n        }\r\n        // improved technique\r\n        else\r\n        {\r\n            // use this if you are getting artifact on the first iteration, or unroll the\r\n            // first iteration out of the loop\r\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \r\n\r\n            float y = h*h/(2.0*ph);\r\n            float d = sqrt(h*h-y*y);\r\n            res = min( res, 10.0*d/max(0.0,t-y) );\r\n            ph = h;\r\n        }\r\n        \r\n        t += h;\r\n        \r\n        if( res<0.0001 || t>tmax ) break;\r\n        \r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRay( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin = 1.0;\r\n    float tmax = 20.0;\r\n   \r\n#if 1\r\n    // bounding volume\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n#endif\r\n    \r\n    float t = tmin;\r\n    for( int i=0; i<64; i++ )\r\n    {\r\n\t    float precis = 0.0005*t;\r\n\t    float res = map( ro+rd*t );\r\n        if( res<precis || t>tmax ) break;\r\n        t += res;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return t;\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.001 + 0.15*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\r\n{ \r\n    vec3  col = vec3(0.0);\r\n    float t = castRay(ro,rd);\r\n\r\n    if( t>-0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = calcNormal( pos );\r\n        \r\n        // material        \r\n\t\tvec3 mate = vec3(0.3);\r\n\r\n        // key light\r\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\r\n        vec3  hal = normalize( lig-rd );\r\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \r\n                    calcSoftshadow( pos, lig, 0.01, 3.0, technique );\r\n\r\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\r\n                    dif *\r\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\r\n\r\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\r\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\r\n        \r\n        // ambient light\r\n        float occ = calcAO( pos, nor );\r\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\r\n        \r\n        // fog\r\n        col *= exp( -0.0005*t*t*t );\r\n    }\r\n\r\n\treturn col;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // camera\t\r\n    float an = 12.0 - sin(0.1*iTime);\r\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\r\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\r\n    // camera-to-world transformation\r\n    mat3 ca = setCamera( ro, ta, 0.0 );\r\n\r\n    int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\r\n\r\n    vec3 tot = vec3(0.0);\r\n#if AA>1\r\n    for( int m=0; m<AA; m++ )\r\n    for( int n=0; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n#else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n#endif\r\n\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\r\n\r\n        // render\t\r\n        vec3 col = render( ro, rd, technique);\r\n\r\n\t\t// gamma\r\n        col = pow( col, vec3(0.4545) );\r\n\r\n        tot += col;\r\n#if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n#endif\r\n\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\r\n\r\n/*\r\n\tA soft clip that smoothly blends between the Reinhard tonemapping transfer function and a hard clip.\r\n*/\r\n\r\n\r\n#define Frame float(iFrame)\r\n#define Time iTime\r\n#define PixelCount iResolution.xy\r\n#define clamp01(x) clamp(x, 0.0, 1.0)\r\n#define rsqrt inversesqrt\r\n\r\nconst float Pi = 3.14159265359;\r\nconst float Pi05 = Pi * 0.5;\r\nconst float Pi2  = Pi * 2.0;\r\nconst float RcpPi= 1.0 / Pi;\r\n\r\nfloat Pow2(float x) {return x*x;}\r\nfloat Pow3(float x) {return x*x*x;}\r\nfloat Pow4(float x) {return Pow2(Pow2(x));}\r\n\r\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\r\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\r\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\r\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\r\n\r\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\r\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\r\n\r\n\r\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\r\n\r\nfloat Graph(float f, float b)\r\n{\r\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \r\n}\r\n\r\n\r\nfloat Line(float u, float b) { return Graph(u, b); }\r\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\r\n\r\nfloat Grid(vec2 uv, float b)\r\n{\r\n    float xl = Lines(uv.x, b);    \r\n    float yl = Lines(uv.y, b);\r\n\r\n    return max(xl, yl);\r\n}\r\n\r\nfloat Cross(vec2 uv, float b)\r\n{\r\n    float xl = Line(uv.x, b);    \r\n    float yl = Line(uv.y, b);\r\n\r\n    return max(xl, yl);\r\n}\r\n\r\nfloat Dot(vec2 sp, vec2 dp, float dr)\r\n{\r\n    float v = length(sp - dp) - dr;\r\n    \r\n    if(v > dr) return 0.0;\r\n    \r\n    v *= ddxyRcpLen(v);\r\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\r\n    \r\n    return v;\r\n}\r\n\r\nfloat Reinhard(float x) { return x / (x + 1.0); }\r\nfloat HardClip(float x) { return   min(x, 1.0); }\r\n\r\n// x: [0, inf], s: (-1, 1] / (soft, hard]\r\nfloat SoftClip(float x, float s)\r\n{\r\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\r\n}\r\n\r\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\r\n{\r\n\tvec2 uv = uv0 - 0.5;\r\n    uv0 += .0;\r\n    \r\n    vec2 tex = uv0;\r\n    tex -= iResolution.xy * 0.125;\r\n    tex /= iResolution.xx * 0.125;\r\n\r\n    tex *= 0.25+0.0375;\r\n    \r\n\r\n    vec3 col = vec3(0.0);\r\n    \r\n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \r\n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \r\n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\r\n    \r\n    \r\n    // relevant plotting code:\r\n    \r\n    // black\r\n    col = mix(col, vec3(0.), Graph(HardClip(tex.x) -tex.y, 1.));  \r\n    col = mix(col, vec3(0.), Graph(Reinhard(tex.x) -tex.y, 1.));  \r\n    \r\n    // grey\r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.0) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.55) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.85) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.9921875) -tex.y, 1.) * 0.5);\r\n    \r\n    // red\r\n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(SoftClip(tex.x, max(-0.99, sin(iTime))) -tex.y, 1.));  \r\n\r\n       \r\n    \r\n    #if 1\r\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\r\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\r\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\r\n    #endif\r\n    \r\n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \r\n\r\n}","inputs":[],"outputs":[],"code":"// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\r\n\r\n/*\r\n\tA soft clip that smoothly blends between the Reinhard tonemapping transfer function and a hard clip.\r\n*/\r\n\r\n\r\n#define Frame float(iFrame)\r\n#define Time iTime\r\n#define PixelCount iResolution.xy\r\n#define clamp01(x) clamp(x, 0.0, 1.0)\r\n#define rsqrt inversesqrt\r\n\r\nconst float Pi = 3.14159265359;\r\nconst float Pi05 = Pi * 0.5;\r\nconst float Pi2  = Pi * 2.0;\r\nconst float RcpPi= 1.0 / Pi;\r\n\r\nfloat Pow2(float x) {return x*x;}\r\nfloat Pow3(float x) {return x*x*x;}\r\nfloat Pow4(float x) {return Pow2(Pow2(x));}\r\n\r\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\r\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\r\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\r\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\r\n\r\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\r\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\r\n\r\n\r\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\r\n\r\nfloat Graph(float f, float b)\r\n{\r\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \r\n}\r\n\r\n\r\nfloat Line(float u, float b) { return Graph(u, b); }\r\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\r\n\r\nfloat Grid(vec2 uv, float b)\r\n{\r\n    float xl = Lines(uv.x, b);    \r\n    float yl = Lines(uv.y, b);\r\n\r\n    return max(xl, yl);\r\n}\r\n\r\nfloat Cross(vec2 uv, float b)\r\n{\r\n    float xl = Line(uv.x, b);    \r\n    float yl = Line(uv.y, b);\r\n\r\n    return max(xl, yl);\r\n}\r\n\r\nfloat Dot(vec2 sp, vec2 dp, float dr)\r\n{\r\n    float v = length(sp - dp) - dr;\r\n    \r\n    if(v > dr) return 0.0;\r\n    \r\n    v *= ddxyRcpLen(v);\r\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\r\n    \r\n    return v;\r\n}\r\n\r\nfloat Reinhard(float x) { return x / (x + 1.0); }\r\nfloat HardClip(float x) { return   min(x, 1.0); }\r\n\r\n// x: [0, inf], s: (-1, 1] / (soft, hard]\r\nfloat SoftClip(float x, float s)\r\n{\r\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\r\n}\r\n\r\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\r\n{\r\n\tvec2 uv = uv0 - 0.5;\r\n    uv0 += .0;\r\n    \r\n    vec2 tex = uv0;\r\n    tex -= iResolution.xy * 0.125;\r\n    tex /= iResolution.xx * 0.125;\r\n\r\n    tex *= 0.25+0.0375;\r\n    \r\n\r\n    vec3 col = vec3(0.0);\r\n    \r\n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \r\n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \r\n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\r\n    \r\n    \r\n    // relevant plotting code:\r\n    \r\n    // black\r\n    col = mix(col, vec3(0.), Graph(HardClip(tex.x) -tex.y, 1.));  \r\n    col = mix(col, vec3(0.), Graph(Reinhard(tex.x) -tex.y, 1.));  \r\n    \r\n    // grey\r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.0) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.55) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.85) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.9921875) -tex.y, 1.) * 0.5);\r\n    \r\n    // red\r\n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(SoftClip(tex.x, max(-0.99, sin(iTime))) -tex.y, 1.));  \r\n\r\n       \r\n    \r\n    #if 1\r\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\r\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\r\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\r\n    #endif\r\n    \r\n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \r\n\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"SoftClip","id":"fb154471d04f4b8196b0d156034d5d23","date":null,"viewed":0,"name":"SoftClip","description":"A soft clip that smoothly blends between the Reinhard tone mapping transfer function and a hard clip.\nhttps://www.shadertoy.com/view/wdtfRS","likes":0,"published":null,"tags":["function"," transfer"]},"ver":null,"info":{"Name":"SoftClip","id":"fb154471d04f4b8196b0d156034d5d23","date":null,"viewed":0,"name":"SoftClip","description":"A soft clip that smoothly blends between the Reinhard tone mapping transfer function and a hard clip.\nhttps://www.shadertoy.com/view/wdtfRS","likes":0,"published":null,"tags":["function"," transfer"]},"renderpass":[{"Code":"// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\r\n\r\n/*\r\n\tA soft clip that smoothly blends between the Reinhard tonemapping transfer function and a hard clip.\r\n*/\r\n\r\n\r\n#define Frame float(iFrame)\r\n#define Time iTime\r\n#define PixelCount iResolution.xy\r\n#define clamp01(x) clamp(x, 0.0, 1.0)\r\n#define rsqrt inversesqrt\r\n\r\nconst float Pi = 3.14159265359;\r\nconst float Pi05 = Pi * 0.5;\r\nconst float Pi2  = Pi * 2.0;\r\nconst float RcpPi= 1.0 / Pi;\r\n\r\nfloat Pow2(float x) {return x*x;}\r\nfloat Pow3(float x) {return x*x*x;}\r\nfloat Pow4(float x) {return Pow2(Pow2(x));}\r\n\r\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\r\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\r\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\r\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\r\n\r\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\r\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\r\n\r\n\r\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\r\n\r\nfloat Graph(float f, float b)\r\n{\r\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \r\n}\r\n\r\n\r\nfloat Line(float u, float b) { return Graph(u, b); }\r\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\r\n\r\nfloat Grid(vec2 uv, float b)\r\n{\r\n    float xl = Lines(uv.x, b);    \r\n    float yl = Lines(uv.y, b);\r\n\r\n    return max(xl, yl);\r\n}\r\n\r\nfloat Cross(vec2 uv, float b)\r\n{\r\n    float xl = Line(uv.x, b);    \r\n    float yl = Line(uv.y, b);\r\n\r\n    return max(xl, yl);\r\n}\r\n\r\nfloat Dot(vec2 sp, vec2 dp, float dr)\r\n{\r\n    float v = length(sp - dp) - dr;\r\n    \r\n    if(v > dr) return 0.0;\r\n    \r\n    v *= ddxyRcpLen(v);\r\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\r\n    \r\n    return v;\r\n}\r\n\r\nfloat Reinhard(float x) { return x / (x + 1.0); }\r\nfloat HardClip(float x) { return   min(x, 1.0); }\r\n\r\n// x: [0, inf], s: (-1, 1] / (soft, hard]\r\nfloat SoftClip(float x, float s)\r\n{\r\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\r\n}\r\n\r\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\r\n{\r\n\tvec2 uv = uv0 - 0.5;\r\n    uv0 += .0;\r\n    \r\n    vec2 tex = uv0;\r\n    tex -= iResolution.xy * 0.125;\r\n    tex /= iResolution.xx * 0.125;\r\n\r\n    tex *= 0.25+0.0375;\r\n    \r\n\r\n    vec3 col = vec3(0.0);\r\n    \r\n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \r\n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \r\n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\r\n    \r\n    \r\n    // relevant plotting code:\r\n    \r\n    // black\r\n    col = mix(col, vec3(0.), Graph(HardClip(tex.x) -tex.y, 1.));  \r\n    col = mix(col, vec3(0.), Graph(Reinhard(tex.x) -tex.y, 1.));  \r\n    \r\n    // grey\r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.0) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.55) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.85) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.9921875) -tex.y, 1.) * 0.5);\r\n    \r\n    // red\r\n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(SoftClip(tex.x, max(-0.99, sin(iTime))) -tex.y, 1.));  \r\n\r\n       \r\n    \r\n    #if 1\r\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\r\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\r\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\r\n    #endif\r\n    \r\n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \r\n\r\n}","inputs":[],"outputs":[],"code":"// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\r\n\r\n/*\r\n\tA soft clip that smoothly blends between the Reinhard tonemapping transfer function and a hard clip.\r\n*/\r\n\r\n\r\n#define Frame float(iFrame)\r\n#define Time iTime\r\n#define PixelCount iResolution.xy\r\n#define clamp01(x) clamp(x, 0.0, 1.0)\r\n#define rsqrt inversesqrt\r\n\r\nconst float Pi = 3.14159265359;\r\nconst float Pi05 = Pi * 0.5;\r\nconst float Pi2  = Pi * 2.0;\r\nconst float RcpPi= 1.0 / Pi;\r\n\r\nfloat Pow2(float x) {return x*x;}\r\nfloat Pow3(float x) {return x*x*x;}\r\nfloat Pow4(float x) {return Pow2(Pow2(x));}\r\n\r\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\r\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\r\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\r\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\r\n\r\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\r\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\r\n\r\n\r\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\r\n\r\nfloat Graph(float f, float b)\r\n{\r\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \r\n}\r\n\r\n\r\nfloat Line(float u, float b) { return Graph(u, b); }\r\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\r\n\r\nfloat Grid(vec2 uv, float b)\r\n{\r\n    float xl = Lines(uv.x, b);    \r\n    float yl = Lines(uv.y, b);\r\n\r\n    return max(xl, yl);\r\n}\r\n\r\nfloat Cross(vec2 uv, float b)\r\n{\r\n    float xl = Line(uv.x, b);    \r\n    float yl = Line(uv.y, b);\r\n\r\n    return max(xl, yl);\r\n}\r\n\r\nfloat Dot(vec2 sp, vec2 dp, float dr)\r\n{\r\n    float v = length(sp - dp) - dr;\r\n    \r\n    if(v > dr) return 0.0;\r\n    \r\n    v *= ddxyRcpLen(v);\r\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\r\n    \r\n    return v;\r\n}\r\n\r\nfloat Reinhard(float x) { return x / (x + 1.0); }\r\nfloat HardClip(float x) { return   min(x, 1.0); }\r\n\r\n// x: [0, inf], s: (-1, 1] / (soft, hard]\r\nfloat SoftClip(float x, float s)\r\n{\r\n    return (1.0 + x - sqrt(1.0 - 2.0*s*x + x*x)) / (1.0 + s);\r\n}\r\n\r\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\r\n{\r\n\tvec2 uv = uv0 - 0.5;\r\n    uv0 += .0;\r\n    \r\n    vec2 tex = uv0;\r\n    tex -= iResolution.xy * 0.125;\r\n    tex /= iResolution.xx * 0.125;\r\n\r\n    tex *= 0.25+0.0375;\r\n    \r\n\r\n    vec3 col = vec3(0.0);\r\n    \r\n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \r\n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \r\n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\r\n    \r\n    \r\n    // relevant plotting code:\r\n    \r\n    // black\r\n    col = mix(col, vec3(0.), Graph(HardClip(tex.x) -tex.y, 1.));  \r\n    col = mix(col, vec3(0.), Graph(Reinhard(tex.x) -tex.y, 1.));  \r\n    \r\n    // grey\r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.0) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.55) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.85) -tex.y, 1.) * 0.5);  \r\n    col = mix(col, vec3(0.5), Graph(SoftClip(tex.x, 0.9921875) -tex.y, 1.) * 0.5);\r\n    \r\n    // red\r\n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(SoftClip(tex.x, max(-0.99, sin(iTime))) -tex.y, 1.));  \r\n\r\n       \r\n    \r\n    #if 1\r\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\r\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\r\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\r\n    #endif\r\n    \r\n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \r\n\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Sphere UV","id":"wl33W2","date":"1577591248","viewed":40,"name":"Sphere UV","description":"\u7403\u4F53UV\u5750\u6807","likes":5,"published":"Public","tags":["math","uv","sphere"]},"ver":"0.1","info":{"Name":"Sphere UV","id":"wl33W2","date":"1577591248","viewed":40,"name":"Sphere UV","description":"\u7403\u4F53UV\u5750\u6807","likes":5,"published":"Public","tags":["math","uv","sphere"]},"renderpass":[{"Code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Squiggles\r\n// Dave H.\r\n// https://www.shadertoy.com/view/4sjXRh\r\n\r\n#define MOD2 vec2(.16632,.17369)\r\n#define MOD3 vec3(.16532,.17369,.15787)\r\n\r\n//----------------------------------------------------------------------------------------\r\n///  2 out, 2 in...\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3.zxy, p3.yxz+19.19);\r\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\r\n}\r\n\r\n//---------------------------------------------------------------------------------------\r\nvec3 Cells(in vec2 p, in float time)\r\n{\r\n    vec2 f = fract(p);\r\n    p = floor(p);\r\n\tfloat d = 1.0e10;\r\n    vec2 id = vec2(0.0);\r\n    time *= 1.5;\r\n    \r\n\tfor (int xo = -1; xo <= 1; xo++)\r\n\t{\r\n\t\tfor (int yo = -1; yo <= 1; yo++)\r\n\t\t{\r\n            vec2 g = vec2(xo, yo);\r\n            vec2 n = Hash22(p+g);\r\n            n = n*n*(3.0-2.0*n);\r\n            \r\n\t\t\tvec2 tp = g + .5 + sin(time + 6.2831 * n)*1.2 - f;\r\n            float d2 = dot(tp, tp);\r\n\t\t\tif (d2 < d)\r\n            {\r\n                // 'id' is the colour code for each squiggle\r\n                d = d2;\r\n                id = n;\r\n            }\r\n\t\t}\r\n\t}\r\n\treturn vec3(sqrt(d), id);\r\n}\r\n\r\n//---------------------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xx;\r\n\tfloat time = iTime;\r\n    vec3 col = vec3(0.0);\r\n\tfloat amp = 1.0;\r\n    float size = 4.0 * (abs(fract(time*.01-.5)-.5)*50.0+1.0) + ((iMouse.x/iResolution.x) * 200.0);\r\n    float timeSlide = .05;\r\n         \r\n    for (int i = 0; i < 20; i++)\r\n    {\r\n        vec3 res = Cells(uv * size - size * .5, time);\r\n        float c = 1.0 - res.x;\r\n        // Get a colour associated with the returned id...\r\n        vec3 wormCol =  clamp(abs(fract((res.y+res.z)* 1.1 + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\r\n        c = smoothstep(0.6+amp*.25, 1., c);\r\n        col += amp * c * ((wormCol * .1) + vec3(.9, .2, .15));\r\n        amp *= .85;\r\n        time -= timeSlide;\r\n    }\r\n\tfragColor = vec4(min(col, 1.0), 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Squiggles\r\n// Dave H.\r\n// https://www.shadertoy.com/view/4sjXRh\r\n\r\n#define MOD2 vec2(.16632,.17369)\r\n#define MOD3 vec3(.16532,.17369,.15787)\r\n\r\n//----------------------------------------------------------------------------------------\r\n///  2 out, 2 in...\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3.zxy, p3.yxz+19.19);\r\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\r\n}\r\n\r\n//---------------------------------------------------------------------------------------\r\nvec3 Cells(in vec2 p, in float time)\r\n{\r\n    vec2 f = fract(p);\r\n    p = floor(p);\r\n\tfloat d = 1.0e10;\r\n    vec2 id = vec2(0.0);\r\n    time *= 1.5;\r\n    \r\n\tfor (int xo = -1; xo <= 1; xo++)\r\n\t{\r\n\t\tfor (int yo = -1; yo <= 1; yo++)\r\n\t\t{\r\n            vec2 g = vec2(xo, yo);\r\n            vec2 n = Hash22(p+g);\r\n            n = n*n*(3.0-2.0*n);\r\n            \r\n\t\t\tvec2 tp = g + .5 + sin(time + 6.2831 * n)*1.2 - f;\r\n            float d2 = dot(tp, tp);\r\n\t\t\tif (d2 < d)\r\n            {\r\n                // 'id' is the colour code for each squiggle\r\n                d = d2;\r\n                id = n;\r\n            }\r\n\t\t}\r\n\t}\r\n\treturn vec3(sqrt(d), id);\r\n}\r\n\r\n//---------------------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xx;\r\n\tfloat time = iTime;\r\n    vec3 col = vec3(0.0);\r\n\tfloat amp = 1.0;\r\n    float size = 4.0 * (abs(fract(time*.01-.5)-.5)*50.0+1.0) + ((iMouse.x/iResolution.x) * 200.0);\r\n    float timeSlide = .05;\r\n         \r\n    for (int i = 0; i < 20; i++)\r\n    {\r\n        vec3 res = Cells(uv * size - size * .5, time);\r\n        float c = 1.0 - res.x;\r\n        // Get a colour associated with the returned id...\r\n        vec3 wormCol =  clamp(abs(fract((res.y+res.z)* 1.1 + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\r\n        c = smoothstep(0.6+amp*.25, 1., c);\r\n        col += amp * c * ((wormCol * .1) + vec3(.9, .2, .15));\r\n        amp *= .85;\r\n        time -= timeSlide;\r\n    }\r\n\tfragColor = vec4(min(col, 1.0), 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Squiggles","id":"e1bb7b017fef4b46ac171b0816c9ee06","date":null,"viewed":0,"name":"Squiggles","description":"Experimenting with movement in Voronoi noise. Mouse X to force zoom out.\nFull screen it if you can!\nhttps://www.shadertoy.com/view/4sjXRh","likes":0,"published":null,"tags":["voronoi"," squiggles"]},"ver":null,"info":{"Name":"Squiggles","id":"e1bb7b017fef4b46ac171b0816c9ee06","date":null,"viewed":0,"name":"Squiggles","description":"Experimenting with movement in Voronoi noise. Mouse X to force zoom out.\nFull screen it if you can!\nhttps://www.shadertoy.com/view/4sjXRh","likes":0,"published":null,"tags":["voronoi"," squiggles"]},"renderpass":[{"Code":"// Squiggles\r\n// Dave H.\r\n// https://www.shadertoy.com/view/4sjXRh\r\n\r\n#define MOD2 vec2(.16632,.17369)\r\n#define MOD3 vec3(.16532,.17369,.15787)\r\n\r\n//----------------------------------------------------------------------------------------\r\n///  2 out, 2 in...\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3.zxy, p3.yxz+19.19);\r\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\r\n}\r\n\r\n//---------------------------------------------------------------------------------------\r\nvec3 Cells(in vec2 p, in float time)\r\n{\r\n    vec2 f = fract(p);\r\n    p = floor(p);\r\n\tfloat d = 1.0e10;\r\n    vec2 id = vec2(0.0);\r\n    time *= 1.5;\r\n    \r\n\tfor (int xo = -1; xo <= 1; xo++)\r\n\t{\r\n\t\tfor (int yo = -1; yo <= 1; yo++)\r\n\t\t{\r\n            vec2 g = vec2(xo, yo);\r\n            vec2 n = Hash22(p+g);\r\n            n = n*n*(3.0-2.0*n);\r\n            \r\n\t\t\tvec2 tp = g + .5 + sin(time + 6.2831 * n)*1.2 - f;\r\n            float d2 = dot(tp, tp);\r\n\t\t\tif (d2 < d)\r\n            {\r\n                // 'id' is the colour code for each squiggle\r\n                d = d2;\r\n                id = n;\r\n            }\r\n\t\t}\r\n\t}\r\n\treturn vec3(sqrt(d), id);\r\n}\r\n\r\n//---------------------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xx;\r\n\tfloat time = iTime;\r\n    vec3 col = vec3(0.0);\r\n\tfloat amp = 1.0;\r\n    float size = 4.0 * (abs(fract(time*.01-.5)-.5)*50.0+1.0) + ((iMouse.x/iResolution.x) * 200.0);\r\n    float timeSlide = .05;\r\n         \r\n    for (int i = 0; i < 20; i++)\r\n    {\r\n        vec3 res = Cells(uv * size - size * .5, time);\r\n        float c = 1.0 - res.x;\r\n        // Get a colour associated with the returned id...\r\n        vec3 wormCol =  clamp(abs(fract((res.y+res.z)* 1.1 + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\r\n        c = smoothstep(0.6+amp*.25, 1., c);\r\n        col += amp * c * ((wormCol * .1) + vec3(.9, .2, .15));\r\n        amp *= .85;\r\n        time -= timeSlide;\r\n    }\r\n\tfragColor = vec4(min(col, 1.0), 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Squiggles\r\n// Dave H.\r\n// https://www.shadertoy.com/view/4sjXRh\r\n\r\n#define MOD2 vec2(.16632,.17369)\r\n#define MOD3 vec3(.16532,.17369,.15787)\r\n\r\n//----------------------------------------------------------------------------------------\r\n///  2 out, 2 in...\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\r\n    p3 += dot(p3.zxy, p3.yxz+19.19);\r\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\r\n}\r\n\r\n//---------------------------------------------------------------------------------------\r\nvec3 Cells(in vec2 p, in float time)\r\n{\r\n    vec2 f = fract(p);\r\n    p = floor(p);\r\n\tfloat d = 1.0e10;\r\n    vec2 id = vec2(0.0);\r\n    time *= 1.5;\r\n    \r\n\tfor (int xo = -1; xo <= 1; xo++)\r\n\t{\r\n\t\tfor (int yo = -1; yo <= 1; yo++)\r\n\t\t{\r\n            vec2 g = vec2(xo, yo);\r\n            vec2 n = Hash22(p+g);\r\n            n = n*n*(3.0-2.0*n);\r\n            \r\n\t\t\tvec2 tp = g + .5 + sin(time + 6.2831 * n)*1.2 - f;\r\n            float d2 = dot(tp, tp);\r\n\t\t\tif (d2 < d)\r\n            {\r\n                // 'id' is the colour code for each squiggle\r\n                d = d2;\r\n                id = n;\r\n            }\r\n\t\t}\r\n\t}\r\n\treturn vec3(sqrt(d), id);\r\n}\r\n\r\n//---------------------------------------------------------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xx;\r\n\tfloat time = iTime;\r\n    vec3 col = vec3(0.0);\r\n\tfloat amp = 1.0;\r\n    float size = 4.0 * (abs(fract(time*.01-.5)-.5)*50.0+1.0) + ((iMouse.x/iResolution.x) * 200.0);\r\n    float timeSlide = .05;\r\n         \r\n    for (int i = 0; i < 20; i++)\r\n    {\r\n        vec3 res = Cells(uv * size - size * .5, time);\r\n        float c = 1.0 - res.x;\r\n        // Get a colour associated with the returned id...\r\n        vec3 wormCol =  clamp(abs(fract((res.y+res.z)* 1.1 + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\r\n        c = smoothstep(0.6+amp*.25, 1., c);\r\n        col += amp * c * ((wormCol * .1) + vec3(.9, .2, .15));\r\n        amp *= .85;\r\n        time -= timeSlide;\r\n    }\r\n\tfragColor = vec4(min(col, 1.0), 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// #### realistic display of star in Hubble images ################\r\n//                            Fabrice NEYRET 15 oct 2013\r\n// toggles:\r\n//    T:      tune (R)GB  vs   Planck spectrum(T)\r\n//    SPACE:  tune 1GB  vs RG1\r\n\r\n// see also https://www.shadertoy.com/view/Xty3zc\r\n//          https://www.shadertoy.com/view/tlc3zM\r\n\r\n#define NB_STARS 200\r\n#define PERS 1          // perspective\r\n\r\n#define SCALE 40.\r\nconst float star_luminosity = 1e3;\r\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\r\n#define PI 3.1415927\r\nvec2 FragCoord, R;\r\n\r\n//--- filter integration (l0..l1) on black body spectrum(T) ---------\r\nfloat F(float x) \r\n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\r\nfloat IntPlanck(float T,float lambda1,float lambda0) \r\n{\r\n\tconst float A=1.1, B=1./1.05;\r\n\tfloat C0 = 0.014387770, C=C0/(B*T);\r\n\tT = 1.; // normalised spectrum better for display :-)\r\n\treturn 100.*A/B*pow(100.*T/C0,4.)*( F(C/lambda1) - F(C/lambda0) );\r\n}\r\n\r\n// --- Planck black body color I.spectrum(Temp) -----------------------\r\nvec3 Planck(float T) {\r\n\treturn vec3(\r\n\t\tIntPlanck(T,.7e-6,.55e-6),   // red filter\r\n        IntPlanck(T,.55e-6,.49e-6),  // green filter\r\n        IntPlanck(T,.49e-6,.4e-6)    // blue filter\r\n\t\t)*1e-14;\r\n}\r\n\r\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \r\nvec3 draw_star(vec2 pos, float I) {\r\n\t// star out of screen\r\n    const float margin = .2;\r\n\tif (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);\r\n\t\r\n\tpos -= FragCoord.xy/iResolution.y; \r\n\t\r\n// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1\r\n// pixels >> fringes -> smoothed Airy ~ 1/x^3\r\n\tfloat d = length(pos)*SCALE;\r\n\t\r\n\tvec3 col, spectrum = I*star_color;\r\n#if 1\r\n\tcol = spectrum/(d*d*d);\r\n#else\r\n\tcol = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);\r\n#endif\r\n\t\r\n// 2ndary mirror handles signature (assuming handles are long ellipses)\r\n\td = length(pos*vec2(50.,.5))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\td = length(pos*vec2(.5,50.))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\r\n\treturn col;\r\n}\r\n\r\n// --- utility functions ----------------------------------\r\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \r\nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel0,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// --- GUI: mouse tuning ----------------------------------\r\nvec3 userInterface() {\r\n\tvec2 uv = FragCoord.xy/iResolution.y - vec2(.8,.5);\r\n\tvec3 col=vec3(0.); float d;\r\n\tvec4 mouse = iMouse/iResolution.y;\r\n\r\n\tif(!key_toggle(9.)) return col; // 'TAB' key : automatic stars field -> exit\r\n\t\r\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); // 1st mouse position silly\r\n\t\r\n\td = length(uv+vec2(.8,.5)-mouse.xy); // color cursor\r\n\tif (d<.02) col = vec3(0.,0.,1.);\r\n\t\r\n\tif(key_toggle(84.))  // 'T' key : tune RGB vs Temperature->Planck Spectrum\r\n\t{   // ---  Plank Spectrum mode ---\r\n\t\tfloat T = 40000.*iMouse.x/iResolution.x;\r\n\t\tstar_color = Planck(T);\r\n\t\t// star_luminosity = pow(T,4.);\r\n\t} \r\n\telse \r\n\t{   // --- RGB mode ---\r\n\t\tstar_color.gb = mouse.xy*star_luminosity; \r\n\t\tif(key_toggle(32.))  // SPACE key: red or blue dominant, tune the 2 others\r\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\r\n\t}\r\n\t\r\n\t// display the 3-filters analyzor at bottom\r\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\r\n\t\tif (uv.y<-.402) col=  vec3(\r\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., // red frame\r\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., // green frame\r\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  // blue frame\r\n\t\t)*star_color/star_luminosity;\r\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\r\n\t}\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\n// --- main -----------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec3 col;\r\n\tFragCoord = fragCoord;\r\n    R = iResolution.xy;\r\n    float t = iTime;\r\n    \r\n\t// --- tunings (color and display mode)\r\n\tcol = userInterface(); \r\n\t\r\n\t// --- camera\r\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\r\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\r\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\r\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\r\n\tfloat c=cos(a),s=sin(a);\r\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\r\n\t//mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\r\n\t\r\n\t// --- display stars \r\n\tif(key_toggle(9.)) // 'TAB' key\r\n\t\tcol += draw_star(vec2(.8,.5),1.);  // one single centred star\r\n\telse \r\n\t{\r\n\t\t// background\r\n\t\tvec2 uv = im*(fragCoord.xy/iResolution.y)+cam.xy;\r\n\t\tfloat bg = texture(iChannel1,uv).r;\r\n\t\tcol += .5*exp(-7.*bg);\r\n\r\n\t\t// do stars\r\n\t\tfor (int i=0; i<NB_STARS; i++) {\r\n\t\t\t// random position, intensity(=surf), temperature(->color)\r\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\r\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\r\n\t\t\tstar_color = Planck(40000.*exp(-3.*rnd(6*i+5)));\r\n\r\n\t\t\t// project to screen coords\r\n\t\t\tpos = pos-cam;\r\n\t\t\tpos.xy = m*pos.xy;\r\n#if PERS // perspective\r\n\t\t\tpos.xy /= pos.z;\r\n#endif\r\n\t\t\tif (pos.z>0.)\r\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I/(pos.z*pos.z));\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// #### realistic display of star in Hubble images ################\r\n//                            Fabrice NEYRET 15 oct 2013\r\n// toggles:\r\n//    T:      tune (R)GB  vs   Planck spectrum(T)\r\n//    SPACE:  tune 1GB  vs RG1\r\n\r\n// see also https://www.shadertoy.com/view/Xty3zc\r\n//          https://www.shadertoy.com/view/tlc3zM\r\n\r\n#define NB_STARS 200\r\n#define PERS 1          // perspective\r\n\r\n#define SCALE 40.\r\nconst float star_luminosity = 1e3;\r\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\r\n#define PI 3.1415927\r\nvec2 FragCoord, R;\r\n\r\n//--- filter integration (l0..l1) on black body spectrum(T) ---------\r\nfloat F(float x) \r\n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\r\nfloat IntPlanck(float T,float lambda1,float lambda0) \r\n{\r\n\tconst float A=1.1, B=1./1.05;\r\n\tfloat C0 = 0.014387770, C=C0/(B*T);\r\n\tT = 1.; // normalised spectrum better for display :-)\r\n\treturn 100.*A/B*pow(100.*T/C0,4.)*( F(C/lambda1) - F(C/lambda0) );\r\n}\r\n\r\n// --- Planck black body color I.spectrum(Temp) -----------------------\r\nvec3 Planck(float T) {\r\n\treturn vec3(\r\n\t\tIntPlanck(T,.7e-6,.55e-6),   // red filter\r\n        IntPlanck(T,.55e-6,.49e-6),  // green filter\r\n        IntPlanck(T,.49e-6,.4e-6)    // blue filter\r\n\t\t)*1e-14;\r\n}\r\n\r\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \r\nvec3 draw_star(vec2 pos, float I) {\r\n\t// star out of screen\r\n    const float margin = .2;\r\n\tif (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);\r\n\t\r\n\tpos -= FragCoord.xy/iResolution.y; \r\n\t\r\n// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1\r\n// pixels >> fringes -> smoothed Airy ~ 1/x^3\r\n\tfloat d = length(pos)*SCALE;\r\n\t\r\n\tvec3 col, spectrum = I*star_color;\r\n#if 1\r\n\tcol = spectrum/(d*d*d);\r\n#else\r\n\tcol = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);\r\n#endif\r\n\t\r\n// 2ndary mirror handles signature (assuming handles are long ellipses)\r\n\td = length(pos*vec2(50.,.5))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\td = length(pos*vec2(.5,50.))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\r\n\treturn col;\r\n}\r\n\r\n// --- utility functions ----------------------------------\r\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \r\nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel0,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// --- GUI: mouse tuning ----------------------------------\r\nvec3 userInterface() {\r\n\tvec2 uv = FragCoord.xy/iResolution.y - vec2(.8,.5);\r\n\tvec3 col=vec3(0.); float d;\r\n\tvec4 mouse = iMouse/iResolution.y;\r\n\r\n\tif(!key_toggle(9.)) return col; // 'TAB' key : automatic stars field -> exit\r\n\t\r\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); // 1st mouse position silly\r\n\t\r\n\td = length(uv+vec2(.8,.5)-mouse.xy); // color cursor\r\n\tif (d<.02) col = vec3(0.,0.,1.);\r\n\t\r\n\tif(key_toggle(84.))  // 'T' key : tune RGB vs Temperature->Planck Spectrum\r\n\t{   // ---  Plank Spectrum mode ---\r\n\t\tfloat T = 40000.*iMouse.x/iResolution.x;\r\n\t\tstar_color = Planck(T);\r\n\t\t// star_luminosity = pow(T,4.);\r\n\t} \r\n\telse \r\n\t{   // --- RGB mode ---\r\n\t\tstar_color.gb = mouse.xy*star_luminosity; \r\n\t\tif(key_toggle(32.))  // SPACE key: red or blue dominant, tune the 2 others\r\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\r\n\t}\r\n\t\r\n\t// display the 3-filters analyzor at bottom\r\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\r\n\t\tif (uv.y<-.402) col=  vec3(\r\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., // red frame\r\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., // green frame\r\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  // blue frame\r\n\t\t)*star_color/star_luminosity;\r\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\r\n\t}\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\n// --- main -----------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec3 col;\r\n\tFragCoord = fragCoord;\r\n    R = iResolution.xy;\r\n    float t = iTime;\r\n    \r\n\t// --- tunings (color and display mode)\r\n\tcol = userInterface(); \r\n\t\r\n\t// --- camera\r\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\r\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\r\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\r\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\r\n\tfloat c=cos(a),s=sin(a);\r\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\r\n\t//mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\r\n\t\r\n\t// --- display stars \r\n\tif(key_toggle(9.)) // 'TAB' key\r\n\t\tcol += draw_star(vec2(.8,.5),1.);  // one single centred star\r\n\telse \r\n\t{\r\n\t\t// background\r\n\t\tvec2 uv = im*(fragCoord.xy/iResolution.y)+cam.xy;\r\n\t\tfloat bg = texture(iChannel1,uv).r;\r\n\t\tcol += .5*exp(-7.*bg);\r\n\r\n\t\t// do stars\r\n\t\tfor (int i=0; i<NB_STARS; i++) {\r\n\t\t\t// random position, intensity(=surf), temperature(->color)\r\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\r\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\r\n\t\t\tstar_color = Planck(40000.*exp(-3.*rnd(6*i+5)));\r\n\r\n\t\t\t// project to screen coords\r\n\t\t\tpos = pos-cam;\r\n\t\t\tpos.xy = m*pos.xy;\r\n#if PERS // perspective\r\n\t\t\tpos.xy /= pos.z;\r\n#endif\r\n\t\t\tif (pos.z>0.)\r\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I/(pos.z*pos.z));\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Star PSF","id":"0cffc693d2374c8abe55f5fb9d563626","date":null,"viewed":0,"name":"Star PSF","description":"TAB: 1 vs many. \r\n      if 1: col=BlackBody(T) vs RGB ( SPACE: mouse.xy = rGB/RGb )\r\n\r\nstar proj = fraction of sensor pixel.\r\nBut lens+aperture diffraction yields Airy spot + cross (diffract on 2ndary mirror handles). \r\nAnd bright stars saturate filters.\r\nhttps://www.shadertoy.com/view/XdsGWs","likes":0,"published":null,"tags":["astrophysics"," optics"," blackbody"," fourier"," planck"," psf"]},"ver":null,"info":{"Name":"Star PSF","id":"0cffc693d2374c8abe55f5fb9d563626","date":null,"viewed":0,"name":"Star PSF","description":"TAB: 1 vs many. \r\n      if 1: col=BlackBody(T) vs RGB ( SPACE: mouse.xy = rGB/RGb )\r\n\r\nstar proj = fraction of sensor pixel.\r\nBut lens+aperture diffraction yields Airy spot + cross (diffract on 2ndary mirror handles). \r\nAnd bright stars saturate filters.\r\nhttps://www.shadertoy.com/view/XdsGWs","likes":0,"published":null,"tags":["astrophysics"," optics"," blackbody"," fourier"," planck"," psf"]},"renderpass":[{"Code":"// #### realistic display of star in Hubble images ################\r\n//                            Fabrice NEYRET 15 oct 2013\r\n// toggles:\r\n//    T:      tune (R)GB  vs   Planck spectrum(T)\r\n//    SPACE:  tune 1GB  vs RG1\r\n\r\n// see also https://www.shadertoy.com/view/Xty3zc\r\n//          https://www.shadertoy.com/view/tlc3zM\r\n\r\n#define NB_STARS 200\r\n#define PERS 1          // perspective\r\n\r\n#define SCALE 40.\r\nconst float star_luminosity = 1e3;\r\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\r\n#define PI 3.1415927\r\nvec2 FragCoord, R;\r\n\r\n//--- filter integration (l0..l1) on black body spectrum(T) ---------\r\nfloat F(float x) \r\n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\r\nfloat IntPlanck(float T,float lambda1,float lambda0) \r\n{\r\n\tconst float A=1.1, B=1./1.05;\r\n\tfloat C0 = 0.014387770, C=C0/(B*T);\r\n\tT = 1.; // normalised spectrum better for display :-)\r\n\treturn 100.*A/B*pow(100.*T/C0,4.)*( F(C/lambda1) - F(C/lambda0) );\r\n}\r\n\r\n// --- Planck black body color I.spectrum(Temp) -----------------------\r\nvec3 Planck(float T) {\r\n\treturn vec3(\r\n\t\tIntPlanck(T,.7e-6,.55e-6),   // red filter\r\n        IntPlanck(T,.55e-6,.49e-6),  // green filter\r\n        IntPlanck(T,.49e-6,.4e-6)    // blue filter\r\n\t\t)*1e-14;\r\n}\r\n\r\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \r\nvec3 draw_star(vec2 pos, float I) {\r\n\t// star out of screen\r\n    const float margin = .2;\r\n\tif (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);\r\n\t\r\n\tpos -= FragCoord.xy/iResolution.y; \r\n\t\r\n// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1\r\n// pixels >> fringes -> smoothed Airy ~ 1/x^3\r\n\tfloat d = length(pos)*SCALE;\r\n\t\r\n\tvec3 col, spectrum = I*star_color;\r\n#if 1\r\n\tcol = spectrum/(d*d*d);\r\n#else\r\n\tcol = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);\r\n#endif\r\n\t\r\n// 2ndary mirror handles signature (assuming handles are long ellipses)\r\n\td = length(pos*vec2(50.,.5))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\td = length(pos*vec2(.5,50.))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\r\n\treturn col;\r\n}\r\n\r\n// --- utility functions ----------------------------------\r\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \r\nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel0,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// --- GUI: mouse tuning ----------------------------------\r\nvec3 userInterface() {\r\n\tvec2 uv = FragCoord.xy/iResolution.y - vec2(.8,.5);\r\n\tvec3 col=vec3(0.); float d;\r\n\tvec4 mouse = iMouse/iResolution.y;\r\n\r\n\tif(!key_toggle(9.)) return col; // 'TAB' key : automatic stars field -> exit\r\n\t\r\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); // 1st mouse position silly\r\n\t\r\n\td = length(uv+vec2(.8,.5)-mouse.xy); // color cursor\r\n\tif (d<.02) col = vec3(0.,0.,1.);\r\n\t\r\n\tif(key_toggle(84.))  // 'T' key : tune RGB vs Temperature->Planck Spectrum\r\n\t{   // ---  Plank Spectrum mode ---\r\n\t\tfloat T = 40000.*iMouse.x/iResolution.x;\r\n\t\tstar_color = Planck(T);\r\n\t\t// star_luminosity = pow(T,4.);\r\n\t} \r\n\telse \r\n\t{   // --- RGB mode ---\r\n\t\tstar_color.gb = mouse.xy*star_luminosity; \r\n\t\tif(key_toggle(32.))  // SPACE key: red or blue dominant, tune the 2 others\r\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\r\n\t}\r\n\t\r\n\t// display the 3-filters analyzor at bottom\r\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\r\n\t\tif (uv.y<-.402) col=  vec3(\r\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., // red frame\r\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., // green frame\r\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  // blue frame\r\n\t\t)*star_color/star_luminosity;\r\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\r\n\t}\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\n// --- main -----------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec3 col;\r\n\tFragCoord = fragCoord;\r\n    R = iResolution.xy;\r\n    float t = iTime;\r\n    \r\n\t// --- tunings (color and display mode)\r\n\tcol = userInterface(); \r\n\t\r\n\t// --- camera\r\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\r\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\r\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\r\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\r\n\tfloat c=cos(a),s=sin(a);\r\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\r\n\t//mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\r\n\t\r\n\t// --- display stars \r\n\tif(key_toggle(9.)) // 'TAB' key\r\n\t\tcol += draw_star(vec2(.8,.5),1.);  // one single centred star\r\n\telse \r\n\t{\r\n\t\t// background\r\n\t\tvec2 uv = im*(fragCoord.xy/iResolution.y)+cam.xy;\r\n\t\tfloat bg = texture(iChannel1,uv).r;\r\n\t\tcol += .5*exp(-7.*bg);\r\n\r\n\t\t// do stars\r\n\t\tfor (int i=0; i<NB_STARS; i++) {\r\n\t\t\t// random position, intensity(=surf), temperature(->color)\r\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\r\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\r\n\t\t\tstar_color = Planck(40000.*exp(-3.*rnd(6*i+5)));\r\n\r\n\t\t\t// project to screen coords\r\n\t\t\tpos = pos-cam;\r\n\t\t\tpos.xy = m*pos.xy;\r\n#if PERS // perspective\r\n\t\t\tpos.xy /= pos.z;\r\n#endif\r\n\t\t\tif (pos.z>0.)\r\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I/(pos.z*pos.z));\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// #### realistic display of star in Hubble images ################\r\n//                            Fabrice NEYRET 15 oct 2013\r\n// toggles:\r\n//    T:      tune (R)GB  vs   Planck spectrum(T)\r\n//    SPACE:  tune 1GB  vs RG1\r\n\r\n// see also https://www.shadertoy.com/view/Xty3zc\r\n//          https://www.shadertoy.com/view/tlc3zM\r\n\r\n#define NB_STARS 200\r\n#define PERS 1          // perspective\r\n\r\n#define SCALE 40.\r\nconst float star_luminosity = 1e3;\r\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\r\n#define PI 3.1415927\r\nvec2 FragCoord, R;\r\n\r\n//--- filter integration (l0..l1) on black body spectrum(T) ---------\r\nfloat F(float x) \r\n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\r\nfloat IntPlanck(float T,float lambda1,float lambda0) \r\n{\r\n\tconst float A=1.1, B=1./1.05;\r\n\tfloat C0 = 0.014387770, C=C0/(B*T);\r\n\tT = 1.; // normalised spectrum better for display :-)\r\n\treturn 100.*A/B*pow(100.*T/C0,4.)*( F(C/lambda1) - F(C/lambda0) );\r\n}\r\n\r\n// --- Planck black body color I.spectrum(Temp) -----------------------\r\nvec3 Planck(float T) {\r\n\treturn vec3(\r\n\t\tIntPlanck(T,.7e-6,.55e-6),   // red filter\r\n        IntPlanck(T,.55e-6,.49e-6),  // green filter\r\n        IntPlanck(T,.49e-6,.4e-6)    // blue filter\r\n\t\t)*1e-14;\r\n}\r\n\r\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \r\nvec3 draw_star(vec2 pos, float I) {\r\n\t// star out of screen\r\n    const float margin = .2;\r\n\tif (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);\r\n\t\r\n\tpos -= FragCoord.xy/iResolution.y; \r\n\t\r\n// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1\r\n// pixels >> fringes -> smoothed Airy ~ 1/x^3\r\n\tfloat d = length(pos)*SCALE;\r\n\t\r\n\tvec3 col, spectrum = I*star_color;\r\n#if 1\r\n\tcol = spectrum/(d*d*d);\r\n#else\r\n\tcol = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);\r\n#endif\r\n\t\r\n// 2ndary mirror handles signature (assuming handles are long ellipses)\r\n\td = length(pos*vec2(50.,.5))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\td = length(pos*vec2(.5,50.))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\r\n\treturn col;\r\n}\r\n\r\n// --- utility functions ----------------------------------\r\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \r\nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel0,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// --- GUI: mouse tuning ----------------------------------\r\nvec3 userInterface() {\r\n\tvec2 uv = FragCoord.xy/iResolution.y - vec2(.8,.5);\r\n\tvec3 col=vec3(0.); float d;\r\n\tvec4 mouse = iMouse/iResolution.y;\r\n\r\n\tif(!key_toggle(9.)) return col; // 'TAB' key : automatic stars field -> exit\r\n\t\r\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); // 1st mouse position silly\r\n\t\r\n\td = length(uv+vec2(.8,.5)-mouse.xy); // color cursor\r\n\tif (d<.02) col = vec3(0.,0.,1.);\r\n\t\r\n\tif(key_toggle(84.))  // 'T' key : tune RGB vs Temperature->Planck Spectrum\r\n\t{   // ---  Plank Spectrum mode ---\r\n\t\tfloat T = 40000.*iMouse.x/iResolution.x;\r\n\t\tstar_color = Planck(T);\r\n\t\t// star_luminosity = pow(T,4.);\r\n\t} \r\n\telse \r\n\t{   // --- RGB mode ---\r\n\t\tstar_color.gb = mouse.xy*star_luminosity; \r\n\t\tif(key_toggle(32.))  // SPACE key: red or blue dominant, tune the 2 others\r\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\r\n\t}\r\n\t\r\n\t// display the 3-filters analyzor at bottom\r\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\r\n\t\tif (uv.y<-.402) col=  vec3(\r\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., // red frame\r\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., // green frame\r\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  // blue frame\r\n\t\t)*star_color/star_luminosity;\r\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\r\n\t}\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\n// --- main -----------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec3 col;\r\n\tFragCoord = fragCoord;\r\n    R = iResolution.xy;\r\n    float t = iTime;\r\n    \r\n\t// --- tunings (color and display mode)\r\n\tcol = userInterface(); \r\n\t\r\n\t// --- camera\r\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\r\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\r\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\r\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\r\n\tfloat c=cos(a),s=sin(a);\r\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\r\n\t//mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\r\n\t\r\n\t// --- display stars \r\n\tif(key_toggle(9.)) // 'TAB' key\r\n\t\tcol += draw_star(vec2(.8,.5),1.);  // one single centred star\r\n\telse \r\n\t{\r\n\t\t// background\r\n\t\tvec2 uv = im*(fragCoord.xy/iResolution.y)+cam.xy;\r\n\t\tfloat bg = texture(iChannel1,uv).r;\r\n\t\tcol += .5*exp(-7.*bg);\r\n\r\n\t\t// do stars\r\n\t\tfor (int i=0; i<NB_STARS; i++) {\r\n\t\t\t// random position, intensity(=surf), temperature(->color)\r\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\r\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\r\n\t\t\tstar_color = Planck(40000.*exp(-3.*rnd(6*i+5)));\r\n\r\n\t\t\t// project to screen coords\r\n\t\t\tpos = pos-cam;\r\n\t\t\tpos.xy = m*pos.xy;\r\n#if PERS // perspective\r\n\t\t\tpos.xy /= pos.z;\r\n#endif\r\n\t\t\tif (pos.z>0.)\r\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I/(pos.z*pos.z));\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// Full telescope PSF + BB emission spectrum: see https://www.shadertoy.com/view/XdsGWs\r\n\r\n#define N 4. // oversampling (use power of 2)\r\n\r\n#define rnd(U) ( 2.* fract( 4356.17 * sin( 1e4* dot(U, vec2(1,171.3)) )) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U0 )\r\n{\r\n    float z = 3.+iTime, r;\r\n    vec2 R = iResolution.xy, U, Ur, Us;\r\n    U0 =  (2.*U0-R)/R.y;\r\n\tU = U0 * z;\r\n    Ur = U+.2*rnd(floor(U)); // local star location\r\n    \r\n    O -= O;\r\n    \r\n    //if (floor(U)==floor(Ur))\r\n        for (float x=-1.; x<=1.; x+=1./N)\r\n            for (float y=-1.; y<=1.; y+=1./N)\r\n                \r\n                Us = Ur + vec2(x,y)*z/R.y,\r\n                r = length( fract(Us)-.5 + floor(Us)-floor(U) ),\r\n\t            O += U0.x<0. \r\n                   ? 6e-4/( pow(r/z,3.) * z*z)     // pix = clamp ( Emit/dist^2 * Bessel )\r\n                   : smoothstep(1.,.8, r*8.);      // pix = disk ( R/dist )\r\n                 //? 1./( pow(r,3.) * z*z)         \r\n                 //: smoothstep(1.,.8, r/1.5*z);   \r\n\r\n    O *= vec4(1,.5,.2,1) / pow(N+N+1.,2.);         // color and sum normalization       \r\n}","inputs":[],"outputs":[],"code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// Full telescope PSF + BB emission spectrum: see https://www.shadertoy.com/view/XdsGWs\r\n\r\n#define N 4. // oversampling (use power of 2)\r\n\r\n#define rnd(U) ( 2.* fract( 4356.17 * sin( 1e4* dot(U, vec2(1,171.3)) )) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U0 )\r\n{\r\n    float z = 3.+iTime, r;\r\n    vec2 R = iResolution.xy, U, Ur, Us;\r\n    U0 =  (2.*U0-R)/R.y;\r\n\tU = U0 * z;\r\n    Ur = U+.2*rnd(floor(U)); // local star location\r\n    \r\n    O -= O;\r\n    \r\n    //if (floor(U)==floor(Ur))\r\n        for (float x=-1.; x<=1.; x+=1./N)\r\n            for (float y=-1.; y<=1.; y+=1./N)\r\n                \r\n                Us = Ur + vec2(x,y)*z/R.y,\r\n                r = length( fract(Us)-.5 + floor(Us)-floor(U) ),\r\n\t            O += U0.x<0. \r\n                   ? 6e-4/( pow(r/z,3.) * z*z)     // pix = clamp ( Emit/dist^2 * Bessel )\r\n                   : smoothstep(1.,.8, r*8.);      // pix = disk ( R/dist )\r\n                 //? 1./( pow(r,3.) * z*z)         \r\n                 //: smoothstep(1.,.8, r/1.5*z);   \r\n\r\n    O *= vec4(1,.5,.2,1) / pow(N+N+1.,2.);         // color and sum normalization       \r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"stars - PSF + saturation ","id":"20379ba94c054b23827a05e5fcea5498","date":null,"viewed":0,"name":"stars - PSF + saturation ","description":"How to draw stars as in astronomic photos ?\r\nStars are only a fraction of pixel, but hugely brighter than the max pixel value, plus the lens PSF causes bloom. So the disk you see (L) is just a clamped bloom r~=1/d^2/3, not a projected sphere r~=1/d (R). \r\nhttps://www.shadertoy.com/view/Xty3zc","likes":0,"published":null,"tags":["star"," psf"," sensor"]},"ver":null,"info":{"Name":"stars - PSF + saturation ","id":"20379ba94c054b23827a05e5fcea5498","date":null,"viewed":0,"name":"stars - PSF + saturation ","description":"How to draw stars as in astronomic photos ?\r\nStars are only a fraction of pixel, but hugely brighter than the max pixel value, plus the lens PSF causes bloom. So the disk you see (L) is just a clamped bloom r~=1/d^2/3, not a projected sphere r~=1/d (R). \r\nhttps://www.shadertoy.com/view/Xty3zc","likes":0,"published":null,"tags":["star"," psf"," sensor"]},"renderpass":[{"Code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// Full telescope PSF + BB emission spectrum: see https://www.shadertoy.com/view/XdsGWs\r\n\r\n#define N 4. // oversampling (use power of 2)\r\n\r\n#define rnd(U) ( 2.* fract( 4356.17 * sin( 1e4* dot(U, vec2(1,171.3)) )) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U0 )\r\n{\r\n    float z = 3.+iTime, r;\r\n    vec2 R = iResolution.xy, U, Ur, Us;\r\n    U0 =  (2.*U0-R)/R.y;\r\n\tU = U0 * z;\r\n    Ur = U+.2*rnd(floor(U)); // local star location\r\n    \r\n    O -= O;\r\n    \r\n    //if (floor(U)==floor(Ur))\r\n        for (float x=-1.; x<=1.; x+=1./N)\r\n            for (float y=-1.; y<=1.; y+=1./N)\r\n                \r\n                Us = Ur + vec2(x,y)*z/R.y,\r\n                r = length( fract(Us)-.5 + floor(Us)-floor(U) ),\r\n\t            O += U0.x<0. \r\n                   ? 6e-4/( pow(r/z,3.) * z*z)     // pix = clamp ( Emit/dist^2 * Bessel )\r\n                   : smoothstep(1.,.8, r*8.);      // pix = disk ( R/dist )\r\n                 //? 1./( pow(r,3.) * z*z)         \r\n                 //: smoothstep(1.,.8, r/1.5*z);   \r\n\r\n    O *= vec4(1,.5,.2,1) / pow(N+N+1.,2.);         // color and sum normalization       \r\n}","inputs":[],"outputs":[],"code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// Full telescope PSF + BB emission spectrum: see https://www.shadertoy.com/view/XdsGWs\r\n\r\n#define N 4. // oversampling (use power of 2)\r\n\r\n#define rnd(U) ( 2.* fract( 4356.17 * sin( 1e4* dot(U, vec2(1,171.3)) )) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U0 )\r\n{\r\n    float z = 3.+iTime, r;\r\n    vec2 R = iResolution.xy, U, Ur, Us;\r\n    U0 =  (2.*U0-R)/R.y;\r\n\tU = U0 * z;\r\n    Ur = U+.2*rnd(floor(U)); // local star location\r\n    \r\n    O -= O;\r\n    \r\n    //if (floor(U)==floor(Ur))\r\n        for (float x=-1.; x<=1.; x+=1./N)\r\n            for (float y=-1.; y<=1.; y+=1./N)\r\n                \r\n                Us = Ur + vec2(x,y)*z/R.y,\r\n                r = length( fract(Us)-.5 + floor(Us)-floor(U) ),\r\n\t            O += U0.x<0. \r\n                   ? 6e-4/( pow(r/z,3.) * z*z)     // pix = clamp ( Emit/dist^2 * Bessel )\r\n                   : smoothstep(1.,.8, r*8.);      // pix = disk ( R/dist )\r\n                 //? 1./( pow(r,3.) * z*z)         \r\n                 //: smoothstep(1.,.8, r/1.5*z);   \r\n\r\n    O *= vec4(1,.5,.2,1) / pow(N+N+1.,2.);         // color and sum normalization       \r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","inputs":[],"outputs":[],"code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Stone Circle ","id":"55b24a179a814cff844d96116c51ee7a","date":null,"viewed":0,"name":"Stone Circle ","description":"Inspired by a story generated using an artificial intelligence.","likes":0,"published":null,"tags":["raymarching"," modeling"," distancemap"," stonecircle"]},"ver":null,"info":{"Name":"Stone Circle ","id":"55b24a179a814cff844d96116c51ee7a","date":null,"viewed":0,"name":"Stone Circle ","description":"Inspired by a story generated using an artificial intelligence.","likes":0,"published":null,"tags":["raymarching"," modeling"," distancemap"," stonecircle"]},"renderpass":[{"Code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","inputs":[],"outputs":[],"code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Storm in a teacup\r\n//\r\n// This started with me trying to work out how to make a cloud,\r\n// and then kinda developed from there...\r\n// The sea and plane are deliberately voxel-y, partly\r\n// to keep the frame rate up and partly coz I just like it. :)\r\n//\r\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\r\n// and a bunch of others for sharing their knowledge!\r\n\r\n#define MIN_DIST   0.0015\r\n#define MAX_DIST   55.0\r\n#define MAX_STEPS  120.0\r\n#define SHADOW_STEPS  32.0\r\n#define MAX_SHADOW_DIST 3.0\r\n#define CLOUD_STEPS  20.0\r\n\r\nfloat time, flash, glow;\r\n\r\n//#define AA  // Enable this line if your GPU can take it!\r\n\r\nstruct MarchData {\r\n    float d;\r\n    vec3 mat;        // RGB\r\n    bool isCloud;\r\n};\r\n\r\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\r\nfloat noise(vec3 p) {\r\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\r\n\tvec3 ip = floor(p);\r\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\r\n\tp -= ip;\r\n\t\r\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\r\n\t\r\n    h.xy = mix(h.xz, h.yw, p.y);\r\n    return mix(h.x, h.y, p.z);\r\n}\r\n\r\nfloat noise(float n) {\r\n    float flr = floor(n);\r\n    vec2 rndRange = fract(sin(vec2(flr, flr + 1.0) * 12.9898) * 43758.5453);\r\n    return mix(rndRange.x, rndRange.y, fract(n));\r\n}\r\n\r\nfloat smin(float a, float b, float k) {\r\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n    return mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nMarchData minResult(MarchData a, MarchData b) {\r\n    if (a.d < b.d) return a;\r\n    return b;\r\n}\r\n\r\nmat2 rot(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\nfloat sdCappedCylinder(vec3 p, float h, float r) {\r\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\r\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nMarchData sdSea(vec3 p, const float bowlInner) {\r\n    MarchData result;\r\n    result.isCloud = false;\r\n\r\n\tmat2 r = rot(23.23);\r\n\r\n    vec2 af = vec2(1.0);\r\n    const vec2 afc = vec2(0.5, 1.64);\r\n    float t = time * 0.4;\r\n\r\n    float wave = noise(p.x);\r\n    for (int i = 0; i < 8; i++) {\r\n\t    wave += (1.0 - abs(sin((p.x + t) * af.y))) * af.x; p.xz *= r; af *= afc; \r\n    }\r\n    \r\n    result.d = max(p.y + 1.0 - wave * 0.3, bowlInner);\r\n    result.mat = vec3(0.03, 0.09, 0.12) * wave;\r\n    return result;\r\n}\r\n\r\nMarchData sdCup(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(1.0);\r\n    result.isCloud = false;\r\n    \r\n    float bowlInner = length(p) + p.y * 0.1 - 2.0;\r\n    \r\n    float h = max(abs(length(p.xy - vec2(2.0, p.x * p.x * 0.1 - 1.1)) - 0.5) - 0.06, abs(p.z) - 0.06);\r\n    result.d = smin(max(abs(bowlInner) - 0.06, p.y), max(h, -bowlInner), 0.1);\r\n    \r\n    return minResult(result, sdSea(p, bowlInner));\r\n}\r\n\r\nfloat sdSaucer(vec3 p) {\r\n    float l = length(p.xz);\r\n    p.y += 1.9 - l * (0.1 + 0.02 * smoothstep(0.0, 0.1, l - 2.05));\r\n    return sdCappedCylinder(p.xzy, 2.6, 0.01) - 0.02;\r\n}\r\n\r\nvec3 getRayDir(vec3 ro, vec2 uv) {\r\n    vec3 forward = normalize(-ro);\r\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\r\n    vec3 up = cross(forward, right);\r\n    return normalize(forward + right * uv.x + up * uv.y);\r\n}\r\n\r\nfloat sdCloud(vec3 p) {\r\n    float n1 = noise(p * 4.0) + noise(p * 9.292 - vec3(0.0, time, 0.0)) * 0.4;\r\n    \r\n    float n = abs(smoothstep(0.0, 1.0, n1 * 0.3) - 0.4) + 0.55;\r\n    p.y -= 1.3;\r\n    return min(length(p + vec3(0.4, 0.0, 0.0)), length(p - vec3(0.4, 0.0, 0.0))) - n;\r\n}\r\n\r\nMarchData sdPlane(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(0.29, 0.33, 0.13);\r\n    result.isCloud = false;\r\n\r\n    // Scale, position, rotate.\r\n    p *= 1.5;\r\n    p.xz *= rot(time * 0.6);\r\n    p.xy -= vec2(1.5, 0.4);\r\n    p.xy *= rot(sin(time * 3.0) * 0.1);\r\n    \r\n    // Fuselage.\r\n    vec3 pp = p + vec3(0.0, 0.0, 0.15);\r\n    result.d = sdBox(pp, vec2(0.04 + pp.z * 0.05, 0.3).xxy);\r\n    \r\n    // Prop.\r\n    vec3 ppp = pp;\r\n    ppp.z -= 0.33;\r\n    ppp.xy *= rot(time * 8.0);\r\n    float d = sdBox(ppp, vec3(0.09, 0.01 * sin(length(p.xy) * 34.0), 0.005));\r\n    \r\n    // Tail.\r\n    pp.yz += vec2(-0.05, 0.26);\r\n    result.d = min(result.d, sdBox(pp, vec3(0.01, 0.06 * cos(pp.z * 25.6), 0.03)));\r\n    result.d = min(result.d, sdBox(pp + vec3(0.0, 0.05, 0.0), vec3(0.15 * cos(pp.z * 12.0), 0.01, 0.03)));\r\n    \r\n    // Wings\r\n    p.y = abs(p.y) - 0.08;\r\n    result.d = min(result.d, sdBox(p, vec3(0.3, 0.01, 0.1)));\r\n    \r\n    if (d < result.d) {\r\n        result.d = d;\r\n        result.mat = vec3(0.05);\r\n    }\r\n\r\n    result.d = (result.d - 0.005) * 0.4;\r\n    return result;\r\n}\r\n\r\n// Map the scene using SDF functions.\r\nbool hideCloud;\r\nMarchData map(vec3 p) {\r\n    MarchData result = sdCup(p);\r\n\r\n    result.d = min(result.d, sdSaucer(p));\r\n    result = minResult(result, sdPlane(p));\r\n    \r\n    float d;\r\n    if (flash > 0.0) {\r\n        d = length(p.xz * rot(fract(time) * 3.141) + vec2(noise(p.y * 6.5) * 0.08) - vec2(0.5, 0.0));\r\n        d = max(d, p.y - 0.7);\r\n        glow += 0.001 / (0.01 + 2.0 * d * d);\r\n        if (d < result.d) result.d = d;\r\n    }\r\n    \r\n    float gnd = length(p.y + 1.7);\r\n    if (gnd < result.d) {\r\n        result.d = gnd;\r\n        result.mat = vec3(0.2);\r\n    }\r\n\r\n    if (!hideCloud) {\r\n        d = sdCloud(p);\r\n        if (d < result.d) {\r\n            result.d = d * 0.7;\r\n            result.isCloud = true;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nvec3 calcNormal(vec3 p, float t) {\r\n    vec2 e = vec2(0.5773, -0.5773) * t * 0.0001;\r\n    return normalize(e.xyy * map(p + e.xyy).d + \r\n\t\t\t\t\t   e.yyx * map(p + e.yyx).d + \r\n\t\t\t\t\t   e.yxy * map(p + e.yxy).d + \r\n\t\t\t\t\t   e.xxx * map(p + e.xxx).d);\r\n}\r\n\r\nvec3 cloudNormal(vec3 p) {\r\n    const vec2 e = vec2(0.5773, -0.5773);\r\n    return normalize(e.xyy * sdCloud(p + e.xyy) + \r\n\t\t\t\t\t e.yyx * sdCloud(p + e.yyx) + \r\n\t\t\t\t\t e.yxy * sdCloud(p + e.yxy) + \r\n\t\t\t\t\t e.xxx * sdCloud(p + e.xxx));\r\n}\r\n\r\nfloat calcShadow(vec3 p, vec3 lightPos) {\r\n    // Thanks iq.\r\n    vec3 rd = normalize(lightPos - p);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = 0.1;\r\n    for (float i = 0.0; i < SHADOW_STEPS; i++)\r\n    {\r\n\t\tfloat h = map(p + rd * t).d;\r\n        res = min(res, 10.0 * h / t);\r\n        t += h;\r\n        if (res < 0.001 || t > MAX_SHADOW_DIST) break;\r\n    }\r\n    \r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n// Quick ambient occlusion.\r\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\r\nfloat cloudAo(vec3 p, vec3 n, float h) { return sdCloud(p + h * n) / h; }\r\n\r\n/**********************************************************************************/\r\n\r\nvec3 vignette(vec3 col, vec2 fragCoord) {\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\r\n    return col;\r\n}\r\n\r\nconst vec3 sunPos = vec3(6.0, 10.0, -4.0);\r\nconst vec3 sunCol = vec3(2.0, 1.6, 1.4);\r\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\r\n    vec3 sunDir = normalize(sunPos - p);\r\n    vec3 n = calcNormal(p, d);\r\n    float amb = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\r\n    \r\n    // Secondary(/bounce) light.\r\n    float bounce = max(0.0, dot(sunDir * vec3(-1.0, 0.0, -1.0), n)) * 0.3;\r\n    \r\n    float primary = max(0.0, dot(sunDir, n)) * mix(0.4, 1.0, calcShadow(p, sunPos));\r\n    return data.mat * (primary + bounce) * amb * sunCol * exp(-length(p) * 0.14);\r\n}\r\n\r\nvec3 cloudLighting(vec3 p, float den) {\r\n    vec3 n = cloudNormal(p);\r\n    vec3 col = sunCol * (1.0 + flash);\r\n    return min(0.75, den) * max(0.1, dot(normalize(sunPos - p), n)) * cloudAo(p, n, 1.0) * col;\r\n}\r\n\r\nvec3 getSceneColor(vec3 ro, vec3 rd) {\r\n    // Raymarch.\r\n    vec3 p;\r\n    MarchData h;\r\n    float d = 0.01;\r\n\tfloat den = 0.0;\r\n    hideCloud = false;\r\n    vec3 cloudP;\r\n    float maxCloudD = 0.0;\r\n    for (float steps = 0.0; steps < MAX_STEPS; steps++) {\r\n        p = ro + rd * d;\r\n        h = map(p);\r\n        \r\n        if (h.d < MIN_DIST) {\r\n            if (!h.isCloud)\r\n                break;\r\n\r\n            hideCloud = true;\r\n            cloudP = p;\r\n            maxCloudD = 20.0 - sdCloud(p + rd * 20.0);\r\n        }\r\n        \r\n        if (d > MAX_DIST)\r\n            break; // Distance limit reached - Stop.\r\n        \r\n        d += h.d; // No hit, so keep marching.\r\n    }\r\n    \r\n    if (hideCloud) {\r\n        for (float i = 0.0; i < CLOUD_STEPS; i++)\r\n            den += clamp(-sdCloud(cloudP + rd * (maxCloudD * i / CLOUD_STEPS)) * 0.2, 0.0, 1.0);\r\n    }\r\n    \r\n    hideCloud = false;\r\n    \r\n    return applyLighting(p, rd, d, h) + cloudLighting(cloudP, den) + vec3(glow) + flash * 0.05;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    time = mod(iTime, 120.0);\r\n    flash = step(0.55, pow(noise(time * 8.0), 5.0));\r\n\r\n    vec3 ro = vec3(0.0, 2.0, -5.0);\r\n    ro.xz *= rot(-0.6);\r\n    \r\n    vec3 col = vec3(0.0);\r\n#ifdef AA\r\n    for (float dx = 0.0; dx <= 1.0; dx++) {\r\n        for (float dy = 0.0; dy <= 1.0; dy++) {\r\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\r\n#else\r\n            vec2 coord = fragCoord;\r\n#endif\r\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\r\n\r\n            col += getSceneColor(ro, getRayDir(ro, uv));\r\n#ifdef AA\r\n        }\r\n    }\r\n    col /= 4.0;\r\n#endif\r\n    \r\n    // Output to screen.\r\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Storm in a teacup\r\n//\r\n// This started with me trying to work out how to make a cloud,\r\n// and then kinda developed from there...\r\n// The sea and plane are deliberately voxel-y, partly\r\n// to keep the frame rate up and partly coz I just like it. :)\r\n//\r\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\r\n// and a bunch of others for sharing their knowledge!\r\n\r\n#define MIN_DIST   0.0015\r\n#define MAX_DIST   55.0\r\n#define MAX_STEPS  120.0\r\n#define SHADOW_STEPS  32.0\r\n#define MAX_SHADOW_DIST 3.0\r\n#define CLOUD_STEPS  20.0\r\n\r\nfloat time, flash, glow;\r\n\r\n//#define AA  // Enable this line if your GPU can take it!\r\n\r\nstruct MarchData {\r\n    float d;\r\n    vec3 mat;        // RGB\r\n    bool isCloud;\r\n};\r\n\r\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\r\nfloat noise(vec3 p) {\r\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\r\n\tvec3 ip = floor(p);\r\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\r\n\tp -= ip;\r\n\t\r\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\r\n\t\r\n    h.xy = mix(h.xz, h.yw, p.y);\r\n    return mix(h.x, h.y, p.z);\r\n}\r\n\r\nfloat noise(float n) {\r\n    float flr = floor(n);\r\n    vec2 rndRange = fract(sin(vec2(flr, flr + 1.0) * 12.9898) * 43758.5453);\r\n    return mix(rndRange.x, rndRange.y, fract(n));\r\n}\r\n\r\nfloat smin(float a, float b, float k) {\r\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n    return mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nMarchData minResult(MarchData a, MarchData b) {\r\n    if (a.d < b.d) return a;\r\n    return b;\r\n}\r\n\r\nmat2 rot(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\nfloat sdCappedCylinder(vec3 p, float h, float r) {\r\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\r\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nMarchData sdSea(vec3 p, const float bowlInner) {\r\n    MarchData result;\r\n    result.isCloud = false;\r\n\r\n\tmat2 r = rot(23.23);\r\n\r\n    vec2 af = vec2(1.0);\r\n    const vec2 afc = vec2(0.5, 1.64);\r\n    float t = time * 0.4;\r\n\r\n    float wave = noise(p.x);\r\n    for (int i = 0; i < 8; i++) {\r\n\t    wave += (1.0 - abs(sin((p.x + t) * af.y))) * af.x; p.xz *= r; af *= afc; \r\n    }\r\n    \r\n    result.d = max(p.y + 1.0 - wave * 0.3, bowlInner);\r\n    result.mat = vec3(0.03, 0.09, 0.12) * wave;\r\n    return result;\r\n}\r\n\r\nMarchData sdCup(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(1.0);\r\n    result.isCloud = false;\r\n    \r\n    float bowlInner = length(p) + p.y * 0.1 - 2.0;\r\n    \r\n    float h = max(abs(length(p.xy - vec2(2.0, p.x * p.x * 0.1 - 1.1)) - 0.5) - 0.06, abs(p.z) - 0.06);\r\n    result.d = smin(max(abs(bowlInner) - 0.06, p.y), max(h, -bowlInner), 0.1);\r\n    \r\n    return minResult(result, sdSea(p, bowlInner));\r\n}\r\n\r\nfloat sdSaucer(vec3 p) {\r\n    float l = length(p.xz);\r\n    p.y += 1.9 - l * (0.1 + 0.02 * smoothstep(0.0, 0.1, l - 2.05));\r\n    return sdCappedCylinder(p.xzy, 2.6, 0.01) - 0.02;\r\n}\r\n\r\nvec3 getRayDir(vec3 ro, vec2 uv) {\r\n    vec3 forward = normalize(-ro);\r\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\r\n    vec3 up = cross(forward, right);\r\n    return normalize(forward + right * uv.x + up * uv.y);\r\n}\r\n\r\nfloat sdCloud(vec3 p) {\r\n    float n1 = noise(p * 4.0) + noise(p * 9.292 - vec3(0.0, time, 0.0)) * 0.4;\r\n    \r\n    float n = abs(smoothstep(0.0, 1.0, n1 * 0.3) - 0.4) + 0.55;\r\n    p.y -= 1.3;\r\n    return min(length(p + vec3(0.4, 0.0, 0.0)), length(p - vec3(0.4, 0.0, 0.0))) - n;\r\n}\r\n\r\nMarchData sdPlane(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(0.29, 0.33, 0.13);\r\n    result.isCloud = false;\r\n\r\n    // Scale, position, rotate.\r\n    p *= 1.5;\r\n    p.xz *= rot(time * 0.6);\r\n    p.xy -= vec2(1.5, 0.4);\r\n    p.xy *= rot(sin(time * 3.0) * 0.1);\r\n    \r\n    // Fuselage.\r\n    vec3 pp = p + vec3(0.0, 0.0, 0.15);\r\n    result.d = sdBox(pp, vec2(0.04 + pp.z * 0.05, 0.3).xxy);\r\n    \r\n    // Prop.\r\n    vec3 ppp = pp;\r\n    ppp.z -= 0.33;\r\n    ppp.xy *= rot(time * 8.0);\r\n    float d = sdBox(ppp, vec3(0.09, 0.01 * sin(length(p.xy) * 34.0), 0.005));\r\n    \r\n    // Tail.\r\n    pp.yz += vec2(-0.05, 0.26);\r\n    result.d = min(result.d, sdBox(pp, vec3(0.01, 0.06 * cos(pp.z * 25.6), 0.03)));\r\n    result.d = min(result.d, sdBox(pp + vec3(0.0, 0.05, 0.0), vec3(0.15 * cos(pp.z * 12.0), 0.01, 0.03)));\r\n    \r\n    // Wings\r\n    p.y = abs(p.y) - 0.08;\r\n    result.d = min(result.d, sdBox(p, vec3(0.3, 0.01, 0.1)));\r\n    \r\n    if (d < result.d) {\r\n        result.d = d;\r\n        result.mat = vec3(0.05);\r\n    }\r\n\r\n    result.d = (result.d - 0.005) * 0.4;\r\n    return result;\r\n}\r\n\r\n// Map the scene using SDF functions.\r\nbool hideCloud;\r\nMarchData map(vec3 p) {\r\n    MarchData result = sdCup(p);\r\n\r\n    result.d = min(result.d, sdSaucer(p));\r\n    result = minResult(result, sdPlane(p));\r\n    \r\n    float d;\r\n    if (flash > 0.0) {\r\n        d = length(p.xz * rot(fract(time) * 3.141) + vec2(noise(p.y * 6.5) * 0.08) - vec2(0.5, 0.0));\r\n        d = max(d, p.y - 0.7);\r\n        glow += 0.001 / (0.01 + 2.0 * d * d);\r\n        if (d < result.d) result.d = d;\r\n    }\r\n    \r\n    float gnd = length(p.y + 1.7);\r\n    if (gnd < result.d) {\r\n        result.d = gnd;\r\n        result.mat = vec3(0.2);\r\n    }\r\n\r\n    if (!hideCloud) {\r\n        d = sdCloud(p);\r\n        if (d < result.d) {\r\n            result.d = d * 0.7;\r\n            result.isCloud = true;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nvec3 calcNormal(vec3 p, float t) {\r\n    vec2 e = vec2(0.5773, -0.5773) * t * 0.0001;\r\n    return normalize(e.xyy * map(p + e.xyy).d + \r\n\t\t\t\t\t   e.yyx * map(p + e.yyx).d + \r\n\t\t\t\t\t   e.yxy * map(p + e.yxy).d + \r\n\t\t\t\t\t   e.xxx * map(p + e.xxx).d);\r\n}\r\n\r\nvec3 cloudNormal(vec3 p) {\r\n    const vec2 e = vec2(0.5773, -0.5773);\r\n    return normalize(e.xyy * sdCloud(p + e.xyy) + \r\n\t\t\t\t\t e.yyx * sdCloud(p + e.yyx) + \r\n\t\t\t\t\t e.yxy * sdCloud(p + e.yxy) + \r\n\t\t\t\t\t e.xxx * sdCloud(p + e.xxx));\r\n}\r\n\r\nfloat calcShadow(vec3 p, vec3 lightPos) {\r\n    // Thanks iq.\r\n    vec3 rd = normalize(lightPos - p);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = 0.1;\r\n    for (float i = 0.0; i < SHADOW_STEPS; i++)\r\n    {\r\n\t\tfloat h = map(p + rd * t).d;\r\n        res = min(res, 10.0 * h / t);\r\n        t += h;\r\n        if (res < 0.001 || t > MAX_SHADOW_DIST) break;\r\n    }\r\n    \r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n// Quick ambient occlusion.\r\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\r\nfloat cloudAo(vec3 p, vec3 n, float h) { return sdCloud(p + h * n) / h; }\r\n\r\n/**********************************************************************************/\r\n\r\nvec3 vignette(vec3 col, vec2 fragCoord) {\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\r\n    return col;\r\n}\r\n\r\nconst vec3 sunPos = vec3(6.0, 10.0, -4.0);\r\nconst vec3 sunCol = vec3(2.0, 1.6, 1.4);\r\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\r\n    vec3 sunDir = normalize(sunPos - p);\r\n    vec3 n = calcNormal(p, d);\r\n    float amb = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\r\n    \r\n    // Secondary(/bounce) light.\r\n    float bounce = max(0.0, dot(sunDir * vec3(-1.0, 0.0, -1.0), n)) * 0.3;\r\n    \r\n    float primary = max(0.0, dot(sunDir, n)) * mix(0.4, 1.0, calcShadow(p, sunPos));\r\n    return data.mat * (primary + bounce) * amb * sunCol * exp(-length(p) * 0.14);\r\n}\r\n\r\nvec3 cloudLighting(vec3 p, float den) {\r\n    vec3 n = cloudNormal(p);\r\n    vec3 col = sunCol * (1.0 + flash);\r\n    return min(0.75, den) * max(0.1, dot(normalize(sunPos - p), n)) * cloudAo(p, n, 1.0) * col;\r\n}\r\n\r\nvec3 getSceneColor(vec3 ro, vec3 rd) {\r\n    // Raymarch.\r\n    vec3 p;\r\n    MarchData h;\r\n    float d = 0.01;\r\n\tfloat den = 0.0;\r\n    hideCloud = false;\r\n    vec3 cloudP;\r\n    float maxCloudD = 0.0;\r\n    for (float steps = 0.0; steps < MAX_STEPS; steps++) {\r\n        p = ro + rd * d;\r\n        h = map(p);\r\n        \r\n        if (h.d < MIN_DIST) {\r\n            if (!h.isCloud)\r\n                break;\r\n\r\n            hideCloud = true;\r\n            cloudP = p;\r\n            maxCloudD = 20.0 - sdCloud(p + rd * 20.0);\r\n        }\r\n        \r\n        if (d > MAX_DIST)\r\n            break; // Distance limit reached - Stop.\r\n        \r\n        d += h.d; // No hit, so keep marching.\r\n    }\r\n    \r\n    if (hideCloud) {\r\n        for (float i = 0.0; i < CLOUD_STEPS; i++)\r\n            den += clamp(-sdCloud(cloudP + rd * (maxCloudD * i / CLOUD_STEPS)) * 0.2, 0.0, 1.0);\r\n    }\r\n    \r\n    hideCloud = false;\r\n    \r\n    return applyLighting(p, rd, d, h) + cloudLighting(cloudP, den) + vec3(glow) + flash * 0.05;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    time = mod(iTime, 120.0);\r\n    flash = step(0.55, pow(noise(time * 8.0), 5.0));\r\n\r\n    vec3 ro = vec3(0.0, 2.0, -5.0);\r\n    ro.xz *= rot(-0.6);\r\n    \r\n    vec3 col = vec3(0.0);\r\n#ifdef AA\r\n    for (float dx = 0.0; dx <= 1.0; dx++) {\r\n        for (float dy = 0.0; dy <= 1.0; dy++) {\r\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\r\n#else\r\n            vec2 coord = fragCoord;\r\n#endif\r\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\r\n\r\n            col += getSceneColor(ro, getRayDir(ro, uv));\r\n#ifdef AA\r\n        }\r\n    }\r\n    col /= 4.0;\r\n#endif\r\n    \r\n    // Output to screen.\r\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Storm in a teacup","id":"3bf98904890a4e0eb02108b4a24393b7","date":null,"viewed":0,"name":"Storm in a teacup","description":"This started with me trying to work out how to make a cloud, and then developed from there.\nThe sea and plane are deliberately voxel-y, partly to keep the frame rate up and partly coz I just like it.\nNo airplanes were harmed in the making of this shader.\nhttps://www.shadertoy.com/view/tsVcWt","likes":0,"published":null,"tags":["3d"," raymarching"," water"," cineshader"]},"ver":null,"info":{"Name":"Storm in a teacup","id":"3bf98904890a4e0eb02108b4a24393b7","date":null,"viewed":0,"name":"Storm in a teacup","description":"This started with me trying to work out how to make a cloud, and then developed from there.\nThe sea and plane are deliberately voxel-y, partly to keep the frame rate up and partly coz I just like it.\nNo airplanes were harmed in the making of this shader.\nhttps://www.shadertoy.com/view/tsVcWt","likes":0,"published":null,"tags":["3d"," raymarching"," water"," cineshader"]},"renderpass":[{"Code":"// Storm in a teacup\r\n//\r\n// This started with me trying to work out how to make a cloud,\r\n// and then kinda developed from there...\r\n// The sea and plane are deliberately voxel-y, partly\r\n// to keep the frame rate up and partly coz I just like it. :)\r\n//\r\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\r\n// and a bunch of others for sharing their knowledge!\r\n\r\n#define MIN_DIST   0.0015\r\n#define MAX_DIST   55.0\r\n#define MAX_STEPS  120.0\r\n#define SHADOW_STEPS  32.0\r\n#define MAX_SHADOW_DIST 3.0\r\n#define CLOUD_STEPS  20.0\r\n\r\nfloat time, flash, glow;\r\n\r\n//#define AA  // Enable this line if your GPU can take it!\r\n\r\nstruct MarchData {\r\n    float d;\r\n    vec3 mat;        // RGB\r\n    bool isCloud;\r\n};\r\n\r\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\r\nfloat noise(vec3 p) {\r\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\r\n\tvec3 ip = floor(p);\r\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\r\n\tp -= ip;\r\n\t\r\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\r\n\t\r\n    h.xy = mix(h.xz, h.yw, p.y);\r\n    return mix(h.x, h.y, p.z);\r\n}\r\n\r\nfloat noise(float n) {\r\n    float flr = floor(n);\r\n    vec2 rndRange = fract(sin(vec2(flr, flr + 1.0) * 12.9898) * 43758.5453);\r\n    return mix(rndRange.x, rndRange.y, fract(n));\r\n}\r\n\r\nfloat smin(float a, float b, float k) {\r\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n    return mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nMarchData minResult(MarchData a, MarchData b) {\r\n    if (a.d < b.d) return a;\r\n    return b;\r\n}\r\n\r\nmat2 rot(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\nfloat sdCappedCylinder(vec3 p, float h, float r) {\r\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\r\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nMarchData sdSea(vec3 p, const float bowlInner) {\r\n    MarchData result;\r\n    result.isCloud = false;\r\n\r\n\tmat2 r = rot(23.23);\r\n\r\n    vec2 af = vec2(1.0);\r\n    const vec2 afc = vec2(0.5, 1.64);\r\n    float t = time * 0.4;\r\n\r\n    float wave = noise(p.x);\r\n    for (int i = 0; i < 8; i++) {\r\n\t    wave += (1.0 - abs(sin((p.x + t) * af.y))) * af.x; p.xz *= r; af *= afc; \r\n    }\r\n    \r\n    result.d = max(p.y + 1.0 - wave * 0.3, bowlInner);\r\n    result.mat = vec3(0.03, 0.09, 0.12) * wave;\r\n    return result;\r\n}\r\n\r\nMarchData sdCup(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(1.0);\r\n    result.isCloud = false;\r\n    \r\n    float bowlInner = length(p) + p.y * 0.1 - 2.0;\r\n    \r\n    float h = max(abs(length(p.xy - vec2(2.0, p.x * p.x * 0.1 - 1.1)) - 0.5) - 0.06, abs(p.z) - 0.06);\r\n    result.d = smin(max(abs(bowlInner) - 0.06, p.y), max(h, -bowlInner), 0.1);\r\n    \r\n    return minResult(result, sdSea(p, bowlInner));\r\n}\r\n\r\nfloat sdSaucer(vec3 p) {\r\n    float l = length(p.xz);\r\n    p.y += 1.9 - l * (0.1 + 0.02 * smoothstep(0.0, 0.1, l - 2.05));\r\n    return sdCappedCylinder(p.xzy, 2.6, 0.01) - 0.02;\r\n}\r\n\r\nvec3 getRayDir(vec3 ro, vec2 uv) {\r\n    vec3 forward = normalize(-ro);\r\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\r\n    vec3 up = cross(forward, right);\r\n    return normalize(forward + right * uv.x + up * uv.y);\r\n}\r\n\r\nfloat sdCloud(vec3 p) {\r\n    float n1 = noise(p * 4.0) + noise(p * 9.292 - vec3(0.0, time, 0.0)) * 0.4;\r\n    \r\n    float n = abs(smoothstep(0.0, 1.0, n1 * 0.3) - 0.4) + 0.55;\r\n    p.y -= 1.3;\r\n    return min(length(p + vec3(0.4, 0.0, 0.0)), length(p - vec3(0.4, 0.0, 0.0))) - n;\r\n}\r\n\r\nMarchData sdPlane(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(0.29, 0.33, 0.13);\r\n    result.isCloud = false;\r\n\r\n    // Scale, position, rotate.\r\n    p *= 1.5;\r\n    p.xz *= rot(time * 0.6);\r\n    p.xy -= vec2(1.5, 0.4);\r\n    p.xy *= rot(sin(time * 3.0) * 0.1);\r\n    \r\n    // Fuselage.\r\n    vec3 pp = p + vec3(0.0, 0.0, 0.15);\r\n    result.d = sdBox(pp, vec2(0.04 + pp.z * 0.05, 0.3).xxy);\r\n    \r\n    // Prop.\r\n    vec3 ppp = pp;\r\n    ppp.z -= 0.33;\r\n    ppp.xy *= rot(time * 8.0);\r\n    float d = sdBox(ppp, vec3(0.09, 0.01 * sin(length(p.xy) * 34.0), 0.005));\r\n    \r\n    // Tail.\r\n    pp.yz += vec2(-0.05, 0.26);\r\n    result.d = min(result.d, sdBox(pp, vec3(0.01, 0.06 * cos(pp.z * 25.6), 0.03)));\r\n    result.d = min(result.d, sdBox(pp + vec3(0.0, 0.05, 0.0), vec3(0.15 * cos(pp.z * 12.0), 0.01, 0.03)));\r\n    \r\n    // Wings\r\n    p.y = abs(p.y) - 0.08;\r\n    result.d = min(result.d, sdBox(p, vec3(0.3, 0.01, 0.1)));\r\n    \r\n    if (d < result.d) {\r\n        result.d = d;\r\n        result.mat = vec3(0.05);\r\n    }\r\n\r\n    result.d = (result.d - 0.005) * 0.4;\r\n    return result;\r\n}\r\n\r\n// Map the scene using SDF functions.\r\nbool hideCloud;\r\nMarchData map(vec3 p) {\r\n    MarchData result = sdCup(p);\r\n\r\n    result.d = min(result.d, sdSaucer(p));\r\n    result = minResult(result, sdPlane(p));\r\n    \r\n    float d;\r\n    if (flash > 0.0) {\r\n        d = length(p.xz * rot(fract(time) * 3.141) + vec2(noise(p.y * 6.5) * 0.08) - vec2(0.5, 0.0));\r\n        d = max(d, p.y - 0.7);\r\n        glow += 0.001 / (0.01 + 2.0 * d * d);\r\n        if (d < result.d) result.d = d;\r\n    }\r\n    \r\n    float gnd = length(p.y + 1.7);\r\n    if (gnd < result.d) {\r\n        result.d = gnd;\r\n        result.mat = vec3(0.2);\r\n    }\r\n\r\n    if (!hideCloud) {\r\n        d = sdCloud(p);\r\n        if (d < result.d) {\r\n            result.d = d * 0.7;\r\n            result.isCloud = true;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nvec3 calcNormal(vec3 p, float t) {\r\n    vec2 e = vec2(0.5773, -0.5773) * t * 0.0001;\r\n    return normalize(e.xyy * map(p + e.xyy).d + \r\n\t\t\t\t\t   e.yyx * map(p + e.yyx).d + \r\n\t\t\t\t\t   e.yxy * map(p + e.yxy).d + \r\n\t\t\t\t\t   e.xxx * map(p + e.xxx).d);\r\n}\r\n\r\nvec3 cloudNormal(vec3 p) {\r\n    const vec2 e = vec2(0.5773, -0.5773);\r\n    return normalize(e.xyy * sdCloud(p + e.xyy) + \r\n\t\t\t\t\t e.yyx * sdCloud(p + e.yyx) + \r\n\t\t\t\t\t e.yxy * sdCloud(p + e.yxy) + \r\n\t\t\t\t\t e.xxx * sdCloud(p + e.xxx));\r\n}\r\n\r\nfloat calcShadow(vec3 p, vec3 lightPos) {\r\n    // Thanks iq.\r\n    vec3 rd = normalize(lightPos - p);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = 0.1;\r\n    for (float i = 0.0; i < SHADOW_STEPS; i++)\r\n    {\r\n\t\tfloat h = map(p + rd * t).d;\r\n        res = min(res, 10.0 * h / t);\r\n        t += h;\r\n        if (res < 0.001 || t > MAX_SHADOW_DIST) break;\r\n    }\r\n    \r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n// Quick ambient occlusion.\r\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\r\nfloat cloudAo(vec3 p, vec3 n, float h) { return sdCloud(p + h * n) / h; }\r\n\r\n/**********************************************************************************/\r\n\r\nvec3 vignette(vec3 col, vec2 fragCoord) {\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\r\n    return col;\r\n}\r\n\r\nconst vec3 sunPos = vec3(6.0, 10.0, -4.0);\r\nconst vec3 sunCol = vec3(2.0, 1.6, 1.4);\r\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\r\n    vec3 sunDir = normalize(sunPos - p);\r\n    vec3 n = calcNormal(p, d);\r\n    float amb = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\r\n    \r\n    // Secondary(/bounce) light.\r\n    float bounce = max(0.0, dot(sunDir * vec3(-1.0, 0.0, -1.0), n)) * 0.3;\r\n    \r\n    float primary = max(0.0, dot(sunDir, n)) * mix(0.4, 1.0, calcShadow(p, sunPos));\r\n    return data.mat * (primary + bounce) * amb * sunCol * exp(-length(p) * 0.14);\r\n}\r\n\r\nvec3 cloudLighting(vec3 p, float den) {\r\n    vec3 n = cloudNormal(p);\r\n    vec3 col = sunCol * (1.0 + flash);\r\n    return min(0.75, den) * max(0.1, dot(normalize(sunPos - p), n)) * cloudAo(p, n, 1.0) * col;\r\n}\r\n\r\nvec3 getSceneColor(vec3 ro, vec3 rd) {\r\n    // Raymarch.\r\n    vec3 p;\r\n    MarchData h;\r\n    float d = 0.01;\r\n\tfloat den = 0.0;\r\n    hideCloud = false;\r\n    vec3 cloudP;\r\n    float maxCloudD = 0.0;\r\n    for (float steps = 0.0; steps < MAX_STEPS; steps++) {\r\n        p = ro + rd * d;\r\n        h = map(p);\r\n        \r\n        if (h.d < MIN_DIST) {\r\n            if (!h.isCloud)\r\n                break;\r\n\r\n            hideCloud = true;\r\n            cloudP = p;\r\n            maxCloudD = 20.0 - sdCloud(p + rd * 20.0);\r\n        }\r\n        \r\n        if (d > MAX_DIST)\r\n            break; // Distance limit reached - Stop.\r\n        \r\n        d += h.d; // No hit, so keep marching.\r\n    }\r\n    \r\n    if (hideCloud) {\r\n        for (float i = 0.0; i < CLOUD_STEPS; i++)\r\n            den += clamp(-sdCloud(cloudP + rd * (maxCloudD * i / CLOUD_STEPS)) * 0.2, 0.0, 1.0);\r\n    }\r\n    \r\n    hideCloud = false;\r\n    \r\n    return applyLighting(p, rd, d, h) + cloudLighting(cloudP, den) + vec3(glow) + flash * 0.05;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    time = mod(iTime, 120.0);\r\n    flash = step(0.55, pow(noise(time * 8.0), 5.0));\r\n\r\n    vec3 ro = vec3(0.0, 2.0, -5.0);\r\n    ro.xz *= rot(-0.6);\r\n    \r\n    vec3 col = vec3(0.0);\r\n#ifdef AA\r\n    for (float dx = 0.0; dx <= 1.0; dx++) {\r\n        for (float dy = 0.0; dy <= 1.0; dy++) {\r\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\r\n#else\r\n            vec2 coord = fragCoord;\r\n#endif\r\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\r\n\r\n            col += getSceneColor(ro, getRayDir(ro, uv));\r\n#ifdef AA\r\n        }\r\n    }\r\n    col /= 4.0;\r\n#endif\r\n    \r\n    // Output to screen.\r\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Storm in a teacup\r\n//\r\n// This started with me trying to work out how to make a cloud,\r\n// and then kinda developed from there...\r\n// The sea and plane are deliberately voxel-y, partly\r\n// to keep the frame rate up and partly coz I just like it. :)\r\n//\r\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\r\n// and a bunch of others for sharing their knowledge!\r\n\r\n#define MIN_DIST   0.0015\r\n#define MAX_DIST   55.0\r\n#define MAX_STEPS  120.0\r\n#define SHADOW_STEPS  32.0\r\n#define MAX_SHADOW_DIST 3.0\r\n#define CLOUD_STEPS  20.0\r\n\r\nfloat time, flash, glow;\r\n\r\n//#define AA  // Enable this line if your GPU can take it!\r\n\r\nstruct MarchData {\r\n    float d;\r\n    vec3 mat;        // RGB\r\n    bool isCloud;\r\n};\r\n\r\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\r\nfloat noise(vec3 p) {\r\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\r\n\tvec3 ip = floor(p);\r\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\r\n\tp -= ip;\r\n\t\r\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\r\n\t\r\n    h.xy = mix(h.xz, h.yw, p.y);\r\n    return mix(h.x, h.y, p.z);\r\n}\r\n\r\nfloat noise(float n) {\r\n    float flr = floor(n);\r\n    vec2 rndRange = fract(sin(vec2(flr, flr + 1.0) * 12.9898) * 43758.5453);\r\n    return mix(rndRange.x, rndRange.y, fract(n));\r\n}\r\n\r\nfloat smin(float a, float b, float k) {\r\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n    return mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nMarchData minResult(MarchData a, MarchData b) {\r\n    if (a.d < b.d) return a;\r\n    return b;\r\n}\r\n\r\nmat2 rot(float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nfloat sdBox(vec3 p, vec3 b) {\r\n    vec3 q = abs(p) - b;\r\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\nfloat sdCappedCylinder(vec3 p, float h, float r) {\r\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\r\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\r\n}\r\n\r\nMarchData sdSea(vec3 p, const float bowlInner) {\r\n    MarchData result;\r\n    result.isCloud = false;\r\n\r\n\tmat2 r = rot(23.23);\r\n\r\n    vec2 af = vec2(1.0);\r\n    const vec2 afc = vec2(0.5, 1.64);\r\n    float t = time * 0.4;\r\n\r\n    float wave = noise(p.x);\r\n    for (int i = 0; i < 8; i++) {\r\n\t    wave += (1.0 - abs(sin((p.x + t) * af.y))) * af.x; p.xz *= r; af *= afc; \r\n    }\r\n    \r\n    result.d = max(p.y + 1.0 - wave * 0.3, bowlInner);\r\n    result.mat = vec3(0.03, 0.09, 0.12) * wave;\r\n    return result;\r\n}\r\n\r\nMarchData sdCup(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(1.0);\r\n    result.isCloud = false;\r\n    \r\n    float bowlInner = length(p) + p.y * 0.1 - 2.0;\r\n    \r\n    float h = max(abs(length(p.xy - vec2(2.0, p.x * p.x * 0.1 - 1.1)) - 0.5) - 0.06, abs(p.z) - 0.06);\r\n    result.d = smin(max(abs(bowlInner) - 0.06, p.y), max(h, -bowlInner), 0.1);\r\n    \r\n    return minResult(result, sdSea(p, bowlInner));\r\n}\r\n\r\nfloat sdSaucer(vec3 p) {\r\n    float l = length(p.xz);\r\n    p.y += 1.9 - l * (0.1 + 0.02 * smoothstep(0.0, 0.1, l - 2.05));\r\n    return sdCappedCylinder(p.xzy, 2.6, 0.01) - 0.02;\r\n}\r\n\r\nvec3 getRayDir(vec3 ro, vec2 uv) {\r\n    vec3 forward = normalize(-ro);\r\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\r\n    vec3 up = cross(forward, right);\r\n    return normalize(forward + right * uv.x + up * uv.y);\r\n}\r\n\r\nfloat sdCloud(vec3 p) {\r\n    float n1 = noise(p * 4.0) + noise(p * 9.292 - vec3(0.0, time, 0.0)) * 0.4;\r\n    \r\n    float n = abs(smoothstep(0.0, 1.0, n1 * 0.3) - 0.4) + 0.55;\r\n    p.y -= 1.3;\r\n    return min(length(p + vec3(0.4, 0.0, 0.0)), length(p - vec3(0.4, 0.0, 0.0))) - n;\r\n}\r\n\r\nMarchData sdPlane(vec3 p) {\r\n    MarchData result;\r\n    result.mat = vec3(0.29, 0.33, 0.13);\r\n    result.isCloud = false;\r\n\r\n    // Scale, position, rotate.\r\n    p *= 1.5;\r\n    p.xz *= rot(time * 0.6);\r\n    p.xy -= vec2(1.5, 0.4);\r\n    p.xy *= rot(sin(time * 3.0) * 0.1);\r\n    \r\n    // Fuselage.\r\n    vec3 pp = p + vec3(0.0, 0.0, 0.15);\r\n    result.d = sdBox(pp, vec2(0.04 + pp.z * 0.05, 0.3).xxy);\r\n    \r\n    // Prop.\r\n    vec3 ppp = pp;\r\n    ppp.z -= 0.33;\r\n    ppp.xy *= rot(time * 8.0);\r\n    float d = sdBox(ppp, vec3(0.09, 0.01 * sin(length(p.xy) * 34.0), 0.005));\r\n    \r\n    // Tail.\r\n    pp.yz += vec2(-0.05, 0.26);\r\n    result.d = min(result.d, sdBox(pp, vec3(0.01, 0.06 * cos(pp.z * 25.6), 0.03)));\r\n    result.d = min(result.d, sdBox(pp + vec3(0.0, 0.05, 0.0), vec3(0.15 * cos(pp.z * 12.0), 0.01, 0.03)));\r\n    \r\n    // Wings\r\n    p.y = abs(p.y) - 0.08;\r\n    result.d = min(result.d, sdBox(p, vec3(0.3, 0.01, 0.1)));\r\n    \r\n    if (d < result.d) {\r\n        result.d = d;\r\n        result.mat = vec3(0.05);\r\n    }\r\n\r\n    result.d = (result.d - 0.005) * 0.4;\r\n    return result;\r\n}\r\n\r\n// Map the scene using SDF functions.\r\nbool hideCloud;\r\nMarchData map(vec3 p) {\r\n    MarchData result = sdCup(p);\r\n\r\n    result.d = min(result.d, sdSaucer(p));\r\n    result = minResult(result, sdPlane(p));\r\n    \r\n    float d;\r\n    if (flash > 0.0) {\r\n        d = length(p.xz * rot(fract(time) * 3.141) + vec2(noise(p.y * 6.5) * 0.08) - vec2(0.5, 0.0));\r\n        d = max(d, p.y - 0.7);\r\n        glow += 0.001 / (0.01 + 2.0 * d * d);\r\n        if (d < result.d) result.d = d;\r\n    }\r\n    \r\n    float gnd = length(p.y + 1.7);\r\n    if (gnd < result.d) {\r\n        result.d = gnd;\r\n        result.mat = vec3(0.2);\r\n    }\r\n\r\n    if (!hideCloud) {\r\n        d = sdCloud(p);\r\n        if (d < result.d) {\r\n            result.d = d * 0.7;\r\n            result.isCloud = true;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nvec3 calcNormal(vec3 p, float t) {\r\n    vec2 e = vec2(0.5773, -0.5773) * t * 0.0001;\r\n    return normalize(e.xyy * map(p + e.xyy).d + \r\n\t\t\t\t\t   e.yyx * map(p + e.yyx).d + \r\n\t\t\t\t\t   e.yxy * map(p + e.yxy).d + \r\n\t\t\t\t\t   e.xxx * map(p + e.xxx).d);\r\n}\r\n\r\nvec3 cloudNormal(vec3 p) {\r\n    const vec2 e = vec2(0.5773, -0.5773);\r\n    return normalize(e.xyy * sdCloud(p + e.xyy) + \r\n\t\t\t\t\t e.yyx * sdCloud(p + e.yyx) + \r\n\t\t\t\t\t e.yxy * sdCloud(p + e.yxy) + \r\n\t\t\t\t\t e.xxx * sdCloud(p + e.xxx));\r\n}\r\n\r\nfloat calcShadow(vec3 p, vec3 lightPos) {\r\n    // Thanks iq.\r\n    vec3 rd = normalize(lightPos - p);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = 0.1;\r\n    for (float i = 0.0; i < SHADOW_STEPS; i++)\r\n    {\r\n\t\tfloat h = map(p + rd * t).d;\r\n        res = min(res, 10.0 * h / t);\r\n        t += h;\r\n        if (res < 0.001 || t > MAX_SHADOW_DIST) break;\r\n    }\r\n    \r\n    return clamp(res, 0.0, 1.0);\r\n}\r\n\r\n// Quick ambient occlusion.\r\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\r\nfloat cloudAo(vec3 p, vec3 n, float h) { return sdCloud(p + h * n) / h; }\r\n\r\n/**********************************************************************************/\r\n\r\nvec3 vignette(vec3 col, vec2 fragCoord) {\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\r\n    return col;\r\n}\r\n\r\nconst vec3 sunPos = vec3(6.0, 10.0, -4.0);\r\nconst vec3 sunCol = vec3(2.0, 1.6, 1.4);\r\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\r\n    vec3 sunDir = normalize(sunPos - p);\r\n    vec3 n = calcNormal(p, d);\r\n    float amb = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\r\n    \r\n    // Secondary(/bounce) light.\r\n    float bounce = max(0.0, dot(sunDir * vec3(-1.0, 0.0, -1.0), n)) * 0.3;\r\n    \r\n    float primary = max(0.0, dot(sunDir, n)) * mix(0.4, 1.0, calcShadow(p, sunPos));\r\n    return data.mat * (primary + bounce) * amb * sunCol * exp(-length(p) * 0.14);\r\n}\r\n\r\nvec3 cloudLighting(vec3 p, float den) {\r\n    vec3 n = cloudNormal(p);\r\n    vec3 col = sunCol * (1.0 + flash);\r\n    return min(0.75, den) * max(0.1, dot(normalize(sunPos - p), n)) * cloudAo(p, n, 1.0) * col;\r\n}\r\n\r\nvec3 getSceneColor(vec3 ro, vec3 rd) {\r\n    // Raymarch.\r\n    vec3 p;\r\n    MarchData h;\r\n    float d = 0.01;\r\n\tfloat den = 0.0;\r\n    hideCloud = false;\r\n    vec3 cloudP;\r\n    float maxCloudD = 0.0;\r\n    for (float steps = 0.0; steps < MAX_STEPS; steps++) {\r\n        p = ro + rd * d;\r\n        h = map(p);\r\n        \r\n        if (h.d < MIN_DIST) {\r\n            if (!h.isCloud)\r\n                break;\r\n\r\n            hideCloud = true;\r\n            cloudP = p;\r\n            maxCloudD = 20.0 - sdCloud(p + rd * 20.0);\r\n        }\r\n        \r\n        if (d > MAX_DIST)\r\n            break; // Distance limit reached - Stop.\r\n        \r\n        d += h.d; // No hit, so keep marching.\r\n    }\r\n    \r\n    if (hideCloud) {\r\n        for (float i = 0.0; i < CLOUD_STEPS; i++)\r\n            den += clamp(-sdCloud(cloudP + rd * (maxCloudD * i / CLOUD_STEPS)) * 0.2, 0.0, 1.0);\r\n    }\r\n    \r\n    hideCloud = false;\r\n    \r\n    return applyLighting(p, rd, d, h) + cloudLighting(cloudP, den) + vec3(glow) + flash * 0.05;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    time = mod(iTime, 120.0);\r\n    flash = step(0.55, pow(noise(time * 8.0), 5.0));\r\n\r\n    vec3 ro = vec3(0.0, 2.0, -5.0);\r\n    ro.xz *= rot(-0.6);\r\n    \r\n    vec3 col = vec3(0.0);\r\n#ifdef AA\r\n    for (float dx = 0.0; dx <= 1.0; dx++) {\r\n        for (float dy = 0.0; dy <= 1.0; dy++) {\r\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\r\n#else\r\n            vec2 coord = fragCoord;\r\n#endif\r\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\r\n\r\n            col += getSceneColor(ro, getRayDir(ro, uv));\r\n#ifdef AA\r\n        }\r\n    }\r\n    col /= 4.0;\r\n#endif\r\n    \r\n    // Output to screen.\r\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^This means do anything you want with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// Set this to change detail level. [1 - 10] is a good range.\r\nconst int NUM_SIN_REPS = 9;\r\nconst int MAX_MARCH_REPS = 250;\r\nconst float MARCH_DISTANCE_MULTIPLIER = 0.1;\r\n\r\nfloat localTime = 0.0;\r\n\r\n// some noise functions\r\nfloat Hash(float f)\r\n{\r\n    return fract(cos(f)*7561.0);\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\r\n    float rand = fract(cos(f)*104729.0);\r\n    return rand;\r\n}\r\nvec2 Hash2(vec2 v)\r\n{\r\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\n\r\nfloat mixS(float f0, float f1, float a)\r\n{\r\n    if (a < 0.5) return f0;\r\n    return f1;\r\n}\r\n\r\nfloat mixC(float f0, float f1, float a)\r\n{\r\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\r\n}\r\n\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nvec2 mixP2(vec2 v0, vec2 v1, float a)\r\n{\r\n    return mix(v0, v1, a*a*(3.0-2.0*a));\r\n}\r\n\r\nfloat mixSS(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\r\n}\r\n\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2dVec(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\r\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\r\n    vec2 xMix = mixP2(h0, h1, fr.x);\r\n    return mixC(xMix.x, xMix.y, fr.y);\r\n}\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nfloat PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\nvec3 RotateX(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\r\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\r\n}\r\nvec3 RotateY(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\r\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\r\n}\r\nvec3 RotateZ(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\r\n}\r\n\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\r\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.015 / dist;\r\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\r\n\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\r\n\treturn sunCol * sunIntensity*0.0425;\r\n}\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\r\n\r\nvec3 camPos = vec3(0.0), camFacing;\r\nvec3 camLookat=vec3(0,0.0,0);\r\n\r\nfloat SinRep(float a)\r\n{\r\n    float h = 0.0;\r\n    float mult = 1.0;\r\n    for (int i = 0; i < NUM_SIN_REPS; i++)\r\n    {\r\n        h += (cos(a*mult)/(mult));\r\n        mult *= 2.0;\r\n    }\r\n    return h;\r\n}\r\n\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    float material = 0.0;\r\n    float h = 0.0;\r\n    p = RotateY(p, p.y*0.4 - cos(localTime)*0.4);\r\n    h += SinRep(RotateY(p, p.z*3.14*0.25).x);\r\n    h += SinRep(RotateZ(p, p.x*3.14*0.25).y);\r\n    h += SinRep(RotateX(p, p.y*3.14*0.25).z);\r\n    material = h;\r\n    //h += SinRep(RotateX(p, p.y).z);\r\n    //h += SinRep(RotateZ(p, sin(h)).y);\r\n    //h += SinRep(RotateY(p, h*1.0).x);\r\n    //h += SinRep(p.x+h)*0.5;\r\n    //h += SinRep(p.y+h)*0.5;\r\n    float final = (length(p)-4.0 - h*(0.25 + sin(localTime)*0.35));\r\n    return vec2(final, material);\r\n}\r\n\r\nfloat distFromSphere;\r\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\r\n{\r\n\t// Use dot product along line to find closest point on line\r\n\tvec3 eyeVec2 = normalize(posB-posA);\r\n\tfloat dp = dot(eyeVec2, pos - posA);\r\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\r\n\t// Clamp that point to line end points if outside\r\n\t//if ((dp - radius) < 0) pointOnLine = posA;\r\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\r\n\t// Distance formula from that point to sphere center, compare with radius.\r\n\tfloat distance = length(pointOnLine - pos);\r\n\tfloat ac = radius*radius - distance*distance;\r\n\tfloat rightLen = 0.0;\r\n\tif (ac >= 0.0) rightLen = sqrt(ac);\r\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\r\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\r\n\tdistFromSphere = distance - radius;\r\n\tif (distance <= radius) return 1.0;\r\n\treturn 0.0;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    localTime = iTime - 1.6;\r\n\t// ---------------- First, set up the camera rays for ray marching ----------------\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n\r\n\t// Camera up vector.\r\n\tvec3 camUp=vec3(0,1,0); // vuv\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\t// vrp\r\n\r\n    // debugging camera\r\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime * 0.123;\r\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\r\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(9.2); \t// prp\r\n\r\n\r\n    // add randomness to camera for depth-of-field look close up.\r\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\r\n\r\n\t// Camera setup.\r\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\r\n\tvec3 upNorm=cross(camVec, sideNorm);//v\r\n\tvec3 worldFacing=(camPos + camVec);//vcv\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\r\n\tvec3 relVec = normalize(worldPix - camPos);//scp\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\t// I put a bounding sphere around the whole object. If the ray is outside\r\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\r\n\tvec3 iA, iB;\r\n\tfloat hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\tvec2 distAndMat = vec2(0.05, 0.0);\r\n\tfloat t = 0.0;\r\n\tfloat inc = 0.02;\r\n\tfloat maxDepth = 110.0;\r\n\tvec3 pos = vec3(0,0,0);\r\n    // start and end the camera ray at the sphere intersections.\r\n    camPos = iA;\r\n    maxDepth = distance(iA, iB);\r\n\t// ray marching time\r\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\r\n\t{\r\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\r\n        {\r\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\r\n            pos = camPos + relVec * t;\r\n            // *******************************************************\r\n            // This is _the_ function that defines the \"distance field\".\r\n            // It's really what makes the scene geometry.\r\n            // *******************************************************\r\n            distAndMat = DistanceToObject(pos);\r\n            // adjust by constant because deformations mess up distance function.\r\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\r\n        }\r\n    }\r\n    else\r\n    {\r\n\t\tt = maxDepth + 1.0;\r\n        distAndMat.x = 1.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\r\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n\tif (abs(distAndMat.x) < 0.75)\r\n    //if (t <= maxDepth)\r\n\t{\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(0.005, 0, 0);\r\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\r\n\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff - so the green sphere light source can also have ambient.\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\r\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.2;\r\n\t\tfor (int i = 0; i < 10; i++)\r\n        {\r\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\r\n\t        sunShadow *= saturate(tempDist*10.0);\r\n            if (tempDist <= 0.0) break;\r\n            iter *= 1.5;\t// constant is more reliable than distance-based\r\n            //iter += max(0.2, tempDist)*1.2;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(relVec, normal);\r\n\r\n        // ------ Calculate texture color of the rock ------\r\n        // base texture can be swirled noise.\r\n\t\tvec3 rp = RotateY(pos, pos.y*0.4 - cos(localTime)*0.4);\r\n        float n = noise(rp*4.0) + noise(rp*8.0) + noise(rp*16.0) + noise(rp*32.0);\r\n        n = saturate(n*0.25 * 0.95 + 0.05);\r\n        vec3 texColor = vec3(0.2,0.3,0.3)*n;\r\n\r\n        // fade to reddish texture on outside\r\n        texColor += vec3(0.99, 0.21, 0.213) * clamp(length(pos)-4.0, 0.0, 0.4);\r\n        // give it green-blue texture that matches the shape using normal length\r\n        texColor += vec3(1.0, 21.0, 26.0)*0.6 * saturate(length(normalU)-0.01);\r\n        // Give it a reddish-rust color in the middle\r\n        texColor -= vec3(0.0, 0.3, 0.5)*saturate(-distAndMat.y*(0.9+sin(localTime+0.5)*0.9));\r\n        // make sure it's not too saturated so it looks realistic\r\n        texColor = max(vec3(0.02),texColor);\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\r\n        // sky color, hemisphere light equation approximation, anbient occlusion\r\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.25;\r\n        // ground color - another hemisphere light\r\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n\r\n        // specular highlights - just a little\r\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\r\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\r\n\r\n        // fog that fades to sun color so that fog is brightest towards sun\r\n        finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\r\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        // fade the sky color, multiply sunset dimming\r\n        finalColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\r\n        // add the sun\r\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.95;\r\n\r\n\t// output the final color with sqrt for \"gamma correction\"\r\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^This means do anything you want with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// Set this to change detail level. [1 - 10] is a good range.\r\nconst int NUM_SIN_REPS = 9;\r\nconst int MAX_MARCH_REPS = 250;\r\nconst float MARCH_DISTANCE_MULTIPLIER = 0.1;\r\n\r\nfloat localTime = 0.0;\r\n\r\n// some noise functions\r\nfloat Hash(float f)\r\n{\r\n    return fract(cos(f)*7561.0);\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\r\n    float rand = fract(cos(f)*104729.0);\r\n    return rand;\r\n}\r\nvec2 Hash2(vec2 v)\r\n{\r\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\n\r\nfloat mixS(float f0, float f1, float a)\r\n{\r\n    if (a < 0.5) return f0;\r\n    return f1;\r\n}\r\n\r\nfloat mixC(float f0, float f1, float a)\r\n{\r\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\r\n}\r\n\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nvec2 mixP2(vec2 v0, vec2 v1, float a)\r\n{\r\n    return mix(v0, v1, a*a*(3.0-2.0*a));\r\n}\r\n\r\nfloat mixSS(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\r\n}\r\n\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2dVec(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\r\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\r\n    vec2 xMix = mixP2(h0, h1, fr.x);\r\n    return mixC(xMix.x, xMix.y, fr.y);\r\n}\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nfloat PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\nvec3 RotateX(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\r\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\r\n}\r\nvec3 RotateY(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\r\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\r\n}\r\nvec3 RotateZ(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\r\n}\r\n\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\r\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.015 / dist;\r\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\r\n\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\r\n\treturn sunCol * sunIntensity*0.0425;\r\n}\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\r\n\r\nvec3 camPos = vec3(0.0), camFacing;\r\nvec3 camLookat=vec3(0,0.0,0);\r\n\r\nfloat SinRep(float a)\r\n{\r\n    float h = 0.0;\r\n    float mult = 1.0;\r\n    for (int i = 0; i < NUM_SIN_REPS; i++)\r\n    {\r\n        h += (cos(a*mult)/(mult));\r\n        mult *= 2.0;\r\n    }\r\n    return h;\r\n}\r\n\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    float material = 0.0;\r\n    float h = 0.0;\r\n    p = RotateY(p, p.y*0.4 - cos(localTime)*0.4);\r\n    h += SinRep(RotateY(p, p.z*3.14*0.25).x);\r\n    h += SinRep(RotateZ(p, p.x*3.14*0.25).y);\r\n    h += SinRep(RotateX(p, p.y*3.14*0.25).z);\r\n    material = h;\r\n    //h += SinRep(RotateX(p, p.y).z);\r\n    //h += SinRep(RotateZ(p, sin(h)).y);\r\n    //h += SinRep(RotateY(p, h*1.0).x);\r\n    //h += SinRep(p.x+h)*0.5;\r\n    //h += SinRep(p.y+h)*0.5;\r\n    float final = (length(p)-4.0 - h*(0.25 + sin(localTime)*0.35));\r\n    return vec2(final, material);\r\n}\r\n\r\nfloat distFromSphere;\r\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\r\n{\r\n\t// Use dot product along line to find closest point on line\r\n\tvec3 eyeVec2 = normalize(posB-posA);\r\n\tfloat dp = dot(eyeVec2, pos - posA);\r\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\r\n\t// Clamp that point to line end points if outside\r\n\t//if ((dp - radius) < 0) pointOnLine = posA;\r\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\r\n\t// Distance formula from that point to sphere center, compare with radius.\r\n\tfloat distance = length(pointOnLine - pos);\r\n\tfloat ac = radius*radius - distance*distance;\r\n\tfloat rightLen = 0.0;\r\n\tif (ac >= 0.0) rightLen = sqrt(ac);\r\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\r\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\r\n\tdistFromSphere = distance - radius;\r\n\tif (distance <= radius) return 1.0;\r\n\treturn 0.0;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    localTime = iTime - 1.6;\r\n\t// ---------------- First, set up the camera rays for ray marching ----------------\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n\r\n\t// Camera up vector.\r\n\tvec3 camUp=vec3(0,1,0); // vuv\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\t// vrp\r\n\r\n    // debugging camera\r\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime * 0.123;\r\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\r\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(9.2); \t// prp\r\n\r\n\r\n    // add randomness to camera for depth-of-field look close up.\r\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\r\n\r\n\t// Camera setup.\r\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\r\n\tvec3 upNorm=cross(camVec, sideNorm);//v\r\n\tvec3 worldFacing=(camPos + camVec);//vcv\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\r\n\tvec3 relVec = normalize(worldPix - camPos);//scp\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\t// I put a bounding sphere around the whole object. If the ray is outside\r\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\r\n\tvec3 iA, iB;\r\n\tfloat hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\tvec2 distAndMat = vec2(0.05, 0.0);\r\n\tfloat t = 0.0;\r\n\tfloat inc = 0.02;\r\n\tfloat maxDepth = 110.0;\r\n\tvec3 pos = vec3(0,0,0);\r\n    // start and end the camera ray at the sphere intersections.\r\n    camPos = iA;\r\n    maxDepth = distance(iA, iB);\r\n\t// ray marching time\r\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\r\n\t{\r\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\r\n        {\r\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\r\n            pos = camPos + relVec * t;\r\n            // *******************************************************\r\n            // This is _the_ function that defines the \"distance field\".\r\n            // It's really what makes the scene geometry.\r\n            // *******************************************************\r\n            distAndMat = DistanceToObject(pos);\r\n            // adjust by constant because deformations mess up distance function.\r\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\r\n        }\r\n    }\r\n    else\r\n    {\r\n\t\tt = maxDepth + 1.0;\r\n        distAndMat.x = 1.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\r\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n\tif (abs(distAndMat.x) < 0.75)\r\n    //if (t <= maxDepth)\r\n\t{\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(0.005, 0, 0);\r\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\r\n\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff - so the green sphere light source can also have ambient.\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\r\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.2;\r\n\t\tfor (int i = 0; i < 10; i++)\r\n        {\r\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\r\n\t        sunShadow *= saturate(tempDist*10.0);\r\n            if (tempDist <= 0.0) break;\r\n            iter *= 1.5;\t// constant is more reliable than distance-based\r\n            //iter += max(0.2, tempDist)*1.2;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(relVec, normal);\r\n\r\n        // ------ Calculate texture color of the rock ------\r\n        // base texture can be swirled noise.\r\n\t\tvec3 rp = RotateY(pos, pos.y*0.4 - cos(localTime)*0.4);\r\n        float n = noise(rp*4.0) + noise(rp*8.0) + noise(rp*16.0) + noise(rp*32.0);\r\n        n = saturate(n*0.25 * 0.95 + 0.05);\r\n        vec3 texColor = vec3(0.2,0.3,0.3)*n;\r\n\r\n        // fade to reddish texture on outside\r\n        texColor += vec3(0.99, 0.21, 0.213) * clamp(length(pos)-4.0, 0.0, 0.4);\r\n        // give it green-blue texture that matches the shape using normal length\r\n        texColor += vec3(1.0, 21.0, 26.0)*0.6 * saturate(length(normalU)-0.01);\r\n        // Give it a reddish-rust color in the middle\r\n        texColor -= vec3(0.0, 0.3, 0.5)*saturate(-distAndMat.y*(0.9+sin(localTime+0.5)*0.9));\r\n        // make sure it's not too saturated so it looks realistic\r\n        texColor = max(vec3(0.02),texColor);\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\r\n        // sky color, hemisphere light equation approximation, anbient occlusion\r\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.25;\r\n        // ground color - another hemisphere light\r\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n\r\n        // specular highlights - just a little\r\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\r\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\r\n\r\n        // fog that fades to sun color so that fog is brightest towards sun\r\n        finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\r\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        // fade the sky color, multiply sunset dimming\r\n        finalColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\r\n        // add the sun\r\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.95;\r\n\r\n\t// output the final color with sqrt for \"gamma correction\"\r\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Stractium","id":"be2a10033c94488599b3062da31e8dd2","date":null,"viewed":0,"name":"Stractium","description":"It's just a whole lot of rotations and sine waves ray marched. I tried to make it look natural by keeping textures less saturated and having hard sunlight with shadows.\nhttps://www.shadertoy.com/view/Mlf3R4","likes":0,"published":null,"tags":["procedural"," fractal"," raymarch"]},"ver":null,"info":{"Name":"Stractium","id":"be2a10033c94488599b3062da31e8dd2","date":null,"viewed":0,"name":"Stractium","description":"It's just a whole lot of rotations and sine waves ray marched. I tried to make it look natural by keeping textures less saturated and having hard sunlight with shadows.\nhttps://www.shadertoy.com/view/Mlf3R4","likes":0,"published":null,"tags":["procedural"," fractal"," raymarch"]},"renderpass":[{"Code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^This means do anything you want with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// Set this to change detail level. [1 - 10] is a good range.\r\nconst int NUM_SIN_REPS = 9;\r\nconst int MAX_MARCH_REPS = 250;\r\nconst float MARCH_DISTANCE_MULTIPLIER = 0.1;\r\n\r\nfloat localTime = 0.0;\r\n\r\n// some noise functions\r\nfloat Hash(float f)\r\n{\r\n    return fract(cos(f)*7561.0);\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\r\n    float rand = fract(cos(f)*104729.0);\r\n    return rand;\r\n}\r\nvec2 Hash2(vec2 v)\r\n{\r\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\n\r\nfloat mixS(float f0, float f1, float a)\r\n{\r\n    if (a < 0.5) return f0;\r\n    return f1;\r\n}\r\n\r\nfloat mixC(float f0, float f1, float a)\r\n{\r\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\r\n}\r\n\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nvec2 mixP2(vec2 v0, vec2 v1, float a)\r\n{\r\n    return mix(v0, v1, a*a*(3.0-2.0*a));\r\n}\r\n\r\nfloat mixSS(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\r\n}\r\n\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2dVec(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\r\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\r\n    vec2 xMix = mixP2(h0, h1, fr.x);\r\n    return mixC(xMix.x, xMix.y, fr.y);\r\n}\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nfloat PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\nvec3 RotateX(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\r\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\r\n}\r\nvec3 RotateY(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\r\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\r\n}\r\nvec3 RotateZ(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\r\n}\r\n\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\r\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.015 / dist;\r\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\r\n\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\r\n\treturn sunCol * sunIntensity*0.0425;\r\n}\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\r\n\r\nvec3 camPos = vec3(0.0), camFacing;\r\nvec3 camLookat=vec3(0,0.0,0);\r\n\r\nfloat SinRep(float a)\r\n{\r\n    float h = 0.0;\r\n    float mult = 1.0;\r\n    for (int i = 0; i < NUM_SIN_REPS; i++)\r\n    {\r\n        h += (cos(a*mult)/(mult));\r\n        mult *= 2.0;\r\n    }\r\n    return h;\r\n}\r\n\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    float material = 0.0;\r\n    float h = 0.0;\r\n    p = RotateY(p, p.y*0.4 - cos(localTime)*0.4);\r\n    h += SinRep(RotateY(p, p.z*3.14*0.25).x);\r\n    h += SinRep(RotateZ(p, p.x*3.14*0.25).y);\r\n    h += SinRep(RotateX(p, p.y*3.14*0.25).z);\r\n    material = h;\r\n    //h += SinRep(RotateX(p, p.y).z);\r\n    //h += SinRep(RotateZ(p, sin(h)).y);\r\n    //h += SinRep(RotateY(p, h*1.0).x);\r\n    //h += SinRep(p.x+h)*0.5;\r\n    //h += SinRep(p.y+h)*0.5;\r\n    float final = (length(p)-4.0 - h*(0.25 + sin(localTime)*0.35));\r\n    return vec2(final, material);\r\n}\r\n\r\nfloat distFromSphere;\r\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\r\n{\r\n\t// Use dot product along line to find closest point on line\r\n\tvec3 eyeVec2 = normalize(posB-posA);\r\n\tfloat dp = dot(eyeVec2, pos - posA);\r\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\r\n\t// Clamp that point to line end points if outside\r\n\t//if ((dp - radius) < 0) pointOnLine = posA;\r\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\r\n\t// Distance formula from that point to sphere center, compare with radius.\r\n\tfloat distance = length(pointOnLine - pos);\r\n\tfloat ac = radius*radius - distance*distance;\r\n\tfloat rightLen = 0.0;\r\n\tif (ac >= 0.0) rightLen = sqrt(ac);\r\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\r\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\r\n\tdistFromSphere = distance - radius;\r\n\tif (distance <= radius) return 1.0;\r\n\treturn 0.0;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    localTime = iTime - 1.6;\r\n\t// ---------------- First, set up the camera rays for ray marching ----------------\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n\r\n\t// Camera up vector.\r\n\tvec3 camUp=vec3(0,1,0); // vuv\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\t// vrp\r\n\r\n    // debugging camera\r\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime * 0.123;\r\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\r\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(9.2); \t// prp\r\n\r\n\r\n    // add randomness to camera for depth-of-field look close up.\r\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\r\n\r\n\t// Camera setup.\r\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\r\n\tvec3 upNorm=cross(camVec, sideNorm);//v\r\n\tvec3 worldFacing=(camPos + camVec);//vcv\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\r\n\tvec3 relVec = normalize(worldPix - camPos);//scp\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\t// I put a bounding sphere around the whole object. If the ray is outside\r\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\r\n\tvec3 iA, iB;\r\n\tfloat hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\tvec2 distAndMat = vec2(0.05, 0.0);\r\n\tfloat t = 0.0;\r\n\tfloat inc = 0.02;\r\n\tfloat maxDepth = 110.0;\r\n\tvec3 pos = vec3(0,0,0);\r\n    // start and end the camera ray at the sphere intersections.\r\n    camPos = iA;\r\n    maxDepth = distance(iA, iB);\r\n\t// ray marching time\r\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\r\n\t{\r\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\r\n        {\r\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\r\n            pos = camPos + relVec * t;\r\n            // *******************************************************\r\n            // This is _the_ function that defines the \"distance field\".\r\n            // It's really what makes the scene geometry.\r\n            // *******************************************************\r\n            distAndMat = DistanceToObject(pos);\r\n            // adjust by constant because deformations mess up distance function.\r\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\r\n        }\r\n    }\r\n    else\r\n    {\r\n\t\tt = maxDepth + 1.0;\r\n        distAndMat.x = 1.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\r\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n\tif (abs(distAndMat.x) < 0.75)\r\n    //if (t <= maxDepth)\r\n\t{\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(0.005, 0, 0);\r\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\r\n\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff - so the green sphere light source can also have ambient.\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\r\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.2;\r\n\t\tfor (int i = 0; i < 10; i++)\r\n        {\r\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\r\n\t        sunShadow *= saturate(tempDist*10.0);\r\n            if (tempDist <= 0.0) break;\r\n            iter *= 1.5;\t// constant is more reliable than distance-based\r\n            //iter += max(0.2, tempDist)*1.2;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(relVec, normal);\r\n\r\n        // ------ Calculate texture color of the rock ------\r\n        // base texture can be swirled noise.\r\n\t\tvec3 rp = RotateY(pos, pos.y*0.4 - cos(localTime)*0.4);\r\n        float n = noise(rp*4.0) + noise(rp*8.0) + noise(rp*16.0) + noise(rp*32.0);\r\n        n = saturate(n*0.25 * 0.95 + 0.05);\r\n        vec3 texColor = vec3(0.2,0.3,0.3)*n;\r\n\r\n        // fade to reddish texture on outside\r\n        texColor += vec3(0.99, 0.21, 0.213) * clamp(length(pos)-4.0, 0.0, 0.4);\r\n        // give it green-blue texture that matches the shape using normal length\r\n        texColor += vec3(1.0, 21.0, 26.0)*0.6 * saturate(length(normalU)-0.01);\r\n        // Give it a reddish-rust color in the middle\r\n        texColor -= vec3(0.0, 0.3, 0.5)*saturate(-distAndMat.y*(0.9+sin(localTime+0.5)*0.9));\r\n        // make sure it's not too saturated so it looks realistic\r\n        texColor = max(vec3(0.02),texColor);\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\r\n        // sky color, hemisphere light equation approximation, anbient occlusion\r\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.25;\r\n        // ground color - another hemisphere light\r\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n\r\n        // specular highlights - just a little\r\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\r\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\r\n\r\n        // fog that fades to sun color so that fog is brightest towards sun\r\n        finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\r\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        // fade the sky color, multiply sunset dimming\r\n        finalColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\r\n        // add the sun\r\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.95;\r\n\r\n\t// output the final color with sqrt for \"gamma correction\"\r\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^This means do anything you want with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// Set this to change detail level. [1 - 10] is a good range.\r\nconst int NUM_SIN_REPS = 9;\r\nconst int MAX_MARCH_REPS = 250;\r\nconst float MARCH_DISTANCE_MULTIPLIER = 0.1;\r\n\r\nfloat localTime = 0.0;\r\n\r\n// some noise functions\r\nfloat Hash(float f)\r\n{\r\n    return fract(cos(f)*7561.0);\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\r\n    float rand = fract(cos(f)*104729.0);\r\n    return rand;\r\n}\r\nvec2 Hash2(vec2 v)\r\n{\r\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\n\r\nfloat mixS(float f0, float f1, float a)\r\n{\r\n    if (a < 0.5) return f0;\r\n    return f1;\r\n}\r\n\r\nfloat mixC(float f0, float f1, float a)\r\n{\r\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\r\n}\r\n\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nvec2 mixP2(vec2 v0, vec2 v1, float a)\r\n{\r\n    return mix(v0, v1, a*a*(3.0-2.0*a));\r\n}\r\n\r\nfloat mixSS(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\r\n}\r\n\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2dVec(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\r\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\r\n    vec2 xMix = mixP2(h0, h1, fr.x);\r\n    return mixC(xMix.x, xMix.y, fr.y);\r\n}\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv);\r\n    vec2 fl = floor(uv);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nfloat PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\nvec3 RotateX(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\r\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\r\n}\r\nvec3 RotateY(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\r\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\r\n}\r\nvec3 RotateZ(vec3 v, float rad)\r\n{\r\n  float cos = cos(rad);\r\n  float sin = sin(rad);\r\n  //if (RIGHT_HANDED_COORD)\r\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\r\n}\r\n\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\r\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.015 / dist;\r\n\tsunIntensity = pow(sunIntensity, 0.3)*100.0;\r\n\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\r\n\treturn sunCol * sunIntensity*0.0425;\r\n}\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*12.0)*300.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\r\n\r\nvec3 camPos = vec3(0.0), camFacing;\r\nvec3 camLookat=vec3(0,0.0,0);\r\n\r\nfloat SinRep(float a)\r\n{\r\n    float h = 0.0;\r\n    float mult = 1.0;\r\n    for (int i = 0; i < NUM_SIN_REPS; i++)\r\n    {\r\n        h += (cos(a*mult)/(mult));\r\n        mult *= 2.0;\r\n    }\r\n    return h;\r\n}\r\n\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    float material = 0.0;\r\n    float h = 0.0;\r\n    p = RotateY(p, p.y*0.4 - cos(localTime)*0.4);\r\n    h += SinRep(RotateY(p, p.z*3.14*0.25).x);\r\n    h += SinRep(RotateZ(p, p.x*3.14*0.25).y);\r\n    h += SinRep(RotateX(p, p.y*3.14*0.25).z);\r\n    material = h;\r\n    //h += SinRep(RotateX(p, p.y).z);\r\n    //h += SinRep(RotateZ(p, sin(h)).y);\r\n    //h += SinRep(RotateY(p, h*1.0).x);\r\n    //h += SinRep(p.x+h)*0.5;\r\n    //h += SinRep(p.y+h)*0.5;\r\n    float final = (length(p)-4.0 - h*(0.25 + sin(localTime)*0.35));\r\n    return vec2(final, material);\r\n}\r\n\r\nfloat distFromSphere;\r\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\r\n{\r\n\t// Use dot product along line to find closest point on line\r\n\tvec3 eyeVec2 = normalize(posB-posA);\r\n\tfloat dp = dot(eyeVec2, pos - posA);\r\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\r\n\t// Clamp that point to line end points if outside\r\n\t//if ((dp - radius) < 0) pointOnLine = posA;\r\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\r\n\t// Distance formula from that point to sphere center, compare with radius.\r\n\tfloat distance = length(pointOnLine - pos);\r\n\tfloat ac = radius*radius - distance*distance;\r\n\tfloat rightLen = 0.0;\r\n\tif (ac >= 0.0) rightLen = sqrt(ac);\r\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\r\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\r\n\tdistFromSphere = distance - radius;\r\n\tif (distance <= radius) return 1.0;\r\n\treturn 0.0;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    localTime = iTime - 1.6;\r\n\t// ---------------- First, set up the camera rays for ray marching ----------------\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n\r\n\t// Camera up vector.\r\n\tvec3 camUp=vec3(0,1,0); // vuv\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\t// vrp\r\n\r\n    // debugging camera\r\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime * 0.123;\r\n\tfloat my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\r\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(9.2); \t// prp\r\n\r\n\r\n    // add randomness to camera for depth-of-field look close up.\r\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\r\n\r\n\t// Camera setup.\r\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\r\n\tvec3 upNorm=cross(camVec, sideNorm);//v\r\n\tvec3 worldFacing=(camPos + camVec);//vcv\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\r\n\tvec3 relVec = normalize(worldPix - camPos);//scp\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\t// I put a bounding sphere around the whole object. If the ray is outside\r\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\r\n\tvec3 iA, iB;\r\n\tfloat hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\r\n\r\n\t// --------------------------------------------------------------------------------\r\n\tvec2 distAndMat = vec2(0.05, 0.0);\r\n\tfloat t = 0.0;\r\n\tfloat inc = 0.02;\r\n\tfloat maxDepth = 110.0;\r\n\tvec3 pos = vec3(0,0,0);\r\n    // start and end the camera ray at the sphere intersections.\r\n    camPos = iA;\r\n    maxDepth = distance(iA, iB);\r\n\t// ray marching time\r\n\tif (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\r\n\t{\r\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\r\n        {\r\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\r\n            pos = camPos + relVec * t;\r\n            // *******************************************************\r\n            // This is _the_ function that defines the \"distance field\".\r\n            // It's really what makes the scene geometry.\r\n            // *******************************************************\r\n            distAndMat = DistanceToObject(pos);\r\n            // adjust by constant because deformations mess up distance function.\r\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\r\n        }\r\n    }\r\n    else\r\n    {\r\n\t\tt = maxDepth + 1.0;\r\n        distAndMat.x = 1.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\r\n\tvec3 sunDir = normalize(vec3(0.93, 1.0, -1.5));\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n\tif (abs(distAndMat.x) < 0.75)\r\n    //if (t <= maxDepth)\r\n\t{\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(0.005, 0, 0);\r\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\r\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\r\n\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff - so the green sphere light source can also have ambient.\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\r\n        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\r\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.2;\r\n\t\tfor (int i = 0; i < 10; i++)\r\n        {\r\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\r\n\t        sunShadow *= saturate(tempDist*10.0);\r\n            if (tempDist <= 0.0) break;\r\n            iter *= 1.5;\t// constant is more reliable than distance-based\r\n            //iter += max(0.2, tempDist)*1.2;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(relVec, normal);\r\n\r\n        // ------ Calculate texture color of the rock ------\r\n        // base texture can be swirled noise.\r\n\t\tvec3 rp = RotateY(pos, pos.y*0.4 - cos(localTime)*0.4);\r\n        float n = noise(rp*4.0) + noise(rp*8.0) + noise(rp*16.0) + noise(rp*32.0);\r\n        n = saturate(n*0.25 * 0.95 + 0.05);\r\n        vec3 texColor = vec3(0.2,0.3,0.3)*n;\r\n\r\n        // fade to reddish texture on outside\r\n        texColor += vec3(0.99, 0.21, 0.213) * clamp(length(pos)-4.0, 0.0, 0.4);\r\n        // give it green-blue texture that matches the shape using normal length\r\n        texColor += vec3(1.0, 21.0, 26.0)*0.6 * saturate(length(normalU)-0.01);\r\n        // Give it a reddish-rust color in the middle\r\n        texColor -= vec3(0.0, 0.3, 0.5)*saturate(-distAndMat.y*(0.9+sin(localTime+0.5)*0.9));\r\n        // make sure it's not too saturated so it looks realistic\r\n        texColor = max(vec3(0.02),texColor);\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;\r\n        // sky color, hemisphere light equation approximation, anbient occlusion\r\n        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.25;\r\n        // ground color - another hemisphere light\r\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n\r\n        // specular highlights - just a little\r\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\r\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\r\n\r\n        // fog that fades to sun color so that fog is brightest towards sun\r\n        finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\r\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        // fade the sky color, multiply sunset dimming\r\n        finalColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\r\n        // add the sun\r\n        finalColor += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.95;\r\n\r\n\t// output the final color with sqrt for \"gamma correction\"\r\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//**********************************************************************************\r\n// dusty menger scene from my 4k intro Surveillance\r\n// Virgill 2016\r\n// https://www.youtube.com/watch?v=kiE2c06EzBQ\r\n// http://www.pouet.net/prod.php?which=67120\r\n//**********************************************************************************\r\n\r\n// circle of confusion idea by eiffie\r\n// more interesting menger by shane\r\nfloat focalDistance=20.;\r\nfloat aperature=.04;\r\nfloat fudgeFactor=.9; \r\nfloat shadowCone=.5;\r\nvec4 orbitTrap = vec4(0.);\r\nfloat blend =0.;\r\nfloat d = 0.;\r\nfloat m = 0.;\r\nvec3 pcoc = vec3(0.);\r\nfloat rCoC,h;\r\nvec4 col=vec4(0.);\t\r\nfloat pixelSize;\r\n\r\n// coc (eiffie)\r\nfloat CircleOfConfusion(float t)\r\n{ \r\nreturn max(abs(focalDistance-t)*aperature,pixelSize*(1.0+t));\r\n}\r\n\r\n// linestep (knighty)\r\nfloat linstep(float a, float b, float t)\r\n{\r\n    float v=(t-a)/(b-a);\r\n    return clamp(v,0.,1.);\r\n}\r\n\r\nvec3 rotXaxis(vec3 p, float rad)\r\n{\r\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\r\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\r\n\tp.z = z2;\r\n\tp.y = y2;\r\n\treturn p;\r\n}\r\n\r\nvec3 rotYaxis(vec3 p, float rad) \r\n{\r\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\r\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\r\n\tp.x = x2;\r\n\tp.z = z2;\r\n\treturn p;\r\n}\r\n\r\nvec3 rotZaxis(vec3 p, float rad) \r\n{\r\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.y;\r\n\tfloat y2 = sin(rad) * p.x + cos(rad) * p.y;\r\n\tp.x = x2;\r\n\tp.y = y2;\r\n\treturn p;\r\n}\r\n\r\nfloat rand1(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\n\r\n// new and interesting menger formula (shane)\r\nfloat NewMenger(vec3 q)\r\n{\r\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\r\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;\r\n    p =  abs(fract(q) - .5);\r\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\r\n    p =  abs(fract(q*2.)*.5 - .25);\r\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); \r\n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\r\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// MAP\r\n//***************************************************************************************************\r\n\r\nfloat map(in vec3 p)\r\n{\r\n\torbitTrap = vec4(length(p)-0.8*p.z,length(p)-0.8*p.y,length(p)-0.8*p.x,0.0)*1.0;\r\n\treturn NewMenger(p);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// fuzzy shadow\r\n//***************************************************************************************************\r\n\r\nconst float ShadowContrast = 0.99;\r\nfloat FuzzyShadow(vec3 ro, vec3 rd, float coneGrad, float rCoC){\r\n\tfloat  t=rCoC*2.0,s=1.0;\r\n\tfor(int i=0;i<9;i++)\r\n\t{\r\n\t\tif(s<0.1)continue;\r\n\t\tfloat r=rCoC+t*coneGrad+0.05;\r\n\t\tfloat d=map(ro+rd*t)+r*0.6;\r\n\t\ts*=linstep(-r,r,d);\r\n\t\tt+=abs(d)*(0.8+0.2*rand1(gl_FragCoord.xy*vec2(i)));\r\n\t}\r\n\treturn clamp(s*ShadowContrast+(1.0-ShadowContrast),0.0,1.0);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// Orbit color\r\n//***************************************************************************************************\r\n\r\nfloat Cycles = 4.0;\r\nvec3 cycle(vec3 c, float s) \r\n{\r\n\treturn vec3(0.5)+0.5*vec3(cos(s*Cycles+c.x),cos(s*Cycles+c.y),cos(s*Cycles+c.z));\r\n}\r\n\r\nvec3 BaseColor = vec3(0.2,0.2,0.2);\r\nvec3 OrbitStrength = vec3(0.8, 0.8, 0.8);\r\nvec4 X = vec4(0.6, 0.5, 0.6, 0.2);\r\nvec4 Y = vec4(1.0, 0.5, 0.1, 0.7);\r\nvec4 Z = vec4(0.7, 0.8, 1.0, 0.3);\r\nvec4 R = vec4(0.7, 0.7, 0.5, 0.1);\r\n\r\nvec3 getColor()\r\n{\r\n\torbitTrap.w = sqrt(orbitTrap.w);\r\n\tvec3 orbitColor = cycle(X.xyz,orbitTrap.x)*X.w*orbitTrap.x + cycle(Y.xyz,orbitTrap.y)*Y.w*orbitTrap.y + cycle(Z.xyz,orbitTrap.z)*Z.w*orbitTrap.z + cycle(R.xyz,orbitTrap.w)*R.w*orbitTrap.w;\r\n\tvec3 color = mix(BaseColor, 3.0*orbitColor,  OrbitStrength);\r\n\treturn color;\r\n}\r\n\r\n\r\n \r\n//***************************************************************************************************\r\n// Cast ray\r\n//***************************************************************************************************\r\n\r\n// coc (eiffie)\r\nvoid castRay(in vec3 ro, in vec3 rd) \r\n{\r\n\tvec3 lig = normalize(vec3(0.4+cos((25.+iTime)*0.33), 0.2, 0.6));\t\t\r\n    float t = 0.;\r\n    for (int i = 0; i < 70; i++) \r\n\t{\r\n\t\tif(col.w>0.999 ||t>15.0)continue;\r\n\t\trCoC=CircleOfConfusion(t);\r\n\t\th = map(ro)+0.5*rCoC;\r\n\t\tif(h<rCoC)\r\n\t\t{\r\n\t\t\tpcoc=ro-rd*abs(h-rCoC);\r\n\t\t\tvec2 v=vec2(rCoC*0.5,0.0);\r\n\t\t\tvec3 N=normalize(vec3(-map(pcoc-v.xyy)+map(pcoc+v.xyy),-map(pcoc-v.yxy)+map(pcoc+v.yxy),-map(pcoc-v.yyx)+map(pcoc+v.yyx)));\r\n\t\t\tvec3 scol=2.3*getColor();\t\r\n\t\t\tfloat newdiff = clamp(dot(lig, N), 0.0, 1.0);\r\n\t\t\tfloat newspec = pow(clamp(dot(reflect(rd, N), lig), 0.0, 1.0), 16.0);\r\n\t\t\tfloat newsh   = FuzzyShadow(pcoc,lig,shadowCone,rCoC+0.00);\t\t\t\r\n\t\t\tscol *= 0.5*newdiff+newspec;\r\n\t\t \tscol *= newsh;\r\n\t\t\tfloat alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-h*1.7);\r\n\t\t\tcol+=vec4(scol*alpha,alpha);\r\n\t\t}\r\n\t\th=abs(fudgeFactor*h*(0.3+0.05*rand1(gl_FragCoord.xy*vec2(i))));\r\n\t\tro+=h*rd;\r\n\t\tt += h;\r\n\t}\r\n}\r\n\r\n//***************************************************************************************************\r\n// main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfocalDistance=6.5+3.*cos((25.+iTime)*0.133);\r\n\tpixelSize=1.0/iResolution.y;\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n\tvec2 p = uv * 2.0 - 1.0;\r\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y)); \r\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\r\n    vec2 m = sin(vec2(0, 1.57079632) + (25.+iTime)/4.);\r\n    rd.xy = mat2(m.y, -m.x, m)*rd.xy;\r\n    rd.xz = mat2(m.y, -m.x, m)*rd.xz;\r\n    vec3 ro = vec3(0.0, 2.0, 5.+sin((25.+iTime)/2.));\r\n    \r\n\tcastRay(ro, rd);\r\n\r\n\tvec2 uv2=-0.3+2.*gl_FragCoord.xy/iResolution.xy;\r\n\t//anti branding noise\r\n    col-=0.10*rand1(uv2.xy*iTime);\t\t\t\t\t\t\t\r\n\r\n\r\n\tfragColor = col*0.7;\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"//**********************************************************************************\r\n// dusty menger scene from my 4k intro Surveillance\r\n// Virgill 2016\r\n// https://www.youtube.com/watch?v=kiE2c06EzBQ\r\n// http://www.pouet.net/prod.php?which=67120\r\n//**********************************************************************************\r\n\r\n// circle of confusion idea by eiffie\r\n// more interesting menger by shane\r\nfloat focalDistance=20.;\r\nfloat aperature=.04;\r\nfloat fudgeFactor=.9; \r\nfloat shadowCone=.5;\r\nvec4 orbitTrap = vec4(0.);\r\nfloat blend =0.;\r\nfloat d = 0.;\r\nfloat m = 0.;\r\nvec3 pcoc = vec3(0.);\r\nfloat rCoC,h;\r\nvec4 col=vec4(0.);\t\r\nfloat pixelSize;\r\n\r\n// coc (eiffie)\r\nfloat CircleOfConfusion(float t)\r\n{ \r\nreturn max(abs(focalDistance-t)*aperature,pixelSize*(1.0+t));\r\n}\r\n\r\n// linestep (knighty)\r\nfloat linstep(float a, float b, float t)\r\n{\r\n    float v=(t-a)/(b-a);\r\n    return clamp(v,0.,1.);\r\n}\r\n\r\nvec3 rotXaxis(vec3 p, float rad)\r\n{\r\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\r\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\r\n\tp.z = z2;\r\n\tp.y = y2;\r\n\treturn p;\r\n}\r\n\r\nvec3 rotYaxis(vec3 p, float rad) \r\n{\r\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\r\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\r\n\tp.x = x2;\r\n\tp.z = z2;\r\n\treturn p;\r\n}\r\n\r\nvec3 rotZaxis(vec3 p, float rad) \r\n{\r\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.y;\r\n\tfloat y2 = sin(rad) * p.x + cos(rad) * p.y;\r\n\tp.x = x2;\r\n\tp.y = y2;\r\n\treturn p;\r\n}\r\n\r\nfloat rand1(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\n\r\n// new and interesting menger formula (shane)\r\nfloat NewMenger(vec3 q)\r\n{\r\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\r\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;\r\n    p =  abs(fract(q) - .5);\r\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\r\n    p =  abs(fract(q*2.)*.5 - .25);\r\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); \r\n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\r\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// MAP\r\n//***************************************************************************************************\r\n\r\nfloat map(in vec3 p)\r\n{\r\n\torbitTrap = vec4(length(p)-0.8*p.z,length(p)-0.8*p.y,length(p)-0.8*p.x,0.0)*1.0;\r\n\treturn NewMenger(p);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// fuzzy shadow\r\n//***************************************************************************************************\r\n\r\nconst float ShadowContrast = 0.99;\r\nfloat FuzzyShadow(vec3 ro, vec3 rd, float coneGrad, float rCoC){\r\n\tfloat  t=rCoC*2.0,s=1.0;\r\n\tfor(int i=0;i<9;i++)\r\n\t{\r\n\t\tif(s<0.1)continue;\r\n\t\tfloat r=rCoC+t*coneGrad+0.05;\r\n\t\tfloat d=map(ro+rd*t)+r*0.6;\r\n\t\ts*=linstep(-r,r,d);\r\n\t\tt+=abs(d)*(0.8+0.2*rand1(gl_FragCoord.xy*vec2(i)));\r\n\t}\r\n\treturn clamp(s*ShadowContrast+(1.0-ShadowContrast),0.0,1.0);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// Orbit color\r\n//***************************************************************************************************\r\n\r\nfloat Cycles = 4.0;\r\nvec3 cycle(vec3 c, float s) \r\n{\r\n\treturn vec3(0.5)+0.5*vec3(cos(s*Cycles+c.x),cos(s*Cycles+c.y),cos(s*Cycles+c.z));\r\n}\r\n\r\nvec3 BaseColor = vec3(0.2,0.2,0.2);\r\nvec3 OrbitStrength = vec3(0.8, 0.8, 0.8);\r\nvec4 X = vec4(0.6, 0.5, 0.6, 0.2);\r\nvec4 Y = vec4(1.0, 0.5, 0.1, 0.7);\r\nvec4 Z = vec4(0.7, 0.8, 1.0, 0.3);\r\nvec4 R = vec4(0.7, 0.7, 0.5, 0.1);\r\n\r\nvec3 getColor()\r\n{\r\n\torbitTrap.w = sqrt(orbitTrap.w);\r\n\tvec3 orbitColor = cycle(X.xyz,orbitTrap.x)*X.w*orbitTrap.x + cycle(Y.xyz,orbitTrap.y)*Y.w*orbitTrap.y + cycle(Z.xyz,orbitTrap.z)*Z.w*orbitTrap.z + cycle(R.xyz,orbitTrap.w)*R.w*orbitTrap.w;\r\n\tvec3 color = mix(BaseColor, 3.0*orbitColor,  OrbitStrength);\r\n\treturn color;\r\n}\r\n\r\n\r\n \r\n//***************************************************************************************************\r\n// Cast ray\r\n//***************************************************************************************************\r\n\r\n// coc (eiffie)\r\nvoid castRay(in vec3 ro, in vec3 rd) \r\n{\r\n\tvec3 lig = normalize(vec3(0.4+cos((25.+iTime)*0.33), 0.2, 0.6));\t\t\r\n    float t = 0.;\r\n    for (int i = 0; i < 70; i++) \r\n\t{\r\n\t\tif(col.w>0.999 ||t>15.0)continue;\r\n\t\trCoC=CircleOfConfusion(t);\r\n\t\th = map(ro)+0.5*rCoC;\r\n\t\tif(h<rCoC)\r\n\t\t{\r\n\t\t\tpcoc=ro-rd*abs(h-rCoC);\r\n\t\t\tvec2 v=vec2(rCoC*0.5,0.0);\r\n\t\t\tvec3 N=normalize(vec3(-map(pcoc-v.xyy)+map(pcoc+v.xyy),-map(pcoc-v.yxy)+map(pcoc+v.yxy),-map(pcoc-v.yyx)+map(pcoc+v.yyx)));\r\n\t\t\tvec3 scol=2.3*getColor();\t\r\n\t\t\tfloat newdiff = clamp(dot(lig, N), 0.0, 1.0);\r\n\t\t\tfloat newspec = pow(clamp(dot(reflect(rd, N), lig), 0.0, 1.0), 16.0);\r\n\t\t\tfloat newsh   = FuzzyShadow(pcoc,lig,shadowCone,rCoC+0.00);\t\t\t\r\n\t\t\tscol *= 0.5*newdiff+newspec;\r\n\t\t \tscol *= newsh;\r\n\t\t\tfloat alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-h*1.7);\r\n\t\t\tcol+=vec4(scol*alpha,alpha);\r\n\t\t}\r\n\t\th=abs(fudgeFactor*h*(0.3+0.05*rand1(gl_FragCoord.xy*vec2(i))));\r\n\t\tro+=h*rd;\r\n\t\tt += h;\r\n\t}\r\n}\r\n\r\n//***************************************************************************************************\r\n// main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfocalDistance=6.5+3.*cos((25.+iTime)*0.133);\r\n\tpixelSize=1.0/iResolution.y;\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n\tvec2 p = uv * 2.0 - 1.0;\r\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y)); \r\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\r\n    vec2 m = sin(vec2(0, 1.57079632) + (25.+iTime)/4.);\r\n    rd.xy = mat2(m.y, -m.x, m)*rd.xy;\r\n    rd.xz = mat2(m.y, -m.x, m)*rd.xz;\r\n    vec3 ro = vec3(0.0, 2.0, 5.+sin((25.+iTime)/2.));\r\n    \r\n\tcastRay(ro, rd);\r\n\r\n\tvec2 uv2=-0.3+2.*gl_FragCoord.xy/iResolution.xy;\r\n\t//anti branding noise\r\n    col-=0.10*rand1(uv2.xy*iTime);\t\t\t\t\t\t\t\r\n\r\n\r\n\tfragColor = col*0.7;\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Surveillance","id":"a3aa57d95c494890a9769830a3f0a322","date":null,"viewed":0,"name":"Surveillance","description":"Dusty menger scene from my 4k intro Surveillance\n\nhttps://www.youtube.com/watch?v=kiE2c06EzBQ\nhttp://www.pouet.net/prod.php?which=67120\nhttps://www.shadertoy.com/view/ltV3Rz","likes":0,"published":null,"tags":["raymarching"," 4k"," demoscene"," menger"," density"," coc"]},"ver":null,"info":{"Name":"Surveillance","id":"a3aa57d95c494890a9769830a3f0a322","date":null,"viewed":0,"name":"Surveillance","description":"Dusty menger scene from my 4k intro Surveillance\n\nhttps://www.youtube.com/watch?v=kiE2c06EzBQ\nhttp://www.pouet.net/prod.php?which=67120\nhttps://www.shadertoy.com/view/ltV3Rz","likes":0,"published":null,"tags":["raymarching"," 4k"," demoscene"," menger"," density"," coc"]},"renderpass":[{"Code":"//**********************************************************************************\r\n// dusty menger scene from my 4k intro Surveillance\r\n// Virgill 2016\r\n// https://www.youtube.com/watch?v=kiE2c06EzBQ\r\n// http://www.pouet.net/prod.php?which=67120\r\n//**********************************************************************************\r\n\r\n// circle of confusion idea by eiffie\r\n// more interesting menger by shane\r\nfloat focalDistance=20.;\r\nfloat aperature=.04;\r\nfloat fudgeFactor=.9; \r\nfloat shadowCone=.5;\r\nvec4 orbitTrap = vec4(0.);\r\nfloat blend =0.;\r\nfloat d = 0.;\r\nfloat m = 0.;\r\nvec3 pcoc = vec3(0.);\r\nfloat rCoC,h;\r\nvec4 col=vec4(0.);\t\r\nfloat pixelSize;\r\n\r\n// coc (eiffie)\r\nfloat CircleOfConfusion(float t)\r\n{ \r\nreturn max(abs(focalDistance-t)*aperature,pixelSize*(1.0+t));\r\n}\r\n\r\n// linestep (knighty)\r\nfloat linstep(float a, float b, float t)\r\n{\r\n    float v=(t-a)/(b-a);\r\n    return clamp(v,0.,1.);\r\n}\r\n\r\nvec3 rotXaxis(vec3 p, float rad)\r\n{\r\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\r\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\r\n\tp.z = z2;\r\n\tp.y = y2;\r\n\treturn p;\r\n}\r\n\r\nvec3 rotYaxis(vec3 p, float rad) \r\n{\r\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\r\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\r\n\tp.x = x2;\r\n\tp.z = z2;\r\n\treturn p;\r\n}\r\n\r\nvec3 rotZaxis(vec3 p, float rad) \r\n{\r\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.y;\r\n\tfloat y2 = sin(rad) * p.x + cos(rad) * p.y;\r\n\tp.x = x2;\r\n\tp.y = y2;\r\n\treturn p;\r\n}\r\n\r\nfloat rand1(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\n\r\n// new and interesting menger formula (shane)\r\nfloat NewMenger(vec3 q)\r\n{\r\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\r\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;\r\n    p =  abs(fract(q) - .5);\r\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\r\n    p =  abs(fract(q*2.)*.5 - .25);\r\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); \r\n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\r\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// MAP\r\n//***************************************************************************************************\r\n\r\nfloat map(in vec3 p)\r\n{\r\n\torbitTrap = vec4(length(p)-0.8*p.z,length(p)-0.8*p.y,length(p)-0.8*p.x,0.0)*1.0;\r\n\treturn NewMenger(p);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// fuzzy shadow\r\n//***************************************************************************************************\r\n\r\nconst float ShadowContrast = 0.99;\r\nfloat FuzzyShadow(vec3 ro, vec3 rd, float coneGrad, float rCoC){\r\n\tfloat  t=rCoC*2.0,s=1.0;\r\n\tfor(int i=0;i<9;i++)\r\n\t{\r\n\t\tif(s<0.1)continue;\r\n\t\tfloat r=rCoC+t*coneGrad+0.05;\r\n\t\tfloat d=map(ro+rd*t)+r*0.6;\r\n\t\ts*=linstep(-r,r,d);\r\n\t\tt+=abs(d)*(0.8+0.2*rand1(gl_FragCoord.xy*vec2(i)));\r\n\t}\r\n\treturn clamp(s*ShadowContrast+(1.0-ShadowContrast),0.0,1.0);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// Orbit color\r\n//***************************************************************************************************\r\n\r\nfloat Cycles = 4.0;\r\nvec3 cycle(vec3 c, float s) \r\n{\r\n\treturn vec3(0.5)+0.5*vec3(cos(s*Cycles+c.x),cos(s*Cycles+c.y),cos(s*Cycles+c.z));\r\n}\r\n\r\nvec3 BaseColor = vec3(0.2,0.2,0.2);\r\nvec3 OrbitStrength = vec3(0.8, 0.8, 0.8);\r\nvec4 X = vec4(0.6, 0.5, 0.6, 0.2);\r\nvec4 Y = vec4(1.0, 0.5, 0.1, 0.7);\r\nvec4 Z = vec4(0.7, 0.8, 1.0, 0.3);\r\nvec4 R = vec4(0.7, 0.7, 0.5, 0.1);\r\n\r\nvec3 getColor()\r\n{\r\n\torbitTrap.w = sqrt(orbitTrap.w);\r\n\tvec3 orbitColor = cycle(X.xyz,orbitTrap.x)*X.w*orbitTrap.x + cycle(Y.xyz,orbitTrap.y)*Y.w*orbitTrap.y + cycle(Z.xyz,orbitTrap.z)*Z.w*orbitTrap.z + cycle(R.xyz,orbitTrap.w)*R.w*orbitTrap.w;\r\n\tvec3 color = mix(BaseColor, 3.0*orbitColor,  OrbitStrength);\r\n\treturn color;\r\n}\r\n\r\n\r\n \r\n//***************************************************************************************************\r\n// Cast ray\r\n//***************************************************************************************************\r\n\r\n// coc (eiffie)\r\nvoid castRay(in vec3 ro, in vec3 rd) \r\n{\r\n\tvec3 lig = normalize(vec3(0.4+cos((25.+iTime)*0.33), 0.2, 0.6));\t\t\r\n    float t = 0.;\r\n    for (int i = 0; i < 70; i++) \r\n\t{\r\n\t\tif(col.w>0.999 ||t>15.0)continue;\r\n\t\trCoC=CircleOfConfusion(t);\r\n\t\th = map(ro)+0.5*rCoC;\r\n\t\tif(h<rCoC)\r\n\t\t{\r\n\t\t\tpcoc=ro-rd*abs(h-rCoC);\r\n\t\t\tvec2 v=vec2(rCoC*0.5,0.0);\r\n\t\t\tvec3 N=normalize(vec3(-map(pcoc-v.xyy)+map(pcoc+v.xyy),-map(pcoc-v.yxy)+map(pcoc+v.yxy),-map(pcoc-v.yyx)+map(pcoc+v.yyx)));\r\n\t\t\tvec3 scol=2.3*getColor();\t\r\n\t\t\tfloat newdiff = clamp(dot(lig, N), 0.0, 1.0);\r\n\t\t\tfloat newspec = pow(clamp(dot(reflect(rd, N), lig), 0.0, 1.0), 16.0);\r\n\t\t\tfloat newsh   = FuzzyShadow(pcoc,lig,shadowCone,rCoC+0.00);\t\t\t\r\n\t\t\tscol *= 0.5*newdiff+newspec;\r\n\t\t \tscol *= newsh;\r\n\t\t\tfloat alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-h*1.7);\r\n\t\t\tcol+=vec4(scol*alpha,alpha);\r\n\t\t}\r\n\t\th=abs(fudgeFactor*h*(0.3+0.05*rand1(gl_FragCoord.xy*vec2(i))));\r\n\t\tro+=h*rd;\r\n\t\tt += h;\r\n\t}\r\n}\r\n\r\n//***************************************************************************************************\r\n// main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfocalDistance=6.5+3.*cos((25.+iTime)*0.133);\r\n\tpixelSize=1.0/iResolution.y;\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n\tvec2 p = uv * 2.0 - 1.0;\r\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y)); \r\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\r\n    vec2 m = sin(vec2(0, 1.57079632) + (25.+iTime)/4.);\r\n    rd.xy = mat2(m.y, -m.x, m)*rd.xy;\r\n    rd.xz = mat2(m.y, -m.x, m)*rd.xz;\r\n    vec3 ro = vec3(0.0, 2.0, 5.+sin((25.+iTime)/2.));\r\n    \r\n\tcastRay(ro, rd);\r\n\r\n\tvec2 uv2=-0.3+2.*gl_FragCoord.xy/iResolution.xy;\r\n\t//anti branding noise\r\n    col-=0.10*rand1(uv2.xy*iTime);\t\t\t\t\t\t\t\r\n\r\n\r\n\tfragColor = col*0.7;\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"//**********************************************************************************\r\n// dusty menger scene from my 4k intro Surveillance\r\n// Virgill 2016\r\n// https://www.youtube.com/watch?v=kiE2c06EzBQ\r\n// http://www.pouet.net/prod.php?which=67120\r\n//**********************************************************************************\r\n\r\n// circle of confusion idea by eiffie\r\n// more interesting menger by shane\r\nfloat focalDistance=20.;\r\nfloat aperature=.04;\r\nfloat fudgeFactor=.9; \r\nfloat shadowCone=.5;\r\nvec4 orbitTrap = vec4(0.);\r\nfloat blend =0.;\r\nfloat d = 0.;\r\nfloat m = 0.;\r\nvec3 pcoc = vec3(0.);\r\nfloat rCoC,h;\r\nvec4 col=vec4(0.);\t\r\nfloat pixelSize;\r\n\r\n// coc (eiffie)\r\nfloat CircleOfConfusion(float t)\r\n{ \r\nreturn max(abs(focalDistance-t)*aperature,pixelSize*(1.0+t));\r\n}\r\n\r\n// linestep (knighty)\r\nfloat linstep(float a, float b, float t)\r\n{\r\n    float v=(t-a)/(b-a);\r\n    return clamp(v,0.,1.);\r\n}\r\n\r\nvec3 rotXaxis(vec3 p, float rad)\r\n{\r\n\tfloat z2 = cos(rad) * p.z - sin(rad) * p.y;\r\n\tfloat y2 = sin(rad) * p.z + cos(rad) * p.y;\r\n\tp.z = z2;\r\n\tp.y = y2;\r\n\treturn p;\r\n}\r\n\r\nvec3 rotYaxis(vec3 p, float rad) \r\n{\r\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.z;\r\n\tfloat z2 = sin(rad) * p.x + cos(rad) * p.z;\r\n\tp.x = x2;\r\n\tp.z = z2;\r\n\treturn p;\r\n}\r\n\r\nvec3 rotZaxis(vec3 p, float rad) \r\n{\r\n\tfloat x2 = cos(rad) * p.x - sin(rad) * p.y;\r\n\tfloat y2 = sin(rad) * p.x + cos(rad) * p.y;\r\n\tp.x = x2;\r\n\tp.y = y2;\r\n\treturn p;\r\n}\r\n\r\nfloat rand1(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\n\r\n// new and interesting menger formula (shane)\r\nfloat NewMenger(vec3 q)\r\n{\r\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\r\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;\r\n    p =  abs(fract(q) - .5);\r\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\r\n    p =  abs(fract(q*2.)*.5 - .25);\r\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); \r\n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\r\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// MAP\r\n//***************************************************************************************************\r\n\r\nfloat map(in vec3 p)\r\n{\r\n\torbitTrap = vec4(length(p)-0.8*p.z,length(p)-0.8*p.y,length(p)-0.8*p.x,0.0)*1.0;\r\n\treturn NewMenger(p);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// fuzzy shadow\r\n//***************************************************************************************************\r\n\r\nconst float ShadowContrast = 0.99;\r\nfloat FuzzyShadow(vec3 ro, vec3 rd, float coneGrad, float rCoC){\r\n\tfloat  t=rCoC*2.0,s=1.0;\r\n\tfor(int i=0;i<9;i++)\r\n\t{\r\n\t\tif(s<0.1)continue;\r\n\t\tfloat r=rCoC+t*coneGrad+0.05;\r\n\t\tfloat d=map(ro+rd*t)+r*0.6;\r\n\t\ts*=linstep(-r,r,d);\r\n\t\tt+=abs(d)*(0.8+0.2*rand1(gl_FragCoord.xy*vec2(i)));\r\n\t}\r\n\treturn clamp(s*ShadowContrast+(1.0-ShadowContrast),0.0,1.0);\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// Orbit color\r\n//***************************************************************************************************\r\n\r\nfloat Cycles = 4.0;\r\nvec3 cycle(vec3 c, float s) \r\n{\r\n\treturn vec3(0.5)+0.5*vec3(cos(s*Cycles+c.x),cos(s*Cycles+c.y),cos(s*Cycles+c.z));\r\n}\r\n\r\nvec3 BaseColor = vec3(0.2,0.2,0.2);\r\nvec3 OrbitStrength = vec3(0.8, 0.8, 0.8);\r\nvec4 X = vec4(0.6, 0.5, 0.6, 0.2);\r\nvec4 Y = vec4(1.0, 0.5, 0.1, 0.7);\r\nvec4 Z = vec4(0.7, 0.8, 1.0, 0.3);\r\nvec4 R = vec4(0.7, 0.7, 0.5, 0.1);\r\n\r\nvec3 getColor()\r\n{\r\n\torbitTrap.w = sqrt(orbitTrap.w);\r\n\tvec3 orbitColor = cycle(X.xyz,orbitTrap.x)*X.w*orbitTrap.x + cycle(Y.xyz,orbitTrap.y)*Y.w*orbitTrap.y + cycle(Z.xyz,orbitTrap.z)*Z.w*orbitTrap.z + cycle(R.xyz,orbitTrap.w)*R.w*orbitTrap.w;\r\n\tvec3 color = mix(BaseColor, 3.0*orbitColor,  OrbitStrength);\r\n\treturn color;\r\n}\r\n\r\n\r\n \r\n//***************************************************************************************************\r\n// Cast ray\r\n//***************************************************************************************************\r\n\r\n// coc (eiffie)\r\nvoid castRay(in vec3 ro, in vec3 rd) \r\n{\r\n\tvec3 lig = normalize(vec3(0.4+cos((25.+iTime)*0.33), 0.2, 0.6));\t\t\r\n    float t = 0.;\r\n    for (int i = 0; i < 70; i++) \r\n\t{\r\n\t\tif(col.w>0.999 ||t>15.0)continue;\r\n\t\trCoC=CircleOfConfusion(t);\r\n\t\th = map(ro)+0.5*rCoC;\r\n\t\tif(h<rCoC)\r\n\t\t{\r\n\t\t\tpcoc=ro-rd*abs(h-rCoC);\r\n\t\t\tvec2 v=vec2(rCoC*0.5,0.0);\r\n\t\t\tvec3 N=normalize(vec3(-map(pcoc-v.xyy)+map(pcoc+v.xyy),-map(pcoc-v.yxy)+map(pcoc+v.yxy),-map(pcoc-v.yyx)+map(pcoc+v.yyx)));\r\n\t\t\tvec3 scol=2.3*getColor();\t\r\n\t\t\tfloat newdiff = clamp(dot(lig, N), 0.0, 1.0);\r\n\t\t\tfloat newspec = pow(clamp(dot(reflect(rd, N), lig), 0.0, 1.0), 16.0);\r\n\t\t\tfloat newsh   = FuzzyShadow(pcoc,lig,shadowCone,rCoC+0.00);\t\t\t\r\n\t\t\tscol *= 0.5*newdiff+newspec;\r\n\t\t \tscol *= newsh;\r\n\t\t\tfloat alpha=(1.0-col.w)*linstep(-rCoC,rCoC,-h*1.7);\r\n\t\t\tcol+=vec4(scol*alpha,alpha);\r\n\t\t}\r\n\t\th=abs(fudgeFactor*h*(0.3+0.05*rand1(gl_FragCoord.xy*vec2(i))));\r\n\t\tro+=h*rd;\r\n\t\tt += h;\r\n\t}\r\n}\r\n\r\n//***************************************************************************************************\r\n// main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfocalDistance=6.5+3.*cos((25.+iTime)*0.133);\r\n\tpixelSize=1.0/iResolution.y;\r\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n\tvec2 p = uv * 2.0 - 1.0;\r\n    vec3 rd = (vec3(2.*fragCoord - iResolution.xy, iResolution.y)); \r\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.2, 0.))));\r\n    vec2 m = sin(vec2(0, 1.57079632) + (25.+iTime)/4.);\r\n    rd.xy = mat2(m.y, -m.x, m)*rd.xy;\r\n    rd.xz = mat2(m.y, -m.x, m)*rd.xz;\r\n    vec3 ro = vec3(0.0, 2.0, 5.+sin((25.+iTime)/2.));\r\n    \r\n\tcastRay(ro, rd);\r\n\r\n\tvec2 uv2=-0.3+2.*gl_FragCoord.xy/iResolution.xy;\r\n\t//anti branding noise\r\n    col-=0.10*rand1(uv2.xy*iTime);\t\t\t\t\t\t\t\r\n\r\n\r\n\tfragColor = col*0.7;\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define ITR 170\r\n#define FAR 80.\r\n#define PRECISION 0.008\r\n#define BASE_STRIDE .75\r\n#define FAR_STRIDE 0.3\r\n#define MIN_STEP .1\r\nconst float logvl = 1.+MIN_STEP;\r\n\r\nconst vec3 SunDir = vec3(1.0,1.0,1.0);\r\nconst vec3 SunColor = vec3(1.64,1.27,0.99)*1.1;\r\nconst vec3 SkyColor = vec3(0.55294,0.78431,0.94902);\r\n\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat _terrain(vec2 p,vec2 offset,float octave, float h,float lacunarity){\r\n    float value =.0;\r\n    for(float i=0.0;i<octave;i++){\r\n        value += value_noise(p-offset)*pow(lacunarity,-h*i);\r\n        p *= lacunarity;\r\n    }\r\n    return value;\r\n}\r\n\r\nfloat H = 2.6;\r\nfloat Lacunarity = 2.0;\r\n\r\nfloat terrainL(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat terrain(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 q = abs(p) - b;\r\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\nfloat map( in vec3 p)\r\n{  \r\n    float d =  0.0;\r\n    if(p.x<-1.0 || p.x>1.0 || p.z<-1.0 || p.z>1.0){\r\n        return 0.01;\r\n        //return sdBox(p,vec3(1.0,.01,1.0))*sign(p.y-0.01);\r\n    }\r\n    \r\n    p.xz *= 2.0;\r\n    float h = terrain(p.x,p.z);\r\n    d = p.y - h;\r\n     //d = abs(d);\r\n    return d;\r\n}\r\n\r\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\r\n{\r\n    float mid = 0.;\r\n    float sgn = sign(map(rd*near+ro));\r\n    for (int i = 0; i < 6; i++)\r\n    { \r\n        mid = (near + far)*.5;\r\n        float d = map(rd*mid+ro);\r\n        if (abs(d) < PRECISION)break;\r\n        if(d*sgn < 0. ) far = mid; else  near = mid;\r\n    }\r\n    return (near+far) * .5;\r\n}\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd)\r\n{\r\n    float t = 0.;\r\n    const int itr = ITR;\r\n    float d = map(rd*t+ro);\r\n    #ifdef OPTIMIZE\r\n    bool sgn = (d > 0.0) ? true : false;\r\n    #else\r\n    float sgn = sign(d);\r\n    #endif\r\n    float told = t;\r\n    bool doBisect = false;\r\n    \r\n    for (int i=0;i<=itr;i++)\r\n    {\r\n        \r\n        if (abs(d) < PRECISION || t > FAR) break;\r\n        else if (i == itr)t = 1000.;\r\n            \r\n        //if we crossed but didn't detect, use bisection method\r\n        #ifdef OPTIMIZE\r\n        if ((d > 0.0) != sgn)\r\n        #else\r\n       \tif (sign(d) != sgn)\r\n        #endif\r\n        {\r\n            doBisect= true;\r\n            break;\r\n        }\r\n        \r\n        told = t;\r\n        #if 1\r\n        if (d > 1.)t += d*FAR_STRIDE;\r\n        else t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #else\r\n        t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #endif\r\n        d = map(rd*t+ro);\r\n    }\r\n    \r\n    if (doBisect)t = bisect(ro,rd,told,t);\r\n    \r\n    return t;\r\n}\r\n\r\nvec3 normal(in vec3 pos, in float t)\r\n{  \r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n    return normalize( vec3(\r\n           map(pos+eps.xyy) - map(pos-eps.xyy),\r\n           map(pos+eps.yxy) - map(pos-eps.yxy),\r\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\r\n}\r\n\r\nvec3 getSkyColor(vec3 ro, vec3 rd)\r\n{\r\n    vec3 blueish = vec3(0.55294,0.78431,0.94902);\r\n    return blueish;\r\n}\r\n\r\nvec3 getTerrainMaterial(vec3 p, vec3 n)\r\n{\r\n    vec3 tx =  vec3(0.2);//tex3D(iChannel1, p/8., n ); // Texture value. Pinkish limestone.\r\n    return tx;\r\n}\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t       \r\n     float camRadius = 3.0;  \r\n    float rota = 0.0;\r\n    float vertical = 1.0;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\trota = iMouse.x/iResolution.x;\r\n        vertical = iMouse.y/iResolution.y - 0.5;\r\n    }\r\n    float theta = rota*3.1415726*2.0;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,vertical*camRadius*2.0,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.0);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, rayo;\r\n    rayDir = computePixelRay( p, rayo );\r\n    \r\n    float rz = intersect(rayo,rayDir);\r\n    vec3 col = vec3(0.0);\r\n    vec3 sky = getSkyColor(rayo, rayDir);\r\n    col += sky;\r\n    \r\n    //shadng\r\n    if (rz < FAR)\r\n    {\r\n        vec3 pos = rayo+rayDir*rz;\r\n        vec3 nor = normal(pos, rz);\r\n       \r\n        float sun = clamp(dot(nor,normalize(SunDir)),0.0,1.0);\r\n                               \r\n        vec3 light = sun*SunColor;\r\n        \r\n        vec3 m = getTerrainMaterial(pos,nor);\r\n        col = m*(light+0.05);\r\n    }\r\n   \r\n    col = pow(col,vec3(1.0/2.2));\r\n\tfragColor = vec4( col, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"#define ITR 170\r\n#define FAR 80.\r\n#define PRECISION 0.008\r\n#define BASE_STRIDE .75\r\n#define FAR_STRIDE 0.3\r\n#define MIN_STEP .1\r\nconst float logvl = 1.+MIN_STEP;\r\n\r\nconst vec3 SunDir = vec3(1.0,1.0,1.0);\r\nconst vec3 SunColor = vec3(1.64,1.27,0.99)*1.1;\r\nconst vec3 SkyColor = vec3(0.55294,0.78431,0.94902);\r\n\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat _terrain(vec2 p,vec2 offset,float octave, float h,float lacunarity){\r\n    float value =.0;\r\n    for(float i=0.0;i<octave;i++){\r\n        value += value_noise(p-offset)*pow(lacunarity,-h*i);\r\n        p *= lacunarity;\r\n    }\r\n    return value;\r\n}\r\n\r\nfloat H = 2.6;\r\nfloat Lacunarity = 2.0;\r\n\r\nfloat terrainL(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat terrain(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 q = abs(p) - b;\r\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\nfloat map( in vec3 p)\r\n{  \r\n    float d =  0.0;\r\n    if(p.x<-1.0 || p.x>1.0 || p.z<-1.0 || p.z>1.0){\r\n        return 0.01;\r\n        //return sdBox(p,vec3(1.0,.01,1.0))*sign(p.y-0.01);\r\n    }\r\n    \r\n    p.xz *= 2.0;\r\n    float h = terrain(p.x,p.z);\r\n    d = p.y - h;\r\n     //d = abs(d);\r\n    return d;\r\n}\r\n\r\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\r\n{\r\n    float mid = 0.;\r\n    float sgn = sign(map(rd*near+ro));\r\n    for (int i = 0; i < 6; i++)\r\n    { \r\n        mid = (near + far)*.5;\r\n        float d = map(rd*mid+ro);\r\n        if (abs(d) < PRECISION)break;\r\n        if(d*sgn < 0. ) far = mid; else  near = mid;\r\n    }\r\n    return (near+far) * .5;\r\n}\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd)\r\n{\r\n    float t = 0.;\r\n    const int itr = ITR;\r\n    float d = map(rd*t+ro);\r\n    #ifdef OPTIMIZE\r\n    bool sgn = (d > 0.0) ? true : false;\r\n    #else\r\n    float sgn = sign(d);\r\n    #endif\r\n    float told = t;\r\n    bool doBisect = false;\r\n    \r\n    for (int i=0;i<=itr;i++)\r\n    {\r\n        \r\n        if (abs(d) < PRECISION || t > FAR) break;\r\n        else if (i == itr)t = 1000.;\r\n            \r\n        //if we crossed but didn't detect, use bisection method\r\n        #ifdef OPTIMIZE\r\n        if ((d > 0.0) != sgn)\r\n        #else\r\n       \tif (sign(d) != sgn)\r\n        #endif\r\n        {\r\n            doBisect= true;\r\n            break;\r\n        }\r\n        \r\n        told = t;\r\n        #if 1\r\n        if (d > 1.)t += d*FAR_STRIDE;\r\n        else t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #else\r\n        t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #endif\r\n        d = map(rd*t+ro);\r\n    }\r\n    \r\n    if (doBisect)t = bisect(ro,rd,told,t);\r\n    \r\n    return t;\r\n}\r\n\r\nvec3 normal(in vec3 pos, in float t)\r\n{  \r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n    return normalize( vec3(\r\n           map(pos+eps.xyy) - map(pos-eps.xyy),\r\n           map(pos+eps.yxy) - map(pos-eps.yxy),\r\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\r\n}\r\n\r\nvec3 getSkyColor(vec3 ro, vec3 rd)\r\n{\r\n    vec3 blueish = vec3(0.55294,0.78431,0.94902);\r\n    return blueish;\r\n}\r\n\r\nvec3 getTerrainMaterial(vec3 p, vec3 n)\r\n{\r\n    vec3 tx =  vec3(0.2);//tex3D(iChannel1, p/8., n ); // Texture value. Pinkish limestone.\r\n    return tx;\r\n}\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t       \r\n     float camRadius = 3.0;  \r\n    float rota = 0.0;\r\n    float vertical = 1.0;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\trota = iMouse.x/iResolution.x;\r\n        vertical = iMouse.y/iResolution.y - 0.5;\r\n    }\r\n    float theta = rota*3.1415726*2.0;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,vertical*camRadius*2.0,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.0);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, rayo;\r\n    rayDir = computePixelRay( p, rayo );\r\n    \r\n    float rz = intersect(rayo,rayDir);\r\n    vec3 col = vec3(0.0);\r\n    vec3 sky = getSkyColor(rayo, rayDir);\r\n    col += sky;\r\n    \r\n    //shadng\r\n    if (rz < FAR)\r\n    {\r\n        vec3 pos = rayo+rayDir*rz;\r\n        vec3 nor = normal(pos, rz);\r\n       \r\n        float sun = clamp(dot(nor,normalize(SunDir)),0.0,1.0);\r\n                               \r\n        vec3 light = sun*SunColor;\r\n        \r\n        vec3 m = getTerrainMaterial(pos,nor);\r\n        col = m*(light+0.05);\r\n    }\r\n   \r\n    col = pow(col,vec3(1.0/2.2));\r\n\tfragColor = vec4( col, 1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Terrain Demo1","id":"44faac1b5bb847ddb4260a5418058413","date":null,"viewed":0,"name":"Terrain Demo1","description":"Terrain Demo1","likes":0,"published":null,"tags":["terrain"," raymarch"," fbm"]},"ver":null,"info":{"Name":"Terrain Demo1","id":"44faac1b5bb847ddb4260a5418058413","date":null,"viewed":0,"name":"Terrain Demo1","description":"Terrain Demo1","likes":0,"published":null,"tags":["terrain"," raymarch"," fbm"]},"renderpass":[{"Code":"#define ITR 170\r\n#define FAR 80.\r\n#define PRECISION 0.008\r\n#define BASE_STRIDE .75\r\n#define FAR_STRIDE 0.3\r\n#define MIN_STEP .1\r\nconst float logvl = 1.+MIN_STEP;\r\n\r\nconst vec3 SunDir = vec3(1.0,1.0,1.0);\r\nconst vec3 SunColor = vec3(1.64,1.27,0.99)*1.1;\r\nconst vec3 SkyColor = vec3(0.55294,0.78431,0.94902);\r\n\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat _terrain(vec2 p,vec2 offset,float octave, float h,float lacunarity){\r\n    float value =.0;\r\n    for(float i=0.0;i<octave;i++){\r\n        value += value_noise(p-offset)*pow(lacunarity,-h*i);\r\n        p *= lacunarity;\r\n    }\r\n    return value;\r\n}\r\n\r\nfloat H = 2.6;\r\nfloat Lacunarity = 2.0;\r\n\r\nfloat terrainL(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat terrain(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 q = abs(p) - b;\r\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\nfloat map( in vec3 p)\r\n{  \r\n    float d =  0.0;\r\n    if(p.x<-1.0 || p.x>1.0 || p.z<-1.0 || p.z>1.0){\r\n        return 0.01;\r\n        //return sdBox(p,vec3(1.0,.01,1.0))*sign(p.y-0.01);\r\n    }\r\n    \r\n    p.xz *= 2.0;\r\n    float h = terrain(p.x,p.z);\r\n    d = p.y - h;\r\n     //d = abs(d);\r\n    return d;\r\n}\r\n\r\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\r\n{\r\n    float mid = 0.;\r\n    float sgn = sign(map(rd*near+ro));\r\n    for (int i = 0; i < 6; i++)\r\n    { \r\n        mid = (near + far)*.5;\r\n        float d = map(rd*mid+ro);\r\n        if (abs(d) < PRECISION)break;\r\n        if(d*sgn < 0. ) far = mid; else  near = mid;\r\n    }\r\n    return (near+far) * .5;\r\n}\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd)\r\n{\r\n    float t = 0.;\r\n    const int itr = ITR;\r\n    float d = map(rd*t+ro);\r\n    #ifdef OPTIMIZE\r\n    bool sgn = (d > 0.0) ? true : false;\r\n    #else\r\n    float sgn = sign(d);\r\n    #endif\r\n    float told = t;\r\n    bool doBisect = false;\r\n    \r\n    for (int i=0;i<=itr;i++)\r\n    {\r\n        \r\n        if (abs(d) < PRECISION || t > FAR) break;\r\n        else if (i == itr)t = 1000.;\r\n            \r\n        //if we crossed but didn't detect, use bisection method\r\n        #ifdef OPTIMIZE\r\n        if ((d > 0.0) != sgn)\r\n        #else\r\n       \tif (sign(d) != sgn)\r\n        #endif\r\n        {\r\n            doBisect= true;\r\n            break;\r\n        }\r\n        \r\n        told = t;\r\n        #if 1\r\n        if (d > 1.)t += d*FAR_STRIDE;\r\n        else t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #else\r\n        t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #endif\r\n        d = map(rd*t+ro);\r\n    }\r\n    \r\n    if (doBisect)t = bisect(ro,rd,told,t);\r\n    \r\n    return t;\r\n}\r\n\r\nvec3 normal(in vec3 pos, in float t)\r\n{  \r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n    return normalize( vec3(\r\n           map(pos+eps.xyy) - map(pos-eps.xyy),\r\n           map(pos+eps.yxy) - map(pos-eps.yxy),\r\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\r\n}\r\n\r\nvec3 getSkyColor(vec3 ro, vec3 rd)\r\n{\r\n    vec3 blueish = vec3(0.55294,0.78431,0.94902);\r\n    return blueish;\r\n}\r\n\r\nvec3 getTerrainMaterial(vec3 p, vec3 n)\r\n{\r\n    vec3 tx =  vec3(0.2);//tex3D(iChannel1, p/8., n ); // Texture value. Pinkish limestone.\r\n    return tx;\r\n}\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t       \r\n     float camRadius = 3.0;  \r\n    float rota = 0.0;\r\n    float vertical = 1.0;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\trota = iMouse.x/iResolution.x;\r\n        vertical = iMouse.y/iResolution.y - 0.5;\r\n    }\r\n    float theta = rota*3.1415726*2.0;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,vertical*camRadius*2.0,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.0);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, rayo;\r\n    rayDir = computePixelRay( p, rayo );\r\n    \r\n    float rz = intersect(rayo,rayDir);\r\n    vec3 col = vec3(0.0);\r\n    vec3 sky = getSkyColor(rayo, rayDir);\r\n    col += sky;\r\n    \r\n    //shadng\r\n    if (rz < FAR)\r\n    {\r\n        vec3 pos = rayo+rayDir*rz;\r\n        vec3 nor = normal(pos, rz);\r\n       \r\n        float sun = clamp(dot(nor,normalize(SunDir)),0.0,1.0);\r\n                               \r\n        vec3 light = sun*SunColor;\r\n        \r\n        vec3 m = getTerrainMaterial(pos,nor);\r\n        col = m*(light+0.05);\r\n    }\r\n   \r\n    col = pow(col,vec3(1.0/2.2));\r\n\tfragColor = vec4( col, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"#define ITR 170\r\n#define FAR 80.\r\n#define PRECISION 0.008\r\n#define BASE_STRIDE .75\r\n#define FAR_STRIDE 0.3\r\n#define MIN_STEP .1\r\nconst float logvl = 1.+MIN_STEP;\r\n\r\nconst vec3 SunDir = vec3(1.0,1.0,1.0);\r\nconst vec3 SunColor = vec3(1.64,1.27,0.99)*1.1;\r\nconst vec3 SkyColor = vec3(0.55294,0.78431,0.94902);\r\n\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat _terrain(vec2 p,vec2 offset,float octave, float h,float lacunarity){\r\n    float value =.0;\r\n    for(float i=0.0;i<octave;i++){\r\n        value += value_noise(p-offset)*pow(lacunarity,-h*i);\r\n        p *= lacunarity;\r\n    }\r\n    return value;\r\n}\r\n\r\nfloat H = 2.6;\r\nfloat Lacunarity = 2.0;\r\n\r\nfloat terrainL(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat terrain(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 q = abs(p) - b;\r\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\nfloat map( in vec3 p)\r\n{  \r\n    float d =  0.0;\r\n    if(p.x<-1.0 || p.x>1.0 || p.z<-1.0 || p.z>1.0){\r\n        return 0.01;\r\n        //return sdBox(p,vec3(1.0,.01,1.0))*sign(p.y-0.01);\r\n    }\r\n    \r\n    p.xz *= 2.0;\r\n    float h = terrain(p.x,p.z);\r\n    d = p.y - h;\r\n     //d = abs(d);\r\n    return d;\r\n}\r\n\r\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\r\n{\r\n    float mid = 0.;\r\n    float sgn = sign(map(rd*near+ro));\r\n    for (int i = 0; i < 6; i++)\r\n    { \r\n        mid = (near + far)*.5;\r\n        float d = map(rd*mid+ro);\r\n        if (abs(d) < PRECISION)break;\r\n        if(d*sgn < 0. ) far = mid; else  near = mid;\r\n    }\r\n    return (near+far) * .5;\r\n}\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd)\r\n{\r\n    float t = 0.;\r\n    const int itr = ITR;\r\n    float d = map(rd*t+ro);\r\n    #ifdef OPTIMIZE\r\n    bool sgn = (d > 0.0) ? true : false;\r\n    #else\r\n    float sgn = sign(d);\r\n    #endif\r\n    float told = t;\r\n    bool doBisect = false;\r\n    \r\n    for (int i=0;i<=itr;i++)\r\n    {\r\n        \r\n        if (abs(d) < PRECISION || t > FAR) break;\r\n        else if (i == itr)t = 1000.;\r\n            \r\n        //if we crossed but didn't detect, use bisection method\r\n        #ifdef OPTIMIZE\r\n        if ((d > 0.0) != sgn)\r\n        #else\r\n       \tif (sign(d) != sgn)\r\n        #endif\r\n        {\r\n            doBisect= true;\r\n            break;\r\n        }\r\n        \r\n        told = t;\r\n        #if 1\r\n        if (d > 1.)t += d*FAR_STRIDE;\r\n        else t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #else\r\n        t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #endif\r\n        d = map(rd*t+ro);\r\n    }\r\n    \r\n    if (doBisect)t = bisect(ro,rd,told,t);\r\n    \r\n    return t;\r\n}\r\n\r\nvec3 normal(in vec3 pos, in float t)\r\n{  \r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n    return normalize( vec3(\r\n           map(pos+eps.xyy) - map(pos-eps.xyy),\r\n           map(pos+eps.yxy) - map(pos-eps.yxy),\r\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\r\n}\r\n\r\nvec3 getSkyColor(vec3 ro, vec3 rd)\r\n{\r\n    vec3 blueish = vec3(0.55294,0.78431,0.94902);\r\n    return blueish;\r\n}\r\n\r\nvec3 getTerrainMaterial(vec3 p, vec3 n)\r\n{\r\n    vec3 tx =  vec3(0.2);//tex3D(iChannel1, p/8., n ); // Texture value. Pinkish limestone.\r\n    return tx;\r\n}\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t       \r\n     float camRadius = 3.0;  \r\n    float rota = 0.0;\r\n    float vertical = 1.0;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\trota = iMouse.x/iResolution.x;\r\n        vertical = iMouse.y/iResolution.y - 0.5;\r\n    }\r\n    float theta = rota*3.1415726*2.0;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,vertical*camRadius*2.0,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.0);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, rayo;\r\n    rayDir = computePixelRay( p, rayo );\r\n    \r\n    float rz = intersect(rayo,rayDir);\r\n    vec3 col = vec3(0.0);\r\n    vec3 sky = getSkyColor(rayo, rayDir);\r\n    col += sky;\r\n    \r\n    //shadng\r\n    if (rz < FAR)\r\n    {\r\n        vec3 pos = rayo+rayDir*rz;\r\n        vec3 nor = normal(pos, rz);\r\n       \r\n        float sun = clamp(dot(nor,normalize(SunDir)),0.0,1.0);\r\n                               \r\n        vec3 light = sun*SunColor;\r\n        \r\n        vec3 m = getTerrainMaterial(pos,nor);\r\n        col = m*(light+0.05);\r\n    }\r\n   \r\n    col = pow(col,vec3(1.0/2.2));\r\n\tfragColor = vec4( col, 1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\r\n// https://creativecommons.org/licenses/by-sa/3.0/\r\n//\r\n//\r\n// This is the implementation for my article \"improved texture interpolation\"\r\n// \r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\n//\r\n// It shows how to get some smooth texture interpolation without resorting to the regular\r\n// bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \r\n// 4 the hardware uses for bilinear interpolation.\r\n//\r\n// With this techinique here, you van get smooth interpolation while the hardware still \r\n// uses only 4 texels, by tricking the hardware. The idea is to get the fractional part\r\n// of the texel coordinates and apply a smooth curve to it such that the derivatives are\r\n// zero at the extremes. The regular cubic or quintic smoothstep functions are just\r\n// perfect for this task.\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 p)\r\n{\r\n   return vec3(value_noise(p),value_noise(p+123.12),value_noise(p+456.43));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = fragCoord.xy / iResolution.x;\r\n    vec2 uv = p*0.1;\t\r\n\t\r\n    //---------------------------------------------\t\r\n\t// regular texture map filtering\r\n    //---------------------------------------------\t\r\n\tvec3 colA = noise23(uv*99.);// texture( iChannel0, uv ).xyz;\r\n\r\n    //---------------------------------------------\t\r\n\t// my own filtering \r\n    //---------------------------------------------\t\r\n\tfloat textureResolution = 64.0;\r\n\tuv = uv*textureResolution + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\r\n\tuv = (uv - 0.5)/textureResolution;\r\n\tvec3 colB = noise23(uv*99.);//texture( iChannel0, uv ).xyz;\r\n\t\r\n    //---------------------------------------------\t\r\n    // mix between the two colors\r\n    //---------------------------------------------\t\r\n\tfloat f = sin(3.14*p.x + 0.7*iTime);\r\n\tvec3 col = mix( colA, colB, smoothstep( -0.1, 0.1, f ) );\r\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\r\n// https://creativecommons.org/licenses/by-sa/3.0/\r\n//\r\n//\r\n// This is the implementation for my article \"improved texture interpolation\"\r\n// \r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\n//\r\n// It shows how to get some smooth texture interpolation without resorting to the regular\r\n// bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \r\n// 4 the hardware uses for bilinear interpolation.\r\n//\r\n// With this techinique here, you van get smooth interpolation while the hardware still \r\n// uses only 4 texels, by tricking the hardware. The idea is to get the fractional part\r\n// of the texel coordinates and apply a smooth curve to it such that the derivatives are\r\n// zero at the extremes. The regular cubic or quintic smoothstep functions are just\r\n// perfect for this task.\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 p)\r\n{\r\n   return vec3(value_noise(p),value_noise(p+123.12),value_noise(p+456.43));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = fragCoord.xy / iResolution.x;\r\n    vec2 uv = p*0.1;\t\r\n\t\r\n    //---------------------------------------------\t\r\n\t// regular texture map filtering\r\n    //---------------------------------------------\t\r\n\tvec3 colA = noise23(uv*99.);// texture( iChannel0, uv ).xyz;\r\n\r\n    //---------------------------------------------\t\r\n\t// my own filtering \r\n    //---------------------------------------------\t\r\n\tfloat textureResolution = 64.0;\r\n\tuv = uv*textureResolution + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\r\n\tuv = (uv - 0.5)/textureResolution;\r\n\tvec3 colB = noise23(uv*99.);//texture( iChannel0, uv ).xyz;\r\n\t\r\n    //---------------------------------------------\t\r\n    // mix between the two colors\r\n    //---------------------------------------------\t\r\n\tfloat f = sin(3.14*p.x + 0.7*iTime);\r\n\tvec3 col = mix( colA, colB, smoothstep( -0.1, 0.1, f ) );\r\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Texture - Better Filtering","id":"7ef99c906e614011b6ee064e8848183c","date":null,"viewed":0,"name":"Texture - Better Filtering","description":"This shader shows how to avoid the ugly artifacts of bilinear texture filtering. You can find more information here: http://www.iquilezles.org/www/articles/texture/texture.htm\nhttps://www.shadertoy.com/view/XsfGDn","likes":0,"published":null,"tags":["2d"," texture"," filtering"]},"ver":null,"info":{"Name":"Texture - Better Filtering","id":"7ef99c906e614011b6ee064e8848183c","date":null,"viewed":0,"name":"Texture - Better Filtering","description":"This shader shows how to avoid the ugly artifacts of bilinear texture filtering. You can find more information here: http://www.iquilezles.org/www/articles/texture/texture.htm\nhttps://www.shadertoy.com/view/XsfGDn","likes":0,"published":null,"tags":["2d"," texture"," filtering"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\r\n// https://creativecommons.org/licenses/by-sa/3.0/\r\n//\r\n//\r\n// This is the implementation for my article \"improved texture interpolation\"\r\n// \r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\n//\r\n// It shows how to get some smooth texture interpolation without resorting to the regular\r\n// bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \r\n// 4 the hardware uses for bilinear interpolation.\r\n//\r\n// With this techinique here, you van get smooth interpolation while the hardware still \r\n// uses only 4 texels, by tricking the hardware. The idea is to get the fractional part\r\n// of the texel coordinates and apply a smooth curve to it such that the derivatives are\r\n// zero at the extremes. The regular cubic or quintic smoothstep functions are just\r\n// perfect for this task.\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 p)\r\n{\r\n   return vec3(value_noise(p),value_noise(p+123.12),value_noise(p+456.43));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = fragCoord.xy / iResolution.x;\r\n    vec2 uv = p*0.1;\t\r\n\t\r\n    //---------------------------------------------\t\r\n\t// regular texture map filtering\r\n    //---------------------------------------------\t\r\n\tvec3 colA = noise23(uv*99.);// texture( iChannel0, uv ).xyz;\r\n\r\n    //---------------------------------------------\t\r\n\t// my own filtering \r\n    //---------------------------------------------\t\r\n\tfloat textureResolution = 64.0;\r\n\tuv = uv*textureResolution + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\r\n\tuv = (uv - 0.5)/textureResolution;\r\n\tvec3 colB = noise23(uv*99.);//texture( iChannel0, uv ).xyz;\r\n\t\r\n    //---------------------------------------------\t\r\n    // mix between the two colors\r\n    //---------------------------------------------\t\r\n\tfloat f = sin(3.14*p.x + 0.7*iTime);\r\n\tvec3 col = mix( colA, colB, smoothstep( -0.1, 0.1, f ) );\r\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\r\n// https://creativecommons.org/licenses/by-sa/3.0/\r\n//\r\n//\r\n// This is the implementation for my article \"improved texture interpolation\"\r\n// \r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\n//\r\n// It shows how to get some smooth texture interpolation without resorting to the regular\r\n// bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \r\n// 4 the hardware uses for bilinear interpolation.\r\n//\r\n// With this techinique here, you van get smooth interpolation while the hardware still \r\n// uses only 4 texels, by tricking the hardware. The idea is to get the fractional part\r\n// of the texel coordinates and apply a smooth curve to it such that the derivatives are\r\n// zero at the extremes. The regular cubic or quintic smoothstep functions are just\r\n// perfect for this task.\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 p)\r\n{\r\n   return vec3(value_noise(p),value_noise(p+123.12),value_noise(p+456.43));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = fragCoord.xy / iResolution.x;\r\n    vec2 uv = p*0.1;\t\r\n\t\r\n    //---------------------------------------------\t\r\n\t// regular texture map filtering\r\n    //---------------------------------------------\t\r\n\tvec3 colA = noise23(uv*99.);// texture( iChannel0, uv ).xyz;\r\n\r\n    //---------------------------------------------\t\r\n\t// my own filtering \r\n    //---------------------------------------------\t\r\n\tfloat textureResolution = 64.0;\r\n\tuv = uv*textureResolution + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\r\n\tuv = (uv - 0.5)/textureResolution;\r\n\tvec3 colB = noise23(uv*99.);//texture( iChannel0, uv ).xyz;\r\n\t\r\n    //---------------------------------------------\t\r\n    // mix between the two colors\r\n    //---------------------------------------------\t\r\n\tfloat f = sin(3.14*p.x + 0.7*iTime);\r\n\tvec3 col = mix( colA, colB, smoothstep( -0.1, 0.1, f ) );\r\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Gardner textured ellipsoids - https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf + bib\r\n\r\nvec3 R = vec3(2.,4.,2.);              // ellipsoid radius\r\nvec3 L = normalize(vec3(-.4,0.,1.));  // light source\r\n#define AMBIENT .4\t\t\t\t\t  // ambient luminosity\r\n\r\n#define ANIM true\r\n#define PI 3.1415927\r\nvec4 FragColor;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )    // in [0,1]\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // in [0,1]\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )    // in [0,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\nfloat snoise( in vec3 x ) // in [-1,1]\r\n{ return 2.*noise(x)-1.; }\r\n\r\nfloat sfbm( vec3 p )      // in [-1,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\r\n    f += 0.2500*snoise( p ); p = m*p*2.03;\r\n    f += 0.1250*snoise( p ); p = m*p*2.01;\r\n    f += 0.0625*snoise( p );\r\n    return f;\r\n}\r\n\r\n\r\n\r\n// --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\r\n\r\n\r\nmat3 lookat(vec3 O, vec3 T, float d) {\r\n\tmat3 M;\r\n\tvec3 OT = normalize(T-O);\r\n\tM[0] = OT;\r\n\tM[2] = normalize(vec3(0.,0.,1.)-OT.z*OT)/d;\r\n\tM[1] = cross(M[2],OT);\r\n\treturn M;\r\n}\r\n\r\n// --- ray -  ellipsoid intersection\r\n// if true, return P,N and thickness l\r\n\r\nbool intersect_ellipsoid(vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\r\n\tvec3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere \r\n\t\t// P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\r\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\r\n\tfloat d = OD*OD - (OO-1.)*DD;\r\n\t\r\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\r\n\t// ray intersects the ellipsoid (and not in our back)\r\n\t// note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\r\n\t\t\r\n\tfloat t = (-OD-sqrt(d))/DD;\r\n\t// return intersection point, normal and thickness\r\n\tP = O+t*D;\r\n\tN=normalize(P/(R*R));\r\n\tl = 2.*sqrt(d)/DD;\r\n\r\n\treturn true;\r\n}\r\n\r\n// --- Gardner textured ellipsoids (sort of)\r\n\r\n// 's' index corresponds to Garner faked silhouette\r\n// 'i' index corresponds to interior term faked by mid-surface\r\n\r\nfloat ks,ps, ki,pi;  // smoothness/thichness parameters\r\n\r\nfloat l;\r\nvoid draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {\r\n\tvec3 D = normalize(M*vec3(1.,pos));\t\t// ray\r\n\t\r\n\tvec3 P,N; \r\n\tif (! intersect_ellipsoid(O,D, P,N,l)) return;\r\n\t\r\n\tvec3 Pm = P+.5*l*D,                \t\t// .5: deepest point inside cloud. \r\n\t\t Nm = normalize(Pm/(R*R)),     \t\t// it's normal\r\n\t     Nn = normalize(P/R);\r\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t// ratio of light-facing (for lighting)\r\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t// ratio of camera-facing (for silhouette)\r\n\r\n\r\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\r\n\tfloat A, l0 = 3.;\r\n\t//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette\r\n\tl = clamp(l-6.*ni,0.,1e10);\r\n\tfloat As = pow(ks*nd, ps), \t\t\t \t // silhouette\r\n\t\t  Ai = 1.-pow(.7,pi*l);              // interior\r\n\r\n\r\n\tAs =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);\r\n\tif (mode==2) \r\n\t\tA = 1.- (1.-As)*(1.-Ai);  \t\t\t// mul Ti and Ts\r\n\telse\r\n\t\tA = (mode==0) ? Ai : As; \r\n\tA = clamp(A,0.,1.); \r\n\tnl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));\r\n\r\n\t#if 0 // noise bump\r\n\tN = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); \r\n\tnl = clamp( dot(N,L),0.,1.);\r\n#endif\r\n\t\r\n\tvec4 col = vec4(mix(nl,1.,AMBIENT));\r\n\tFragColor = mix(FragColor,col,A);\r\n}\r\n\r\n// === main =============================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.85,.5));\r\n\tvec2 mouse = 2.*(iMouse.xy / iResolution.xy - vec2(.85,.5));\r\n\tfloat z = .2;\r\n\tks = 1.+mouse.x, ps = mouse.y*8., ki, pi;\r\n\tks = 1.; ps = 3.;   ki = .9; pi = 3.;\r\n\t\r\n\tif (iMouse.z>0.) {\r\n\t\tt = -PI/2.*mouse.x;\r\n\t\tz = -PI/2.*mouse.y;\r\n\t}\r\n\tvec3 O = vec3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t// camera\r\n\tfloat compas = t-.2*uv.x; vec2 dir = vec2(cos(compas),sin(compas));\r\n\tFragColor = (keyToggle(64+19)) \r\n\t\t? vec4(0.) \r\n\t\t: clamp(vec4(.6,.7+.3*dir,1.)*(uv.y+1.6)/1.8,0.,1.); \t\t// sky\r\n\r\n\tmat3 M = lookat(O,vec3(0.),5.); \r\n\tvec2 dx = vec2(1.,0.);\r\n\t\r\n\tif (!keyToggle(32))\r\n\t\tdraw_obj(O,M, uv, 2);\t\r\n\telse {\r\n\t\tdraw_obj(O,M, 1.5*(uv+dx), 0);\t\r\n\t\tdraw_obj(O,M, 1.5*(uv-dx), 1);\t\r\n\t}\r\n    \r\n   fragColor = FragColor; \r\n}\r\n","inputs":[],"outputs":[],"code":"// Gardner textured ellipsoids - https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf + bib\r\n\r\nvec3 R = vec3(2.,4.,2.);              // ellipsoid radius\r\nvec3 L = normalize(vec3(-.4,0.,1.));  // light source\r\n#define AMBIENT .4\t\t\t\t\t  // ambient luminosity\r\n\r\n#define ANIM true\r\n#define PI 3.1415927\r\nvec4 FragColor;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )    // in [0,1]\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // in [0,1]\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )    // in [0,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\nfloat snoise( in vec3 x ) // in [-1,1]\r\n{ return 2.*noise(x)-1.; }\r\n\r\nfloat sfbm( vec3 p )      // in [-1,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\r\n    f += 0.2500*snoise( p ); p = m*p*2.03;\r\n    f += 0.1250*snoise( p ); p = m*p*2.01;\r\n    f += 0.0625*snoise( p );\r\n    return f;\r\n}\r\n\r\n\r\n\r\n// --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\r\n\r\n\r\nmat3 lookat(vec3 O, vec3 T, float d) {\r\n\tmat3 M;\r\n\tvec3 OT = normalize(T-O);\r\n\tM[0] = OT;\r\n\tM[2] = normalize(vec3(0.,0.,1.)-OT.z*OT)/d;\r\n\tM[1] = cross(M[2],OT);\r\n\treturn M;\r\n}\r\n\r\n// --- ray -  ellipsoid intersection\r\n// if true, return P,N and thickness l\r\n\r\nbool intersect_ellipsoid(vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\r\n\tvec3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere \r\n\t\t// P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\r\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\r\n\tfloat d = OD*OD - (OO-1.)*DD;\r\n\t\r\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\r\n\t// ray intersects the ellipsoid (and not in our back)\r\n\t// note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\r\n\t\t\r\n\tfloat t = (-OD-sqrt(d))/DD;\r\n\t// return intersection point, normal and thickness\r\n\tP = O+t*D;\r\n\tN=normalize(P/(R*R));\r\n\tl = 2.*sqrt(d)/DD;\r\n\r\n\treturn true;\r\n}\r\n\r\n// --- Gardner textured ellipsoids (sort of)\r\n\r\n// 's' index corresponds to Garner faked silhouette\r\n// 'i' index corresponds to interior term faked by mid-surface\r\n\r\nfloat ks,ps, ki,pi;  // smoothness/thichness parameters\r\n\r\nfloat l;\r\nvoid draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {\r\n\tvec3 D = normalize(M*vec3(1.,pos));\t\t// ray\r\n\t\r\n\tvec3 P,N; \r\n\tif (! intersect_ellipsoid(O,D, P,N,l)) return;\r\n\t\r\n\tvec3 Pm = P+.5*l*D,                \t\t// .5: deepest point inside cloud. \r\n\t\t Nm = normalize(Pm/(R*R)),     \t\t// it's normal\r\n\t     Nn = normalize(P/R);\r\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t// ratio of light-facing (for lighting)\r\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t// ratio of camera-facing (for silhouette)\r\n\r\n\r\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\r\n\tfloat A, l0 = 3.;\r\n\t//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette\r\n\tl = clamp(l-6.*ni,0.,1e10);\r\n\tfloat As = pow(ks*nd, ps), \t\t\t \t // silhouette\r\n\t\t  Ai = 1.-pow(.7,pi*l);              // interior\r\n\r\n\r\n\tAs =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);\r\n\tif (mode==2) \r\n\t\tA = 1.- (1.-As)*(1.-Ai);  \t\t\t// mul Ti and Ts\r\n\telse\r\n\t\tA = (mode==0) ? Ai : As; \r\n\tA = clamp(A,0.,1.); \r\n\tnl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));\r\n\r\n\t#if 0 // noise bump\r\n\tN = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); \r\n\tnl = clamp( dot(N,L),0.,1.);\r\n#endif\r\n\t\r\n\tvec4 col = vec4(mix(nl,1.,AMBIENT));\r\n\tFragColor = mix(FragColor,col,A);\r\n}\r\n\r\n// === main =============================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.85,.5));\r\n\tvec2 mouse = 2.*(iMouse.xy / iResolution.xy - vec2(.85,.5));\r\n\tfloat z = .2;\r\n\tks = 1.+mouse.x, ps = mouse.y*8., ki, pi;\r\n\tks = 1.; ps = 3.;   ki = .9; pi = 3.;\r\n\t\r\n\tif (iMouse.z>0.) {\r\n\t\tt = -PI/2.*mouse.x;\r\n\t\tz = -PI/2.*mouse.y;\r\n\t}\r\n\tvec3 O = vec3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t// camera\r\n\tfloat compas = t-.2*uv.x; vec2 dir = vec2(cos(compas),sin(compas));\r\n\tFragColor = (keyToggle(64+19)) \r\n\t\t? vec4(0.) \r\n\t\t: clamp(vec4(.6,.7+.3*dir,1.)*(uv.y+1.6)/1.8,0.,1.); \t\t// sky\r\n\r\n\tmat3 M = lookat(O,vec3(0.),5.); \r\n\tvec2 dx = vec2(1.,0.);\r\n\t\r\n\tif (!keyToggle(32))\r\n\t\tdraw_obj(O,M, uv, 2);\t\r\n\telse {\r\n\t\tdraw_obj(O,M, 1.5*(uv+dx), 0);\t\r\n\t\tdraw_obj(O,M, 1.5*(uv-dx), 1);\t\r\n\t}\r\n    \r\n   fragColor = FragColor; \r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"textured ellipsoids","id":"f68887fe97e4464198de45525837f846","date":null,"viewed":0,"name":"textured ellipsoids","description":"S: toggles sky  SPACE: decompos\n \nIn Siggraph'85, Gardner proposed a smart way to fake hypertextures with simple ellipsoids.\nThe secret is to have transparency (or the density noise) vanishing at silhouettes, i.e., view-dep (e.g. based on dot(N,Eye) ).\nhttps://www.shadertoy.com/view/XsfXW8","likes":0,"published":null,"tags":["procedural"," noise"," cloud"]},"ver":null,"info":{"Name":"textured ellipsoids","id":"f68887fe97e4464198de45525837f846","date":null,"viewed":0,"name":"textured ellipsoids","description":"S: toggles sky  SPACE: decompos\n \nIn Siggraph'85, Gardner proposed a smart way to fake hypertextures with simple ellipsoids.\nThe secret is to have transparency (or the density noise) vanishing at silhouettes, i.e., view-dep (e.g. based on dot(N,Eye) ).\nhttps://www.shadertoy.com/view/XsfXW8","likes":0,"published":null,"tags":["procedural"," noise"," cloud"]},"renderpass":[{"Code":"// Gardner textured ellipsoids - https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf + bib\r\n\r\nvec3 R = vec3(2.,4.,2.);              // ellipsoid radius\r\nvec3 L = normalize(vec3(-.4,0.,1.));  // light source\r\n#define AMBIENT .4\t\t\t\t\t  // ambient luminosity\r\n\r\n#define ANIM true\r\n#define PI 3.1415927\r\nvec4 FragColor;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )    // in [0,1]\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // in [0,1]\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )    // in [0,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\nfloat snoise( in vec3 x ) // in [-1,1]\r\n{ return 2.*noise(x)-1.; }\r\n\r\nfloat sfbm( vec3 p )      // in [-1,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\r\n    f += 0.2500*snoise( p ); p = m*p*2.03;\r\n    f += 0.1250*snoise( p ); p = m*p*2.01;\r\n    f += 0.0625*snoise( p );\r\n    return f;\r\n}\r\n\r\n\r\n\r\n// --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\r\n\r\n\r\nmat3 lookat(vec3 O, vec3 T, float d) {\r\n\tmat3 M;\r\n\tvec3 OT = normalize(T-O);\r\n\tM[0] = OT;\r\n\tM[2] = normalize(vec3(0.,0.,1.)-OT.z*OT)/d;\r\n\tM[1] = cross(M[2],OT);\r\n\treturn M;\r\n}\r\n\r\n// --- ray -  ellipsoid intersection\r\n// if true, return P,N and thickness l\r\n\r\nbool intersect_ellipsoid(vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\r\n\tvec3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere \r\n\t\t// P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\r\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\r\n\tfloat d = OD*OD - (OO-1.)*DD;\r\n\t\r\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\r\n\t// ray intersects the ellipsoid (and not in our back)\r\n\t// note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\r\n\t\t\r\n\tfloat t = (-OD-sqrt(d))/DD;\r\n\t// return intersection point, normal and thickness\r\n\tP = O+t*D;\r\n\tN=normalize(P/(R*R));\r\n\tl = 2.*sqrt(d)/DD;\r\n\r\n\treturn true;\r\n}\r\n\r\n// --- Gardner textured ellipsoids (sort of)\r\n\r\n// 's' index corresponds to Garner faked silhouette\r\n// 'i' index corresponds to interior term faked by mid-surface\r\n\r\nfloat ks,ps, ki,pi;  // smoothness/thichness parameters\r\n\r\nfloat l;\r\nvoid draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {\r\n\tvec3 D = normalize(M*vec3(1.,pos));\t\t// ray\r\n\t\r\n\tvec3 P,N; \r\n\tif (! intersect_ellipsoid(O,D, P,N,l)) return;\r\n\t\r\n\tvec3 Pm = P+.5*l*D,                \t\t// .5: deepest point inside cloud. \r\n\t\t Nm = normalize(Pm/(R*R)),     \t\t// it's normal\r\n\t     Nn = normalize(P/R);\r\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t// ratio of light-facing (for lighting)\r\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t// ratio of camera-facing (for silhouette)\r\n\r\n\r\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\r\n\tfloat A, l0 = 3.;\r\n\t//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette\r\n\tl = clamp(l-6.*ni,0.,1e10);\r\n\tfloat As = pow(ks*nd, ps), \t\t\t \t // silhouette\r\n\t\t  Ai = 1.-pow(.7,pi*l);              // interior\r\n\r\n\r\n\tAs =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);\r\n\tif (mode==2) \r\n\t\tA = 1.- (1.-As)*(1.-Ai);  \t\t\t// mul Ti and Ts\r\n\telse\r\n\t\tA = (mode==0) ? Ai : As; \r\n\tA = clamp(A,0.,1.); \r\n\tnl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));\r\n\r\n\t#if 0 // noise bump\r\n\tN = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); \r\n\tnl = clamp( dot(N,L),0.,1.);\r\n#endif\r\n\t\r\n\tvec4 col = vec4(mix(nl,1.,AMBIENT));\r\n\tFragColor = mix(FragColor,col,A);\r\n}\r\n\r\n// === main =============================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.85,.5));\r\n\tvec2 mouse = 2.*(iMouse.xy / iResolution.xy - vec2(.85,.5));\r\n\tfloat z = .2;\r\n\tks = 1.+mouse.x, ps = mouse.y*8., ki, pi;\r\n\tks = 1.; ps = 3.;   ki = .9; pi = 3.;\r\n\t\r\n\tif (iMouse.z>0.) {\r\n\t\tt = -PI/2.*mouse.x;\r\n\t\tz = -PI/2.*mouse.y;\r\n\t}\r\n\tvec3 O = vec3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t// camera\r\n\tfloat compas = t-.2*uv.x; vec2 dir = vec2(cos(compas),sin(compas));\r\n\tFragColor = (keyToggle(64+19)) \r\n\t\t? vec4(0.) \r\n\t\t: clamp(vec4(.6,.7+.3*dir,1.)*(uv.y+1.6)/1.8,0.,1.); \t\t// sky\r\n\r\n\tmat3 M = lookat(O,vec3(0.),5.); \r\n\tvec2 dx = vec2(1.,0.);\r\n\t\r\n\tif (!keyToggle(32))\r\n\t\tdraw_obj(O,M, uv, 2);\t\r\n\telse {\r\n\t\tdraw_obj(O,M, 1.5*(uv+dx), 0);\t\r\n\t\tdraw_obj(O,M, 1.5*(uv-dx), 1);\t\r\n\t}\r\n    \r\n   fragColor = FragColor; \r\n}\r\n","inputs":[],"outputs":[],"code":"// Gardner textured ellipsoids - https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf + bib\r\n\r\nvec3 R = vec3(2.,4.,2.);              // ellipsoid radius\r\nvec3 L = normalize(vec3(-.4,0.,1.));  // light source\r\n#define AMBIENT .4\t\t\t\t\t  // ambient luminosity\r\n\r\n#define ANIM true\r\n#define PI 3.1415927\r\nvec4 FragColor;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )    // in [0,1]\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // in [0,1]\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )    // in [0,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\nfloat snoise( in vec3 x ) // in [-1,1]\r\n{ return 2.*noise(x)-1.; }\r\n\r\nfloat sfbm( vec3 p )      // in [-1,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\r\n    f += 0.2500*snoise( p ); p = m*p*2.03;\r\n    f += 0.1250*snoise( p ); p = m*p*2.01;\r\n    f += 0.0625*snoise( p );\r\n    return f;\r\n}\r\n\r\n\r\n\r\n// --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\r\n\r\n\r\nmat3 lookat(vec3 O, vec3 T, float d) {\r\n\tmat3 M;\r\n\tvec3 OT = normalize(T-O);\r\n\tM[0] = OT;\r\n\tM[2] = normalize(vec3(0.,0.,1.)-OT.z*OT)/d;\r\n\tM[1] = cross(M[2],OT);\r\n\treturn M;\r\n}\r\n\r\n// --- ray -  ellipsoid intersection\r\n// if true, return P,N and thickness l\r\n\r\nbool intersect_ellipsoid(vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\r\n\tvec3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere \r\n\t\t// P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\r\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\r\n\tfloat d = OD*OD - (OO-1.)*DD;\r\n\t\r\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\r\n\t// ray intersects the ellipsoid (and not in our back)\r\n\t// note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\r\n\t\t\r\n\tfloat t = (-OD-sqrt(d))/DD;\r\n\t// return intersection point, normal and thickness\r\n\tP = O+t*D;\r\n\tN=normalize(P/(R*R));\r\n\tl = 2.*sqrt(d)/DD;\r\n\r\n\treturn true;\r\n}\r\n\r\n// --- Gardner textured ellipsoids (sort of)\r\n\r\n// 's' index corresponds to Garner faked silhouette\r\n// 'i' index corresponds to interior term faked by mid-surface\r\n\r\nfloat ks,ps, ki,pi;  // smoothness/thichness parameters\r\n\r\nfloat l;\r\nvoid draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {\r\n\tvec3 D = normalize(M*vec3(1.,pos));\t\t// ray\r\n\t\r\n\tvec3 P,N; \r\n\tif (! intersect_ellipsoid(O,D, P,N,l)) return;\r\n\t\r\n\tvec3 Pm = P+.5*l*D,                \t\t// .5: deepest point inside cloud. \r\n\t\t Nm = normalize(Pm/(R*R)),     \t\t// it's normal\r\n\t     Nn = normalize(P/R);\r\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t// ratio of light-facing (for lighting)\r\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t// ratio of camera-facing (for silhouette)\r\n\r\n\r\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\r\n\tfloat A, l0 = 3.;\r\n\t//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette\r\n\tl = clamp(l-6.*ni,0.,1e10);\r\n\tfloat As = pow(ks*nd, ps), \t\t\t \t // silhouette\r\n\t\t  Ai = 1.-pow(.7,pi*l);              // interior\r\n\r\n\r\n\tAs =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);\r\n\tif (mode==2) \r\n\t\tA = 1.- (1.-As)*(1.-Ai);  \t\t\t// mul Ti and Ts\r\n\telse\r\n\t\tA = (mode==0) ? Ai : As; \r\n\tA = clamp(A,0.,1.); \r\n\tnl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));\r\n\r\n\t#if 0 // noise bump\r\n\tN = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); \r\n\tnl = clamp( dot(N,L),0.,1.);\r\n#endif\r\n\t\r\n\tvec4 col = vec4(mix(nl,1.,AMBIENT));\r\n\tFragColor = mix(FragColor,col,A);\r\n}\r\n\r\n// === main =============================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.85,.5));\r\n\tvec2 mouse = 2.*(iMouse.xy / iResolution.xy - vec2(.85,.5));\r\n\tfloat z = .2;\r\n\tks = 1.+mouse.x, ps = mouse.y*8., ki, pi;\r\n\tks = 1.; ps = 3.;   ki = .9; pi = 3.;\r\n\t\r\n\tif (iMouse.z>0.) {\r\n\t\tt = -PI/2.*mouse.x;\r\n\t\tz = -PI/2.*mouse.y;\r\n\t}\r\n\tvec3 O = vec3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t// camera\r\n\tfloat compas = t-.2*uv.x; vec2 dir = vec2(cos(compas),sin(compas));\r\n\tFragColor = (keyToggle(64+19)) \r\n\t\t? vec4(0.) \r\n\t\t: clamp(vec4(.6,.7+.3*dir,1.)*(uv.y+1.6)/1.8,0.,1.); \t\t// sky\r\n\r\n\tmat3 M = lookat(O,vec3(0.),5.); \r\n\tvec2 dx = vec2(1.,0.);\r\n\t\r\n\tif (!keyToggle(32))\r\n\t\tdraw_obj(O,M, uv, 2);\t\r\n\telse {\r\n\t\tdraw_obj(O,M, 1.5*(uv+dx), 0);\t\r\n\t\tdraw_obj(O,M, 1.5*(uv-dx), 1);\t\r\n\t}\r\n    \r\n   fragColor = FragColor; \r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// ***********************************************************\r\n// Alcatraz / The explorer 4k Intro\r\n// by Jochen \"Virgill\" Feldk\u00F6tter\r\n//\r\n// 4kb executable: http://www.pouet.net/prod.php?which=75741\r\n//\r\n// ***********************************************************\r\n\r\n\r\n// use mouse for light direction\r\n//#define mouse    \r\n\r\n\r\nint scene = 0;\r\n// 0 = empty\t\t\t\tcolor:\t\t\tparticles: off \r\n// 1 = falling objects\t\tcolor:red\t\tparticles: off \r\n// 2 = wobble floor\t\t\tcolor:red\t\tparticles: on\r\n// 3 = room with stone\t\tcolor:blue\t\tparticles: on\r\n// 4 = kleinian fractal\t\tcolor:red\t\tparticles: on\t\r\n// 5 = wtf scene\t\t \tcolor:blue\t\tparticles: off\r\n\r\nint scene_idx,lightscene_idx;\t// init   // empty                   // falling objects        // wobble floor           // room with stone        // kleinian fractal       // wtf scene \r\nfloat lightscenesx[37] = float[37] (2.3,  2.3,0.0,0.0,6.9,4.6,2.3,   0.0,3.0,0.0,4.0,7.5,3.4,  8.0,8.5,5.0,5.0,5.0,5.0,  0.0,8.5,5.0,5.0,8.0,8.5,  8.5,8.5,4.2,5.0,4.0,4.3,  6.9,8.0,2.0,2.5,3.6,4.6);\r\nfloat lightscenesy[37] = float[37] (0.0,  0.0,2.3,0.0,0.0,2.3,0.0,   2.0,1.0,1.0,3.0,0.0,0.5,  0.0,0.0,3.0,3.0,4.0,3.0,  0.8,1.0,5.0,3.5,0.0,1.0,  8.0,7.5,1.5,3.5,1.5,2.5,  0.0,0.0,0.0,0.0,0.0,0.0);\r\nfloat lightduration = 4.; \r\nfloat sceneduration = 24.; \r\nvec2  lightscene,lightscene_old,lightscene_interpolated;\r\n\r\n\r\n\r\n\r\nvec3 lightpos;\r\nvec3 lightdir = vec3(0,0,1);\r\nfloat scatter,test;\r\n\r\n\r\n\r\n// noise\r\nfloat rnd(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\r\n}\r\n\r\n// box sdf\r\nfloat sdBox(vec3 p,vec3 b)\r\n{\r\n  vec3 d = abs(p)-b;\r\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\r\n}\r\n\r\n// 3D noise function (shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip = floor(p);\r\n    p -= ip; \r\n    vec3 s = vec3(7,157,113);\r\n    vec4 h = vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p = p*p*(3.-2.*p); \r\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\r\n    h.xy = mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\n// cone sdf\r\nfloat sdCone( vec3 p, vec2 c )\r\n{\r\n    return dot(c,vec2(length(p.xy),p.z));\r\n}\r\n\r\n\r\n// rotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n\r\n// wtf fractal (shane)\r\nconst float md = .6;\r\nconst float fl = 1.;\r\nfloat mapy(vec3 p) \r\n{\r\n\tp.x = mod(p.x+1.,2.) - 1.0;\r\n\tvec4 q = vec4(p,1.);\r\n\tvec4 o = q;\r\n\t\r\nfor(int i = 0; i < 10; i++) {\r\n\t\tpR(q.yz,1.55);\r\n\t\tq.xyz = clamp(q.xyz, -fl, fl)*2. - q.xyz;\r\n\t\tfloat r = dot(q.xyz, q.xyz);\r\n\t\tq *= clamp(max(md/r, .6), 0.0, 1.);\r\n\t\tq = (3./md)*q-o;\r\n\r\n\t}\r\n\r\n\treturn (length(q.xyz))/q.w-0.005;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfloat map(vec3 p, int vol) \r\n{\r\n    float d = 1.;\r\n\tvec3 r = p;\r\n \r\n// sphere ship\r\n    float ship = length(r-lightpos)-0.1; \r\n\r\n// cone light\r\n\tvec3 schein=(r-lightpos);\r\n#ifdef mouse\r\n    pR(schein.zx,iMouse.x*-0.03);\r\n    pR(schein.yz,iMouse.y*0.03);\r\n#else\r\n    pR(schein.zx,-lightscene_interpolated.y);\r\n    pR(schein.yz,lightscene_interpolated.x); \r\n#endif    \r\n\tfloat s= sdCone(schein,normalize(vec2(1,1)))/length(schein*schein)+0.2*noise(10.*p+2.*sin(.2*iTime))+0.1*noise(p*23.+sin(0.3*iTime))+0.2*rnd(p.xy);\r\n\tscatter += max(-s,0.)*0.07;\r\n     \r\n\r\n// scene: falling objects\r\n\tif (scene==1)\r\n\t{\r\n        vec3 c= vec3(1.5);\r\n        p.y+=.4*iTime;\r\n        vec3 q = mod(p,c)-.5*c;\r\n\r\n        d=max(length(q)-0.1,p.z-3.);\r\n        d-=.2*noise(6.*p)+0.005*noise(80.*p);\r\n        d=min(d,p.z+4.);\r\n    } \r\n    \r\n// scene: wobble floor\r\n    if (scene==2)\r\n    {\r\n    \td=p.y-0.01*noise(50.*p)+0.4*noise(2.*p+0.2*iTime)+0.09*noise(7.*p);\r\n    }\r\n   \r\n// scene: room with stone\r\n\tif (scene==3)\r\n    {\r\n\t\td = p.y-log(1.*pow(length(p.xz),1.)+0.2);\r\n\t\td = min(d,length(p)-0.4-0.04*noise(p*70.)-0.5*noise(p*4.+iTime)-0.02*noise(p*114.+iTime));\r\n\t\td +=0.05*noise(p*10.)-0.009*noise(p*-40.)+noise(p*2.);;\r\n\t}    \r\n    \r\n// scene: kleinian fractal\r\n    if (scene==4)\r\n    {\r\n\t\tvec4 q = vec4(p,1.);\r\n\t\tq*=.5;\r\n        q.x +=.5;\r\n\t\tq.z+=1.;\r\n\t\tfor(int i=0;i<8;i++) \r\n    \t{\r\n\t\t\tq.xyz=-1.+2.*fract(.5+.5*q.xyz);\r\n\t\t\tq=1.3*q/max(dot(q.xyz,q.xyz),.1);\r\n\t\t}\r\n\t\td=max(0.9*abs(q.y)/q.w,length(p)-3.5)-0.002*noise(50.*p); // with bounding circle\r\n \t\ttest =1.-1./(q.w);//\thighlight fractal area\r\n    }\r\n    \r\n     \r\n// scene: wtf\r\n\tif (scene==5)\r\n\t{\r\n        p.z+=3.5;\r\n        p.y-=0.1*(iTime-120.);\r\n        p.z-=0.1*(iTime-120.);\r\n            d = .5*mapy(p);\r\n    }   \r\n\r\n    return min(ship,d);\r\n}\r\n\r\n\r\n\r\n//***************************************************************************************************\r\n// normal calculation\r\n//***************************************************************************************************\r\n\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps = 0.002, d = map(pos,0);\r\n    if (scene==4) eps = 0.2;\r\n    if (scene==5) eps = 0.02;\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0),0)-d,map(pos+vec3(0,eps,0),0)-d,map(pos+vec3(0,0,eps),0)-d));\r\n}\r\n\r\n\r\n\r\n// ray marching loop (added noise to make it noisy)\r\nfloat castRay(in vec3 ro, in vec3 rd, in float maxt, in vec2 co) {\r\n    float precis = 0.001;\r\n    float h = precis * 2.0;\r\n    float t = -3.5+rnd(co+0.01*iTime)*7.;\r\n    for(int i = 0; i < 200; i++) \r\n    {\r\n    \tif(abs(h) < precis || t > maxt) continue;\r\n        h = map(ro+rd*t,1);\r\n        t += 0.25*h;\r\n    }\r\n    return t;\r\n    \r\n\r\n}\r\n\r\n\r\n\r\n//***************************************************************************************************\r\n// Main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n\r\n// scene handling   \r\n   \tlightscene_idx \t= int(floor((iTime+.8)/lightduration));\r\n    scene \t\t\t= int(floor(iTime/sceneduration));\r\n   \tlightscene \t\t= vec2(lightscenesx[lightscene_idx+1],lightscenesy[lightscene_idx+1]);     \r\n   \tlightscene_old\t= vec2(lightscenesx[lightscene_idx],lightscenesy[lightscene_idx]);     \r\n\tlightscene_interpolated = mix(lightscene,lightscene_old, exp(-64.*pow(fract((iTime+.8)/lightduration),4.)))*0.7;\r\n\r\n\t// camera setup (iq)   \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 p = uv * 2.0 - 1.0;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    float theta = iTime * 3.141592 * 0.20;\r\n    float x = 5.0 * cos(theta*0.5);\r\n    float z = 5.0 * sin(theta*0.5);\r\n    \r\n    vec3 ro = vec3(0.5*x, 4.0, 5.3);\r\n    if (scene==5||scene==0) ro = vec3(0.0, 8.0, -0.0001);  \r\n    \r\n\r\n    \r\n    \r\n    vec3 ta = vec3(0.0, 0.25, 0.0);\r\n    vec3 cw = normalize(ta - ro);\r\n    vec3 cp = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = normalize(cross(cw, cp));\r\n    vec3 cv = normalize(cross(cu, cw));\r\n    vec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\r\n\r\n    float ypos=0.8;\r\n    if (scene==1||scene==3||scene==5) ypos=0.;\r\n    \r\n    lightpos = vec3(ypos,0.7 + 0.2 * sin(theta*2.0),1.-0.2*sin(0.2*iTime)); \r\n    if (scene==5||scene==0) lightpos = vec3(0,2,0); \r\n    \r\n    \r\n#ifdef mouse\r\n    pR(lightdir.yz,iMouse.y*-0.03);\r\n    pR(lightdir.zx,iMouse.x*0.03);\r\n#else\r\n    pR(lightdir.yz,-lightscene_interpolated.x);\r\n    pR(lightdir.zx,lightscene_interpolated.y);\r\n#endif    \r\n    \r\n// feedbak noise (with buffer a)\r\n   \tuv.x-=0.005*noise(uv.yxx*32.-iTime)-0.0025;\r\n   \tuv.y+=0.005*noise(uv.yxx*32.+iTime)-0.0025; \r\n    vec3 bufa= texture(iChannel0,uv).xyz;\r\n    \r\n\r\n // render\r\n    vec3 col = vec3(0);\r\n   \tfloat t= castRay(ro, rd, 15.0,uv);    \r\n\tfloat depth = clamp(t/5.-1.3,0.,1.);\r\n\tif (t>15.) t=-1000000.;\r\n    vec3 pos = ro + rd * t;\r\n    vec3 nor = calcNormal(pos);\r\n    \r\n    \r\n// colors    \r\n    vec3 basecol = vec3(2./1., 1./4., 1./16.);\r\n    if (scene==3||scene==5) basecol = vec3(1./16., 1./4., 2./1.);\r\n    \r\n    \r\n// treat light as conelight\r\n    float ncol=0.;\r\n    float cone=1.;\r\n    vec3 L = normalize(lightpos - pos);\t\t\t\t// vector to light position (from surcface)\r\n    float NdotL = dot(nor,L);\r\n    float conedot = dot(lightdir, normalize(L));\r\n    float conecos = 0.7071;\r\n    float cold = NdotL; \t\t\t\t\t\t\t\t\t// diffuse\r\n    float cols = pow(clamp(dot(nor,normalize(L+normalize(ro - pos))), 0.0, 1.0), 60.0);\t// specular  \r\n\r\n    if (NdotL > 0.0 && conedot > conecos)  \t\t\t// 45 degrees, corresponding to cone param (1,1)\r\n    {        \r\n         cone =  pow((conedot-conecos)/(1.-conecos),4.);// pow for cone light distribution\r\n         ncol = (cold + cols) * cone;\t\t\t\t\t// combine  \r\n\t\t col+=clamp((test),0.,1.)*scatter*cone*vec3(0.2,0.05,0.);\r\n    }    \r\n  \r\n\r\n\r\n    \r\n\r\n// particles   \r\n    float d;\r\n    for (int i; i<36; i++)\r\n    {\r\n    \tfloat fi =float(i);\r\n    \tvec2 pos = vec2(.5+.2*sin(fi+.5*iTime+ cos(.01*iTime*fi))+ .2*sin(-fi),  \r\n                        .5+.2*cos(fi+.2*iTime+ sin(.02*iTime*fi)))+.2*cos( fi);\r\n    \td += clamp(1.-(length(350.*(.8+.5*sin(fi*iTime))*(pos - uv))),0.,1.);\r\n   \t}\r\n    if (scene==2||scene==3||scene==4) col+=d*ncol*(basecol+vec3(0,.5,0))*2.;\r\n\r\n    \r\n    \r\n// color for light (+ feedback noise)\r\n\tcol+=0.3*scatter*vec3(1.,0.8,.6)+0.6*bufa;\r\n// color for material\r\n    col+= 0.6*basecol*exp(6.*(-1.+ncol)); \r\n\t\r\n\r\n    \r\n  float fade =min (3.*abs(sin((3.1415*iTime/sceneduration))),1.); \r\n if (iTime>140.) fade=0.;\r\n\tfragColor = vec4(col*fade,depth);\r\n}","inputs":[],"outputs":[],"code":"// ***********************************************************\r\n// Alcatraz / The explorer 4k Intro\r\n// by Jochen \"Virgill\" Feldk\u00F6tter\r\n//\r\n// 4kb executable: http://www.pouet.net/prod.php?which=75741\r\n//\r\n// ***********************************************************\r\n\r\n\r\n// use mouse for light direction\r\n//#define mouse    \r\n\r\n\r\nint scene = 0;\r\n// 0 = empty\t\t\t\tcolor:\t\t\tparticles: off \r\n// 1 = falling objects\t\tcolor:red\t\tparticles: off \r\n// 2 = wobble floor\t\t\tcolor:red\t\tparticles: on\r\n// 3 = room with stone\t\tcolor:blue\t\tparticles: on\r\n// 4 = kleinian fractal\t\tcolor:red\t\tparticles: on\t\r\n// 5 = wtf scene\t\t \tcolor:blue\t\tparticles: off\r\n\r\nint scene_idx,lightscene_idx;\t// init   // empty                   // falling objects        // wobble floor           // room with stone        // kleinian fractal       // wtf scene \r\nfloat lightscenesx[37] = float[37] (2.3,  2.3,0.0,0.0,6.9,4.6,2.3,   0.0,3.0,0.0,4.0,7.5,3.4,  8.0,8.5,5.0,5.0,5.0,5.0,  0.0,8.5,5.0,5.0,8.0,8.5,  8.5,8.5,4.2,5.0,4.0,4.3,  6.9,8.0,2.0,2.5,3.6,4.6);\r\nfloat lightscenesy[37] = float[37] (0.0,  0.0,2.3,0.0,0.0,2.3,0.0,   2.0,1.0,1.0,3.0,0.0,0.5,  0.0,0.0,3.0,3.0,4.0,3.0,  0.8,1.0,5.0,3.5,0.0,1.0,  8.0,7.5,1.5,3.5,1.5,2.5,  0.0,0.0,0.0,0.0,0.0,0.0);\r\nfloat lightduration = 4.; \r\nfloat sceneduration = 24.; \r\nvec2  lightscene,lightscene_old,lightscene_interpolated;\r\n\r\n\r\n\r\n\r\nvec3 lightpos;\r\nvec3 lightdir = vec3(0,0,1);\r\nfloat scatter,test;\r\n\r\n\r\n\r\n// noise\r\nfloat rnd(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\r\n}\r\n\r\n// box sdf\r\nfloat sdBox(vec3 p,vec3 b)\r\n{\r\n  vec3 d = abs(p)-b;\r\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\r\n}\r\n\r\n// 3D noise function (shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip = floor(p);\r\n    p -= ip; \r\n    vec3 s = vec3(7,157,113);\r\n    vec4 h = vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p = p*p*(3.-2.*p); \r\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\r\n    h.xy = mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\n// cone sdf\r\nfloat sdCone( vec3 p, vec2 c )\r\n{\r\n    return dot(c,vec2(length(p.xy),p.z));\r\n}\r\n\r\n\r\n// rotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n\r\n// wtf fractal (shane)\r\nconst float md = .6;\r\nconst float fl = 1.;\r\nfloat mapy(vec3 p) \r\n{\r\n\tp.x = mod(p.x+1.,2.) - 1.0;\r\n\tvec4 q = vec4(p,1.);\r\n\tvec4 o = q;\r\n\t\r\nfor(int i = 0; i < 10; i++) {\r\n\t\tpR(q.yz,1.55);\r\n\t\tq.xyz = clamp(q.xyz, -fl, fl)*2. - q.xyz;\r\n\t\tfloat r = dot(q.xyz, q.xyz);\r\n\t\tq *= clamp(max(md/r, .6), 0.0, 1.);\r\n\t\tq = (3./md)*q-o;\r\n\r\n\t}\r\n\r\n\treturn (length(q.xyz))/q.w-0.005;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfloat map(vec3 p, int vol) \r\n{\r\n    float d = 1.;\r\n\tvec3 r = p;\r\n \r\n// sphere ship\r\n    float ship = length(r-lightpos)-0.1; \r\n\r\n// cone light\r\n\tvec3 schein=(r-lightpos);\r\n#ifdef mouse\r\n    pR(schein.zx,iMouse.x*-0.03);\r\n    pR(schein.yz,iMouse.y*0.03);\r\n#else\r\n    pR(schein.zx,-lightscene_interpolated.y);\r\n    pR(schein.yz,lightscene_interpolated.x); \r\n#endif    \r\n\tfloat s= sdCone(schein,normalize(vec2(1,1)))/length(schein*schein)+0.2*noise(10.*p+2.*sin(.2*iTime))+0.1*noise(p*23.+sin(0.3*iTime))+0.2*rnd(p.xy);\r\n\tscatter += max(-s,0.)*0.07;\r\n     \r\n\r\n// scene: falling objects\r\n\tif (scene==1)\r\n\t{\r\n        vec3 c= vec3(1.5);\r\n        p.y+=.4*iTime;\r\n        vec3 q = mod(p,c)-.5*c;\r\n\r\n        d=max(length(q)-0.1,p.z-3.);\r\n        d-=.2*noise(6.*p)+0.005*noise(80.*p);\r\n        d=min(d,p.z+4.);\r\n    } \r\n    \r\n// scene: wobble floor\r\n    if (scene==2)\r\n    {\r\n    \td=p.y-0.01*noise(50.*p)+0.4*noise(2.*p+0.2*iTime)+0.09*noise(7.*p);\r\n    }\r\n   \r\n// scene: room with stone\r\n\tif (scene==3)\r\n    {\r\n\t\td = p.y-log(1.*pow(length(p.xz),1.)+0.2);\r\n\t\td = min(d,length(p)-0.4-0.04*noise(p*70.)-0.5*noise(p*4.+iTime)-0.02*noise(p*114.+iTime));\r\n\t\td +=0.05*noise(p*10.)-0.009*noise(p*-40.)+noise(p*2.);;\r\n\t}    \r\n    \r\n// scene: kleinian fractal\r\n    if (scene==4)\r\n    {\r\n\t\tvec4 q = vec4(p,1.);\r\n\t\tq*=.5;\r\n        q.x +=.5;\r\n\t\tq.z+=1.;\r\n\t\tfor(int i=0;i<8;i++) \r\n    \t{\r\n\t\t\tq.xyz=-1.+2.*fract(.5+.5*q.xyz);\r\n\t\t\tq=1.3*q/max(dot(q.xyz,q.xyz),.1);\r\n\t\t}\r\n\t\td=max(0.9*abs(q.y)/q.w,length(p)-3.5)-0.002*noise(50.*p); // with bounding circle\r\n \t\ttest =1.-1./(q.w);//\thighlight fractal area\r\n    }\r\n    \r\n     \r\n// scene: wtf\r\n\tif (scene==5)\r\n\t{\r\n        p.z+=3.5;\r\n        p.y-=0.1*(iTime-120.);\r\n        p.z-=0.1*(iTime-120.);\r\n            d = .5*mapy(p);\r\n    }   \r\n\r\n    return min(ship,d);\r\n}\r\n\r\n\r\n\r\n//***************************************************************************************************\r\n// normal calculation\r\n//***************************************************************************************************\r\n\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps = 0.002, d = map(pos,0);\r\n    if (scene==4) eps = 0.2;\r\n    if (scene==5) eps = 0.02;\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0),0)-d,map(pos+vec3(0,eps,0),0)-d,map(pos+vec3(0,0,eps),0)-d));\r\n}\r\n\r\n\r\n\r\n// ray marching loop (added noise to make it noisy)\r\nfloat castRay(in vec3 ro, in vec3 rd, in float maxt, in vec2 co) {\r\n    float precis = 0.001;\r\n    float h = precis * 2.0;\r\n    float t = -3.5+rnd(co+0.01*iTime)*7.;\r\n    for(int i = 0; i < 200; i++) \r\n    {\r\n    \tif(abs(h) < precis || t > maxt) continue;\r\n        h = map(ro+rd*t,1);\r\n        t += 0.25*h;\r\n    }\r\n    return t;\r\n    \r\n\r\n}\r\n\r\n\r\n\r\n//***************************************************************************************************\r\n// Main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n\r\n// scene handling   \r\n   \tlightscene_idx \t= int(floor((iTime+.8)/lightduration));\r\n    scene \t\t\t= int(floor(iTime/sceneduration));\r\n   \tlightscene \t\t= vec2(lightscenesx[lightscene_idx+1],lightscenesy[lightscene_idx+1]);     \r\n   \tlightscene_old\t= vec2(lightscenesx[lightscene_idx],lightscenesy[lightscene_idx]);     \r\n\tlightscene_interpolated = mix(lightscene,lightscene_old, exp(-64.*pow(fract((iTime+.8)/lightduration),4.)))*0.7;\r\n\r\n\t// camera setup (iq)   \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 p = uv * 2.0 - 1.0;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    float theta = iTime * 3.141592 * 0.20;\r\n    float x = 5.0 * cos(theta*0.5);\r\n    float z = 5.0 * sin(theta*0.5);\r\n    \r\n    vec3 ro = vec3(0.5*x, 4.0, 5.3);\r\n    if (scene==5||scene==0) ro = vec3(0.0, 8.0, -0.0001);  \r\n    \r\n\r\n    \r\n    \r\n    vec3 ta = vec3(0.0, 0.25, 0.0);\r\n    vec3 cw = normalize(ta - ro);\r\n    vec3 cp = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = normalize(cross(cw, cp));\r\n    vec3 cv = normalize(cross(cu, cw));\r\n    vec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\r\n\r\n    float ypos=0.8;\r\n    if (scene==1||scene==3||scene==5) ypos=0.;\r\n    \r\n    lightpos = vec3(ypos,0.7 + 0.2 * sin(theta*2.0),1.-0.2*sin(0.2*iTime)); \r\n    if (scene==5||scene==0) lightpos = vec3(0,2,0); \r\n    \r\n    \r\n#ifdef mouse\r\n    pR(lightdir.yz,iMouse.y*-0.03);\r\n    pR(lightdir.zx,iMouse.x*0.03);\r\n#else\r\n    pR(lightdir.yz,-lightscene_interpolated.x);\r\n    pR(lightdir.zx,lightscene_interpolated.y);\r\n#endif    \r\n    \r\n// feedbak noise (with buffer a)\r\n   \tuv.x-=0.005*noise(uv.yxx*32.-iTime)-0.0025;\r\n   \tuv.y+=0.005*noise(uv.yxx*32.+iTime)-0.0025; \r\n    vec3 bufa= texture(iChannel0,uv).xyz;\r\n    \r\n\r\n // render\r\n    vec3 col = vec3(0);\r\n   \tfloat t= castRay(ro, rd, 15.0,uv);    \r\n\tfloat depth = clamp(t/5.-1.3,0.,1.);\r\n\tif (t>15.) t=-1000000.;\r\n    vec3 pos = ro + rd * t;\r\n    vec3 nor = calcNormal(pos);\r\n    \r\n    \r\n// colors    \r\n    vec3 basecol = vec3(2./1., 1./4., 1./16.);\r\n    if (scene==3||scene==5) basecol = vec3(1./16., 1./4., 2./1.);\r\n    \r\n    \r\n// treat light as conelight\r\n    float ncol=0.;\r\n    float cone=1.;\r\n    vec3 L = normalize(lightpos - pos);\t\t\t\t// vector to light position (from surcface)\r\n    float NdotL = dot(nor,L);\r\n    float conedot = dot(lightdir, normalize(L));\r\n    float conecos = 0.7071;\r\n    float cold = NdotL; \t\t\t\t\t\t\t\t\t// diffuse\r\n    float cols = pow(clamp(dot(nor,normalize(L+normalize(ro - pos))), 0.0, 1.0), 60.0);\t// specular  \r\n\r\n    if (NdotL > 0.0 && conedot > conecos)  \t\t\t// 45 degrees, corresponding to cone param (1,1)\r\n    {        \r\n         cone =  pow((conedot-conecos)/(1.-conecos),4.);// pow for cone light distribution\r\n         ncol = (cold + cols) * cone;\t\t\t\t\t// combine  \r\n\t\t col+=clamp((test),0.,1.)*scatter*cone*vec3(0.2,0.05,0.);\r\n    }    \r\n  \r\n\r\n\r\n    \r\n\r\n// particles   \r\n    float d;\r\n    for (int i; i<36; i++)\r\n    {\r\n    \tfloat fi =float(i);\r\n    \tvec2 pos = vec2(.5+.2*sin(fi+.5*iTime+ cos(.01*iTime*fi))+ .2*sin(-fi),  \r\n                        .5+.2*cos(fi+.2*iTime+ sin(.02*iTime*fi)))+.2*cos( fi);\r\n    \td += clamp(1.-(length(350.*(.8+.5*sin(fi*iTime))*(pos - uv))),0.,1.);\r\n   \t}\r\n    if (scene==2||scene==3||scene==4) col+=d*ncol*(basecol+vec3(0,.5,0))*2.;\r\n\r\n    \r\n    \r\n// color for light (+ feedback noise)\r\n\tcol+=0.3*scatter*vec3(1.,0.8,.6)+0.6*bufa;\r\n// color for material\r\n    col+= 0.6*basecol*exp(6.*(-1.+ncol)); \r\n\t\r\n\r\n    \r\n  float fade =min (3.*abs(sin((3.1415*iTime/sceneduration))),1.); \r\n if (iTime>140.) fade=0.;\r\n\tfragColor = vec4(col*fade,depth);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"The explorer","id":"ce90770389ac419095bf5bbf1fe4bfd1","date":null,"viewed":0,"name":"The explorer","description":"Alcatraz / The explorer 4k Intro\nby Jochen \"Virgill\" Feldk\u00F6tter\n4kb executable: http://www.pouet.net/prod.php?which=75741\nhttps://www.shadertoy.com/view/lsGyDt","likes":0,"published":null,"tags":["4k"," volumetric"," fractals"," raymarchin"," 4kintro"," conelight"]},"ver":null,"info":{"Name":"The explorer","id":"ce90770389ac419095bf5bbf1fe4bfd1","date":null,"viewed":0,"name":"The explorer","description":"Alcatraz / The explorer 4k Intro\nby Jochen \"Virgill\" Feldk\u00F6tter\n4kb executable: http://www.pouet.net/prod.php?which=75741\nhttps://www.shadertoy.com/view/lsGyDt","likes":0,"published":null,"tags":["4k"," volumetric"," fractals"," raymarchin"," 4kintro"," conelight"]},"renderpass":[{"Code":"// ***********************************************************\r\n// Alcatraz / The explorer 4k Intro\r\n// by Jochen \"Virgill\" Feldk\u00F6tter\r\n//\r\n// 4kb executable: http://www.pouet.net/prod.php?which=75741\r\n//\r\n// ***********************************************************\r\n\r\n\r\n// use mouse for light direction\r\n//#define mouse    \r\n\r\n\r\nint scene = 0;\r\n// 0 = empty\t\t\t\tcolor:\t\t\tparticles: off \r\n// 1 = falling objects\t\tcolor:red\t\tparticles: off \r\n// 2 = wobble floor\t\t\tcolor:red\t\tparticles: on\r\n// 3 = room with stone\t\tcolor:blue\t\tparticles: on\r\n// 4 = kleinian fractal\t\tcolor:red\t\tparticles: on\t\r\n// 5 = wtf scene\t\t \tcolor:blue\t\tparticles: off\r\n\r\nint scene_idx,lightscene_idx;\t// init   // empty                   // falling objects        // wobble floor           // room with stone        // kleinian fractal       // wtf scene \r\nfloat lightscenesx[37] = float[37] (2.3,  2.3,0.0,0.0,6.9,4.6,2.3,   0.0,3.0,0.0,4.0,7.5,3.4,  8.0,8.5,5.0,5.0,5.0,5.0,  0.0,8.5,5.0,5.0,8.0,8.5,  8.5,8.5,4.2,5.0,4.0,4.3,  6.9,8.0,2.0,2.5,3.6,4.6);\r\nfloat lightscenesy[37] = float[37] (0.0,  0.0,2.3,0.0,0.0,2.3,0.0,   2.0,1.0,1.0,3.0,0.0,0.5,  0.0,0.0,3.0,3.0,4.0,3.0,  0.8,1.0,5.0,3.5,0.0,1.0,  8.0,7.5,1.5,3.5,1.5,2.5,  0.0,0.0,0.0,0.0,0.0,0.0);\r\nfloat lightduration = 4.; \r\nfloat sceneduration = 24.; \r\nvec2  lightscene,lightscene_old,lightscene_interpolated;\r\n\r\n\r\n\r\n\r\nvec3 lightpos;\r\nvec3 lightdir = vec3(0,0,1);\r\nfloat scatter,test;\r\n\r\n\r\n\r\n// noise\r\nfloat rnd(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\r\n}\r\n\r\n// box sdf\r\nfloat sdBox(vec3 p,vec3 b)\r\n{\r\n  vec3 d = abs(p)-b;\r\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\r\n}\r\n\r\n// 3D noise function (shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip = floor(p);\r\n    p -= ip; \r\n    vec3 s = vec3(7,157,113);\r\n    vec4 h = vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p = p*p*(3.-2.*p); \r\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\r\n    h.xy = mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\n// cone sdf\r\nfloat sdCone( vec3 p, vec2 c )\r\n{\r\n    return dot(c,vec2(length(p.xy),p.z));\r\n}\r\n\r\n\r\n// rotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n\r\n// wtf fractal (shane)\r\nconst float md = .6;\r\nconst float fl = 1.;\r\nfloat mapy(vec3 p) \r\n{\r\n\tp.x = mod(p.x+1.,2.) - 1.0;\r\n\tvec4 q = vec4(p,1.);\r\n\tvec4 o = q;\r\n\t\r\nfor(int i = 0; i < 10; i++) {\r\n\t\tpR(q.yz,1.55);\r\n\t\tq.xyz = clamp(q.xyz, -fl, fl)*2. - q.xyz;\r\n\t\tfloat r = dot(q.xyz, q.xyz);\r\n\t\tq *= clamp(max(md/r, .6), 0.0, 1.);\r\n\t\tq = (3./md)*q-o;\r\n\r\n\t}\r\n\r\n\treturn (length(q.xyz))/q.w-0.005;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfloat map(vec3 p, int vol) \r\n{\r\n    float d = 1.;\r\n\tvec3 r = p;\r\n \r\n// sphere ship\r\n    float ship = length(r-lightpos)-0.1; \r\n\r\n// cone light\r\n\tvec3 schein=(r-lightpos);\r\n#ifdef mouse\r\n    pR(schein.zx,iMouse.x*-0.03);\r\n    pR(schein.yz,iMouse.y*0.03);\r\n#else\r\n    pR(schein.zx,-lightscene_interpolated.y);\r\n    pR(schein.yz,lightscene_interpolated.x); \r\n#endif    \r\n\tfloat s= sdCone(schein,normalize(vec2(1,1)))/length(schein*schein)+0.2*noise(10.*p+2.*sin(.2*iTime))+0.1*noise(p*23.+sin(0.3*iTime))+0.2*rnd(p.xy);\r\n\tscatter += max(-s,0.)*0.07;\r\n     \r\n\r\n// scene: falling objects\r\n\tif (scene==1)\r\n\t{\r\n        vec3 c= vec3(1.5);\r\n        p.y+=.4*iTime;\r\n        vec3 q = mod(p,c)-.5*c;\r\n\r\n        d=max(length(q)-0.1,p.z-3.);\r\n        d-=.2*noise(6.*p)+0.005*noise(80.*p);\r\n        d=min(d,p.z+4.);\r\n    } \r\n    \r\n// scene: wobble floor\r\n    if (scene==2)\r\n    {\r\n    \td=p.y-0.01*noise(50.*p)+0.4*noise(2.*p+0.2*iTime)+0.09*noise(7.*p);\r\n    }\r\n   \r\n// scene: room with stone\r\n\tif (scene==3)\r\n    {\r\n\t\td = p.y-log(1.*pow(length(p.xz),1.)+0.2);\r\n\t\td = min(d,length(p)-0.4-0.04*noise(p*70.)-0.5*noise(p*4.+iTime)-0.02*noise(p*114.+iTime));\r\n\t\td +=0.05*noise(p*10.)-0.009*noise(p*-40.)+noise(p*2.);;\r\n\t}    \r\n    \r\n// scene: kleinian fractal\r\n    if (scene==4)\r\n    {\r\n\t\tvec4 q = vec4(p,1.);\r\n\t\tq*=.5;\r\n        q.x +=.5;\r\n\t\tq.z+=1.;\r\n\t\tfor(int i=0;i<8;i++) \r\n    \t{\r\n\t\t\tq.xyz=-1.+2.*fract(.5+.5*q.xyz);\r\n\t\t\tq=1.3*q/max(dot(q.xyz,q.xyz),.1);\r\n\t\t}\r\n\t\td=max(0.9*abs(q.y)/q.w,length(p)-3.5)-0.002*noise(50.*p); // with bounding circle\r\n \t\ttest =1.-1./(q.w);//\thighlight fractal area\r\n    }\r\n    \r\n     \r\n// scene: wtf\r\n\tif (scene==5)\r\n\t{\r\n        p.z+=3.5;\r\n        p.y-=0.1*(iTime-120.);\r\n        p.z-=0.1*(iTime-120.);\r\n            d = .5*mapy(p);\r\n    }   \r\n\r\n    return min(ship,d);\r\n}\r\n\r\n\r\n\r\n//***************************************************************************************************\r\n// normal calculation\r\n//***************************************************************************************************\r\n\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps = 0.002, d = map(pos,0);\r\n    if (scene==4) eps = 0.2;\r\n    if (scene==5) eps = 0.02;\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0),0)-d,map(pos+vec3(0,eps,0),0)-d,map(pos+vec3(0,0,eps),0)-d));\r\n}\r\n\r\n\r\n\r\n// ray marching loop (added noise to make it noisy)\r\nfloat castRay(in vec3 ro, in vec3 rd, in float maxt, in vec2 co) {\r\n    float precis = 0.001;\r\n    float h = precis * 2.0;\r\n    float t = -3.5+rnd(co+0.01*iTime)*7.;\r\n    for(int i = 0; i < 200; i++) \r\n    {\r\n    \tif(abs(h) < precis || t > maxt) continue;\r\n        h = map(ro+rd*t,1);\r\n        t += 0.25*h;\r\n    }\r\n    return t;\r\n    \r\n\r\n}\r\n\r\n\r\n\r\n//***************************************************************************************************\r\n// Main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n\r\n// scene handling   \r\n   \tlightscene_idx \t= int(floor((iTime+.8)/lightduration));\r\n    scene \t\t\t= int(floor(iTime/sceneduration));\r\n   \tlightscene \t\t= vec2(lightscenesx[lightscene_idx+1],lightscenesy[lightscene_idx+1]);     \r\n   \tlightscene_old\t= vec2(lightscenesx[lightscene_idx],lightscenesy[lightscene_idx]);     \r\n\tlightscene_interpolated = mix(lightscene,lightscene_old, exp(-64.*pow(fract((iTime+.8)/lightduration),4.)))*0.7;\r\n\r\n\t// camera setup (iq)   \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 p = uv * 2.0 - 1.0;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    float theta = iTime * 3.141592 * 0.20;\r\n    float x = 5.0 * cos(theta*0.5);\r\n    float z = 5.0 * sin(theta*0.5);\r\n    \r\n    vec3 ro = vec3(0.5*x, 4.0, 5.3);\r\n    if (scene==5||scene==0) ro = vec3(0.0, 8.0, -0.0001);  \r\n    \r\n\r\n    \r\n    \r\n    vec3 ta = vec3(0.0, 0.25, 0.0);\r\n    vec3 cw = normalize(ta - ro);\r\n    vec3 cp = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = normalize(cross(cw, cp));\r\n    vec3 cv = normalize(cross(cu, cw));\r\n    vec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\r\n\r\n    float ypos=0.8;\r\n    if (scene==1||scene==3||scene==5) ypos=0.;\r\n    \r\n    lightpos = vec3(ypos,0.7 + 0.2 * sin(theta*2.0),1.-0.2*sin(0.2*iTime)); \r\n    if (scene==5||scene==0) lightpos = vec3(0,2,0); \r\n    \r\n    \r\n#ifdef mouse\r\n    pR(lightdir.yz,iMouse.y*-0.03);\r\n    pR(lightdir.zx,iMouse.x*0.03);\r\n#else\r\n    pR(lightdir.yz,-lightscene_interpolated.x);\r\n    pR(lightdir.zx,lightscene_interpolated.y);\r\n#endif    \r\n    \r\n// feedbak noise (with buffer a)\r\n   \tuv.x-=0.005*noise(uv.yxx*32.-iTime)-0.0025;\r\n   \tuv.y+=0.005*noise(uv.yxx*32.+iTime)-0.0025; \r\n    vec3 bufa= texture(iChannel0,uv).xyz;\r\n    \r\n\r\n // render\r\n    vec3 col = vec3(0);\r\n   \tfloat t= castRay(ro, rd, 15.0,uv);    \r\n\tfloat depth = clamp(t/5.-1.3,0.,1.);\r\n\tif (t>15.) t=-1000000.;\r\n    vec3 pos = ro + rd * t;\r\n    vec3 nor = calcNormal(pos);\r\n    \r\n    \r\n// colors    \r\n    vec3 basecol = vec3(2./1., 1./4., 1./16.);\r\n    if (scene==3||scene==5) basecol = vec3(1./16., 1./4., 2./1.);\r\n    \r\n    \r\n// treat light as conelight\r\n    float ncol=0.;\r\n    float cone=1.;\r\n    vec3 L = normalize(lightpos - pos);\t\t\t\t// vector to light position (from surcface)\r\n    float NdotL = dot(nor,L);\r\n    float conedot = dot(lightdir, normalize(L));\r\n    float conecos = 0.7071;\r\n    float cold = NdotL; \t\t\t\t\t\t\t\t\t// diffuse\r\n    float cols = pow(clamp(dot(nor,normalize(L+normalize(ro - pos))), 0.0, 1.0), 60.0);\t// specular  \r\n\r\n    if (NdotL > 0.0 && conedot > conecos)  \t\t\t// 45 degrees, corresponding to cone param (1,1)\r\n    {        \r\n         cone =  pow((conedot-conecos)/(1.-conecos),4.);// pow for cone light distribution\r\n         ncol = (cold + cols) * cone;\t\t\t\t\t// combine  \r\n\t\t col+=clamp((test),0.,1.)*scatter*cone*vec3(0.2,0.05,0.);\r\n    }    \r\n  \r\n\r\n\r\n    \r\n\r\n// particles   \r\n    float d;\r\n    for (int i; i<36; i++)\r\n    {\r\n    \tfloat fi =float(i);\r\n    \tvec2 pos = vec2(.5+.2*sin(fi+.5*iTime+ cos(.01*iTime*fi))+ .2*sin(-fi),  \r\n                        .5+.2*cos(fi+.2*iTime+ sin(.02*iTime*fi)))+.2*cos( fi);\r\n    \td += clamp(1.-(length(350.*(.8+.5*sin(fi*iTime))*(pos - uv))),0.,1.);\r\n   \t}\r\n    if (scene==2||scene==3||scene==4) col+=d*ncol*(basecol+vec3(0,.5,0))*2.;\r\n\r\n    \r\n    \r\n// color for light (+ feedback noise)\r\n\tcol+=0.3*scatter*vec3(1.,0.8,.6)+0.6*bufa;\r\n// color for material\r\n    col+= 0.6*basecol*exp(6.*(-1.+ncol)); \r\n\t\r\n\r\n    \r\n  float fade =min (3.*abs(sin((3.1415*iTime/sceneduration))),1.); \r\n if (iTime>140.) fade=0.;\r\n\tfragColor = vec4(col*fade,depth);\r\n}","inputs":[],"outputs":[],"code":"// ***********************************************************\r\n// Alcatraz / The explorer 4k Intro\r\n// by Jochen \"Virgill\" Feldk\u00F6tter\r\n//\r\n// 4kb executable: http://www.pouet.net/prod.php?which=75741\r\n//\r\n// ***********************************************************\r\n\r\n\r\n// use mouse for light direction\r\n//#define mouse    \r\n\r\n\r\nint scene = 0;\r\n// 0 = empty\t\t\t\tcolor:\t\t\tparticles: off \r\n// 1 = falling objects\t\tcolor:red\t\tparticles: off \r\n// 2 = wobble floor\t\t\tcolor:red\t\tparticles: on\r\n// 3 = room with stone\t\tcolor:blue\t\tparticles: on\r\n// 4 = kleinian fractal\t\tcolor:red\t\tparticles: on\t\r\n// 5 = wtf scene\t\t \tcolor:blue\t\tparticles: off\r\n\r\nint scene_idx,lightscene_idx;\t// init   // empty                   // falling objects        // wobble floor           // room with stone        // kleinian fractal       // wtf scene \r\nfloat lightscenesx[37] = float[37] (2.3,  2.3,0.0,0.0,6.9,4.6,2.3,   0.0,3.0,0.0,4.0,7.5,3.4,  8.0,8.5,5.0,5.0,5.0,5.0,  0.0,8.5,5.0,5.0,8.0,8.5,  8.5,8.5,4.2,5.0,4.0,4.3,  6.9,8.0,2.0,2.5,3.6,4.6);\r\nfloat lightscenesy[37] = float[37] (0.0,  0.0,2.3,0.0,0.0,2.3,0.0,   2.0,1.0,1.0,3.0,0.0,0.5,  0.0,0.0,3.0,3.0,4.0,3.0,  0.8,1.0,5.0,3.5,0.0,1.0,  8.0,7.5,1.5,3.5,1.5,2.5,  0.0,0.0,0.0,0.0,0.0,0.0);\r\nfloat lightduration = 4.; \r\nfloat sceneduration = 24.; \r\nvec2  lightscene,lightscene_old,lightscene_interpolated;\r\n\r\n\r\n\r\n\r\nvec3 lightpos;\r\nvec3 lightdir = vec3(0,0,1);\r\nfloat scatter,test;\r\n\r\n\r\n\r\n// noise\r\nfloat rnd(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\r\n}\r\n\r\n// box sdf\r\nfloat sdBox(vec3 p,vec3 b)\r\n{\r\n  vec3 d = abs(p)-b;\r\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\r\n}\r\n\r\n// 3D noise function (shane)\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip = floor(p);\r\n    p -= ip; \r\n    vec3 s = vec3(7,157,113);\r\n    vec4 h = vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\r\n    p = p*p*(3.-2.*p); \r\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\r\n    h.xy = mix(h.xz,h.yw,p.y);\r\n    return mix(h.x,h.y,p.z); \r\n}\r\n\r\n// cone sdf\r\nfloat sdCone( vec3 p, vec2 c )\r\n{\r\n    return dot(c,vec2(length(p.xy),p.z));\r\n}\r\n\r\n\r\n// rotation\r\nvoid pR(inout vec2 p,float a) \r\n{\r\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\r\n}\r\n\r\n\r\n// wtf fractal (shane)\r\nconst float md = .6;\r\nconst float fl = 1.;\r\nfloat mapy(vec3 p) \r\n{\r\n\tp.x = mod(p.x+1.,2.) - 1.0;\r\n\tvec4 q = vec4(p,1.);\r\n\tvec4 o = q;\r\n\t\r\nfor(int i = 0; i < 10; i++) {\r\n\t\tpR(q.yz,1.55);\r\n\t\tq.xyz = clamp(q.xyz, -fl, fl)*2. - q.xyz;\r\n\t\tfloat r = dot(q.xyz, q.xyz);\r\n\t\tq *= clamp(max(md/r, .6), 0.0, 1.);\r\n\t\tq = (3./md)*q-o;\r\n\r\n\t}\r\n\r\n\treturn (length(q.xyz))/q.w-0.005;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfloat map(vec3 p, int vol) \r\n{\r\n    float d = 1.;\r\n\tvec3 r = p;\r\n \r\n// sphere ship\r\n    float ship = length(r-lightpos)-0.1; \r\n\r\n// cone light\r\n\tvec3 schein=(r-lightpos);\r\n#ifdef mouse\r\n    pR(schein.zx,iMouse.x*-0.03);\r\n    pR(schein.yz,iMouse.y*0.03);\r\n#else\r\n    pR(schein.zx,-lightscene_interpolated.y);\r\n    pR(schein.yz,lightscene_interpolated.x); \r\n#endif    \r\n\tfloat s= sdCone(schein,normalize(vec2(1,1)))/length(schein*schein)+0.2*noise(10.*p+2.*sin(.2*iTime))+0.1*noise(p*23.+sin(0.3*iTime))+0.2*rnd(p.xy);\r\n\tscatter += max(-s,0.)*0.07;\r\n     \r\n\r\n// scene: falling objects\r\n\tif (scene==1)\r\n\t{\r\n        vec3 c= vec3(1.5);\r\n        p.y+=.4*iTime;\r\n        vec3 q = mod(p,c)-.5*c;\r\n\r\n        d=max(length(q)-0.1,p.z-3.);\r\n        d-=.2*noise(6.*p)+0.005*noise(80.*p);\r\n        d=min(d,p.z+4.);\r\n    } \r\n    \r\n// scene: wobble floor\r\n    if (scene==2)\r\n    {\r\n    \td=p.y-0.01*noise(50.*p)+0.4*noise(2.*p+0.2*iTime)+0.09*noise(7.*p);\r\n    }\r\n   \r\n// scene: room with stone\r\n\tif (scene==3)\r\n    {\r\n\t\td = p.y-log(1.*pow(length(p.xz),1.)+0.2);\r\n\t\td = min(d,length(p)-0.4-0.04*noise(p*70.)-0.5*noise(p*4.+iTime)-0.02*noise(p*114.+iTime));\r\n\t\td +=0.05*noise(p*10.)-0.009*noise(p*-40.)+noise(p*2.);;\r\n\t}    \r\n    \r\n// scene: kleinian fractal\r\n    if (scene==4)\r\n    {\r\n\t\tvec4 q = vec4(p,1.);\r\n\t\tq*=.5;\r\n        q.x +=.5;\r\n\t\tq.z+=1.;\r\n\t\tfor(int i=0;i<8;i++) \r\n    \t{\r\n\t\t\tq.xyz=-1.+2.*fract(.5+.5*q.xyz);\r\n\t\t\tq=1.3*q/max(dot(q.xyz,q.xyz),.1);\r\n\t\t}\r\n\t\td=max(0.9*abs(q.y)/q.w,length(p)-3.5)-0.002*noise(50.*p); // with bounding circle\r\n \t\ttest =1.-1./(q.w);//\thighlight fractal area\r\n    }\r\n    \r\n     \r\n// scene: wtf\r\n\tif (scene==5)\r\n\t{\r\n        p.z+=3.5;\r\n        p.y-=0.1*(iTime-120.);\r\n        p.z-=0.1*(iTime-120.);\r\n            d = .5*mapy(p);\r\n    }   \r\n\r\n    return min(ship,d);\r\n}\r\n\r\n\r\n\r\n//***************************************************************************************************\r\n// normal calculation\r\n//***************************************************************************************************\r\n\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps = 0.002, d = map(pos,0);\r\n    if (scene==4) eps = 0.2;\r\n    if (scene==5) eps = 0.02;\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0),0)-d,map(pos+vec3(0,eps,0),0)-d,map(pos+vec3(0,0,eps),0)-d));\r\n}\r\n\r\n\r\n\r\n// ray marching loop (added noise to make it noisy)\r\nfloat castRay(in vec3 ro, in vec3 rd, in float maxt, in vec2 co) {\r\n    float precis = 0.001;\r\n    float h = precis * 2.0;\r\n    float t = -3.5+rnd(co+0.01*iTime)*7.;\r\n    for(int i = 0; i < 200; i++) \r\n    {\r\n    \tif(abs(h) < precis || t > maxt) continue;\r\n        h = map(ro+rd*t,1);\r\n        t += 0.25*h;\r\n    }\r\n    return t;\r\n    \r\n\r\n}\r\n\r\n\r\n\r\n//***************************************************************************************************\r\n// Main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n\r\n// scene handling   \r\n   \tlightscene_idx \t= int(floor((iTime+.8)/lightduration));\r\n    scene \t\t\t= int(floor(iTime/sceneduration));\r\n   \tlightscene \t\t= vec2(lightscenesx[lightscene_idx+1],lightscenesy[lightscene_idx+1]);     \r\n   \tlightscene_old\t= vec2(lightscenesx[lightscene_idx],lightscenesy[lightscene_idx]);     \r\n\tlightscene_interpolated = mix(lightscene,lightscene_old, exp(-64.*pow(fract((iTime+.8)/lightduration),4.)))*0.7;\r\n\r\n\t// camera setup (iq)   \r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 p = uv * 2.0 - 1.0;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    float theta = iTime * 3.141592 * 0.20;\r\n    float x = 5.0 * cos(theta*0.5);\r\n    float z = 5.0 * sin(theta*0.5);\r\n    \r\n    vec3 ro = vec3(0.5*x, 4.0, 5.3);\r\n    if (scene==5||scene==0) ro = vec3(0.0, 8.0, -0.0001);  \r\n    \r\n\r\n    \r\n    \r\n    vec3 ta = vec3(0.0, 0.25, 0.0);\r\n    vec3 cw = normalize(ta - ro);\r\n    vec3 cp = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = normalize(cross(cw, cp));\r\n    vec3 cv = normalize(cross(cu, cw));\r\n    vec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\r\n\r\n    float ypos=0.8;\r\n    if (scene==1||scene==3||scene==5) ypos=0.;\r\n    \r\n    lightpos = vec3(ypos,0.7 + 0.2 * sin(theta*2.0),1.-0.2*sin(0.2*iTime)); \r\n    if (scene==5||scene==0) lightpos = vec3(0,2,0); \r\n    \r\n    \r\n#ifdef mouse\r\n    pR(lightdir.yz,iMouse.y*-0.03);\r\n    pR(lightdir.zx,iMouse.x*0.03);\r\n#else\r\n    pR(lightdir.yz,-lightscene_interpolated.x);\r\n    pR(lightdir.zx,lightscene_interpolated.y);\r\n#endif    \r\n    \r\n// feedbak noise (with buffer a)\r\n   \tuv.x-=0.005*noise(uv.yxx*32.-iTime)-0.0025;\r\n   \tuv.y+=0.005*noise(uv.yxx*32.+iTime)-0.0025; \r\n    vec3 bufa= texture(iChannel0,uv).xyz;\r\n    \r\n\r\n // render\r\n    vec3 col = vec3(0);\r\n   \tfloat t= castRay(ro, rd, 15.0,uv);    \r\n\tfloat depth = clamp(t/5.-1.3,0.,1.);\r\n\tif (t>15.) t=-1000000.;\r\n    vec3 pos = ro + rd * t;\r\n    vec3 nor = calcNormal(pos);\r\n    \r\n    \r\n// colors    \r\n    vec3 basecol = vec3(2./1., 1./4., 1./16.);\r\n    if (scene==3||scene==5) basecol = vec3(1./16., 1./4., 2./1.);\r\n    \r\n    \r\n// treat light as conelight\r\n    float ncol=0.;\r\n    float cone=1.;\r\n    vec3 L = normalize(lightpos - pos);\t\t\t\t// vector to light position (from surcface)\r\n    float NdotL = dot(nor,L);\r\n    float conedot = dot(lightdir, normalize(L));\r\n    float conecos = 0.7071;\r\n    float cold = NdotL; \t\t\t\t\t\t\t\t\t// diffuse\r\n    float cols = pow(clamp(dot(nor,normalize(L+normalize(ro - pos))), 0.0, 1.0), 60.0);\t// specular  \r\n\r\n    if (NdotL > 0.0 && conedot > conecos)  \t\t\t// 45 degrees, corresponding to cone param (1,1)\r\n    {        \r\n         cone =  pow((conedot-conecos)/(1.-conecos),4.);// pow for cone light distribution\r\n         ncol = (cold + cols) * cone;\t\t\t\t\t// combine  \r\n\t\t col+=clamp((test),0.,1.)*scatter*cone*vec3(0.2,0.05,0.);\r\n    }    \r\n  \r\n\r\n\r\n    \r\n\r\n// particles   \r\n    float d;\r\n    for (int i; i<36; i++)\r\n    {\r\n    \tfloat fi =float(i);\r\n    \tvec2 pos = vec2(.5+.2*sin(fi+.5*iTime+ cos(.01*iTime*fi))+ .2*sin(-fi),  \r\n                        .5+.2*cos(fi+.2*iTime+ sin(.02*iTime*fi)))+.2*cos( fi);\r\n    \td += clamp(1.-(length(350.*(.8+.5*sin(fi*iTime))*(pos - uv))),0.,1.);\r\n   \t}\r\n    if (scene==2||scene==3||scene==4) col+=d*ncol*(basecol+vec3(0,.5,0))*2.;\r\n\r\n    \r\n    \r\n// color for light (+ feedback noise)\r\n\tcol+=0.3*scatter*vec3(1.,0.8,.6)+0.6*bufa;\r\n// color for material\r\n    col+= 0.6*basecol*exp(6.*(-1.+ncol)); \r\n\t\r\n\r\n    \r\n  float fade =min (3.*abs(sin((3.1415*iTime/sceneduration))),1.); \r\n if (iTime>140.) fade=0.;\r\n\tfragColor = vec4(col*fade,depth);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"const float PI=3.14159265358979323846;\r\n\r\n#define speed (iTime*0.2975)\r\n#define ground_x (1.0-0.325*sin(PI*speed*0.25))\r\nfloat ground_y=1.0;\r\nfloat ground_z=0.5;\r\n\r\nvec2 rotate(vec2 k,float t)\r\n\t{\r\n\treturn vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\r\n\t}\r\n\r\nfloat draw_scene(vec3 p)\r\n\t{\r\n\tfloat tunnel_m=0.125*cos(PI*p.z*1.0+speed*4.0-PI);\r\n\tfloat tunnel1_p=2.0;\r\n\tfloat tunnel1_w=tunnel1_p*0.225;\r\n\tfloat tunnel1=length(mod(p.xy,tunnel1_p)-tunnel1_p*0.5)-tunnel1_w;\t// tunnel1\r\n\tfloat tunnel2_p=2.0;\r\n\tfloat tunnel2_w=tunnel2_p*0.2125+tunnel2_p*0.0125*cos(PI*p.y*8.0)+tunnel2_p*0.0125*cos(PI*p.z*8.0);\r\n\tfloat tunnel2=length(mod(p.xy,tunnel2_p)-tunnel2_p*0.5)-tunnel2_w;\t// tunnel2\r\n\tfloat hole1_p=1.0;\r\n\tfloat hole1_w=hole1_p*0.5;\r\n\tfloat hole1=length(mod(p.xz,hole1_p).xy-hole1_p*0.5)-hole1_w;\t// hole1\r\n\tfloat hole2_p=0.25;\r\n\tfloat hole2_w=hole2_p*0.375;\r\n\tfloat hole2=length(mod(p.yz,hole2_p).xy-hole2_p*0.5)-hole2_w;\t// hole2\r\n\tfloat hole3_p=0.5;\r\n\tfloat hole3_w=hole3_p*0.25+0.125*sin(PI*p.z*2.0);\r\n\tfloat hole3=length(mod(p.xy,hole3_p).xy-hole3_p*0.5)-hole3_w;\t// hole3\r\n\tfloat tube_m=0.075*sin(PI*p.z*1.0);\r\n\tfloat tube_p=0.5+tube_m;\r\n\tfloat tube_w=tube_p*0.025+0.00125*cos(PI*p.z*128.0);\r\n\tfloat tube=length(mod(p.xy,tube_p)-tube_p*0.5)-tube_w;\t\t\t// tube\r\n\tfloat bubble_p=0.05;\r\n\tfloat bubble_w=bubble_p*0.5+0.025*cos(PI*p.z*2.0);\r\n\tfloat bubble=length(mod(p.yz,bubble_p)-bubble_p*0.5)-bubble_w;\t// bubble\r\n\treturn max(min(min(-tunnel1,mix(tunnel2,-bubble,0.375)),max(min(-hole1,hole2),-hole3)),-tube);\r\n\t}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n\t{\r\n\tvec2 position=(fragCoord.xy/iResolution.xy);\r\n\tvec2 p=-1.0+2.0*position;\r\n\tvec3 dir=normalize(vec3(p*vec2(1.77,1.0),1.0));\t\t// screen ratio (x,y) fov (z)\r\n\t//dir.yz=rotate(dir.yz,PI*0.5*sin(PI*speed*0.125));\t// rotation x\r\n\tdir.zx=rotate(dir.zx,-PI*speed*0.25);\t\t\t\t// rotation y\r\n\tdir.xy=rotate(dir.xy,-speed*0.5);\t\t\t\t\t// rotation z\r\n\tvec3 ray=vec3(ground_x,ground_y,ground_z-speed*2.5);\r\n\tfloat t=0.0;\r\n\tconst int ray_n=96;\r\n\tfor(int i=0;i<ray_n;i++)\r\n\t\t{\r\n\t\tfloat k=draw_scene(ray+dir*t);\r\n\t\tt+=k*0.75;\r\n\t\t}\r\n\tvec3 hit=ray+dir*t;\r\n\tvec2 h=vec2(-0.0025,0.002); // light\r\n\tvec3 n=normalize(vec3(draw_scene(hit+h.xyx),draw_scene(hit+h.yxy),draw_scene(hit+h.yyx)));\r\n\tfloat c=(n.x+n.y+n.z)*0.35;\r\n\tvec3 color=vec3(c,c,c)+t*0.0625;\r\n\tfragColor=vec4(vec3(c-t*0.0375+p.y*0.05,c-t*0.025-p.y*0.0625,c+t*0.025-p.y*0.025)+color*color,1.0);\r\n\t}","inputs":[],"outputs":[],"code":"const float PI=3.14159265358979323846;\r\n\r\n#define speed (iTime*0.2975)\r\n#define ground_x (1.0-0.325*sin(PI*speed*0.25))\r\nfloat ground_y=1.0;\r\nfloat ground_z=0.5;\r\n\r\nvec2 rotate(vec2 k,float t)\r\n\t{\r\n\treturn vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\r\n\t}\r\n\r\nfloat draw_scene(vec3 p)\r\n\t{\r\n\tfloat tunnel_m=0.125*cos(PI*p.z*1.0+speed*4.0-PI);\r\n\tfloat tunnel1_p=2.0;\r\n\tfloat tunnel1_w=tunnel1_p*0.225;\r\n\tfloat tunnel1=length(mod(p.xy,tunnel1_p)-tunnel1_p*0.5)-tunnel1_w;\t// tunnel1\r\n\tfloat tunnel2_p=2.0;\r\n\tfloat tunnel2_w=tunnel2_p*0.2125+tunnel2_p*0.0125*cos(PI*p.y*8.0)+tunnel2_p*0.0125*cos(PI*p.z*8.0);\r\n\tfloat tunnel2=length(mod(p.xy,tunnel2_p)-tunnel2_p*0.5)-tunnel2_w;\t// tunnel2\r\n\tfloat hole1_p=1.0;\r\n\tfloat hole1_w=hole1_p*0.5;\r\n\tfloat hole1=length(mod(p.xz,hole1_p).xy-hole1_p*0.5)-hole1_w;\t// hole1\r\n\tfloat hole2_p=0.25;\r\n\tfloat hole2_w=hole2_p*0.375;\r\n\tfloat hole2=length(mod(p.yz,hole2_p).xy-hole2_p*0.5)-hole2_w;\t// hole2\r\n\tfloat hole3_p=0.5;\r\n\tfloat hole3_w=hole3_p*0.25+0.125*sin(PI*p.z*2.0);\r\n\tfloat hole3=length(mod(p.xy,hole3_p).xy-hole3_p*0.5)-hole3_w;\t// hole3\r\n\tfloat tube_m=0.075*sin(PI*p.z*1.0);\r\n\tfloat tube_p=0.5+tube_m;\r\n\tfloat tube_w=tube_p*0.025+0.00125*cos(PI*p.z*128.0);\r\n\tfloat tube=length(mod(p.xy,tube_p)-tube_p*0.5)-tube_w;\t\t\t// tube\r\n\tfloat bubble_p=0.05;\r\n\tfloat bubble_w=bubble_p*0.5+0.025*cos(PI*p.z*2.0);\r\n\tfloat bubble=length(mod(p.yz,bubble_p)-bubble_p*0.5)-bubble_w;\t// bubble\r\n\treturn max(min(min(-tunnel1,mix(tunnel2,-bubble,0.375)),max(min(-hole1,hole2),-hole3)),-tube);\r\n\t}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n\t{\r\n\tvec2 position=(fragCoord.xy/iResolution.xy);\r\n\tvec2 p=-1.0+2.0*position;\r\n\tvec3 dir=normalize(vec3(p*vec2(1.77,1.0),1.0));\t\t// screen ratio (x,y) fov (z)\r\n\t//dir.yz=rotate(dir.yz,PI*0.5*sin(PI*speed*0.125));\t// rotation x\r\n\tdir.zx=rotate(dir.zx,-PI*speed*0.25);\t\t\t\t// rotation y\r\n\tdir.xy=rotate(dir.xy,-speed*0.5);\t\t\t\t\t// rotation z\r\n\tvec3 ray=vec3(ground_x,ground_y,ground_z-speed*2.5);\r\n\tfloat t=0.0;\r\n\tconst int ray_n=96;\r\n\tfor(int i=0;i<ray_n;i++)\r\n\t\t{\r\n\t\tfloat k=draw_scene(ray+dir*t);\r\n\t\tt+=k*0.75;\r\n\t\t}\r\n\tvec3 hit=ray+dir*t;\r\n\tvec2 h=vec2(-0.0025,0.002); // light\r\n\tvec3 n=normalize(vec3(draw_scene(hit+h.xyx),draw_scene(hit+h.yxy),draw_scene(hit+h.yyx)));\r\n\tfloat c=(n.x+n.y+n.z)*0.35;\r\n\tvec3 color=vec3(c,c,c)+t*0.0625;\r\n\tfragColor=vec4(vec3(c-t*0.0375+p.y*0.05,c-t*0.025-p.y*0.0625,c+t*0.025-p.y*0.025)+color*color,1.0);\r\n\t}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"The road to Hell","id":"509b3068ab854357bb58a6b1664a1ea0","date":null,"viewed":0,"name":"The road to Hell","description":"A pixel shader I did for Razor 1911's \"The Scene Is Dead\" 64k intro.\nIt's a pretty simple mix of boolean operations on various tubes and spheres but I'm pretty statisfied with the final result \nhttps://www.shadertoy.com/view/Mds3Rn","likes":0,"published":null,"tags":["raymarching"," tunnel"]},"ver":null,"info":{"Name":"The road to Hell","id":"509b3068ab854357bb58a6b1664a1ea0","date":null,"viewed":0,"name":"The road to Hell","description":"A pixel shader I did for Razor 1911's \"The Scene Is Dead\" 64k intro.\nIt's a pretty simple mix of boolean operations on various tubes and spheres but I'm pretty statisfied with the final result \nhttps://www.shadertoy.com/view/Mds3Rn","likes":0,"published":null,"tags":["raymarching"," tunnel"]},"renderpass":[{"Code":"const float PI=3.14159265358979323846;\r\n\r\n#define speed (iTime*0.2975)\r\n#define ground_x (1.0-0.325*sin(PI*speed*0.25))\r\nfloat ground_y=1.0;\r\nfloat ground_z=0.5;\r\n\r\nvec2 rotate(vec2 k,float t)\r\n\t{\r\n\treturn vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\r\n\t}\r\n\r\nfloat draw_scene(vec3 p)\r\n\t{\r\n\tfloat tunnel_m=0.125*cos(PI*p.z*1.0+speed*4.0-PI);\r\n\tfloat tunnel1_p=2.0;\r\n\tfloat tunnel1_w=tunnel1_p*0.225;\r\n\tfloat tunnel1=length(mod(p.xy,tunnel1_p)-tunnel1_p*0.5)-tunnel1_w;\t// tunnel1\r\n\tfloat tunnel2_p=2.0;\r\n\tfloat tunnel2_w=tunnel2_p*0.2125+tunnel2_p*0.0125*cos(PI*p.y*8.0)+tunnel2_p*0.0125*cos(PI*p.z*8.0);\r\n\tfloat tunnel2=length(mod(p.xy,tunnel2_p)-tunnel2_p*0.5)-tunnel2_w;\t// tunnel2\r\n\tfloat hole1_p=1.0;\r\n\tfloat hole1_w=hole1_p*0.5;\r\n\tfloat hole1=length(mod(p.xz,hole1_p).xy-hole1_p*0.5)-hole1_w;\t// hole1\r\n\tfloat hole2_p=0.25;\r\n\tfloat hole2_w=hole2_p*0.375;\r\n\tfloat hole2=length(mod(p.yz,hole2_p).xy-hole2_p*0.5)-hole2_w;\t// hole2\r\n\tfloat hole3_p=0.5;\r\n\tfloat hole3_w=hole3_p*0.25+0.125*sin(PI*p.z*2.0);\r\n\tfloat hole3=length(mod(p.xy,hole3_p).xy-hole3_p*0.5)-hole3_w;\t// hole3\r\n\tfloat tube_m=0.075*sin(PI*p.z*1.0);\r\n\tfloat tube_p=0.5+tube_m;\r\n\tfloat tube_w=tube_p*0.025+0.00125*cos(PI*p.z*128.0);\r\n\tfloat tube=length(mod(p.xy,tube_p)-tube_p*0.5)-tube_w;\t\t\t// tube\r\n\tfloat bubble_p=0.05;\r\n\tfloat bubble_w=bubble_p*0.5+0.025*cos(PI*p.z*2.0);\r\n\tfloat bubble=length(mod(p.yz,bubble_p)-bubble_p*0.5)-bubble_w;\t// bubble\r\n\treturn max(min(min(-tunnel1,mix(tunnel2,-bubble,0.375)),max(min(-hole1,hole2),-hole3)),-tube);\r\n\t}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n\t{\r\n\tvec2 position=(fragCoord.xy/iResolution.xy);\r\n\tvec2 p=-1.0+2.0*position;\r\n\tvec3 dir=normalize(vec3(p*vec2(1.77,1.0),1.0));\t\t// screen ratio (x,y) fov (z)\r\n\t//dir.yz=rotate(dir.yz,PI*0.5*sin(PI*speed*0.125));\t// rotation x\r\n\tdir.zx=rotate(dir.zx,-PI*speed*0.25);\t\t\t\t// rotation y\r\n\tdir.xy=rotate(dir.xy,-speed*0.5);\t\t\t\t\t// rotation z\r\n\tvec3 ray=vec3(ground_x,ground_y,ground_z-speed*2.5);\r\n\tfloat t=0.0;\r\n\tconst int ray_n=96;\r\n\tfor(int i=0;i<ray_n;i++)\r\n\t\t{\r\n\t\tfloat k=draw_scene(ray+dir*t);\r\n\t\tt+=k*0.75;\r\n\t\t}\r\n\tvec3 hit=ray+dir*t;\r\n\tvec2 h=vec2(-0.0025,0.002); // light\r\n\tvec3 n=normalize(vec3(draw_scene(hit+h.xyx),draw_scene(hit+h.yxy),draw_scene(hit+h.yyx)));\r\n\tfloat c=(n.x+n.y+n.z)*0.35;\r\n\tvec3 color=vec3(c,c,c)+t*0.0625;\r\n\tfragColor=vec4(vec3(c-t*0.0375+p.y*0.05,c-t*0.025-p.y*0.0625,c+t*0.025-p.y*0.025)+color*color,1.0);\r\n\t}","inputs":[],"outputs":[],"code":"const float PI=3.14159265358979323846;\r\n\r\n#define speed (iTime*0.2975)\r\n#define ground_x (1.0-0.325*sin(PI*speed*0.25))\r\nfloat ground_y=1.0;\r\nfloat ground_z=0.5;\r\n\r\nvec2 rotate(vec2 k,float t)\r\n\t{\r\n\treturn vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\r\n\t}\r\n\r\nfloat draw_scene(vec3 p)\r\n\t{\r\n\tfloat tunnel_m=0.125*cos(PI*p.z*1.0+speed*4.0-PI);\r\n\tfloat tunnel1_p=2.0;\r\n\tfloat tunnel1_w=tunnel1_p*0.225;\r\n\tfloat tunnel1=length(mod(p.xy,tunnel1_p)-tunnel1_p*0.5)-tunnel1_w;\t// tunnel1\r\n\tfloat tunnel2_p=2.0;\r\n\tfloat tunnel2_w=tunnel2_p*0.2125+tunnel2_p*0.0125*cos(PI*p.y*8.0)+tunnel2_p*0.0125*cos(PI*p.z*8.0);\r\n\tfloat tunnel2=length(mod(p.xy,tunnel2_p)-tunnel2_p*0.5)-tunnel2_w;\t// tunnel2\r\n\tfloat hole1_p=1.0;\r\n\tfloat hole1_w=hole1_p*0.5;\r\n\tfloat hole1=length(mod(p.xz,hole1_p).xy-hole1_p*0.5)-hole1_w;\t// hole1\r\n\tfloat hole2_p=0.25;\r\n\tfloat hole2_w=hole2_p*0.375;\r\n\tfloat hole2=length(mod(p.yz,hole2_p).xy-hole2_p*0.5)-hole2_w;\t// hole2\r\n\tfloat hole3_p=0.5;\r\n\tfloat hole3_w=hole3_p*0.25+0.125*sin(PI*p.z*2.0);\r\n\tfloat hole3=length(mod(p.xy,hole3_p).xy-hole3_p*0.5)-hole3_w;\t// hole3\r\n\tfloat tube_m=0.075*sin(PI*p.z*1.0);\r\n\tfloat tube_p=0.5+tube_m;\r\n\tfloat tube_w=tube_p*0.025+0.00125*cos(PI*p.z*128.0);\r\n\tfloat tube=length(mod(p.xy,tube_p)-tube_p*0.5)-tube_w;\t\t\t// tube\r\n\tfloat bubble_p=0.05;\r\n\tfloat bubble_w=bubble_p*0.5+0.025*cos(PI*p.z*2.0);\r\n\tfloat bubble=length(mod(p.yz,bubble_p)-bubble_p*0.5)-bubble_w;\t// bubble\r\n\treturn max(min(min(-tunnel1,mix(tunnel2,-bubble,0.375)),max(min(-hole1,hole2),-hole3)),-tube);\r\n\t}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n\t{\r\n\tvec2 position=(fragCoord.xy/iResolution.xy);\r\n\tvec2 p=-1.0+2.0*position;\r\n\tvec3 dir=normalize(vec3(p*vec2(1.77,1.0),1.0));\t\t// screen ratio (x,y) fov (z)\r\n\t//dir.yz=rotate(dir.yz,PI*0.5*sin(PI*speed*0.125));\t// rotation x\r\n\tdir.zx=rotate(dir.zx,-PI*speed*0.25);\t\t\t\t// rotation y\r\n\tdir.xy=rotate(dir.xy,-speed*0.5);\t\t\t\t\t// rotation z\r\n\tvec3 ray=vec3(ground_x,ground_y,ground_z-speed*2.5);\r\n\tfloat t=0.0;\r\n\tconst int ray_n=96;\r\n\tfor(int i=0;i<ray_n;i++)\r\n\t\t{\r\n\t\tfloat k=draw_scene(ray+dir*t);\r\n\t\tt+=k*0.75;\r\n\t\t}\r\n\tvec3 hit=ray+dir*t;\r\n\tvec2 h=vec2(-0.0025,0.002); // light\r\n\tvec3 n=normalize(vec3(draw_scene(hit+h.xyx),draw_scene(hit+h.yxy),draw_scene(hit+h.yyx)));\r\n\tfloat c=(n.x+n.y+n.z)*0.35;\r\n\tvec3 color=vec3(c,c,c)+t*0.0625;\r\n\tfragColor=vec4(vec3(c-t*0.0375+p.y*0.05,c-t*0.025-p.y*0.0625,c+t*0.025-p.y*0.025)+color*color,1.0);\r\n\t}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//\r\n// __ __|  |   |  ____|   \\  |         \\      \\  |  __ \\       __ )   ____|  ____|  _ \\    _ \\   ____| \r\n//    |    |   |  __|      \\ |        _ \\      \\ |  |   |      __ \\   __|    |     |   |  |   |  __|   \r\n//    |    ___ |  |      |\\  |       ___ \\   |\\  |  |   |      |   |  |      __|   |   |  __ <   |     \r\n//   _|   _|  _| _____| _| \\_|     _/    _\\ _| \\_| ____/      ____/  _____| _|    \\___/  _| \\_\\ _____| \r\n//\r\n//\r\n//                                                                         4k PC intro - Altair MMXIX\r\n//\r\n//\r\n//    Code & design:    KK\r\n//    Music & design:   Lesnik\r\n//    Add. code:        Virgill\r\n//\r\n//\r\n//\r\n//\r\n\r\n// Scene control:\r\n//\r\n// $0003\tBA\t1..0\t- camera distance 0..3\r\n// $000C\tDC\t3..2\t- scenery \t00:forest\t\t01:city\r\n//\t\t\t\t\t\t\t\t\t10:terrain\t\t11:landscape\r\n//\t \t\t\t\t\t\t\t\t-0:circle\t\t-1:triangle\r\n//\r\n// $0010\t E\t 4\t\t- 0:glowing\t\t1:solid\r\n// $0020\t F\t 5\t\t- large voronoi range / end phase of city destruction\r\n// $0040\t G\t 6\t\t- city destruction\r\n// $0080\t H\t 7\t\t- black sphere (only flag H = black screen)\r\n// $0100\t I\t 8\t\t- camera angle\r\n// $0200\t J\t 9\t\t- voronoi destruction\r\n// $0400\t K\t10\t\t- camera distance + 0.5\r\n// $0800\t L  11\t\t- water (with C=0 D=1)\r\n// $1000\t M  12\t\t- darkness\r\n// $2000\t N\t13\t\t- sharp OUT transition\r\n// $4000\t O\t14\t\t- sharp IN transition\r\n// $8000\t P\t15\t\t- shape particles\r\n//\r\n//\r\n\r\n\r\nconst ivec3 SCENES[] = ivec3[](\r\n#define SCENE(n,d,b)\tivec3((d),(b),(n))\r\n\r\n\t//intro\r\n\tSCENE(2, 16, 0x050A | 0x0000),\r\n\tSCENE(3, 16, 0x040B | 0x0000),\r\n\r\n\t//PART 1 - forest+rocks\r\n\tSCENE(4, 12, 0x0013 | 0x4000),\r\n\tSCENE(5, 11, 0x0051 | 0x2000),\r\n\tSCENE(6, 1, 0x0410 | 0x6000),\r\n\tSCENE(7, 8, 0x0010 | 0x6000),\r\n\tSCENE(8, 12, 0x0110 | 0x4000),\r\n\tSCENE(9, 12, 0x001F | 0x0000),\r\n\tSCENE(10, 12, 0x001C | 0x6000),\r\n\r\n\t//the ball!\r\n\tSCENE(11, 8, 0x0080 | 0x0000), //d\r\n\tSCENE(13, 20, 0x0418 | 0x2000),\r\n\r\n\t//PART 2 - city\r\n\tSCENE(14, 16, 0x0407 | 0x4000),\r\n\tSCENE(15, 16, 0x0014 | 0x0000),\r\n\tSCENE(16, 20, 0x0124 | 0x6000),\r\n\tSCENE(17, 11, 0x0044 | 0x6000),\r\n\r\n\t//the ball!\r\n\tSCENE(18, 13, 0x0080 | 0x0000), //d        \r\n\tSCENE(20, 20, 0x0818 | 0x4000),\r\n\r\n\t//PART 3 - destruction\r\n\tSCENE(80, 16, 0x0041 | 0x2000),\r\n\tSCENE(21, 16, 0x0200 | 0x6000),\r\n\tSCENE(33, 16, 0x0074 | 0x0000),\r\n\tSCENE(22, 16, 0x040c | 0x7000),\r\n\tSCENE(24, 19, 0x063c | 0x3000),\r\n\r\n\tSCENE(26, 7, 0x0080 | 0x0000), //d\r\n\r\n\t\t\t\t\t\t\t\t   //outtro - water\r\n\tSCENE(28, 12, 0x1908 | 0x0000),\r\n\tSCENE(27, 16, 0x0808 | 0x1000),\r\n\tSCENE(97, 10, 0x0C08 | 0xB000),\r\n\r\n\tSCENE(96, 8, 0x0080 | 0x0000), //d\r\n\r\n\t\t\t\t\t\t\t\t   //the ball! \r\n//\tSCENE(30, 12, 0x0018 | 0x4000),\r\n//\tSCENE(31, 16, 0x0098 | 0x0000),\r\n\tSCENE(32, 24, 0x0098 | 0x6000),\r\n\tSCENE(0, 255, 0x0080 | 0x0000) //d\t\r\n#undef SCENE\r\n\t);\r\n\r\n\r\n\r\n// ================================ Helper functions ================================\r\n\r\n\r\nfloat sat(float x)\r\n{\r\n\treturn clamp(x, 0., 1.);\r\n}\r\n\r\n\r\n// ================================ Noises ================================\r\n\r\n// 3D noise - method by iq/shane\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\n\r\n// ================================ Voronoi ================================\r\n\r\nvec2 vcore(vec2 m, vec2 p, vec2 s)\r\n{\r\n\tvec2 c = floor(2.5*p+s);\t\t// 1./.4   r\r\n\tc += fract(43758.5*sin(c+17.*c.yx));\r\n\r\n\tfloat v = length(.4*c-p);\t// r\r\n\treturn v<m.x ? vec2(v, m.x) : v<m.y ? vec2(m.x, v) : m;\r\n}\r\n\r\n\r\n\r\n// ================================ Patterns ================================\r\n\r\n\r\nfloat lattice(vec3 p)\r\n{\r\n\tp=abs(p);\r\n\tp=max(p, p.yzx);\r\n\tp=min(p, p.yzx);\r\n\tp=min(p, p.yzx);\r\n\treturn p.x;\r\n}\r\n\r\n\r\n\r\n// ================================ SDF merge functions ================================\r\n\r\n\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif( x < d.x ) d = vec3(x, y, z);\r\n}\r\n\r\n\r\n\r\n// ================================ Domain operations ================================\r\n\r\n\r\n// rotation\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\ta *= 6.283;\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\n\r\n// 3D repetition\r\nvec3 rep(vec3 p, float r)\r\n{\r\n\treturn (fract(p/r-.5)-.5)*r;\r\n}\r\n\r\n// diffuse reflection hash - method by fizzer\r\nvec3 hashHs(vec3 n, inout float seed)\r\n{\r\n\tvec2 uv = (seed=32.+seed*fract(seed))+vec2(78.233, 10.873);\r\n\tuv = fract(.1031*uv);\r\n\tuv *= 19.19+uv;\r\n\tuv = fract(2.*uv*uv);\r\n\r\n\tfloat u = 2.*uv.x-1.;\r\n\r\n\tvec3 v = vec3(sqrt(1.-u*u), 0., u);\r\n\tpR(v.xy, uv.y);\r\n\treturn normalize(n+v);\r\n}\r\n\r\n\r\n// ================================ Complex SDFs ================================\r\n\r\nfloat vines(vec3 p, float s)\r\n{\r\n\tp.y=abs(p.y);\r\n\tpR(p.xz, .1*p.y); p=abs(p); p.xz -= .06*s;\r\n\tpR(p.xz, -.16*p.y); p=abs(p); p.xz -= .05*s;\r\n\tpR(p.xz, .4*p.y);\r\n\treturn length(abs(p.xz) - .04*(s*.5+.5));\r\n}\r\n\r\n\r\n// ================================================ Intro ================================================\r\n\r\n\r\nconst int QN = 100;\r\nconst int QD = 50;\r\n\r\nconst float QNs = 45./float(QN);\r\nconst float QNq = 1.35/float(QN);\r\nconst float QDs = 30./float(QD);\r\nconst float QDq = .9/float(QD);\r\n\r\n\r\nint seq_code;\r\nivec3 iA;\r\nfloat cb(int n) {\r\n\treturn float((seq_code>>n)&1);\r\n}\r\n\r\nvec3 lpos3;\r\nfloat camz, destr, sprog;\t// scene progress\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvec3 map(vec3 p)\r\n{\r\n\tfloat\r\n\t\ta=.5*iTime*cb(11),\r\n\t\tn0 = noise(73.*p+a),\r\n\t\tn1 = noise(10.*p+a+a),\r\n\t\tn2 = noise(2.*p+a)-.5,\r\n\t\tn3 = noise(.4*p+a)-.5,\r\n\t\th;\r\n\tfloat\r\n\t\twn1 = .2*n0+n1,\r\n\t\twn2 = sat(10.*n2),\r\n\t\twn3 = sat(10.*n3)*sat(.2*p.x*p.x-.1+.3*n2);\r\n\tfloat wallnoise = wn1*(.02+wn2),\r\n        \teclipse=sat(5.*sprog-3.)*cb(7);\r\n\tvec3 d = vec3(1, 0, 0), q, t;\r\n\r\n\tdmin(d, 6.-p.y-.1*n1+.3*n2-.4*n3,\r\n\t\t(2.-.4*cb(12)-1.*eclipse+1.5*sat(1000.*\r\n\t\t(1.3-length((p-7.*lpos3).xz))*cb(4)\t// enl\r\n\t\t))*(.12+.3*n0+.5*n1+.5*n2+.5*n3),\t\t// ebase,\r\n\t\t0.); \t\t// common sky\r\n\r\n\r\n\th = mix(.05*n0+.07*n1+.3*n2+n3,\t\t\t\t\t// terrain\r\n\t\t.002*n0+.04*n1+.2*n2+.4*n3, cb(11));\t// water\r\n\tif( cb(3)==0. )\r\n\t\tdmin(d, .8+p.y-.1*wallnoise, .01+.9*wn2, 0.);\t// forrest floor\r\n\telse if( cb(2)==0. )\r\n\t\tdmin(d, 1.2-.6*cb(11)+p.y-h, mix(.8+h*(1.-eclipse), .01, cb(11)), 0.);\t// terrain\r\n\telse\r\n\t\tdmin(d, .6+p.y-(wn1/3.+n2+.5+3.*sat(4.*n3-1.))*(.02+wn3), .01+.9*wn3, 0.);\t// rocks\r\n\r\n\r\n\r\n\th = sat(mix(.85*sprog, 1., cb(5))*2.*cb(6)-.5+.2*p.y);\r\n\th*=2.*(n0-.2)*h;\r\n\tif( cb(3)==0. )\r\n\t\tif( cb(2)==0. )\r\n\t\t{\r\n\t\t\t// trees\r\n\t\t\tq=rep(abs(p)-1.6, 3.2);\r\n\t\t\tq.y = abs(p.y)-3.;\r\n\t\t\tdmin(d,\r\n\t\t\t\tmax(p.y-3.5+wn2, vines(\r\n\t\t\t\t\tq,\r\n\t\t\t\t\t.1*wn1+.5+10./pow(1.+.95*q.y*q.y, 1.5)\r\n\t\t\t\t) -\r\n\t\t\t\t\tmix(.02+.08*wn1, -.1, (.55+p.y/3.)*sat(-15.-p.z))\r\n\t\t\t\t), .9, .0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// city\r\n\t\t\tq=p;\r\n\t\t\tq.xz=rep(q-3., 6.).xz;\r\n\r\n\t\t\tdmin(d,\r\n\t\t\t\t(max(\r\n\t\t\t\t\tmin(lattice(rep(q, .17))-.01, lattice(rep(q, .3))-.03),\r\n\t\t\t\t\tlength(max(abs(q) - vec3(1, 3, 1), 0.))+sat(wallnoise+q.y/10.-.25)\r\n\t\t\t\t)-h), .7, 0.);\r\n\t\t}\r\n\r\n\r\n\t\tq=p;\r\n\t\tq.y-=1.5*n0*sprog*cb(15);\r\n\t\tif( camz<30. )\r\n\t\t\tif( cb(2)==0. )\r\n\t\t\t\t// circle\r\n\t\t\t\tif( cb(4)==0. )\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tlength(vec2(q.z, length(q.xy)-.5))-.025,\r\n\t\t\t\t\t\t2.5, -.3);\r\n\t\t\t\telse\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tlength(q)-.6,\r\n\t\t\t\t\t\t1.8+eclipse*(p.z+.4*(p.y+p.x)<0. ? -.8 : .5),\r\n\t\t\t\t\t\t.0);\r\n\t\t\telse\r\n\t\t\t\t// glowing triangle/square\r\n\t\t\t\tif( cb(4)==0. )\r\n\t\t\t\t\tfor( float i=0.; i<.99; i+=1./(3.+cb(3)) ) {\r\n\t\t\t\t\t\tt=q;\r\n\t\t\t\t\t\tpR(t.xy, i);\r\n\t\t\t\t\t\tt.y -= .3+.22*cb(3);\r\n\t\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\t\tmax(length(t.yz)-.025, abs(t.x)-.532),\r\n\t\t\t\t\t\t\t2.5, -.3);\r\n\t\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tpR(q.xz, .05);\r\n\t\t\t\t\tq.y -= .5;\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tmax(q.y, dot(abs(q), normalize(vec3(1, .6, 1)))-.4),\r\n\t\t\t\t\t\t1.4, .0);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t// destruction\r\n\t\tvec2 r=p.xz+p.xy, s = vec2(.5, -.5), vd=50.*vcore(vcore(vcore(vcore(vec2(1), r, s.xx), r, s.xy), r, s.yx), r, s.yy);\r\n\t\th = vd.y-vd.x+sat(p.y)+1.-1.5*sat((destr-length(p.xz)));\r\n\t\td.yz = mix(d.yz, vec2(3., -.3), sat(1.-h));\r\n\r\n\t\treturn d;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tfragColor = vec4(0);\r\n    \r\n    // sequencing\r\n\t{\r\n\t\tint spos = 0;\r\n\t\tfloat stim = iTime*1000.*441./10./(9586.*2.);\r\n\t\tint istim = int(stim);\r\n        while( SCENES[spos].x<255 && stim>=float(SCENES[spos].x) )\r\n            stim -= float(SCENES[spos++].x);\r\n        iA.y = seq_code = SCENES[spos].y;\r\n        sprog = sat(stim / float(SCENES[spos].x));\r\n\t}\r\n\r\n\tcamz = mix((15.+10.*cb(0)+20.*cb(1)+5.*cb(10))*(1.-.1*sprog)-10., .6, pow(sprog,6.)*cb(7));\r\n\tdestr = sprog*cb(9)*(3.+5.*cb(5));\r\n\r\n\r\n\r\n\tfragColor = vec4(0);\r\n\tif( uv.y>.11 && uv.y<.89 )\r\n\t{\r\n\t\tfloat t1 = 0., t2 = 0., seed = uv.x*uv.y+uv.y+uv.x+fract(iTime);\r\n\t\tvec3 ro1 = vec3(0, 0, -.1),\r\n\t\t\trd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.y/1.8, 1)),\r\n\t\t\tscol=vec3(0), m1, m2, nor1, pos1, pos2;\r\n\r\n\t\t// camera angle\r\n\t\tvec2 ca=vec2(.1, .07)*cb(8), e = vec2(0, .0001);\r\n\t\tpR(ro1.zy, ca.y); pR(rd1.zy, ca.y);\r\n\t\tpR(ro1.zx, ca.x); pR(rd1.zx, ca.x);\r\n\t\tro1.z-=camz;\r\n\r\n\t\tlpos3 = normalize(mix(vec3(.5, 1, 0), vec3(0, -1, 0), sat(destr)));\r\n\r\n\t\tt1 = .2*fract(seed);\r\n\r\n\t\tfor( int i = 0; i < QN; i++ )\r\n\t\t{\r\n\t\t\tpos1 = ro1+rd1*t1;\r\n\t\t\tm1 = map(pos1);\r\n\t\t\tt1+=QNs*m1.x;\r\n\r\n\t\t\tif( m1.x<.005 )\r\n\t\t\t{\r\n\t\t\t\tif( m1.z<0. )\r\n\t\t\t\t\tscol+= vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*float(QN-i);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tpos2=pos1+mix(lpos3, hashHs(lpos3, seed), .04)*t2;\r\n\t\t\tm2 = map(pos2);\r\n\t\t\tt2+=m2.x;\r\n\r\n\t\t\tscol +=\r\n\t\t\t\tmax(0., m1.z) +\r\n\t\t\t\tvec3(1.+m1.z, 1., 1.-m1.z)*max(0., m1.y-1.) +\r\n\t\t\t\t(.5+5.*m1.x*noise(7.*pos1+vec3(iTime)))*max(0., m2.y-1.)*(1.-cb(12));\r\n\t\t}\r\n\t\tscol *= QNq;\r\n\r\n\t\tnor1 = normalize(m1.x-vec3(map(pos1 - e.yxx).x, map(pos1 - e.xyx).x, map(pos1 - e.xxy).x));\r\n\r\n\t\tt2=1.;\r\n\t\tfor( int i = 0; i < QD; i++ )\r\n\t\t{\r\n\t\t\tpos2 = pos1 + mix(reflect(rd1, nor1), hashHs(nor1, seed), sat(m1.y))*t2;\r\n\t\t\tm2 = map(pos2);\r\n\t\t\tt2+=QDs*m2.x;\r\n\r\n\t\t\tscol += vec3(1.+m2.z, 1., 1.-m2.z)*max(0., m2.y-1.)*QDq;\r\n\r\n\t\t}\r\n\t\tscol=clamp(scol, 0., 1.)\r\n\t\t\t*sat(cb(14)+15.*sprog)\r\n\t\t\t*sat(cb(13)+5.-5.*sprog)\r\n\t\t\t-float(iA.y==128)\r\n\t\t\t;\r\n        fragColor = scol.xyzz;\r\n\t\t//fragColor = mix(scol.xyzz, texture(iChannel0, uv), pow(.0001, iTimeDelta));\r\n\t}\r\n}\r\n","inputs":[],"outputs":[],"code":"//\r\n// __ __|  |   |  ____|   \\  |         \\      \\  |  __ \\       __ )   ____|  ____|  _ \\    _ \\   ____| \r\n//    |    |   |  __|      \\ |        _ \\      \\ |  |   |      __ \\   __|    |     |   |  |   |  __|   \r\n//    |    ___ |  |      |\\  |       ___ \\   |\\  |  |   |      |   |  |      __|   |   |  __ <   |     \r\n//   _|   _|  _| _____| _| \\_|     _/    _\\ _| \\_| ____/      ____/  _____| _|    \\___/  _| \\_\\ _____| \r\n//\r\n//\r\n//                                                                         4k PC intro - Altair MMXIX\r\n//\r\n//\r\n//    Code & design:    KK\r\n//    Music & design:   Lesnik\r\n//    Add. code:        Virgill\r\n//\r\n//\r\n//\r\n//\r\n\r\n// Scene control:\r\n//\r\n// $0003\tBA\t1..0\t- camera distance 0..3\r\n// $000C\tDC\t3..2\t- scenery \t00:forest\t\t01:city\r\n//\t\t\t\t\t\t\t\t\t10:terrain\t\t11:landscape\r\n//\t \t\t\t\t\t\t\t\t-0:circle\t\t-1:triangle\r\n//\r\n// $0010\t E\t 4\t\t- 0:glowing\t\t1:solid\r\n// $0020\t F\t 5\t\t- large voronoi range / end phase of city destruction\r\n// $0040\t G\t 6\t\t- city destruction\r\n// $0080\t H\t 7\t\t- black sphere (only flag H = black screen)\r\n// $0100\t I\t 8\t\t- camera angle\r\n// $0200\t J\t 9\t\t- voronoi destruction\r\n// $0400\t K\t10\t\t- camera distance + 0.5\r\n// $0800\t L  11\t\t- water (with C=0 D=1)\r\n// $1000\t M  12\t\t- darkness\r\n// $2000\t N\t13\t\t- sharp OUT transition\r\n// $4000\t O\t14\t\t- sharp IN transition\r\n// $8000\t P\t15\t\t- shape particles\r\n//\r\n//\r\n\r\n\r\nconst ivec3 SCENES[] = ivec3[](\r\n#define SCENE(n,d,b)\tivec3((d),(b),(n))\r\n\r\n\t//intro\r\n\tSCENE(2, 16, 0x050A | 0x0000),\r\n\tSCENE(3, 16, 0x040B | 0x0000),\r\n\r\n\t//PART 1 - forest+rocks\r\n\tSCENE(4, 12, 0x0013 | 0x4000),\r\n\tSCENE(5, 11, 0x0051 | 0x2000),\r\n\tSCENE(6, 1, 0x0410 | 0x6000),\r\n\tSCENE(7, 8, 0x0010 | 0x6000),\r\n\tSCENE(8, 12, 0x0110 | 0x4000),\r\n\tSCENE(9, 12, 0x001F | 0x0000),\r\n\tSCENE(10, 12, 0x001C | 0x6000),\r\n\r\n\t//the ball!\r\n\tSCENE(11, 8, 0x0080 | 0x0000), //d\r\n\tSCENE(13, 20, 0x0418 | 0x2000),\r\n\r\n\t//PART 2 - city\r\n\tSCENE(14, 16, 0x0407 | 0x4000),\r\n\tSCENE(15, 16, 0x0014 | 0x0000),\r\n\tSCENE(16, 20, 0x0124 | 0x6000),\r\n\tSCENE(17, 11, 0x0044 | 0x6000),\r\n\r\n\t//the ball!\r\n\tSCENE(18, 13, 0x0080 | 0x0000), //d        \r\n\tSCENE(20, 20, 0x0818 | 0x4000),\r\n\r\n\t//PART 3 - destruction\r\n\tSCENE(80, 16, 0x0041 | 0x2000),\r\n\tSCENE(21, 16, 0x0200 | 0x6000),\r\n\tSCENE(33, 16, 0x0074 | 0x0000),\r\n\tSCENE(22, 16, 0x040c | 0x7000),\r\n\tSCENE(24, 19, 0x063c | 0x3000),\r\n\r\n\tSCENE(26, 7, 0x0080 | 0x0000), //d\r\n\r\n\t\t\t\t\t\t\t\t   //outtro - water\r\n\tSCENE(28, 12, 0x1908 | 0x0000),\r\n\tSCENE(27, 16, 0x0808 | 0x1000),\r\n\tSCENE(97, 10, 0x0C08 | 0xB000),\r\n\r\n\tSCENE(96, 8, 0x0080 | 0x0000), //d\r\n\r\n\t\t\t\t\t\t\t\t   //the ball! \r\n//\tSCENE(30, 12, 0x0018 | 0x4000),\r\n//\tSCENE(31, 16, 0x0098 | 0x0000),\r\n\tSCENE(32, 24, 0x0098 | 0x6000),\r\n\tSCENE(0, 255, 0x0080 | 0x0000) //d\t\r\n#undef SCENE\r\n\t);\r\n\r\n\r\n\r\n// ================================ Helper functions ================================\r\n\r\n\r\nfloat sat(float x)\r\n{\r\n\treturn clamp(x, 0., 1.);\r\n}\r\n\r\n\r\n// ================================ Noises ================================\r\n\r\n// 3D noise - method by iq/shane\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\n\r\n// ================================ Voronoi ================================\r\n\r\nvec2 vcore(vec2 m, vec2 p, vec2 s)\r\n{\r\n\tvec2 c = floor(2.5*p+s);\t\t// 1./.4   r\r\n\tc += fract(43758.5*sin(c+17.*c.yx));\r\n\r\n\tfloat v = length(.4*c-p);\t// r\r\n\treturn v<m.x ? vec2(v, m.x) : v<m.y ? vec2(m.x, v) : m;\r\n}\r\n\r\n\r\n\r\n// ================================ Patterns ================================\r\n\r\n\r\nfloat lattice(vec3 p)\r\n{\r\n\tp=abs(p);\r\n\tp=max(p, p.yzx);\r\n\tp=min(p, p.yzx);\r\n\tp=min(p, p.yzx);\r\n\treturn p.x;\r\n}\r\n\r\n\r\n\r\n// ================================ SDF merge functions ================================\r\n\r\n\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif( x < d.x ) d = vec3(x, y, z);\r\n}\r\n\r\n\r\n\r\n// ================================ Domain operations ================================\r\n\r\n\r\n// rotation\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\ta *= 6.283;\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\n\r\n// 3D repetition\r\nvec3 rep(vec3 p, float r)\r\n{\r\n\treturn (fract(p/r-.5)-.5)*r;\r\n}\r\n\r\n// diffuse reflection hash - method by fizzer\r\nvec3 hashHs(vec3 n, inout float seed)\r\n{\r\n\tvec2 uv = (seed=32.+seed*fract(seed))+vec2(78.233, 10.873);\r\n\tuv = fract(.1031*uv);\r\n\tuv *= 19.19+uv;\r\n\tuv = fract(2.*uv*uv);\r\n\r\n\tfloat u = 2.*uv.x-1.;\r\n\r\n\tvec3 v = vec3(sqrt(1.-u*u), 0., u);\r\n\tpR(v.xy, uv.y);\r\n\treturn normalize(n+v);\r\n}\r\n\r\n\r\n// ================================ Complex SDFs ================================\r\n\r\nfloat vines(vec3 p, float s)\r\n{\r\n\tp.y=abs(p.y);\r\n\tpR(p.xz, .1*p.y); p=abs(p); p.xz -= .06*s;\r\n\tpR(p.xz, -.16*p.y); p=abs(p); p.xz -= .05*s;\r\n\tpR(p.xz, .4*p.y);\r\n\treturn length(abs(p.xz) - .04*(s*.5+.5));\r\n}\r\n\r\n\r\n// ================================================ Intro ================================================\r\n\r\n\r\nconst int QN = 100;\r\nconst int QD = 50;\r\n\r\nconst float QNs = 45./float(QN);\r\nconst float QNq = 1.35/float(QN);\r\nconst float QDs = 30./float(QD);\r\nconst float QDq = .9/float(QD);\r\n\r\n\r\nint seq_code;\r\nivec3 iA;\r\nfloat cb(int n) {\r\n\treturn float((seq_code>>n)&1);\r\n}\r\n\r\nvec3 lpos3;\r\nfloat camz, destr, sprog;\t// scene progress\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvec3 map(vec3 p)\r\n{\r\n\tfloat\r\n\t\ta=.5*iTime*cb(11),\r\n\t\tn0 = noise(73.*p+a),\r\n\t\tn1 = noise(10.*p+a+a),\r\n\t\tn2 = noise(2.*p+a)-.5,\r\n\t\tn3 = noise(.4*p+a)-.5,\r\n\t\th;\r\n\tfloat\r\n\t\twn1 = .2*n0+n1,\r\n\t\twn2 = sat(10.*n2),\r\n\t\twn3 = sat(10.*n3)*sat(.2*p.x*p.x-.1+.3*n2);\r\n\tfloat wallnoise = wn1*(.02+wn2),\r\n        \teclipse=sat(5.*sprog-3.)*cb(7);\r\n\tvec3 d = vec3(1, 0, 0), q, t;\r\n\r\n\tdmin(d, 6.-p.y-.1*n1+.3*n2-.4*n3,\r\n\t\t(2.-.4*cb(12)-1.*eclipse+1.5*sat(1000.*\r\n\t\t(1.3-length((p-7.*lpos3).xz))*cb(4)\t// enl\r\n\t\t))*(.12+.3*n0+.5*n1+.5*n2+.5*n3),\t\t// ebase,\r\n\t\t0.); \t\t// common sky\r\n\r\n\r\n\th = mix(.05*n0+.07*n1+.3*n2+n3,\t\t\t\t\t// terrain\r\n\t\t.002*n0+.04*n1+.2*n2+.4*n3, cb(11));\t// water\r\n\tif( cb(3)==0. )\r\n\t\tdmin(d, .8+p.y-.1*wallnoise, .01+.9*wn2, 0.);\t// forrest floor\r\n\telse if( cb(2)==0. )\r\n\t\tdmin(d, 1.2-.6*cb(11)+p.y-h, mix(.8+h*(1.-eclipse), .01, cb(11)), 0.);\t// terrain\r\n\telse\r\n\t\tdmin(d, .6+p.y-(wn1/3.+n2+.5+3.*sat(4.*n3-1.))*(.02+wn3), .01+.9*wn3, 0.);\t// rocks\r\n\r\n\r\n\r\n\th = sat(mix(.85*sprog, 1., cb(5))*2.*cb(6)-.5+.2*p.y);\r\n\th*=2.*(n0-.2)*h;\r\n\tif( cb(3)==0. )\r\n\t\tif( cb(2)==0. )\r\n\t\t{\r\n\t\t\t// trees\r\n\t\t\tq=rep(abs(p)-1.6, 3.2);\r\n\t\t\tq.y = abs(p.y)-3.;\r\n\t\t\tdmin(d,\r\n\t\t\t\tmax(p.y-3.5+wn2, vines(\r\n\t\t\t\t\tq,\r\n\t\t\t\t\t.1*wn1+.5+10./pow(1.+.95*q.y*q.y, 1.5)\r\n\t\t\t\t) -\r\n\t\t\t\t\tmix(.02+.08*wn1, -.1, (.55+p.y/3.)*sat(-15.-p.z))\r\n\t\t\t\t), .9, .0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// city\r\n\t\t\tq=p;\r\n\t\t\tq.xz=rep(q-3., 6.).xz;\r\n\r\n\t\t\tdmin(d,\r\n\t\t\t\t(max(\r\n\t\t\t\t\tmin(lattice(rep(q, .17))-.01, lattice(rep(q, .3))-.03),\r\n\t\t\t\t\tlength(max(abs(q) - vec3(1, 3, 1), 0.))+sat(wallnoise+q.y/10.-.25)\r\n\t\t\t\t)-h), .7, 0.);\r\n\t\t}\r\n\r\n\r\n\t\tq=p;\r\n\t\tq.y-=1.5*n0*sprog*cb(15);\r\n\t\tif( camz<30. )\r\n\t\t\tif( cb(2)==0. )\r\n\t\t\t\t// circle\r\n\t\t\t\tif( cb(4)==0. )\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tlength(vec2(q.z, length(q.xy)-.5))-.025,\r\n\t\t\t\t\t\t2.5, -.3);\r\n\t\t\t\telse\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tlength(q)-.6,\r\n\t\t\t\t\t\t1.8+eclipse*(p.z+.4*(p.y+p.x)<0. ? -.8 : .5),\r\n\t\t\t\t\t\t.0);\r\n\t\t\telse\r\n\t\t\t\t// glowing triangle/square\r\n\t\t\t\tif( cb(4)==0. )\r\n\t\t\t\t\tfor( float i=0.; i<.99; i+=1./(3.+cb(3)) ) {\r\n\t\t\t\t\t\tt=q;\r\n\t\t\t\t\t\tpR(t.xy, i);\r\n\t\t\t\t\t\tt.y -= .3+.22*cb(3);\r\n\t\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\t\tmax(length(t.yz)-.025, abs(t.x)-.532),\r\n\t\t\t\t\t\t\t2.5, -.3);\r\n\t\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tpR(q.xz, .05);\r\n\t\t\t\t\tq.y -= .5;\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tmax(q.y, dot(abs(q), normalize(vec3(1, .6, 1)))-.4),\r\n\t\t\t\t\t\t1.4, .0);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t// destruction\r\n\t\tvec2 r=p.xz+p.xy, s = vec2(.5, -.5), vd=50.*vcore(vcore(vcore(vcore(vec2(1), r, s.xx), r, s.xy), r, s.yx), r, s.yy);\r\n\t\th = vd.y-vd.x+sat(p.y)+1.-1.5*sat((destr-length(p.xz)));\r\n\t\td.yz = mix(d.yz, vec2(3., -.3), sat(1.-h));\r\n\r\n\t\treturn d;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tfragColor = vec4(0);\r\n    \r\n    // sequencing\r\n\t{\r\n\t\tint spos = 0;\r\n\t\tfloat stim = iTime*1000.*441./10./(9586.*2.);\r\n\t\tint istim = int(stim);\r\n        while( SCENES[spos].x<255 && stim>=float(SCENES[spos].x) )\r\n            stim -= float(SCENES[spos++].x);\r\n        iA.y = seq_code = SCENES[spos].y;\r\n        sprog = sat(stim / float(SCENES[spos].x));\r\n\t}\r\n\r\n\tcamz = mix((15.+10.*cb(0)+20.*cb(1)+5.*cb(10))*(1.-.1*sprog)-10., .6, pow(sprog,6.)*cb(7));\r\n\tdestr = sprog*cb(9)*(3.+5.*cb(5));\r\n\r\n\r\n\r\n\tfragColor = vec4(0);\r\n\tif( uv.y>.11 && uv.y<.89 )\r\n\t{\r\n\t\tfloat t1 = 0., t2 = 0., seed = uv.x*uv.y+uv.y+uv.x+fract(iTime);\r\n\t\tvec3 ro1 = vec3(0, 0, -.1),\r\n\t\t\trd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.y/1.8, 1)),\r\n\t\t\tscol=vec3(0), m1, m2, nor1, pos1, pos2;\r\n\r\n\t\t// camera angle\r\n\t\tvec2 ca=vec2(.1, .07)*cb(8), e = vec2(0, .0001);\r\n\t\tpR(ro1.zy, ca.y); pR(rd1.zy, ca.y);\r\n\t\tpR(ro1.zx, ca.x); pR(rd1.zx, ca.x);\r\n\t\tro1.z-=camz;\r\n\r\n\t\tlpos3 = normalize(mix(vec3(.5, 1, 0), vec3(0, -1, 0), sat(destr)));\r\n\r\n\t\tt1 = .2*fract(seed);\r\n\r\n\t\tfor( int i = 0; i < QN; i++ )\r\n\t\t{\r\n\t\t\tpos1 = ro1+rd1*t1;\r\n\t\t\tm1 = map(pos1);\r\n\t\t\tt1+=QNs*m1.x;\r\n\r\n\t\t\tif( m1.x<.005 )\r\n\t\t\t{\r\n\t\t\t\tif( m1.z<0. )\r\n\t\t\t\t\tscol+= vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*float(QN-i);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tpos2=pos1+mix(lpos3, hashHs(lpos3, seed), .04)*t2;\r\n\t\t\tm2 = map(pos2);\r\n\t\t\tt2+=m2.x;\r\n\r\n\t\t\tscol +=\r\n\t\t\t\tmax(0., m1.z) +\r\n\t\t\t\tvec3(1.+m1.z, 1., 1.-m1.z)*max(0., m1.y-1.) +\r\n\t\t\t\t(.5+5.*m1.x*noise(7.*pos1+vec3(iTime)))*max(0., m2.y-1.)*(1.-cb(12));\r\n\t\t}\r\n\t\tscol *= QNq;\r\n\r\n\t\tnor1 = normalize(m1.x-vec3(map(pos1 - e.yxx).x, map(pos1 - e.xyx).x, map(pos1 - e.xxy).x));\r\n\r\n\t\tt2=1.;\r\n\t\tfor( int i = 0; i < QD; i++ )\r\n\t\t{\r\n\t\t\tpos2 = pos1 + mix(reflect(rd1, nor1), hashHs(nor1, seed), sat(m1.y))*t2;\r\n\t\t\tm2 = map(pos2);\r\n\t\t\tt2+=QDs*m2.x;\r\n\r\n\t\t\tscol += vec3(1.+m2.z, 1., 1.-m2.z)*max(0., m2.y-1.)*QDq;\r\n\r\n\t\t}\r\n\t\tscol=clamp(scol, 0., 1.)\r\n\t\t\t*sat(cb(14)+15.*sprog)\r\n\t\t\t*sat(cb(13)+5.-5.*sprog)\r\n\t\t\t-float(iA.y==128)\r\n\t\t\t;\r\n        fragColor = scol.xyzz;\r\n\t\t//fragColor = mix(scol.xyzz, texture(iChannel0, uv), pow(.0001, iTimeDelta));\r\n\t}\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Then and Before - PC4k by Altair","id":"418bf30d2b644c0f9db39ad2726ad0a6","date":null,"viewed":0,"name":"Then and Before - PC4k by Altair","description":"4k PC intro released at Xenium 2019\n\nDownload/pouet: https://www.pouet.net/prod.php?which=82778\nhttps://www.shadertoy.com/view/3ddGzn","likes":0,"published":null,"tags":["Then and Before - PC4k by Altair"]},"ver":null,"info":{"Name":"Then and Before - PC4k by Altair","id":"418bf30d2b644c0f9db39ad2726ad0a6","date":null,"viewed":0,"name":"Then and Before - PC4k by Altair","description":"4k PC intro released at Xenium 2019\n\nDownload/pouet: https://www.pouet.net/prod.php?which=82778\nhttps://www.shadertoy.com/view/3ddGzn","likes":0,"published":null,"tags":["Then and Before - PC4k by Altair"]},"renderpass":[{"Code":"//\r\n// __ __|  |   |  ____|   \\  |         \\      \\  |  __ \\       __ )   ____|  ____|  _ \\    _ \\   ____| \r\n//    |    |   |  __|      \\ |        _ \\      \\ |  |   |      __ \\   __|    |     |   |  |   |  __|   \r\n//    |    ___ |  |      |\\  |       ___ \\   |\\  |  |   |      |   |  |      __|   |   |  __ <   |     \r\n//   _|   _|  _| _____| _| \\_|     _/    _\\ _| \\_| ____/      ____/  _____| _|    \\___/  _| \\_\\ _____| \r\n//\r\n//\r\n//                                                                         4k PC intro - Altair MMXIX\r\n//\r\n//\r\n//    Code & design:    KK\r\n//    Music & design:   Lesnik\r\n//    Add. code:        Virgill\r\n//\r\n//\r\n//\r\n//\r\n\r\n// Scene control:\r\n//\r\n// $0003\tBA\t1..0\t- camera distance 0..3\r\n// $000C\tDC\t3..2\t- scenery \t00:forest\t\t01:city\r\n//\t\t\t\t\t\t\t\t\t10:terrain\t\t11:landscape\r\n//\t \t\t\t\t\t\t\t\t-0:circle\t\t-1:triangle\r\n//\r\n// $0010\t E\t 4\t\t- 0:glowing\t\t1:solid\r\n// $0020\t F\t 5\t\t- large voronoi range / end phase of city destruction\r\n// $0040\t G\t 6\t\t- city destruction\r\n// $0080\t H\t 7\t\t- black sphere (only flag H = black screen)\r\n// $0100\t I\t 8\t\t- camera angle\r\n// $0200\t J\t 9\t\t- voronoi destruction\r\n// $0400\t K\t10\t\t- camera distance + 0.5\r\n// $0800\t L  11\t\t- water (with C=0 D=1)\r\n// $1000\t M  12\t\t- darkness\r\n// $2000\t N\t13\t\t- sharp OUT transition\r\n// $4000\t O\t14\t\t- sharp IN transition\r\n// $8000\t P\t15\t\t- shape particles\r\n//\r\n//\r\n\r\n\r\nconst ivec3 SCENES[] = ivec3[](\r\n#define SCENE(n,d,b)\tivec3((d),(b),(n))\r\n\r\n\t//intro\r\n\tSCENE(2, 16, 0x050A | 0x0000),\r\n\tSCENE(3, 16, 0x040B | 0x0000),\r\n\r\n\t//PART 1 - forest+rocks\r\n\tSCENE(4, 12, 0x0013 | 0x4000),\r\n\tSCENE(5, 11, 0x0051 | 0x2000),\r\n\tSCENE(6, 1, 0x0410 | 0x6000),\r\n\tSCENE(7, 8, 0x0010 | 0x6000),\r\n\tSCENE(8, 12, 0x0110 | 0x4000),\r\n\tSCENE(9, 12, 0x001F | 0x0000),\r\n\tSCENE(10, 12, 0x001C | 0x6000),\r\n\r\n\t//the ball!\r\n\tSCENE(11, 8, 0x0080 | 0x0000), //d\r\n\tSCENE(13, 20, 0x0418 | 0x2000),\r\n\r\n\t//PART 2 - city\r\n\tSCENE(14, 16, 0x0407 | 0x4000),\r\n\tSCENE(15, 16, 0x0014 | 0x0000),\r\n\tSCENE(16, 20, 0x0124 | 0x6000),\r\n\tSCENE(17, 11, 0x0044 | 0x6000),\r\n\r\n\t//the ball!\r\n\tSCENE(18, 13, 0x0080 | 0x0000), //d        \r\n\tSCENE(20, 20, 0x0818 | 0x4000),\r\n\r\n\t//PART 3 - destruction\r\n\tSCENE(80, 16, 0x0041 | 0x2000),\r\n\tSCENE(21, 16, 0x0200 | 0x6000),\r\n\tSCENE(33, 16, 0x0074 | 0x0000),\r\n\tSCENE(22, 16, 0x040c | 0x7000),\r\n\tSCENE(24, 19, 0x063c | 0x3000),\r\n\r\n\tSCENE(26, 7, 0x0080 | 0x0000), //d\r\n\r\n\t\t\t\t\t\t\t\t   //outtro - water\r\n\tSCENE(28, 12, 0x1908 | 0x0000),\r\n\tSCENE(27, 16, 0x0808 | 0x1000),\r\n\tSCENE(97, 10, 0x0C08 | 0xB000),\r\n\r\n\tSCENE(96, 8, 0x0080 | 0x0000), //d\r\n\r\n\t\t\t\t\t\t\t\t   //the ball! \r\n//\tSCENE(30, 12, 0x0018 | 0x4000),\r\n//\tSCENE(31, 16, 0x0098 | 0x0000),\r\n\tSCENE(32, 24, 0x0098 | 0x6000),\r\n\tSCENE(0, 255, 0x0080 | 0x0000) //d\t\r\n#undef SCENE\r\n\t);\r\n\r\n\r\n\r\n// ================================ Helper functions ================================\r\n\r\n\r\nfloat sat(float x)\r\n{\r\n\treturn clamp(x, 0., 1.);\r\n}\r\n\r\n\r\n// ================================ Noises ================================\r\n\r\n// 3D noise - method by iq/shane\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\n\r\n// ================================ Voronoi ================================\r\n\r\nvec2 vcore(vec2 m, vec2 p, vec2 s)\r\n{\r\n\tvec2 c = floor(2.5*p+s);\t\t// 1./.4   r\r\n\tc += fract(43758.5*sin(c+17.*c.yx));\r\n\r\n\tfloat v = length(.4*c-p);\t// r\r\n\treturn v<m.x ? vec2(v, m.x) : v<m.y ? vec2(m.x, v) : m;\r\n}\r\n\r\n\r\n\r\n// ================================ Patterns ================================\r\n\r\n\r\nfloat lattice(vec3 p)\r\n{\r\n\tp=abs(p);\r\n\tp=max(p, p.yzx);\r\n\tp=min(p, p.yzx);\r\n\tp=min(p, p.yzx);\r\n\treturn p.x;\r\n}\r\n\r\n\r\n\r\n// ================================ SDF merge functions ================================\r\n\r\n\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif( x < d.x ) d = vec3(x, y, z);\r\n}\r\n\r\n\r\n\r\n// ================================ Domain operations ================================\r\n\r\n\r\n// rotation\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\ta *= 6.283;\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\n\r\n// 3D repetition\r\nvec3 rep(vec3 p, float r)\r\n{\r\n\treturn (fract(p/r-.5)-.5)*r;\r\n}\r\n\r\n// diffuse reflection hash - method by fizzer\r\nvec3 hashHs(vec3 n, inout float seed)\r\n{\r\n\tvec2 uv = (seed=32.+seed*fract(seed))+vec2(78.233, 10.873);\r\n\tuv = fract(.1031*uv);\r\n\tuv *= 19.19+uv;\r\n\tuv = fract(2.*uv*uv);\r\n\r\n\tfloat u = 2.*uv.x-1.;\r\n\r\n\tvec3 v = vec3(sqrt(1.-u*u), 0., u);\r\n\tpR(v.xy, uv.y);\r\n\treturn normalize(n+v);\r\n}\r\n\r\n\r\n// ================================ Complex SDFs ================================\r\n\r\nfloat vines(vec3 p, float s)\r\n{\r\n\tp.y=abs(p.y);\r\n\tpR(p.xz, .1*p.y); p=abs(p); p.xz -= .06*s;\r\n\tpR(p.xz, -.16*p.y); p=abs(p); p.xz -= .05*s;\r\n\tpR(p.xz, .4*p.y);\r\n\treturn length(abs(p.xz) - .04*(s*.5+.5));\r\n}\r\n\r\n\r\n// ================================================ Intro ================================================\r\n\r\n\r\nconst int QN = 100;\r\nconst int QD = 50;\r\n\r\nconst float QNs = 45./float(QN);\r\nconst float QNq = 1.35/float(QN);\r\nconst float QDs = 30./float(QD);\r\nconst float QDq = .9/float(QD);\r\n\r\n\r\nint seq_code;\r\nivec3 iA;\r\nfloat cb(int n) {\r\n\treturn float((seq_code>>n)&1);\r\n}\r\n\r\nvec3 lpos3;\r\nfloat camz, destr, sprog;\t// scene progress\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvec3 map(vec3 p)\r\n{\r\n\tfloat\r\n\t\ta=.5*iTime*cb(11),\r\n\t\tn0 = noise(73.*p+a),\r\n\t\tn1 = noise(10.*p+a+a),\r\n\t\tn2 = noise(2.*p+a)-.5,\r\n\t\tn3 = noise(.4*p+a)-.5,\r\n\t\th;\r\n\tfloat\r\n\t\twn1 = .2*n0+n1,\r\n\t\twn2 = sat(10.*n2),\r\n\t\twn3 = sat(10.*n3)*sat(.2*p.x*p.x-.1+.3*n2);\r\n\tfloat wallnoise = wn1*(.02+wn2),\r\n        \teclipse=sat(5.*sprog-3.)*cb(7);\r\n\tvec3 d = vec3(1, 0, 0), q, t;\r\n\r\n\tdmin(d, 6.-p.y-.1*n1+.3*n2-.4*n3,\r\n\t\t(2.-.4*cb(12)-1.*eclipse+1.5*sat(1000.*\r\n\t\t(1.3-length((p-7.*lpos3).xz))*cb(4)\t// enl\r\n\t\t))*(.12+.3*n0+.5*n1+.5*n2+.5*n3),\t\t// ebase,\r\n\t\t0.); \t\t// common sky\r\n\r\n\r\n\th = mix(.05*n0+.07*n1+.3*n2+n3,\t\t\t\t\t// terrain\r\n\t\t.002*n0+.04*n1+.2*n2+.4*n3, cb(11));\t// water\r\n\tif( cb(3)==0. )\r\n\t\tdmin(d, .8+p.y-.1*wallnoise, .01+.9*wn2, 0.);\t// forrest floor\r\n\telse if( cb(2)==0. )\r\n\t\tdmin(d, 1.2-.6*cb(11)+p.y-h, mix(.8+h*(1.-eclipse), .01, cb(11)), 0.);\t// terrain\r\n\telse\r\n\t\tdmin(d, .6+p.y-(wn1/3.+n2+.5+3.*sat(4.*n3-1.))*(.02+wn3), .01+.9*wn3, 0.);\t// rocks\r\n\r\n\r\n\r\n\th = sat(mix(.85*sprog, 1., cb(5))*2.*cb(6)-.5+.2*p.y);\r\n\th*=2.*(n0-.2)*h;\r\n\tif( cb(3)==0. )\r\n\t\tif( cb(2)==0. )\r\n\t\t{\r\n\t\t\t// trees\r\n\t\t\tq=rep(abs(p)-1.6, 3.2);\r\n\t\t\tq.y = abs(p.y)-3.;\r\n\t\t\tdmin(d,\r\n\t\t\t\tmax(p.y-3.5+wn2, vines(\r\n\t\t\t\t\tq,\r\n\t\t\t\t\t.1*wn1+.5+10./pow(1.+.95*q.y*q.y, 1.5)\r\n\t\t\t\t) -\r\n\t\t\t\t\tmix(.02+.08*wn1, -.1, (.55+p.y/3.)*sat(-15.-p.z))\r\n\t\t\t\t), .9, .0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// city\r\n\t\t\tq=p;\r\n\t\t\tq.xz=rep(q-3., 6.).xz;\r\n\r\n\t\t\tdmin(d,\r\n\t\t\t\t(max(\r\n\t\t\t\t\tmin(lattice(rep(q, .17))-.01, lattice(rep(q, .3))-.03),\r\n\t\t\t\t\tlength(max(abs(q) - vec3(1, 3, 1), 0.))+sat(wallnoise+q.y/10.-.25)\r\n\t\t\t\t)-h), .7, 0.);\r\n\t\t}\r\n\r\n\r\n\t\tq=p;\r\n\t\tq.y-=1.5*n0*sprog*cb(15);\r\n\t\tif( camz<30. )\r\n\t\t\tif( cb(2)==0. )\r\n\t\t\t\t// circle\r\n\t\t\t\tif( cb(4)==0. )\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tlength(vec2(q.z, length(q.xy)-.5))-.025,\r\n\t\t\t\t\t\t2.5, -.3);\r\n\t\t\t\telse\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tlength(q)-.6,\r\n\t\t\t\t\t\t1.8+eclipse*(p.z+.4*(p.y+p.x)<0. ? -.8 : .5),\r\n\t\t\t\t\t\t.0);\r\n\t\t\telse\r\n\t\t\t\t// glowing triangle/square\r\n\t\t\t\tif( cb(4)==0. )\r\n\t\t\t\t\tfor( float i=0.; i<.99; i+=1./(3.+cb(3)) ) {\r\n\t\t\t\t\t\tt=q;\r\n\t\t\t\t\t\tpR(t.xy, i);\r\n\t\t\t\t\t\tt.y -= .3+.22*cb(3);\r\n\t\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\t\tmax(length(t.yz)-.025, abs(t.x)-.532),\r\n\t\t\t\t\t\t\t2.5, -.3);\r\n\t\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tpR(q.xz, .05);\r\n\t\t\t\t\tq.y -= .5;\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tmax(q.y, dot(abs(q), normalize(vec3(1, .6, 1)))-.4),\r\n\t\t\t\t\t\t1.4, .0);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t// destruction\r\n\t\tvec2 r=p.xz+p.xy, s = vec2(.5, -.5), vd=50.*vcore(vcore(vcore(vcore(vec2(1), r, s.xx), r, s.xy), r, s.yx), r, s.yy);\r\n\t\th = vd.y-vd.x+sat(p.y)+1.-1.5*sat((destr-length(p.xz)));\r\n\t\td.yz = mix(d.yz, vec2(3., -.3), sat(1.-h));\r\n\r\n\t\treturn d;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tfragColor = vec4(0);\r\n    \r\n    // sequencing\r\n\t{\r\n\t\tint spos = 0;\r\n\t\tfloat stim = iTime*1000.*441./10./(9586.*2.);\r\n\t\tint istim = int(stim);\r\n        while( SCENES[spos].x<255 && stim>=float(SCENES[spos].x) )\r\n            stim -= float(SCENES[spos++].x);\r\n        iA.y = seq_code = SCENES[spos].y;\r\n        sprog = sat(stim / float(SCENES[spos].x));\r\n\t}\r\n\r\n\tcamz = mix((15.+10.*cb(0)+20.*cb(1)+5.*cb(10))*(1.-.1*sprog)-10., .6, pow(sprog,6.)*cb(7));\r\n\tdestr = sprog*cb(9)*(3.+5.*cb(5));\r\n\r\n\r\n\r\n\tfragColor = vec4(0);\r\n\tif( uv.y>.11 && uv.y<.89 )\r\n\t{\r\n\t\tfloat t1 = 0., t2 = 0., seed = uv.x*uv.y+uv.y+uv.x+fract(iTime);\r\n\t\tvec3 ro1 = vec3(0, 0, -.1),\r\n\t\t\trd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.y/1.8, 1)),\r\n\t\t\tscol=vec3(0), m1, m2, nor1, pos1, pos2;\r\n\r\n\t\t// camera angle\r\n\t\tvec2 ca=vec2(.1, .07)*cb(8), e = vec2(0, .0001);\r\n\t\tpR(ro1.zy, ca.y); pR(rd1.zy, ca.y);\r\n\t\tpR(ro1.zx, ca.x); pR(rd1.zx, ca.x);\r\n\t\tro1.z-=camz;\r\n\r\n\t\tlpos3 = normalize(mix(vec3(.5, 1, 0), vec3(0, -1, 0), sat(destr)));\r\n\r\n\t\tt1 = .2*fract(seed);\r\n\r\n\t\tfor( int i = 0; i < QN; i++ )\r\n\t\t{\r\n\t\t\tpos1 = ro1+rd1*t1;\r\n\t\t\tm1 = map(pos1);\r\n\t\t\tt1+=QNs*m1.x;\r\n\r\n\t\t\tif( m1.x<.005 )\r\n\t\t\t{\r\n\t\t\t\tif( m1.z<0. )\r\n\t\t\t\t\tscol+= vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*float(QN-i);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tpos2=pos1+mix(lpos3, hashHs(lpos3, seed), .04)*t2;\r\n\t\t\tm2 = map(pos2);\r\n\t\t\tt2+=m2.x;\r\n\r\n\t\t\tscol +=\r\n\t\t\t\tmax(0., m1.z) +\r\n\t\t\t\tvec3(1.+m1.z, 1., 1.-m1.z)*max(0., m1.y-1.) +\r\n\t\t\t\t(.5+5.*m1.x*noise(7.*pos1+vec3(iTime)))*max(0., m2.y-1.)*(1.-cb(12));\r\n\t\t}\r\n\t\tscol *= QNq;\r\n\r\n\t\tnor1 = normalize(m1.x-vec3(map(pos1 - e.yxx).x, map(pos1 - e.xyx).x, map(pos1 - e.xxy).x));\r\n\r\n\t\tt2=1.;\r\n\t\tfor( int i = 0; i < QD; i++ )\r\n\t\t{\r\n\t\t\tpos2 = pos1 + mix(reflect(rd1, nor1), hashHs(nor1, seed), sat(m1.y))*t2;\r\n\t\t\tm2 = map(pos2);\r\n\t\t\tt2+=QDs*m2.x;\r\n\r\n\t\t\tscol += vec3(1.+m2.z, 1., 1.-m2.z)*max(0., m2.y-1.)*QDq;\r\n\r\n\t\t}\r\n\t\tscol=clamp(scol, 0., 1.)\r\n\t\t\t*sat(cb(14)+15.*sprog)\r\n\t\t\t*sat(cb(13)+5.-5.*sprog)\r\n\t\t\t-float(iA.y==128)\r\n\t\t\t;\r\n        fragColor = scol.xyzz;\r\n\t\t//fragColor = mix(scol.xyzz, texture(iChannel0, uv), pow(.0001, iTimeDelta));\r\n\t}\r\n}\r\n","inputs":[],"outputs":[],"code":"//\r\n// __ __|  |   |  ____|   \\  |         \\      \\  |  __ \\       __ )   ____|  ____|  _ \\    _ \\   ____| \r\n//    |    |   |  __|      \\ |        _ \\      \\ |  |   |      __ \\   __|    |     |   |  |   |  __|   \r\n//    |    ___ |  |      |\\  |       ___ \\   |\\  |  |   |      |   |  |      __|   |   |  __ <   |     \r\n//   _|   _|  _| _____| _| \\_|     _/    _\\ _| \\_| ____/      ____/  _____| _|    \\___/  _| \\_\\ _____| \r\n//\r\n//\r\n//                                                                         4k PC intro - Altair MMXIX\r\n//\r\n//\r\n//    Code & design:    KK\r\n//    Music & design:   Lesnik\r\n//    Add. code:        Virgill\r\n//\r\n//\r\n//\r\n//\r\n\r\n// Scene control:\r\n//\r\n// $0003\tBA\t1..0\t- camera distance 0..3\r\n// $000C\tDC\t3..2\t- scenery \t00:forest\t\t01:city\r\n//\t\t\t\t\t\t\t\t\t10:terrain\t\t11:landscape\r\n//\t \t\t\t\t\t\t\t\t-0:circle\t\t-1:triangle\r\n//\r\n// $0010\t E\t 4\t\t- 0:glowing\t\t1:solid\r\n// $0020\t F\t 5\t\t- large voronoi range / end phase of city destruction\r\n// $0040\t G\t 6\t\t- city destruction\r\n// $0080\t H\t 7\t\t- black sphere (only flag H = black screen)\r\n// $0100\t I\t 8\t\t- camera angle\r\n// $0200\t J\t 9\t\t- voronoi destruction\r\n// $0400\t K\t10\t\t- camera distance + 0.5\r\n// $0800\t L  11\t\t- water (with C=0 D=1)\r\n// $1000\t M  12\t\t- darkness\r\n// $2000\t N\t13\t\t- sharp OUT transition\r\n// $4000\t O\t14\t\t- sharp IN transition\r\n// $8000\t P\t15\t\t- shape particles\r\n//\r\n//\r\n\r\n\r\nconst ivec3 SCENES[] = ivec3[](\r\n#define SCENE(n,d,b)\tivec3((d),(b),(n))\r\n\r\n\t//intro\r\n\tSCENE(2, 16, 0x050A | 0x0000),\r\n\tSCENE(3, 16, 0x040B | 0x0000),\r\n\r\n\t//PART 1 - forest+rocks\r\n\tSCENE(4, 12, 0x0013 | 0x4000),\r\n\tSCENE(5, 11, 0x0051 | 0x2000),\r\n\tSCENE(6, 1, 0x0410 | 0x6000),\r\n\tSCENE(7, 8, 0x0010 | 0x6000),\r\n\tSCENE(8, 12, 0x0110 | 0x4000),\r\n\tSCENE(9, 12, 0x001F | 0x0000),\r\n\tSCENE(10, 12, 0x001C | 0x6000),\r\n\r\n\t//the ball!\r\n\tSCENE(11, 8, 0x0080 | 0x0000), //d\r\n\tSCENE(13, 20, 0x0418 | 0x2000),\r\n\r\n\t//PART 2 - city\r\n\tSCENE(14, 16, 0x0407 | 0x4000),\r\n\tSCENE(15, 16, 0x0014 | 0x0000),\r\n\tSCENE(16, 20, 0x0124 | 0x6000),\r\n\tSCENE(17, 11, 0x0044 | 0x6000),\r\n\r\n\t//the ball!\r\n\tSCENE(18, 13, 0x0080 | 0x0000), //d        \r\n\tSCENE(20, 20, 0x0818 | 0x4000),\r\n\r\n\t//PART 3 - destruction\r\n\tSCENE(80, 16, 0x0041 | 0x2000),\r\n\tSCENE(21, 16, 0x0200 | 0x6000),\r\n\tSCENE(33, 16, 0x0074 | 0x0000),\r\n\tSCENE(22, 16, 0x040c | 0x7000),\r\n\tSCENE(24, 19, 0x063c | 0x3000),\r\n\r\n\tSCENE(26, 7, 0x0080 | 0x0000), //d\r\n\r\n\t\t\t\t\t\t\t\t   //outtro - water\r\n\tSCENE(28, 12, 0x1908 | 0x0000),\r\n\tSCENE(27, 16, 0x0808 | 0x1000),\r\n\tSCENE(97, 10, 0x0C08 | 0xB000),\r\n\r\n\tSCENE(96, 8, 0x0080 | 0x0000), //d\r\n\r\n\t\t\t\t\t\t\t\t   //the ball! \r\n//\tSCENE(30, 12, 0x0018 | 0x4000),\r\n//\tSCENE(31, 16, 0x0098 | 0x0000),\r\n\tSCENE(32, 24, 0x0098 | 0x6000),\r\n\tSCENE(0, 255, 0x0080 | 0x0000) //d\t\r\n#undef SCENE\r\n\t);\r\n\r\n\r\n\r\n// ================================ Helper functions ================================\r\n\r\n\r\nfloat sat(float x)\r\n{\r\n\treturn clamp(x, 0., 1.);\r\n}\r\n\r\n\r\n// ================================ Noises ================================\r\n\r\n// 3D noise - method by iq/shane\r\nfloat noise(vec3 p)\r\n{\r\n\tvec3 ip=floor(p);\r\n\tp-=ip;\r\n\tvec3 s=vec3(7, 157, 113);\r\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\r\n\tp=p*p*(3.-2.*p);\r\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\r\n\th.xy=mix(h.xz, h.yw, p.y);\r\n\treturn mix(h.x, h.y, p.z);\r\n}\r\n\r\n\r\n// ================================ Voronoi ================================\r\n\r\nvec2 vcore(vec2 m, vec2 p, vec2 s)\r\n{\r\n\tvec2 c = floor(2.5*p+s);\t\t// 1./.4   r\r\n\tc += fract(43758.5*sin(c+17.*c.yx));\r\n\r\n\tfloat v = length(.4*c-p);\t// r\r\n\treturn v<m.x ? vec2(v, m.x) : v<m.y ? vec2(m.x, v) : m;\r\n}\r\n\r\n\r\n\r\n// ================================ Patterns ================================\r\n\r\n\r\nfloat lattice(vec3 p)\r\n{\r\n\tp=abs(p);\r\n\tp=max(p, p.yzx);\r\n\tp=min(p, p.yzx);\r\n\tp=min(p, p.yzx);\r\n\treturn p.x;\r\n}\r\n\r\n\r\n\r\n// ================================ SDF merge functions ================================\r\n\r\n\r\nvoid dmin(inout vec3 d, float x, float y, float z)\r\n{\r\n\tif( x < d.x ) d = vec3(x, y, z);\r\n}\r\n\r\n\r\n\r\n// ================================ Domain operations ================================\r\n\r\n\r\n// rotation\r\nvoid pR(inout vec2 p, float a)\r\n{\r\n\ta *= 6.283;\r\n\tp = cos(a)*p+sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\n\r\n// 3D repetition\r\nvec3 rep(vec3 p, float r)\r\n{\r\n\treturn (fract(p/r-.5)-.5)*r;\r\n}\r\n\r\n// diffuse reflection hash - method by fizzer\r\nvec3 hashHs(vec3 n, inout float seed)\r\n{\r\n\tvec2 uv = (seed=32.+seed*fract(seed))+vec2(78.233, 10.873);\r\n\tuv = fract(.1031*uv);\r\n\tuv *= 19.19+uv;\r\n\tuv = fract(2.*uv*uv);\r\n\r\n\tfloat u = 2.*uv.x-1.;\r\n\r\n\tvec3 v = vec3(sqrt(1.-u*u), 0., u);\r\n\tpR(v.xy, uv.y);\r\n\treturn normalize(n+v);\r\n}\r\n\r\n\r\n// ================================ Complex SDFs ================================\r\n\r\nfloat vines(vec3 p, float s)\r\n{\r\n\tp.y=abs(p.y);\r\n\tpR(p.xz, .1*p.y); p=abs(p); p.xz -= .06*s;\r\n\tpR(p.xz, -.16*p.y); p=abs(p); p.xz -= .05*s;\r\n\tpR(p.xz, .4*p.y);\r\n\treturn length(abs(p.xz) - .04*(s*.5+.5));\r\n}\r\n\r\n\r\n// ================================================ Intro ================================================\r\n\r\n\r\nconst int QN = 100;\r\nconst int QD = 50;\r\n\r\nconst float QNs = 45./float(QN);\r\nconst float QNq = 1.35/float(QN);\r\nconst float QDs = 30./float(QD);\r\nconst float QDq = .9/float(QD);\r\n\r\n\r\nint seq_code;\r\nivec3 iA;\r\nfloat cb(int n) {\r\n\treturn float((seq_code>>n)&1);\r\n}\r\n\r\nvec3 lpos3;\r\nfloat camz, destr, sprog;\t// scene progress\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvec3 map(vec3 p)\r\n{\r\n\tfloat\r\n\t\ta=.5*iTime*cb(11),\r\n\t\tn0 = noise(73.*p+a),\r\n\t\tn1 = noise(10.*p+a+a),\r\n\t\tn2 = noise(2.*p+a)-.5,\r\n\t\tn3 = noise(.4*p+a)-.5,\r\n\t\th;\r\n\tfloat\r\n\t\twn1 = .2*n0+n1,\r\n\t\twn2 = sat(10.*n2),\r\n\t\twn3 = sat(10.*n3)*sat(.2*p.x*p.x-.1+.3*n2);\r\n\tfloat wallnoise = wn1*(.02+wn2),\r\n        \teclipse=sat(5.*sprog-3.)*cb(7);\r\n\tvec3 d = vec3(1, 0, 0), q, t;\r\n\r\n\tdmin(d, 6.-p.y-.1*n1+.3*n2-.4*n3,\r\n\t\t(2.-.4*cb(12)-1.*eclipse+1.5*sat(1000.*\r\n\t\t(1.3-length((p-7.*lpos3).xz))*cb(4)\t// enl\r\n\t\t))*(.12+.3*n0+.5*n1+.5*n2+.5*n3),\t\t// ebase,\r\n\t\t0.); \t\t// common sky\r\n\r\n\r\n\th = mix(.05*n0+.07*n1+.3*n2+n3,\t\t\t\t\t// terrain\r\n\t\t.002*n0+.04*n1+.2*n2+.4*n3, cb(11));\t// water\r\n\tif( cb(3)==0. )\r\n\t\tdmin(d, .8+p.y-.1*wallnoise, .01+.9*wn2, 0.);\t// forrest floor\r\n\telse if( cb(2)==0. )\r\n\t\tdmin(d, 1.2-.6*cb(11)+p.y-h, mix(.8+h*(1.-eclipse), .01, cb(11)), 0.);\t// terrain\r\n\telse\r\n\t\tdmin(d, .6+p.y-(wn1/3.+n2+.5+3.*sat(4.*n3-1.))*(.02+wn3), .01+.9*wn3, 0.);\t// rocks\r\n\r\n\r\n\r\n\th = sat(mix(.85*sprog, 1., cb(5))*2.*cb(6)-.5+.2*p.y);\r\n\th*=2.*(n0-.2)*h;\r\n\tif( cb(3)==0. )\r\n\t\tif( cb(2)==0. )\r\n\t\t{\r\n\t\t\t// trees\r\n\t\t\tq=rep(abs(p)-1.6, 3.2);\r\n\t\t\tq.y = abs(p.y)-3.;\r\n\t\t\tdmin(d,\r\n\t\t\t\tmax(p.y-3.5+wn2, vines(\r\n\t\t\t\t\tq,\r\n\t\t\t\t\t.1*wn1+.5+10./pow(1.+.95*q.y*q.y, 1.5)\r\n\t\t\t\t) -\r\n\t\t\t\t\tmix(.02+.08*wn1, -.1, (.55+p.y/3.)*sat(-15.-p.z))\r\n\t\t\t\t), .9, .0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// city\r\n\t\t\tq=p;\r\n\t\t\tq.xz=rep(q-3., 6.).xz;\r\n\r\n\t\t\tdmin(d,\r\n\t\t\t\t(max(\r\n\t\t\t\t\tmin(lattice(rep(q, .17))-.01, lattice(rep(q, .3))-.03),\r\n\t\t\t\t\tlength(max(abs(q) - vec3(1, 3, 1), 0.))+sat(wallnoise+q.y/10.-.25)\r\n\t\t\t\t)-h), .7, 0.);\r\n\t\t}\r\n\r\n\r\n\t\tq=p;\r\n\t\tq.y-=1.5*n0*sprog*cb(15);\r\n\t\tif( camz<30. )\r\n\t\t\tif( cb(2)==0. )\r\n\t\t\t\t// circle\r\n\t\t\t\tif( cb(4)==0. )\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tlength(vec2(q.z, length(q.xy)-.5))-.025,\r\n\t\t\t\t\t\t2.5, -.3);\r\n\t\t\t\telse\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tlength(q)-.6,\r\n\t\t\t\t\t\t1.8+eclipse*(p.z+.4*(p.y+p.x)<0. ? -.8 : .5),\r\n\t\t\t\t\t\t.0);\r\n\t\t\telse\r\n\t\t\t\t// glowing triangle/square\r\n\t\t\t\tif( cb(4)==0. )\r\n\t\t\t\t\tfor( float i=0.; i<.99; i+=1./(3.+cb(3)) ) {\r\n\t\t\t\t\t\tt=q;\r\n\t\t\t\t\t\tpR(t.xy, i);\r\n\t\t\t\t\t\tt.y -= .3+.22*cb(3);\r\n\t\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\t\tmax(length(t.yz)-.025, abs(t.x)-.532),\r\n\t\t\t\t\t\t\t2.5, -.3);\r\n\t\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tpR(q.xz, .05);\r\n\t\t\t\t\tq.y -= .5;\r\n\t\t\t\t\tdmin(d,\r\n\t\t\t\t\t\tmax(q.y, dot(abs(q), normalize(vec3(1, .6, 1)))-.4),\r\n\t\t\t\t\t\t1.4, .0);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t// destruction\r\n\t\tvec2 r=p.xz+p.xy, s = vec2(.5, -.5), vd=50.*vcore(vcore(vcore(vcore(vec2(1), r, s.xx), r, s.xy), r, s.yx), r, s.yy);\r\n\t\th = vd.y-vd.x+sat(p.y)+1.-1.5*sat((destr-length(p.xz)));\r\n\t\td.yz = mix(d.yz, vec2(3., -.3), sat(1.-h));\r\n\r\n\t\treturn d;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tfragColor = vec4(0);\r\n    \r\n    // sequencing\r\n\t{\r\n\t\tint spos = 0;\r\n\t\tfloat stim = iTime*1000.*441./10./(9586.*2.);\r\n\t\tint istim = int(stim);\r\n        while( SCENES[spos].x<255 && stim>=float(SCENES[spos].x) )\r\n            stim -= float(SCENES[spos++].x);\r\n        iA.y = seq_code = SCENES[spos].y;\r\n        sprog = sat(stim / float(SCENES[spos].x));\r\n\t}\r\n\r\n\tcamz = mix((15.+10.*cb(0)+20.*cb(1)+5.*cb(10))*(1.-.1*sprog)-10., .6, pow(sprog,6.)*cb(7));\r\n\tdestr = sprog*cb(9)*(3.+5.*cb(5));\r\n\r\n\r\n\r\n\tfragColor = vec4(0);\r\n\tif( uv.y>.11 && uv.y<.89 )\r\n\t{\r\n\t\tfloat t1 = 0., t2 = 0., seed = uv.x*uv.y+uv.y+uv.x+fract(iTime);\r\n\t\tvec3 ro1 = vec3(0, 0, -.1),\r\n\t\t\trd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.y/1.8, 1)),\r\n\t\t\tscol=vec3(0), m1, m2, nor1, pos1, pos2;\r\n\r\n\t\t// camera angle\r\n\t\tvec2 ca=vec2(.1, .07)*cb(8), e = vec2(0, .0001);\r\n\t\tpR(ro1.zy, ca.y); pR(rd1.zy, ca.y);\r\n\t\tpR(ro1.zx, ca.x); pR(rd1.zx, ca.x);\r\n\t\tro1.z-=camz;\r\n\r\n\t\tlpos3 = normalize(mix(vec3(.5, 1, 0), vec3(0, -1, 0), sat(destr)));\r\n\r\n\t\tt1 = .2*fract(seed);\r\n\r\n\t\tfor( int i = 0; i < QN; i++ )\r\n\t\t{\r\n\t\t\tpos1 = ro1+rd1*t1;\r\n\t\t\tm1 = map(pos1);\r\n\t\t\tt1+=QNs*m1.x;\r\n\r\n\t\t\tif( m1.x<.005 )\r\n\t\t\t{\r\n\t\t\t\tif( m1.z<0. )\r\n\t\t\t\t\tscol+= vec3(1.+m1.z, 1., 1.-m1.z)*step(1., m1.y)*float(QN-i);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tpos2=pos1+mix(lpos3, hashHs(lpos3, seed), .04)*t2;\r\n\t\t\tm2 = map(pos2);\r\n\t\t\tt2+=m2.x;\r\n\r\n\t\t\tscol +=\r\n\t\t\t\tmax(0., m1.z) +\r\n\t\t\t\tvec3(1.+m1.z, 1., 1.-m1.z)*max(0., m1.y-1.) +\r\n\t\t\t\t(.5+5.*m1.x*noise(7.*pos1+vec3(iTime)))*max(0., m2.y-1.)*(1.-cb(12));\r\n\t\t}\r\n\t\tscol *= QNq;\r\n\r\n\t\tnor1 = normalize(m1.x-vec3(map(pos1 - e.yxx).x, map(pos1 - e.xyx).x, map(pos1 - e.xxy).x));\r\n\r\n\t\tt2=1.;\r\n\t\tfor( int i = 0; i < QD; i++ )\r\n\t\t{\r\n\t\t\tpos2 = pos1 + mix(reflect(rd1, nor1), hashHs(nor1, seed), sat(m1.y))*t2;\r\n\t\t\tm2 = map(pos2);\r\n\t\t\tt2+=QDs*m2.x;\r\n\r\n\t\t\tscol += vec3(1.+m2.z, 1., 1.-m2.z)*max(0., m2.y-1.)*QDq;\r\n\r\n\t\t}\r\n\t\tscol=clamp(scol, 0., 1.)\r\n\t\t\t*sat(cb(14)+15.*sprog)\r\n\t\t\t*sat(cb(13)+5.-5.*sprog)\r\n\t\t\t-float(iA.y==128)\r\n\t\t\t;\r\n        fragColor = scol.xyzz;\r\n\t\t//fragColor = mix(scol.xyzz, texture(iChannel0, uv), pow(.0001, iTimeDelta));\r\n\t}\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Found this on GLSL sandbox. I really liked it, changed a few things and made it tileable.\r\n// :)\r\n// by David Hoskins.\r\n\r\n\r\n// Water turbulence effect by joltz0r 2013-07-04, improved 2013-07-07\r\n\r\n\r\n// Redefine below to see the tiling...\r\n//#define SHOW_TILING\r\n\r\n#define TAU 6.28318530718\r\n#define MAX_ITER 5\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n\tfloat time = iTime * .5+23.0;\r\n    // uv should be the 0-1 uv of texture...\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n#ifdef SHOW_TILING\r\n\tvec2 p = mod(uv*TAU*2.0, TAU)-250.0;\r\n#else\r\n    vec2 p = mod(uv*TAU, TAU)-250.0;\r\n#endif\r\n\tvec2 i = vec2(p);\r\n\tfloat c = 1.0;\r\n\tfloat inten = .005;\r\n\r\n\tfor (int n = 0; n < MAX_ITER; n++) \r\n\t{\r\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\r\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\r\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\r\n\t}\r\n\tc /= float(MAX_ITER);\r\n\tc = 1.17-pow(c, 1.4);\r\n\tvec3 colour = vec3(pow(abs(c), 8.0));\r\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\r\n    \r\n\r\n\t#ifdef SHOW_TILING\r\n\t// Flash tile borders...\r\n\tvec2 pixel = 2.0 / iResolution.xy;\r\n\tuv *= 2.0;\r\n\r\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\r\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\r\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\r\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\r\n\t\r\n\t#endif\r\n\tfragColor = vec4(colour, 1.0);\r\n}","inputs":[],"outputs":[],"code":"// Found this on GLSL sandbox. I really liked it, changed a few things and made it tileable.\r\n// :)\r\n// by David Hoskins.\r\n\r\n\r\n// Water turbulence effect by joltz0r 2013-07-04, improved 2013-07-07\r\n\r\n\r\n// Redefine below to see the tiling...\r\n//#define SHOW_TILING\r\n\r\n#define TAU 6.28318530718\r\n#define MAX_ITER 5\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n\tfloat time = iTime * .5+23.0;\r\n    // uv should be the 0-1 uv of texture...\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n#ifdef SHOW_TILING\r\n\tvec2 p = mod(uv*TAU*2.0, TAU)-250.0;\r\n#else\r\n    vec2 p = mod(uv*TAU, TAU)-250.0;\r\n#endif\r\n\tvec2 i = vec2(p);\r\n\tfloat c = 1.0;\r\n\tfloat inten = .005;\r\n\r\n\tfor (int n = 0; n < MAX_ITER; n++) \r\n\t{\r\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\r\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\r\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\r\n\t}\r\n\tc /= float(MAX_ITER);\r\n\tc = 1.17-pow(c, 1.4);\r\n\tvec3 colour = vec3(pow(abs(c), 8.0));\r\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\r\n    \r\n\r\n\t#ifdef SHOW_TILING\r\n\t// Flash tile borders...\r\n\tvec2 pixel = 2.0 / iResolution.xy;\r\n\tuv *= 2.0;\r\n\r\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\r\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\r\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\r\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\r\n\t\r\n\t#endif\r\n\tfragColor = vec4(colour, 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Tileable Water Caustic","id":"d1de38029d824e8b84d97adcb9fb5a05","date":null,"viewed":0,"name":"Tileable Water Caustic","description":"Found this on GLSL sandbox. I really liked it, changed a few things and made it tile-able. \nCheck out the #define to see the tiling.\nSee it full-screen if you can.\nhttps://www.shadertoy.com/view/MdlXz8","likes":0,"published":null,"tags":["water"," caustic"]},"ver":null,"info":{"Name":"Tileable Water Caustic","id":"d1de38029d824e8b84d97adcb9fb5a05","date":null,"viewed":0,"name":"Tileable Water Caustic","description":"Found this on GLSL sandbox. I really liked it, changed a few things and made it tile-able. \nCheck out the #define to see the tiling.\nSee it full-screen if you can.\nhttps://www.shadertoy.com/view/MdlXz8","likes":0,"published":null,"tags":["water"," caustic"]},"renderpass":[{"Code":"// Found this on GLSL sandbox. I really liked it, changed a few things and made it tileable.\r\n// :)\r\n// by David Hoskins.\r\n\r\n\r\n// Water turbulence effect by joltz0r 2013-07-04, improved 2013-07-07\r\n\r\n\r\n// Redefine below to see the tiling...\r\n//#define SHOW_TILING\r\n\r\n#define TAU 6.28318530718\r\n#define MAX_ITER 5\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n\tfloat time = iTime * .5+23.0;\r\n    // uv should be the 0-1 uv of texture...\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n#ifdef SHOW_TILING\r\n\tvec2 p = mod(uv*TAU*2.0, TAU)-250.0;\r\n#else\r\n    vec2 p = mod(uv*TAU, TAU)-250.0;\r\n#endif\r\n\tvec2 i = vec2(p);\r\n\tfloat c = 1.0;\r\n\tfloat inten = .005;\r\n\r\n\tfor (int n = 0; n < MAX_ITER; n++) \r\n\t{\r\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\r\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\r\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\r\n\t}\r\n\tc /= float(MAX_ITER);\r\n\tc = 1.17-pow(c, 1.4);\r\n\tvec3 colour = vec3(pow(abs(c), 8.0));\r\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\r\n    \r\n\r\n\t#ifdef SHOW_TILING\r\n\t// Flash tile borders...\r\n\tvec2 pixel = 2.0 / iResolution.xy;\r\n\tuv *= 2.0;\r\n\r\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\r\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\r\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\r\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\r\n\t\r\n\t#endif\r\n\tfragColor = vec4(colour, 1.0);\r\n}","inputs":[],"outputs":[],"code":"// Found this on GLSL sandbox. I really liked it, changed a few things and made it tileable.\r\n// :)\r\n// by David Hoskins.\r\n\r\n\r\n// Water turbulence effect by joltz0r 2013-07-04, improved 2013-07-07\r\n\r\n\r\n// Redefine below to see the tiling...\r\n//#define SHOW_TILING\r\n\r\n#define TAU 6.28318530718\r\n#define MAX_ITER 5\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n\tfloat time = iTime * .5+23.0;\r\n    // uv should be the 0-1 uv of texture...\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n#ifdef SHOW_TILING\r\n\tvec2 p = mod(uv*TAU*2.0, TAU)-250.0;\r\n#else\r\n    vec2 p = mod(uv*TAU, TAU)-250.0;\r\n#endif\r\n\tvec2 i = vec2(p);\r\n\tfloat c = 1.0;\r\n\tfloat inten = .005;\r\n\r\n\tfor (int n = 0; n < MAX_ITER; n++) \r\n\t{\r\n\t\tfloat t = time * (1.0 - (3.5 / float(n+1)));\r\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\r\n\t\tc += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\r\n\t}\r\n\tc /= float(MAX_ITER);\r\n\tc = 1.17-pow(c, 1.4);\r\n\tvec3 colour = vec3(pow(abs(c), 8.0));\r\n    colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\r\n    \r\n\r\n\t#ifdef SHOW_TILING\r\n\t// Flash tile borders...\r\n\tvec2 pixel = 2.0 / iResolution.xy;\r\n\tuv *= 2.0;\r\n\r\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\r\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\r\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\r\n\tcolour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\r\n\t\r\n\t#endif\r\n\tfragColor = vec4(colour, 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//**************************************************************************************************\r\n// There\u00B4s something under the surface\r\n// Just testing enhanced sphere tracing: lgdv.cs.fau.de/get/2234\r\n// Implemented by chronos in www.shadertoy.com/view/4lj3zK\r\n\r\n// Soundtrack \"System malfunction\" done with 64klang\r\n\r\n//**************************************************************************************************\r\n\r\nfloat sminPoly( float a, float b, float k )\r\n{\r\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n    return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\n\r\nfloat vmax(vec3 v) {\r\n\treturn max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n\tvec3 d = abs(p) - b;\r\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pModGrid2(inout vec2 p, vec2 size) {\r\n\tvec2 c = floor((p + size*0.5)/size);\r\n\tp = mod(p + size*0.5, size) - size*0.5;\r\n\tp *= mod(c,vec2(2))*2. - vec2(1);\r\n\tp -= size/2.;\r\n\tif (p.x > p.y) p.xy = p.yx;\r\n\treturn floor(c/2.);\r\n}\r\n\r\nvec2 ku=vec2(0.);\r\n\r\nfloat sdPlane(vec3 p) \r\n{\r\nreturn p.y+(0.002*sin(p.x*110.))+(0.002*sin(p.z*112.))-0.3-0.1*sin(2.*iTime+2.*p.z);\r\n}\r\n\r\nfloat fField2(vec3 p) \r\n{\r\n\tvec2 q = pModGrid2(p.xz,vec2(0.8));\r\n\tpR(p.xz,iTime*0.11);\r\n\tvec2 q2 = pModGrid2(p.xz,vec2(0.7));\r\n\tpR(p.xy,iTime*0.134);\r\n\tfloat box = fBox(p-vec3(0),vec3(0.6))-0.08;\r\n\tku=q; return box;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    return sminPoly(fField2(p),sdPlane(p),-0.01);\r\n}\r\n\r\nfloat shadowsoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\r\n{\r\n\tfloat t = mint;\r\n\tfloat res = 1.0;\r\n    for ( int i = 0; i < 28; ++i )\r\n    {\r\n        float h = map( ro + rd * t );\r\n        if ( h < 0.001 ) return 0.0;\r\n\t\tres = min( res, k * h / t );\r\n        t += h;\r\n\t\tif ( t > maxt )\r\n\t\t\tbreak;\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps=0.0001;\r\n\tfloat d=map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\nfloat castRay(in vec3 ray_origin, in vec3 ray_direction, in bool inside) {\r\n    float relaxation = 1.5;// range [1.0, 2.0]\r\n    float distance_min =  0.1;\r\n    float distance_max = 12.0;\r\n    float precis   = 0.0005;\r\n    float distance = distance_min;\r\n    float previous_radius = 0.0;\r\n    float stepLength = 0.0;\r\n    float function_sign = 1.0;\r\n    if(map(ray_origin) < 0.0) function_sign = -1.0;\r\n    \r\n\tfor(int i = 0; i < 60; i++ ) {\r\n        float result; \r\n        if (inside==false) result = map(ray_origin + ray_direction * distance);\r\n        else result = -map(ray_origin + ray_direction * distance);\r\n        float signed_radius = function_sign * result;\r\n        float radius = abs(signed_radius);\r\n        \r\n        bool sorFail = relaxation > 1.0 && (radius + previous_radius) < stepLength;\r\n        if(sorFail) {\r\n        \tstepLength -= relaxation * stepLength; // revert last step\r\n            relaxation = 1.0;\r\n        } else {\r\n        \tstepLength = signed_radius * relaxation;   \r\n        }\r\n        previous_radius = radius;\r\n        if(!sorFail && radius < precis || distance > distance_max ) break;\r\n        distance += stepLength;\r\n    }\r\n    return  distance;\r\n\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n    vec2 uv,p;\r\n\tuv.xy = gl_FragCoord.xy /iResolution.xy; p = uv * 2.0 - 1.0;\r\n   \r\n//  cam    \r\n\tp.x *= iResolution.x /iResolution.y;\r\n\tfloat theta = sin(iTime*0.1) * 6.28;\r\n    float x = 3.0 * cos(theta); \r\n    float z = 3.0 * sin(theta); \r\n\tvec3 ro = vec3(x*2.2, 5.0+2.*sin((iTime+37.)*0.15), z*1.4);\t\t\r\n\r\n\tvec3 cw = normalize(vec3(0., 0.25, 0.) - ro);\r\n    vec3 cp = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = normalize(cross(cw, cp));\r\n    vec3 cv = normalize(cross(cu, cw));\r\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\r\n\r\n// \trender:\r\n    vec3 col= vec3(0.0);\r\n    float t = castRay(ro,rd,false);\r\n\tvec3 pos = ro + rd *t;\r\n\tvec3 nor = calcNormal(pos);\r\n\tvec3 ligvec = vec3(-0.5, 0.5, 0.5);\r\n\tvec3 lig = normalize(ligvec);\t\r\n\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\r\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\r\n\tcol = vec3(0.2*dif+1.*spec);\r\n    \r\n    float sh = shadowsoft(pos,lig,0.01,0.2,1.2); \r\n    col *= clamp(sh, 0.0, 1.0);\r\n\r\n\r\n//  refraction\r\n\tvec3 rd2 = refract(rd,nor,0.77);  \r\n    float t2 = castRay(pos,rd2,true);\r\n\tvec3 pos2 = pos + rd2* t2;\r\n    vec3 nor2 = calcNormal(pos2);\r\n\tfloat dif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    col.r += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n\trd2 = refract(rd,nor,0.83);\r\n    t2 = castRay(pos,rd2,true);\r\n\tpos2 = pos + rd2* t2;\r\n    nor2 = calcNormal(pos2);\r\n\tdif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    col.b += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n\trd2 = refract(rd,nor,0.8);\r\n    t2 = castRay(pos,rd2,true);\r\n\tpos2 = pos + rd2* t2;\r\n    nor2 = calcNormal(pos2);\r\n\tdif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    float spec2 = pow(clamp(dot(reflect(rd2, nor2), lig), 0.0, 1.0), 16.0);\r\n    col.g += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n    col +=0.3*spec2;\r\n    col *= clamp(sh, 0.8, 1.0);\r\n\r\n\tvec3 ro3 = pos2+rd; \r\n\tvec3 rd3 = rd2+0.05;\r\n    float t3 = castRay(ro3,rd3,false);\r\n\tvec3 pos3 = ro3 + rd3* t3;\r\n    vec3 nor3 = calcNormal(pos3);\r\n\tfloat dif3 = clamp(dot(lig, -nor3), 0.0, 1.0);\r\n    col-= 0.2*(1.-dif3);\r\n    col += 0.1*texture(iChannel0, vec2(0., 0.)).xyz;\r\n    col = mix(col, vec3(0.4,0.5,0.5), ku.y*0.2*t2);\r\n    fragColor = vec4(col, 1.0);\r\n\r\n}\r\n\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"//**************************************************************************************************\r\n// There\u00B4s something under the surface\r\n// Just testing enhanced sphere tracing: lgdv.cs.fau.de/get/2234\r\n// Implemented by chronos in www.shadertoy.com/view/4lj3zK\r\n\r\n// Soundtrack \"System malfunction\" done with 64klang\r\n\r\n//**************************************************************************************************\r\n\r\nfloat sminPoly( float a, float b, float k )\r\n{\r\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n    return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\n\r\nfloat vmax(vec3 v) {\r\n\treturn max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n\tvec3 d = abs(p) - b;\r\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pModGrid2(inout vec2 p, vec2 size) {\r\n\tvec2 c = floor((p + size*0.5)/size);\r\n\tp = mod(p + size*0.5, size) - size*0.5;\r\n\tp *= mod(c,vec2(2))*2. - vec2(1);\r\n\tp -= size/2.;\r\n\tif (p.x > p.y) p.xy = p.yx;\r\n\treturn floor(c/2.);\r\n}\r\n\r\nvec2 ku=vec2(0.);\r\n\r\nfloat sdPlane(vec3 p) \r\n{\r\nreturn p.y+(0.002*sin(p.x*110.))+(0.002*sin(p.z*112.))-0.3-0.1*sin(2.*iTime+2.*p.z);\r\n}\r\n\r\nfloat fField2(vec3 p) \r\n{\r\n\tvec2 q = pModGrid2(p.xz,vec2(0.8));\r\n\tpR(p.xz,iTime*0.11);\r\n\tvec2 q2 = pModGrid2(p.xz,vec2(0.7));\r\n\tpR(p.xy,iTime*0.134);\r\n\tfloat box = fBox(p-vec3(0),vec3(0.6))-0.08;\r\n\tku=q; return box;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    return sminPoly(fField2(p),sdPlane(p),-0.01);\r\n}\r\n\r\nfloat shadowsoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\r\n{\r\n\tfloat t = mint;\r\n\tfloat res = 1.0;\r\n    for ( int i = 0; i < 28; ++i )\r\n    {\r\n        float h = map( ro + rd * t );\r\n        if ( h < 0.001 ) return 0.0;\r\n\t\tres = min( res, k * h / t );\r\n        t += h;\r\n\t\tif ( t > maxt )\r\n\t\t\tbreak;\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps=0.0001;\r\n\tfloat d=map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\nfloat castRay(in vec3 ray_origin, in vec3 ray_direction, in bool inside) {\r\n    float relaxation = 1.5;// range [1.0, 2.0]\r\n    float distance_min =  0.1;\r\n    float distance_max = 12.0;\r\n    float precis   = 0.0005;\r\n    float distance = distance_min;\r\n    float previous_radius = 0.0;\r\n    float stepLength = 0.0;\r\n    float function_sign = 1.0;\r\n    if(map(ray_origin) < 0.0) function_sign = -1.0;\r\n    \r\n\tfor(int i = 0; i < 60; i++ ) {\r\n        float result; \r\n        if (inside==false) result = map(ray_origin + ray_direction * distance);\r\n        else result = -map(ray_origin + ray_direction * distance);\r\n        float signed_radius = function_sign * result;\r\n        float radius = abs(signed_radius);\r\n        \r\n        bool sorFail = relaxation > 1.0 && (radius + previous_radius) < stepLength;\r\n        if(sorFail) {\r\n        \tstepLength -= relaxation * stepLength; // revert last step\r\n            relaxation = 1.0;\r\n        } else {\r\n        \tstepLength = signed_radius * relaxation;   \r\n        }\r\n        previous_radius = radius;\r\n        if(!sorFail && radius < precis || distance > distance_max ) break;\r\n        distance += stepLength;\r\n    }\r\n    return  distance;\r\n\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n    vec2 uv,p;\r\n\tuv.xy = gl_FragCoord.xy /iResolution.xy; p = uv * 2.0 - 1.0;\r\n   \r\n//  cam    \r\n\tp.x *= iResolution.x /iResolution.y;\r\n\tfloat theta = sin(iTime*0.1) * 6.28;\r\n    float x = 3.0 * cos(theta); \r\n    float z = 3.0 * sin(theta); \r\n\tvec3 ro = vec3(x*2.2, 5.0+2.*sin((iTime+37.)*0.15), z*1.4);\t\t\r\n\r\n\tvec3 cw = normalize(vec3(0., 0.25, 0.) - ro);\r\n    vec3 cp = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = normalize(cross(cw, cp));\r\n    vec3 cv = normalize(cross(cu, cw));\r\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\r\n\r\n// \trender:\r\n    vec3 col= vec3(0.0);\r\n    float t = castRay(ro,rd,false);\r\n\tvec3 pos = ro + rd *t;\r\n\tvec3 nor = calcNormal(pos);\r\n\tvec3 ligvec = vec3(-0.5, 0.5, 0.5);\r\n\tvec3 lig = normalize(ligvec);\t\r\n\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\r\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\r\n\tcol = vec3(0.2*dif+1.*spec);\r\n    \r\n    float sh = shadowsoft(pos,lig,0.01,0.2,1.2); \r\n    col *= clamp(sh, 0.0, 1.0);\r\n\r\n\r\n//  refraction\r\n\tvec3 rd2 = refract(rd,nor,0.77);  \r\n    float t2 = castRay(pos,rd2,true);\r\n\tvec3 pos2 = pos + rd2* t2;\r\n    vec3 nor2 = calcNormal(pos2);\r\n\tfloat dif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    col.r += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n\trd2 = refract(rd,nor,0.83);\r\n    t2 = castRay(pos,rd2,true);\r\n\tpos2 = pos + rd2* t2;\r\n    nor2 = calcNormal(pos2);\r\n\tdif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    col.b += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n\trd2 = refract(rd,nor,0.8);\r\n    t2 = castRay(pos,rd2,true);\r\n\tpos2 = pos + rd2* t2;\r\n    nor2 = calcNormal(pos2);\r\n\tdif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    float spec2 = pow(clamp(dot(reflect(rd2, nor2), lig), 0.0, 1.0), 16.0);\r\n    col.g += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n    col +=0.3*spec2;\r\n    col *= clamp(sh, 0.8, 1.0);\r\n\r\n\tvec3 ro3 = pos2+rd; \r\n\tvec3 rd3 = rd2+0.05;\r\n    float t3 = castRay(ro3,rd3,false);\r\n\tvec3 pos3 = ro3 + rd3* t3;\r\n    vec3 nor3 = calcNormal(pos3);\r\n\tfloat dif3 = clamp(dot(lig, -nor3), 0.0, 1.0);\r\n    col-= 0.2*(1.-dif3);\r\n    col += 0.1*texture(iChannel0, vec2(0., 0.)).xyz;\r\n    col = mix(col, vec3(0.4,0.5,0.5), ku.y*0.2*t2);\r\n    fragColor = vec4(col, 1.0);\r\n\r\n}\r\n\r\n\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Under the surface","id":"e531fbbcae944bc18dbdae94d68856ea","date":null,"viewed":0,"name":"Under the surface","description":"There is something under the surface\nJust testing enhanced sphere tracing: lgdv.cs.fau.de/get/2234\nImplemented by chronos in www.shadertoy.com/view/4lj3zK\nhttps://www.shadertoy.com/view/Xtc3DM","likes":0,"published":null,"tags":["spheretracing"," relaxed"," enhanced"," 64klang"]},"ver":null,"info":{"Name":"Under the surface","id":"e531fbbcae944bc18dbdae94d68856ea","date":null,"viewed":0,"name":"Under the surface","description":"There is something under the surface\nJust testing enhanced sphere tracing: lgdv.cs.fau.de/get/2234\nImplemented by chronos in www.shadertoy.com/view/4lj3zK\nhttps://www.shadertoy.com/view/Xtc3DM","likes":0,"published":null,"tags":["spheretracing"," relaxed"," enhanced"," 64klang"]},"renderpass":[{"Code":"//**************************************************************************************************\r\n// There\u00B4s something under the surface\r\n// Just testing enhanced sphere tracing: lgdv.cs.fau.de/get/2234\r\n// Implemented by chronos in www.shadertoy.com/view/4lj3zK\r\n\r\n// Soundtrack \"System malfunction\" done with 64klang\r\n\r\n//**************************************************************************************************\r\n\r\nfloat sminPoly( float a, float b, float k )\r\n{\r\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n    return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\n\r\nfloat vmax(vec3 v) {\r\n\treturn max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n\tvec3 d = abs(p) - b;\r\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pModGrid2(inout vec2 p, vec2 size) {\r\n\tvec2 c = floor((p + size*0.5)/size);\r\n\tp = mod(p + size*0.5, size) - size*0.5;\r\n\tp *= mod(c,vec2(2))*2. - vec2(1);\r\n\tp -= size/2.;\r\n\tif (p.x > p.y) p.xy = p.yx;\r\n\treturn floor(c/2.);\r\n}\r\n\r\nvec2 ku=vec2(0.);\r\n\r\nfloat sdPlane(vec3 p) \r\n{\r\nreturn p.y+(0.002*sin(p.x*110.))+(0.002*sin(p.z*112.))-0.3-0.1*sin(2.*iTime+2.*p.z);\r\n}\r\n\r\nfloat fField2(vec3 p) \r\n{\r\n\tvec2 q = pModGrid2(p.xz,vec2(0.8));\r\n\tpR(p.xz,iTime*0.11);\r\n\tvec2 q2 = pModGrid2(p.xz,vec2(0.7));\r\n\tpR(p.xy,iTime*0.134);\r\n\tfloat box = fBox(p-vec3(0),vec3(0.6))-0.08;\r\n\tku=q; return box;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    return sminPoly(fField2(p),sdPlane(p),-0.01);\r\n}\r\n\r\nfloat shadowsoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\r\n{\r\n\tfloat t = mint;\r\n\tfloat res = 1.0;\r\n    for ( int i = 0; i < 28; ++i )\r\n    {\r\n        float h = map( ro + rd * t );\r\n        if ( h < 0.001 ) return 0.0;\r\n\t\tres = min( res, k * h / t );\r\n        t += h;\r\n\t\tif ( t > maxt )\r\n\t\t\tbreak;\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps=0.0001;\r\n\tfloat d=map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\nfloat castRay(in vec3 ray_origin, in vec3 ray_direction, in bool inside) {\r\n    float relaxation = 1.5;// range [1.0, 2.0]\r\n    float distance_min =  0.1;\r\n    float distance_max = 12.0;\r\n    float precis   = 0.0005;\r\n    float distance = distance_min;\r\n    float previous_radius = 0.0;\r\n    float stepLength = 0.0;\r\n    float function_sign = 1.0;\r\n    if(map(ray_origin) < 0.0) function_sign = -1.0;\r\n    \r\n\tfor(int i = 0; i < 60; i++ ) {\r\n        float result; \r\n        if (inside==false) result = map(ray_origin + ray_direction * distance);\r\n        else result = -map(ray_origin + ray_direction * distance);\r\n        float signed_radius = function_sign * result;\r\n        float radius = abs(signed_radius);\r\n        \r\n        bool sorFail = relaxation > 1.0 && (radius + previous_radius) < stepLength;\r\n        if(sorFail) {\r\n        \tstepLength -= relaxation * stepLength; // revert last step\r\n            relaxation = 1.0;\r\n        } else {\r\n        \tstepLength = signed_radius * relaxation;   \r\n        }\r\n        previous_radius = radius;\r\n        if(!sorFail && radius < precis || distance > distance_max ) break;\r\n        distance += stepLength;\r\n    }\r\n    return  distance;\r\n\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n    vec2 uv,p;\r\n\tuv.xy = gl_FragCoord.xy /iResolution.xy; p = uv * 2.0 - 1.0;\r\n   \r\n//  cam    \r\n\tp.x *= iResolution.x /iResolution.y;\r\n\tfloat theta = sin(iTime*0.1) * 6.28;\r\n    float x = 3.0 * cos(theta); \r\n    float z = 3.0 * sin(theta); \r\n\tvec3 ro = vec3(x*2.2, 5.0+2.*sin((iTime+37.)*0.15), z*1.4);\t\t\r\n\r\n\tvec3 cw = normalize(vec3(0., 0.25, 0.) - ro);\r\n    vec3 cp = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = normalize(cross(cw, cp));\r\n    vec3 cv = normalize(cross(cu, cw));\r\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\r\n\r\n// \trender:\r\n    vec3 col= vec3(0.0);\r\n    float t = castRay(ro,rd,false);\r\n\tvec3 pos = ro + rd *t;\r\n\tvec3 nor = calcNormal(pos);\r\n\tvec3 ligvec = vec3(-0.5, 0.5, 0.5);\r\n\tvec3 lig = normalize(ligvec);\t\r\n\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\r\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\r\n\tcol = vec3(0.2*dif+1.*spec);\r\n    \r\n    float sh = shadowsoft(pos,lig,0.01,0.2,1.2); \r\n    col *= clamp(sh, 0.0, 1.0);\r\n\r\n\r\n//  refraction\r\n\tvec3 rd2 = refract(rd,nor,0.77);  \r\n    float t2 = castRay(pos,rd2,true);\r\n\tvec3 pos2 = pos + rd2* t2;\r\n    vec3 nor2 = calcNormal(pos2);\r\n\tfloat dif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    col.r += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n\trd2 = refract(rd,nor,0.83);\r\n    t2 = castRay(pos,rd2,true);\r\n\tpos2 = pos + rd2* t2;\r\n    nor2 = calcNormal(pos2);\r\n\tdif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    col.b += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n\trd2 = refract(rd,nor,0.8);\r\n    t2 = castRay(pos,rd2,true);\r\n\tpos2 = pos + rd2* t2;\r\n    nor2 = calcNormal(pos2);\r\n\tdif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    float spec2 = pow(clamp(dot(reflect(rd2, nor2), lig), 0.0, 1.0), 16.0);\r\n    col.g += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n    col +=0.3*spec2;\r\n    col *= clamp(sh, 0.8, 1.0);\r\n\r\n\tvec3 ro3 = pos2+rd; \r\n\tvec3 rd3 = rd2+0.05;\r\n    float t3 = castRay(ro3,rd3,false);\r\n\tvec3 pos3 = ro3 + rd3* t3;\r\n    vec3 nor3 = calcNormal(pos3);\r\n\tfloat dif3 = clamp(dot(lig, -nor3), 0.0, 1.0);\r\n    col-= 0.2*(1.-dif3);\r\n    col += 0.1*texture(iChannel0, vec2(0., 0.)).xyz;\r\n    col = mix(col, vec3(0.4,0.5,0.5), ku.y*0.2*t2);\r\n    fragColor = vec4(col, 1.0);\r\n\r\n}\r\n\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"//**************************************************************************************************\r\n// There\u00B4s something under the surface\r\n// Just testing enhanced sphere tracing: lgdv.cs.fau.de/get/2234\r\n// Implemented by chronos in www.shadertoy.com/view/4lj3zK\r\n\r\n// Soundtrack \"System malfunction\" done with 64klang\r\n\r\n//**************************************************************************************************\r\n\r\nfloat sminPoly( float a, float b, float k )\r\n{\r\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n    return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\n\r\nfloat vmax(vec3 v) {\r\n\treturn max(max(v.x, v.y), v.z);\r\n}\r\n\r\nfloat fBox(vec3 p, vec3 b) {\r\n\tvec3 d = abs(p) - b;\r\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nvec2 pModGrid2(inout vec2 p, vec2 size) {\r\n\tvec2 c = floor((p + size*0.5)/size);\r\n\tp = mod(p + size*0.5, size) - size*0.5;\r\n\tp *= mod(c,vec2(2))*2. - vec2(1);\r\n\tp -= size/2.;\r\n\tif (p.x > p.y) p.xy = p.yx;\r\n\treturn floor(c/2.);\r\n}\r\n\r\nvec2 ku=vec2(0.);\r\n\r\nfloat sdPlane(vec3 p) \r\n{\r\nreturn p.y+(0.002*sin(p.x*110.))+(0.002*sin(p.z*112.))-0.3-0.1*sin(2.*iTime+2.*p.z);\r\n}\r\n\r\nfloat fField2(vec3 p) \r\n{\r\n\tvec2 q = pModGrid2(p.xz,vec2(0.8));\r\n\tpR(p.xz,iTime*0.11);\r\n\tvec2 q2 = pModGrid2(p.xz,vec2(0.7));\r\n\tpR(p.xy,iTime*0.134);\r\n\tfloat box = fBox(p-vec3(0),vec3(0.6))-0.08;\r\n\tku=q; return box;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    return sminPoly(fField2(p),sdPlane(p),-0.01);\r\n}\r\n\r\nfloat shadowsoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\r\n{\r\n\tfloat t = mint;\r\n\tfloat res = 1.0;\r\n    for ( int i = 0; i < 28; ++i )\r\n    {\r\n        float h = map( ro + rd * t );\r\n        if ( h < 0.001 ) return 0.0;\r\n\t\tres = min( res, k * h / t );\r\n        t += h;\r\n\t\tif ( t > maxt )\r\n\t\t\tbreak;\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\nvec3 calcNormal(vec3 pos)\r\n{\r\n    float eps=0.0001;\r\n\tfloat d=map(pos);\r\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\r\n}\r\n\r\nfloat castRay(in vec3 ray_origin, in vec3 ray_direction, in bool inside) {\r\n    float relaxation = 1.5;// range [1.0, 2.0]\r\n    float distance_min =  0.1;\r\n    float distance_max = 12.0;\r\n    float precis   = 0.0005;\r\n    float distance = distance_min;\r\n    float previous_radius = 0.0;\r\n    float stepLength = 0.0;\r\n    float function_sign = 1.0;\r\n    if(map(ray_origin) < 0.0) function_sign = -1.0;\r\n    \r\n\tfor(int i = 0; i < 60; i++ ) {\r\n        float result; \r\n        if (inside==false) result = map(ray_origin + ray_direction * distance);\r\n        else result = -map(ray_origin + ray_direction * distance);\r\n        float signed_radius = function_sign * result;\r\n        float radius = abs(signed_radius);\r\n        \r\n        bool sorFail = relaxation > 1.0 && (radius + previous_radius) < stepLength;\r\n        if(sorFail) {\r\n        \tstepLength -= relaxation * stepLength; // revert last step\r\n            relaxation = 1.0;\r\n        } else {\r\n        \tstepLength = signed_radius * relaxation;   \r\n        }\r\n        previous_radius = radius;\r\n        if(!sorFail && radius < precis || distance > distance_max ) break;\r\n        distance += stepLength;\r\n    }\r\n    return  distance;\r\n\r\n}\r\n\r\n\r\n//***************************************************************************************************\r\n// main\r\n//***************************************************************************************************\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \r\n{\r\n    vec2 uv,p;\r\n\tuv.xy = gl_FragCoord.xy /iResolution.xy; p = uv * 2.0 - 1.0;\r\n   \r\n//  cam    \r\n\tp.x *= iResolution.x /iResolution.y;\r\n\tfloat theta = sin(iTime*0.1) * 6.28;\r\n    float x = 3.0 * cos(theta); \r\n    float z = 3.0 * sin(theta); \r\n\tvec3 ro = vec3(x*2.2, 5.0+2.*sin((iTime+37.)*0.15), z*1.4);\t\t\r\n\r\n\tvec3 cw = normalize(vec3(0., 0.25, 0.) - ro);\r\n    vec3 cp = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = normalize(cross(cw, cp));\r\n    vec3 cv = normalize(cross(cu, cw));\r\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\r\n\r\n// \trender:\r\n    vec3 col= vec3(0.0);\r\n    float t = castRay(ro,rd,false);\r\n\tvec3 pos = ro + rd *t;\r\n\tvec3 nor = calcNormal(pos);\r\n\tvec3 ligvec = vec3(-0.5, 0.5, 0.5);\r\n\tvec3 lig = normalize(ligvec);\t\r\n\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\r\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\r\n\tcol = vec3(0.2*dif+1.*spec);\r\n    \r\n    float sh = shadowsoft(pos,lig,0.01,0.2,1.2); \r\n    col *= clamp(sh, 0.0, 1.0);\r\n\r\n\r\n//  refraction\r\n\tvec3 rd2 = refract(rd,nor,0.77);  \r\n    float t2 = castRay(pos,rd2,true);\r\n\tvec3 pos2 = pos + rd2* t2;\r\n    vec3 nor2 = calcNormal(pos2);\r\n\tfloat dif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    col.r += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n\trd2 = refract(rd,nor,0.83);\r\n    t2 = castRay(pos,rd2,true);\r\n\tpos2 = pos + rd2* t2;\r\n    nor2 = calcNormal(pos2);\r\n\tdif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    col.b += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n\trd2 = refract(rd,nor,0.8);\r\n    t2 = castRay(pos,rd2,true);\r\n\tpos2 = pos + rd2* t2;\r\n    nor2 = calcNormal(pos2);\r\n\tdif2 = clamp(dot(lig, nor2), 0.0, 1.0);\r\n    float spec2 = pow(clamp(dot(reflect(rd2, nor2), lig), 0.0, 1.0), 16.0);\r\n    col.g += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\r\n    col +=0.3*spec2;\r\n    col *= clamp(sh, 0.8, 1.0);\r\n\r\n\tvec3 ro3 = pos2+rd; \r\n\tvec3 rd3 = rd2+0.05;\r\n    float t3 = castRay(ro3,rd3,false);\r\n\tvec3 pos3 = ro3 + rd3* t3;\r\n    vec3 nor3 = calcNormal(pos3);\r\n\tfloat dif3 = clamp(dot(lig, -nor3), 0.0, 1.0);\r\n    col-= 0.2*(1.-dif3);\r\n    col += 0.1*texture(iChannel0, vec2(0., 0.)).xyz;\r\n    col = mix(col, vec3(0.4,0.5,0.5), ku.y*0.2*t2);\r\n    fragColor = vec4(col, 1.0);\r\n\r\n}\r\n\r\n\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// variations on noise \r\n\r\n#define SCALE_LACUNARITY 8. // when exponent is active\r\n#define NOctaves 20.    \t// max scales\r\n#define LimitDetails 2. \t// Anti aliasing\r\n#define ANIM 0\t\t\t\t// Manual / Auto\r\n#define ClampLevel 1.\t\t// Colormap\r\n\r\n\r\n// widgets from https://www.shadertoy.com/view/lsXXzN\r\n\r\nvec2 FragCoord;\r\nvec4 FragColor;\r\n\r\n// --- key toggles -----------------------------------------------------\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- Digit display ----------------------------------------------------\r\n\r\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\r\n\r\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\r\n\r\nfloat segment(vec2 uv, bool On) {\r\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\r\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\r\n\t\t        : 0.;\r\n}\r\n\r\nfloat sevenSegment(vec2 uv,int num) {\r\n\tfloat seg= 0.;\r\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\r\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\r\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\r\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\r\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\r\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\r\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\r\n\treturn seg;\r\n}\r\n\r\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\r\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\r\n\r\n\tif (nr<0) {\r\n\t\tnr = -nr;\r\n\t\tif (uv.x>1.5) {\r\n\t\t\tuv.x -= 2.;\r\n\t\t\treturn segment(uv.yx,true); // <<<< signe. bug\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (uv.x>0.) {\r\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\r\n\t\tuv -= vec2(.75,0.);\r\n\t} else {\r\n\t\tuv += vec2(.75,0.); \r\n\t\tnr = int(mod(float(nr),10.));\r\n\t}\r\n\r\n\treturn sevenSegment(uv,nr);\r\n}\r\n\r\nfloat dots(vec2 uv, int dot) {\r\n\tfloat point0 = float(dot/2),\r\n\t\t  point1 = float(dot)-2.*point0; \r\n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\r\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\r\n\treturn 0.;\r\n}\r\n//    ... end of digits adapted from Andre\r\n\r\n#define STEPX .875\r\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\r\n\r\n// 2digit int + sign\r\nbool display(vec2 pos, float scale, float offset, int number, int dot) { // dot: draw separator\r\n\tvec2 uv = FragCoord.xy/iResolution.y;\r\n\tuv = (uv-pos)/scale*2.; \r\n    uv.x = .5-uv.x + STEPX*offset;\r\n\tuv.y -= 1.;\r\n\t\r\n\tfloat seg = showNum(uv,number,false);\r\n\toffset += 2.;\r\n\t\r\n\tif (dot>0) {\r\n\t\tuv.x += STEPX*offset; \r\n\t\tseg += dots(uv,dot);\r\n\t\toffset += 2.;\r\n\t}\r\n\r\n\tFragColor += seg*vec4(0.,.5,1.,1.);  // change color here\r\n\t_offset = offset;\r\n\treturn (seg>0.);\r\n}\r\n\r\n// 2.2 float + sign\r\nbool display(vec2 pos, float scale, float offset, float val) { // dot: draw separator\r\n\tif (display( pos, scale, 0., int(val), 1)) return true;\r\n    if (display( pos, scale, _offset, int(fract(val)*100.), 0)) return true;\r\n\treturn false;\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {                     // noise in [-1,1]\r\n    // p+= iTime;\r\n    vec2 i = floor(p), f = fract(p);\r\n\tvec2 u = f*f*(3.-2.*f);\r\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \r\n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\r\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \r\n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\r\n}\r\n\r\n\r\nvec3 colormap(float value) {\r\n\tfloat maxv = ClampLevel;\r\n\tvec3 c1,c2;\r\n\tfloat t;\r\n\tif (value < maxv / 3.) {\r\n\t\tc1 = vec3(0.);   \t c2 = vec3(1.,0.,0.); \tt =  1./3.;\r\n\t} else if (value < maxv * 2. / 3.) {\r\n\t\tc1 = vec3(1.,0.,0.); c2 = vec3(1.,1.,.5);\tt =  2./3. ;\r\n\t} else {\r\n\t\tc1 = vec3(1.,1.,.5); c2 = vec3(1.);      \tt =  1.;\r\n\t}\r\n\tt = (t*maxv-value)/(maxv/3.);\r\n\treturn t*c1 + (1.-t)*c2;\r\n}\r\n\r\n// ===============================================================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \r\n    float t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy/ iResolution.y- vec2(.5*iResolution.x/iResolution.y,.5));\r\n\tvec4 mouse = iMouse / iResolution.xyxy;\r\n\tFragCoord=fragCoord;\r\n    FragColor=fragColor=vec4(0);\r\n    \r\n\t// --- tunings ------------------------------\r\n\r\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\r\n\t\r\n #if ANIM\r\n\tfloat cycle = cos(mod(-t,100.)/100.*2.*3.14);\r\n\tfloat zoom = exp(cycle*cycle*20.);\r\n#else\r\n\tfloat zoom = 0.;\r\n\tzoom = (keyToggle(83)) ? abs(mouse.z) : mouse.x ;\r\n\tzoom = exp(-6. + zoom*9.);\r\n#endif\r\n\t\r\n\tif (!keyToggle(68)) { // 'D' : switch on/off display mouse.xy\r\n\t\tvec2 pos ; float scale = 0.1;\r\n        pos = vec2(.2,.8); if (display( pos, scale, 0., mouse.x*100.)) { fragColor=FragColor; return; }\r\n        pos.y -= .15;\t   if (display( pos, scale, 0., mouse.y*100.)) { fragColor=FragColor; return; }\r\n\t}\r\n\t\r\n\tint TYPE = (keyToggle(84)) ? 0 : 1;\t// 0: additive perlin  1: multiplicative perlin\r\n\r\n\r\n\tif (keyToggle(71)) { // 'G' : map on galaxy\r\n\t\tfloat r = length(uv), a = atan(uv.y,uv.x);  // to polar\r\n\t\tif (!keyToggle(64+25)) { // 'Y'\r\n\t\t\tr = 1.*log(r/.1); \t\t\t\t\t\t    // restore aspect ratio\r\n\t\t\ta -= r;           \t\t\t\t\t\t\t// slight slant\r\n\t\t\tuv = vec2(a,2.*r-1.);\r\n\t\t} \r\n\t\telse {\r\n\t\t\ta -= r;\r\n\t\t\tuv = vec2(r*cos(a),r*sin(a));\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (keyToggle(64+23)) { // 'W' : gravity waves ( = galaxy spirals)\r\n#define AMP .1\r\n\t\tfloat phi = 3.*(uv.x-.5*iTime);\r\n\t\tuv.x -= AMP*sin(phi);\r\n\t\tmouse.y = 6.*AMP*(1.+cos(phi))/2.;\r\n\t}\r\n\t\r\n\t// zoom and centering\r\n\tuv *= zoom; \r\n\t\r\n\tif (keyToggle(64+26)) { // 'Z'  mapping reference\r\n\t\tuv *= 8.;\r\n\t\tfloat n = 20.*2.*sign(mod(uv.x,1.)-.5)*sign(mod(uv.y,1.)-.5)-1.;\r\n\t\tfragColor=vec4(n); return;\r\n\t}\r\n\t\r\n\tfloat theta = 4. + float(ANIM)*.01*t; // some rotations, not compulsory\r\n    mat2 m = 2.*mat2( cos(theta),sin(theta), \r\n\t\t\t\t\t -sin(theta),cos(theta) );\r\n\t\t\r\n\t// noise type:   0: smooth  1: abs  2: 1-abs  3: 1/(1+x)\r\n\tint NOISE = ((keyToggle(78))?1:0) + ((keyToggle(66))?2:0);\r\n\t\r\n\t\r\n\t// --- computation of the noise cascade ----------------------------\r\n\t\r\n\tfloat d = (TYPE==0) ? 0.:.5; // density\r\n\tfloat q = zoom;\r\n\t\r\n\tfor (float i = 0.; i < NOctaves; i++) { // cumulates scales from large to small\r\n\t\t\r\n\t\tif (TYPE==1) if(d < 1e-2) continue;\r\n\t\tfloat crit = iResolution.x/(q*LimitDetails)-1.;\r\n\t\tif (crit < 0.) continue; // otherwise, smaller than pixel\r\n\t\r\n\t\t// --- base noise     normalization should ensure constant average\r\n\t\t\r\n\t\tfloat n = noise(uv + 10.*i*i); // base noise [-1,1]\r\n#define GAIN 1. // 5.*mouse.y // 5.\r\n\t\t// n = clamp(GAIN*n,-1.,1.); // to cancel poor stddev\r\n\t\tif (NOISE == 0)\r\n\t\t\tn = (1.+n)*.95; // [0.,1.]\r\n\t\telse if (NOISE == 1)\r\n\t\t\tn = abs(n)*8.5;\r\n\t\telse if (NOISE == 3)\r\n\t\t\tn = (1.-abs(n)) * 1.1;\r\n\t\telse if (NOISE == 2)\r\n\t\t\tn = 1./(1.+n)*.9;\r\n\r\n\t\t\t\r\n\t\t// --- lacunarity ( = vicinity at largest scale )\r\n\t\t\t\r\n\t\tif (keyToggle(69)) // 'E' : mouse.y tune exponent\r\n\t\t{ \r\n\t\t\tfloat P = mouse.y*10.; //  power to control high-scale lacunarity\r\n\t\t\t// lacunarity fall-off with scale.   'S' : mouse.x tune scales of lacunarity\r\n\t\t\tfloat lac = SCALE_LACUNARITY * ( (keyToggle(83)) ? 2.*mouse.x : 1.);\r\n\t\t\tP = 1. + P*exp(-i/lac);\r\n#define FACTOR 1.5\r\n\t\t\tn = clamp(n,0.,FACTOR); \r\n\t\t\tn = pow(n,P); \r\n\t\t}\r\n\t\t\r\n\r\n\t\t// --- fading zone to avoid aliasing\r\n\t\tif (crit<1.)   \r\n\t\t\tn = n*crit + (1.-crit); \r\n\r\n\t\t// --- cumulates cascade bands\r\n\t\tif (TYPE==1)\r\n\t\t\td *= n; \t\t\t// cumulates multiplicatively\r\n\t\telse\r\n\t\t\td += .4*n*zoom/q;   // cumulates additively\r\n\t\t\r\n\t\tuv = m*uv; q*= 2.; // go to the next octave\r\n\t}\r\n\r\n    if (keyToggle(64+9)) // 'I' : reverse\r\n        d = 1.-d;\r\n\tfragColor.xyz = (keyToggle(67)) ?  vec3(d) : colormap(d) ;\r\n    //if (d<0.) fragColor = vec4(0,0,1,0);\r\n    //if (d>1.) fragColor = vec4(1,0,0,0);\r\n}","inputs":[],"outputs":[],"code":"// variations on noise \r\n\r\n#define SCALE_LACUNARITY 8. // when exponent is active\r\n#define NOctaves 20.    \t// max scales\r\n#define LimitDetails 2. \t// Anti aliasing\r\n#define ANIM 0\t\t\t\t// Manual / Auto\r\n#define ClampLevel 1.\t\t// Colormap\r\n\r\n\r\n// widgets from https://www.shadertoy.com/view/lsXXzN\r\n\r\nvec2 FragCoord;\r\nvec4 FragColor;\r\n\r\n// --- key toggles -----------------------------------------------------\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- Digit display ----------------------------------------------------\r\n\r\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\r\n\r\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\r\n\r\nfloat segment(vec2 uv, bool On) {\r\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\r\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\r\n\t\t        : 0.;\r\n}\r\n\r\nfloat sevenSegment(vec2 uv,int num) {\r\n\tfloat seg= 0.;\r\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\r\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\r\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\r\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\r\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\r\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\r\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\r\n\treturn seg;\r\n}\r\n\r\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\r\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\r\n\r\n\tif (nr<0) {\r\n\t\tnr = -nr;\r\n\t\tif (uv.x>1.5) {\r\n\t\t\tuv.x -= 2.;\r\n\t\t\treturn segment(uv.yx,true); // <<<< signe. bug\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (uv.x>0.) {\r\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\r\n\t\tuv -= vec2(.75,0.);\r\n\t} else {\r\n\t\tuv += vec2(.75,0.); \r\n\t\tnr = int(mod(float(nr),10.));\r\n\t}\r\n\r\n\treturn sevenSegment(uv,nr);\r\n}\r\n\r\nfloat dots(vec2 uv, int dot) {\r\n\tfloat point0 = float(dot/2),\r\n\t\t  point1 = float(dot)-2.*point0; \r\n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\r\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\r\n\treturn 0.;\r\n}\r\n//    ... end of digits adapted from Andre\r\n\r\n#define STEPX .875\r\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\r\n\r\n// 2digit int + sign\r\nbool display(vec2 pos, float scale, float offset, int number, int dot) { // dot: draw separator\r\n\tvec2 uv = FragCoord.xy/iResolution.y;\r\n\tuv = (uv-pos)/scale*2.; \r\n    uv.x = .5-uv.x + STEPX*offset;\r\n\tuv.y -= 1.;\r\n\t\r\n\tfloat seg = showNum(uv,number,false);\r\n\toffset += 2.;\r\n\t\r\n\tif (dot>0) {\r\n\t\tuv.x += STEPX*offset; \r\n\t\tseg += dots(uv,dot);\r\n\t\toffset += 2.;\r\n\t}\r\n\r\n\tFragColor += seg*vec4(0.,.5,1.,1.);  // change color here\r\n\t_offset = offset;\r\n\treturn (seg>0.);\r\n}\r\n\r\n// 2.2 float + sign\r\nbool display(vec2 pos, float scale, float offset, float val) { // dot: draw separator\r\n\tif (display( pos, scale, 0., int(val), 1)) return true;\r\n    if (display( pos, scale, _offset, int(fract(val)*100.), 0)) return true;\r\n\treturn false;\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {                     // noise in [-1,1]\r\n    // p+= iTime;\r\n    vec2 i = floor(p), f = fract(p);\r\n\tvec2 u = f*f*(3.-2.*f);\r\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \r\n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\r\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \r\n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\r\n}\r\n\r\n\r\nvec3 colormap(float value) {\r\n\tfloat maxv = ClampLevel;\r\n\tvec3 c1,c2;\r\n\tfloat t;\r\n\tif (value < maxv / 3.) {\r\n\t\tc1 = vec3(0.);   \t c2 = vec3(1.,0.,0.); \tt =  1./3.;\r\n\t} else if (value < maxv * 2. / 3.) {\r\n\t\tc1 = vec3(1.,0.,0.); c2 = vec3(1.,1.,.5);\tt =  2./3. ;\r\n\t} else {\r\n\t\tc1 = vec3(1.,1.,.5); c2 = vec3(1.);      \tt =  1.;\r\n\t}\r\n\tt = (t*maxv-value)/(maxv/3.);\r\n\treturn t*c1 + (1.-t)*c2;\r\n}\r\n\r\n// ===============================================================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \r\n    float t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy/ iResolution.y- vec2(.5*iResolution.x/iResolution.y,.5));\r\n\tvec4 mouse = iMouse / iResolution.xyxy;\r\n\tFragCoord=fragCoord;\r\n    FragColor=fragColor=vec4(0);\r\n    \r\n\t// --- tunings ------------------------------\r\n\r\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\r\n\t\r\n #if ANIM\r\n\tfloat cycle = cos(mod(-t,100.)/100.*2.*3.14);\r\n\tfloat zoom = exp(cycle*cycle*20.);\r\n#else\r\n\tfloat zoom = 0.;\r\n\tzoom = (keyToggle(83)) ? abs(mouse.z) : mouse.x ;\r\n\tzoom = exp(-6. + zoom*9.);\r\n#endif\r\n\t\r\n\tif (!keyToggle(68)) { // 'D' : switch on/off display mouse.xy\r\n\t\tvec2 pos ; float scale = 0.1;\r\n        pos = vec2(.2,.8); if (display( pos, scale, 0., mouse.x*100.)) { fragColor=FragColor; return; }\r\n        pos.y -= .15;\t   if (display( pos, scale, 0., mouse.y*100.)) { fragColor=FragColor; return; }\r\n\t}\r\n\t\r\n\tint TYPE = (keyToggle(84)) ? 0 : 1;\t// 0: additive perlin  1: multiplicative perlin\r\n\r\n\r\n\tif (keyToggle(71)) { // 'G' : map on galaxy\r\n\t\tfloat r = length(uv), a = atan(uv.y,uv.x);  // to polar\r\n\t\tif (!keyToggle(64+25)) { // 'Y'\r\n\t\t\tr = 1.*log(r/.1); \t\t\t\t\t\t    // restore aspect ratio\r\n\t\t\ta -= r;           \t\t\t\t\t\t\t// slight slant\r\n\t\t\tuv = vec2(a,2.*r-1.);\r\n\t\t} \r\n\t\telse {\r\n\t\t\ta -= r;\r\n\t\t\tuv = vec2(r*cos(a),r*sin(a));\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (keyToggle(64+23)) { // 'W' : gravity waves ( = galaxy spirals)\r\n#define AMP .1\r\n\t\tfloat phi = 3.*(uv.x-.5*iTime);\r\n\t\tuv.x -= AMP*sin(phi);\r\n\t\tmouse.y = 6.*AMP*(1.+cos(phi))/2.;\r\n\t}\r\n\t\r\n\t// zoom and centering\r\n\tuv *= zoom; \r\n\t\r\n\tif (keyToggle(64+26)) { // 'Z'  mapping reference\r\n\t\tuv *= 8.;\r\n\t\tfloat n = 20.*2.*sign(mod(uv.x,1.)-.5)*sign(mod(uv.y,1.)-.5)-1.;\r\n\t\tfragColor=vec4(n); return;\r\n\t}\r\n\t\r\n\tfloat theta = 4. + float(ANIM)*.01*t; // some rotations, not compulsory\r\n    mat2 m = 2.*mat2( cos(theta),sin(theta), \r\n\t\t\t\t\t -sin(theta),cos(theta) );\r\n\t\t\r\n\t// noise type:   0: smooth  1: abs  2: 1-abs  3: 1/(1+x)\r\n\tint NOISE = ((keyToggle(78))?1:0) + ((keyToggle(66))?2:0);\r\n\t\r\n\t\r\n\t// --- computation of the noise cascade ----------------------------\r\n\t\r\n\tfloat d = (TYPE==0) ? 0.:.5; // density\r\n\tfloat q = zoom;\r\n\t\r\n\tfor (float i = 0.; i < NOctaves; i++) { // cumulates scales from large to small\r\n\t\t\r\n\t\tif (TYPE==1) if(d < 1e-2) continue;\r\n\t\tfloat crit = iResolution.x/(q*LimitDetails)-1.;\r\n\t\tif (crit < 0.) continue; // otherwise, smaller than pixel\r\n\t\r\n\t\t// --- base noise     normalization should ensure constant average\r\n\t\t\r\n\t\tfloat n = noise(uv + 10.*i*i); // base noise [-1,1]\r\n#define GAIN 1. // 5.*mouse.y // 5.\r\n\t\t// n = clamp(GAIN*n,-1.,1.); // to cancel poor stddev\r\n\t\tif (NOISE == 0)\r\n\t\t\tn = (1.+n)*.95; // [0.,1.]\r\n\t\telse if (NOISE == 1)\r\n\t\t\tn = abs(n)*8.5;\r\n\t\telse if (NOISE == 3)\r\n\t\t\tn = (1.-abs(n)) * 1.1;\r\n\t\telse if (NOISE == 2)\r\n\t\t\tn = 1./(1.+n)*.9;\r\n\r\n\t\t\t\r\n\t\t// --- lacunarity ( = vicinity at largest scale )\r\n\t\t\t\r\n\t\tif (keyToggle(69)) // 'E' : mouse.y tune exponent\r\n\t\t{ \r\n\t\t\tfloat P = mouse.y*10.; //  power to control high-scale lacunarity\r\n\t\t\t// lacunarity fall-off with scale.   'S' : mouse.x tune scales of lacunarity\r\n\t\t\tfloat lac = SCALE_LACUNARITY * ( (keyToggle(83)) ? 2.*mouse.x : 1.);\r\n\t\t\tP = 1. + P*exp(-i/lac);\r\n#define FACTOR 1.5\r\n\t\t\tn = clamp(n,0.,FACTOR); \r\n\t\t\tn = pow(n,P); \r\n\t\t}\r\n\t\t\r\n\r\n\t\t// --- fading zone to avoid aliasing\r\n\t\tif (crit<1.)   \r\n\t\t\tn = n*crit + (1.-crit); \r\n\r\n\t\t// --- cumulates cascade bands\r\n\t\tif (TYPE==1)\r\n\t\t\td *= n; \t\t\t// cumulates multiplicatively\r\n\t\telse\r\n\t\t\td += .4*n*zoom/q;   // cumulates additively\r\n\t\t\r\n\t\tuv = m*uv; q*= 2.; // go to the next octave\r\n\t}\r\n\r\n    if (keyToggle(64+9)) // 'I' : reverse\r\n        d = 1.-d;\r\n\tfragColor.xyz = (keyToggle(67)) ?  vec3(d) : colormap(d) ;\r\n    //if (d<0.) fragColor = vec4(0,0,1,0);\r\n    //if (d>1.) fragColor = vec4(1,0,0,0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Variations on Noise ","id":"4a1b0c6a08954e17b6c3c097a7220090","date":null,"viewed":0,"name":"Variations on Noise ","description":"variation on https://www.shadertoy.com/view/Xs23D3\nmouse.x: zoom   S: mouse.x controls lacunarity instead \nE:   mouse.y = exponent (=vicinity)\nN+B: noise type:   00: smooth 10: abs 11: 1-abs 10:1/n\nT: add or mul \nC: toggles colors   G: toggles galaxy\nhttps://www.shadertoy.com/view/ldjGWc","likes":0,"published":null,"tags":[" fractal"," noise"," perlin"," filtering"," multiscale"]},"ver":null,"info":{"Name":"Variations on Noise ","id":"4a1b0c6a08954e17b6c3c097a7220090","date":null,"viewed":0,"name":"Variations on Noise ","description":"variation on https://www.shadertoy.com/view/Xs23D3\nmouse.x: zoom   S: mouse.x controls lacunarity instead \nE:   mouse.y = exponent (=vicinity)\nN+B: noise type:   00: smooth 10: abs 11: 1-abs 10:1/n\nT: add or mul \nC: toggles colors   G: toggles galaxy\nhttps://www.shadertoy.com/view/ldjGWc","likes":0,"published":null,"tags":[" fractal"," noise"," perlin"," filtering"," multiscale"]},"renderpass":[{"Code":"// variations on noise \r\n\r\n#define SCALE_LACUNARITY 8. // when exponent is active\r\n#define NOctaves 20.    \t// max scales\r\n#define LimitDetails 2. \t// Anti aliasing\r\n#define ANIM 0\t\t\t\t// Manual / Auto\r\n#define ClampLevel 1.\t\t// Colormap\r\n\r\n\r\n// widgets from https://www.shadertoy.com/view/lsXXzN\r\n\r\nvec2 FragCoord;\r\nvec4 FragColor;\r\n\r\n// --- key toggles -----------------------------------------------------\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- Digit display ----------------------------------------------------\r\n\r\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\r\n\r\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\r\n\r\nfloat segment(vec2 uv, bool On) {\r\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\r\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\r\n\t\t        : 0.;\r\n}\r\n\r\nfloat sevenSegment(vec2 uv,int num) {\r\n\tfloat seg= 0.;\r\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\r\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\r\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\r\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\r\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\r\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\r\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\r\n\treturn seg;\r\n}\r\n\r\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\r\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\r\n\r\n\tif (nr<0) {\r\n\t\tnr = -nr;\r\n\t\tif (uv.x>1.5) {\r\n\t\t\tuv.x -= 2.;\r\n\t\t\treturn segment(uv.yx,true); // <<<< signe. bug\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (uv.x>0.) {\r\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\r\n\t\tuv -= vec2(.75,0.);\r\n\t} else {\r\n\t\tuv += vec2(.75,0.); \r\n\t\tnr = int(mod(float(nr),10.));\r\n\t}\r\n\r\n\treturn sevenSegment(uv,nr);\r\n}\r\n\r\nfloat dots(vec2 uv, int dot) {\r\n\tfloat point0 = float(dot/2),\r\n\t\t  point1 = float(dot)-2.*point0; \r\n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\r\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\r\n\treturn 0.;\r\n}\r\n//    ... end of digits adapted from Andre\r\n\r\n#define STEPX .875\r\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\r\n\r\n// 2digit int + sign\r\nbool display(vec2 pos, float scale, float offset, int number, int dot) { // dot: draw separator\r\n\tvec2 uv = FragCoord.xy/iResolution.y;\r\n\tuv = (uv-pos)/scale*2.; \r\n    uv.x = .5-uv.x + STEPX*offset;\r\n\tuv.y -= 1.;\r\n\t\r\n\tfloat seg = showNum(uv,number,false);\r\n\toffset += 2.;\r\n\t\r\n\tif (dot>0) {\r\n\t\tuv.x += STEPX*offset; \r\n\t\tseg += dots(uv,dot);\r\n\t\toffset += 2.;\r\n\t}\r\n\r\n\tFragColor += seg*vec4(0.,.5,1.,1.);  // change color here\r\n\t_offset = offset;\r\n\treturn (seg>0.);\r\n}\r\n\r\n// 2.2 float + sign\r\nbool display(vec2 pos, float scale, float offset, float val) { // dot: draw separator\r\n\tif (display( pos, scale, 0., int(val), 1)) return true;\r\n    if (display( pos, scale, _offset, int(fract(val)*100.), 0)) return true;\r\n\treturn false;\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {                     // noise in [-1,1]\r\n    // p+= iTime;\r\n    vec2 i = floor(p), f = fract(p);\r\n\tvec2 u = f*f*(3.-2.*f);\r\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \r\n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\r\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \r\n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\r\n}\r\n\r\n\r\nvec3 colormap(float value) {\r\n\tfloat maxv = ClampLevel;\r\n\tvec3 c1,c2;\r\n\tfloat t;\r\n\tif (value < maxv / 3.) {\r\n\t\tc1 = vec3(0.);   \t c2 = vec3(1.,0.,0.); \tt =  1./3.;\r\n\t} else if (value < maxv * 2. / 3.) {\r\n\t\tc1 = vec3(1.,0.,0.); c2 = vec3(1.,1.,.5);\tt =  2./3. ;\r\n\t} else {\r\n\t\tc1 = vec3(1.,1.,.5); c2 = vec3(1.);      \tt =  1.;\r\n\t}\r\n\tt = (t*maxv-value)/(maxv/3.);\r\n\treturn t*c1 + (1.-t)*c2;\r\n}\r\n\r\n// ===============================================================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \r\n    float t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy/ iResolution.y- vec2(.5*iResolution.x/iResolution.y,.5));\r\n\tvec4 mouse = iMouse / iResolution.xyxy;\r\n\tFragCoord=fragCoord;\r\n    FragColor=fragColor=vec4(0);\r\n    \r\n\t// --- tunings ------------------------------\r\n\r\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\r\n\t\r\n #if ANIM\r\n\tfloat cycle = cos(mod(-t,100.)/100.*2.*3.14);\r\n\tfloat zoom = exp(cycle*cycle*20.);\r\n#else\r\n\tfloat zoom = 0.;\r\n\tzoom = (keyToggle(83)) ? abs(mouse.z) : mouse.x ;\r\n\tzoom = exp(-6. + zoom*9.);\r\n#endif\r\n\t\r\n\tif (!keyToggle(68)) { // 'D' : switch on/off display mouse.xy\r\n\t\tvec2 pos ; float scale = 0.1;\r\n        pos = vec2(.2,.8); if (display( pos, scale, 0., mouse.x*100.)) { fragColor=FragColor; return; }\r\n        pos.y -= .15;\t   if (display( pos, scale, 0., mouse.y*100.)) { fragColor=FragColor; return; }\r\n\t}\r\n\t\r\n\tint TYPE = (keyToggle(84)) ? 0 : 1;\t// 0: additive perlin  1: multiplicative perlin\r\n\r\n\r\n\tif (keyToggle(71)) { // 'G' : map on galaxy\r\n\t\tfloat r = length(uv), a = atan(uv.y,uv.x);  // to polar\r\n\t\tif (!keyToggle(64+25)) { // 'Y'\r\n\t\t\tr = 1.*log(r/.1); \t\t\t\t\t\t    // restore aspect ratio\r\n\t\t\ta -= r;           \t\t\t\t\t\t\t// slight slant\r\n\t\t\tuv = vec2(a,2.*r-1.);\r\n\t\t} \r\n\t\telse {\r\n\t\t\ta -= r;\r\n\t\t\tuv = vec2(r*cos(a),r*sin(a));\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (keyToggle(64+23)) { // 'W' : gravity waves ( = galaxy spirals)\r\n#define AMP .1\r\n\t\tfloat phi = 3.*(uv.x-.5*iTime);\r\n\t\tuv.x -= AMP*sin(phi);\r\n\t\tmouse.y = 6.*AMP*(1.+cos(phi))/2.;\r\n\t}\r\n\t\r\n\t// zoom and centering\r\n\tuv *= zoom; \r\n\t\r\n\tif (keyToggle(64+26)) { // 'Z'  mapping reference\r\n\t\tuv *= 8.;\r\n\t\tfloat n = 20.*2.*sign(mod(uv.x,1.)-.5)*sign(mod(uv.y,1.)-.5)-1.;\r\n\t\tfragColor=vec4(n); return;\r\n\t}\r\n\t\r\n\tfloat theta = 4. + float(ANIM)*.01*t; // some rotations, not compulsory\r\n    mat2 m = 2.*mat2( cos(theta),sin(theta), \r\n\t\t\t\t\t -sin(theta),cos(theta) );\r\n\t\t\r\n\t// noise type:   0: smooth  1: abs  2: 1-abs  3: 1/(1+x)\r\n\tint NOISE = ((keyToggle(78))?1:0) + ((keyToggle(66))?2:0);\r\n\t\r\n\t\r\n\t// --- computation of the noise cascade ----------------------------\r\n\t\r\n\tfloat d = (TYPE==0) ? 0.:.5; // density\r\n\tfloat q = zoom;\r\n\t\r\n\tfor (float i = 0.; i < NOctaves; i++) { // cumulates scales from large to small\r\n\t\t\r\n\t\tif (TYPE==1) if(d < 1e-2) continue;\r\n\t\tfloat crit = iResolution.x/(q*LimitDetails)-1.;\r\n\t\tif (crit < 0.) continue; // otherwise, smaller than pixel\r\n\t\r\n\t\t// --- base noise     normalization should ensure constant average\r\n\t\t\r\n\t\tfloat n = noise(uv + 10.*i*i); // base noise [-1,1]\r\n#define GAIN 1. // 5.*mouse.y // 5.\r\n\t\t// n = clamp(GAIN*n,-1.,1.); // to cancel poor stddev\r\n\t\tif (NOISE == 0)\r\n\t\t\tn = (1.+n)*.95; // [0.,1.]\r\n\t\telse if (NOISE == 1)\r\n\t\t\tn = abs(n)*8.5;\r\n\t\telse if (NOISE == 3)\r\n\t\t\tn = (1.-abs(n)) * 1.1;\r\n\t\telse if (NOISE == 2)\r\n\t\t\tn = 1./(1.+n)*.9;\r\n\r\n\t\t\t\r\n\t\t// --- lacunarity ( = vicinity at largest scale )\r\n\t\t\t\r\n\t\tif (keyToggle(69)) // 'E' : mouse.y tune exponent\r\n\t\t{ \r\n\t\t\tfloat P = mouse.y*10.; //  power to control high-scale lacunarity\r\n\t\t\t// lacunarity fall-off with scale.   'S' : mouse.x tune scales of lacunarity\r\n\t\t\tfloat lac = SCALE_LACUNARITY * ( (keyToggle(83)) ? 2.*mouse.x : 1.);\r\n\t\t\tP = 1. + P*exp(-i/lac);\r\n#define FACTOR 1.5\r\n\t\t\tn = clamp(n,0.,FACTOR); \r\n\t\t\tn = pow(n,P); \r\n\t\t}\r\n\t\t\r\n\r\n\t\t// --- fading zone to avoid aliasing\r\n\t\tif (crit<1.)   \r\n\t\t\tn = n*crit + (1.-crit); \r\n\r\n\t\t// --- cumulates cascade bands\r\n\t\tif (TYPE==1)\r\n\t\t\td *= n; \t\t\t// cumulates multiplicatively\r\n\t\telse\r\n\t\t\td += .4*n*zoom/q;   // cumulates additively\r\n\t\t\r\n\t\tuv = m*uv; q*= 2.; // go to the next octave\r\n\t}\r\n\r\n    if (keyToggle(64+9)) // 'I' : reverse\r\n        d = 1.-d;\r\n\tfragColor.xyz = (keyToggle(67)) ?  vec3(d) : colormap(d) ;\r\n    //if (d<0.) fragColor = vec4(0,0,1,0);\r\n    //if (d>1.) fragColor = vec4(1,0,0,0);\r\n}","inputs":[],"outputs":[],"code":"// variations on noise \r\n\r\n#define SCALE_LACUNARITY 8. // when exponent is active\r\n#define NOctaves 20.    \t// max scales\r\n#define LimitDetails 2. \t// Anti aliasing\r\n#define ANIM 0\t\t\t\t// Manual / Auto\r\n#define ClampLevel 1.\t\t// Colormap\r\n\r\n\r\n// widgets from https://www.shadertoy.com/view/lsXXzN\r\n\r\nvec2 FragCoord;\r\nvec4 FragColor;\r\n\r\n// --- key toggles -----------------------------------------------------\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- Digit display ----------------------------------------------------\r\n\r\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\r\n\r\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\r\n\r\nfloat segment(vec2 uv, bool On) {\r\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\r\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\r\n\t\t        : 0.;\r\n}\r\n\r\nfloat sevenSegment(vec2 uv,int num) {\r\n\tfloat seg= 0.;\r\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\r\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\r\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\r\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\r\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\r\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\r\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\r\n\treturn seg;\r\n}\r\n\r\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\r\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\r\n\r\n\tif (nr<0) {\r\n\t\tnr = -nr;\r\n\t\tif (uv.x>1.5) {\r\n\t\t\tuv.x -= 2.;\r\n\t\t\treturn segment(uv.yx,true); // <<<< signe. bug\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (uv.x>0.) {\r\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\r\n\t\tuv -= vec2(.75,0.);\r\n\t} else {\r\n\t\tuv += vec2(.75,0.); \r\n\t\tnr = int(mod(float(nr),10.));\r\n\t}\r\n\r\n\treturn sevenSegment(uv,nr);\r\n}\r\n\r\nfloat dots(vec2 uv, int dot) {\r\n\tfloat point0 = float(dot/2),\r\n\t\t  point1 = float(dot)-2.*point0; \r\n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\r\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\r\n\treturn 0.;\r\n}\r\n//    ... end of digits adapted from Andre\r\n\r\n#define STEPX .875\r\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\r\n\r\n// 2digit int + sign\r\nbool display(vec2 pos, float scale, float offset, int number, int dot) { // dot: draw separator\r\n\tvec2 uv = FragCoord.xy/iResolution.y;\r\n\tuv = (uv-pos)/scale*2.; \r\n    uv.x = .5-uv.x + STEPX*offset;\r\n\tuv.y -= 1.;\r\n\t\r\n\tfloat seg = showNum(uv,number,false);\r\n\toffset += 2.;\r\n\t\r\n\tif (dot>0) {\r\n\t\tuv.x += STEPX*offset; \r\n\t\tseg += dots(uv,dot);\r\n\t\toffset += 2.;\r\n\t}\r\n\r\n\tFragColor += seg*vec4(0.,.5,1.,1.);  // change color here\r\n\t_offset = offset;\r\n\treturn (seg>0.);\r\n}\r\n\r\n// 2.2 float + sign\r\nbool display(vec2 pos, float scale, float offset, float val) { // dot: draw separator\r\n\tif (display( pos, scale, 0., int(val), 1)) return true;\r\n    if (display( pos, scale, _offset, int(fract(val)*100.), 0)) return true;\r\n\treturn false;\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {                     // noise in [-1,1]\r\n    // p+= iTime;\r\n    vec2 i = floor(p), f = fract(p);\r\n\tvec2 u = f*f*(3.-2.*f);\r\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \r\n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\r\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \r\n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\r\n}\r\n\r\n\r\nvec3 colormap(float value) {\r\n\tfloat maxv = ClampLevel;\r\n\tvec3 c1,c2;\r\n\tfloat t;\r\n\tif (value < maxv / 3.) {\r\n\t\tc1 = vec3(0.);   \t c2 = vec3(1.,0.,0.); \tt =  1./3.;\r\n\t} else if (value < maxv * 2. / 3.) {\r\n\t\tc1 = vec3(1.,0.,0.); c2 = vec3(1.,1.,.5);\tt =  2./3. ;\r\n\t} else {\r\n\t\tc1 = vec3(1.,1.,.5); c2 = vec3(1.);      \tt =  1.;\r\n\t}\r\n\tt = (t*maxv-value)/(maxv/3.);\r\n\treturn t*c1 + (1.-t)*c2;\r\n}\r\n\r\n// ===============================================================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \r\n    float t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy/ iResolution.y- vec2(.5*iResolution.x/iResolution.y,.5));\r\n\tvec4 mouse = iMouse / iResolution.xyxy;\r\n\tFragCoord=fragCoord;\r\n    FragColor=fragColor=vec4(0);\r\n    \r\n\t// --- tunings ------------------------------\r\n\r\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\r\n\t\r\n #if ANIM\r\n\tfloat cycle = cos(mod(-t,100.)/100.*2.*3.14);\r\n\tfloat zoom = exp(cycle*cycle*20.);\r\n#else\r\n\tfloat zoom = 0.;\r\n\tzoom = (keyToggle(83)) ? abs(mouse.z) : mouse.x ;\r\n\tzoom = exp(-6. + zoom*9.);\r\n#endif\r\n\t\r\n\tif (!keyToggle(68)) { // 'D' : switch on/off display mouse.xy\r\n\t\tvec2 pos ; float scale = 0.1;\r\n        pos = vec2(.2,.8); if (display( pos, scale, 0., mouse.x*100.)) { fragColor=FragColor; return; }\r\n        pos.y -= .15;\t   if (display( pos, scale, 0., mouse.y*100.)) { fragColor=FragColor; return; }\r\n\t}\r\n\t\r\n\tint TYPE = (keyToggle(84)) ? 0 : 1;\t// 0: additive perlin  1: multiplicative perlin\r\n\r\n\r\n\tif (keyToggle(71)) { // 'G' : map on galaxy\r\n\t\tfloat r = length(uv), a = atan(uv.y,uv.x);  // to polar\r\n\t\tif (!keyToggle(64+25)) { // 'Y'\r\n\t\t\tr = 1.*log(r/.1); \t\t\t\t\t\t    // restore aspect ratio\r\n\t\t\ta -= r;           \t\t\t\t\t\t\t// slight slant\r\n\t\t\tuv = vec2(a,2.*r-1.);\r\n\t\t} \r\n\t\telse {\r\n\t\t\ta -= r;\r\n\t\t\tuv = vec2(r*cos(a),r*sin(a));\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (keyToggle(64+23)) { // 'W' : gravity waves ( = galaxy spirals)\r\n#define AMP .1\r\n\t\tfloat phi = 3.*(uv.x-.5*iTime);\r\n\t\tuv.x -= AMP*sin(phi);\r\n\t\tmouse.y = 6.*AMP*(1.+cos(phi))/2.;\r\n\t}\r\n\t\r\n\t// zoom and centering\r\n\tuv *= zoom; \r\n\t\r\n\tif (keyToggle(64+26)) { // 'Z'  mapping reference\r\n\t\tuv *= 8.;\r\n\t\tfloat n = 20.*2.*sign(mod(uv.x,1.)-.5)*sign(mod(uv.y,1.)-.5)-1.;\r\n\t\tfragColor=vec4(n); return;\r\n\t}\r\n\t\r\n\tfloat theta = 4. + float(ANIM)*.01*t; // some rotations, not compulsory\r\n    mat2 m = 2.*mat2( cos(theta),sin(theta), \r\n\t\t\t\t\t -sin(theta),cos(theta) );\r\n\t\t\r\n\t// noise type:   0: smooth  1: abs  2: 1-abs  3: 1/(1+x)\r\n\tint NOISE = ((keyToggle(78))?1:0) + ((keyToggle(66))?2:0);\r\n\t\r\n\t\r\n\t// --- computation of the noise cascade ----------------------------\r\n\t\r\n\tfloat d = (TYPE==0) ? 0.:.5; // density\r\n\tfloat q = zoom;\r\n\t\r\n\tfor (float i = 0.; i < NOctaves; i++) { // cumulates scales from large to small\r\n\t\t\r\n\t\tif (TYPE==1) if(d < 1e-2) continue;\r\n\t\tfloat crit = iResolution.x/(q*LimitDetails)-1.;\r\n\t\tif (crit < 0.) continue; // otherwise, smaller than pixel\r\n\t\r\n\t\t// --- base noise     normalization should ensure constant average\r\n\t\t\r\n\t\tfloat n = noise(uv + 10.*i*i); // base noise [-1,1]\r\n#define GAIN 1. // 5.*mouse.y // 5.\r\n\t\t// n = clamp(GAIN*n,-1.,1.); // to cancel poor stddev\r\n\t\tif (NOISE == 0)\r\n\t\t\tn = (1.+n)*.95; // [0.,1.]\r\n\t\telse if (NOISE == 1)\r\n\t\t\tn = abs(n)*8.5;\r\n\t\telse if (NOISE == 3)\r\n\t\t\tn = (1.-abs(n)) * 1.1;\r\n\t\telse if (NOISE == 2)\r\n\t\t\tn = 1./(1.+n)*.9;\r\n\r\n\t\t\t\r\n\t\t// --- lacunarity ( = vicinity at largest scale )\r\n\t\t\t\r\n\t\tif (keyToggle(69)) // 'E' : mouse.y tune exponent\r\n\t\t{ \r\n\t\t\tfloat P = mouse.y*10.; //  power to control high-scale lacunarity\r\n\t\t\t// lacunarity fall-off with scale.   'S' : mouse.x tune scales of lacunarity\r\n\t\t\tfloat lac = SCALE_LACUNARITY * ( (keyToggle(83)) ? 2.*mouse.x : 1.);\r\n\t\t\tP = 1. + P*exp(-i/lac);\r\n#define FACTOR 1.5\r\n\t\t\tn = clamp(n,0.,FACTOR); \r\n\t\t\tn = pow(n,P); \r\n\t\t}\r\n\t\t\r\n\r\n\t\t// --- fading zone to avoid aliasing\r\n\t\tif (crit<1.)   \r\n\t\t\tn = n*crit + (1.-crit); \r\n\r\n\t\t// --- cumulates cascade bands\r\n\t\tif (TYPE==1)\r\n\t\t\td *= n; \t\t\t// cumulates multiplicatively\r\n\t\telse\r\n\t\t\td += .4*n*zoom/q;   // cumulates additively\r\n\t\t\r\n\t\tuv = m*uv; q*= 2.; // go to the next octave\r\n\t}\r\n\r\n    if (keyToggle(64+9)) // 'I' : reverse\r\n        d = 1.-d;\r\n\tfragColor.xyz = (keyToggle(67)) ?  vec3(d) : colormap(d) ;\r\n    //if (d<0.) fragColor = vec4(0,0,1,0);\r\n    //if (d>1.) fragColor = vec4(1,0,0,0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//Font liberated from http://paulbourke.net/dataformats/hershey/\r\n\r\nfloat res=0.;\r\nvec2 cpos=vec2(0.);\r\n\r\nfloat antiAlias(float x,vec2 iResolution) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.);}\r\n\r\n#define PI 3.14159265359\r\n\r\n//float opU( float d1, float d2 )\r\n//{\r\n//    return max(d1,d2);\r\n//}\r\n#define opU(a,b) max(a,b)\r\n\r\nfloat width;\r\n\r\nfloat line( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p - a;\r\n    vec2 ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    float d = length( pa - ba*h );\r\n\r\n    return  1.00 + width - d;\r\n}\r\n// CHAR: 32 : \r\nvoid char_32(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 33 :!\r\nvoid char_33(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 34 :\"\r\nvoid char_34(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 35 :#\r\nvoid char_35(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(18.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(17.0,6.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 36 :$\r\nvoid char_36(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,25.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,25.0)*s,vec2(12.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 37 :%\r\nvoid char_37(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(21.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,19.0)*s,vec2(10.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(6.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,20.0)*s,vec2(13.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,19.0)*s,vec2(16.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,19.0)*s,vec2(19.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,20.0)*s,vec2(21.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(15.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,2.0)*s,vec2(16.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,0.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,0.0)*s,vec2(20.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,1.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,3.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(19.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,7.0)*s,vec2(17.0,7.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 38 :&\r\nvoid char_38(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(23.0,12.0)*s,vec2(23.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,13.0)*s,vec2(22.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,14.0)*s,vec2(21.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,14.0)*s,vec2(20.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,13.0)*s,vec2(19.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,11.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,9.0)*s,vec2(12.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,13.0)*s,vec2(13.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,14.0)*s,vec2(14.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,16.0)*s,vec2(14.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,18.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(8.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,16.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(11.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,10.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,0.0)*s,vec2(22.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,0.0)*s,vec2(23.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,1.0)*s,vec2(23.0,2.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 39 :'\r\nvoid char_39(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(6.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,18.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,15.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 40 :(\r\nvoid char_40(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(9.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(9.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-5.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 41 :)\r\nvoid char_41(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(5.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(9.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,16.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(10.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,7.0)*s,vec2(9.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(5.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-5.0)*s,vec2(3.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 42 :*\r\nvoid char_42(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(3.0,12.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 43 :+\r\nvoid char_43(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 44 :,\r\nvoid char_44(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 45 :-\r\nvoid char_45(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 46 :.\r\nvoid char_46(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 47 :/\r\nvoid char_47(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,25.0)*s,vec2(2.0,-7.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 48 :0\r\nvoid char_0(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,4.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 49 :1\r\nvoid char_1(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(11.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 50 :2\r\nvoid char_2(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(15.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,19.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(16.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,15.0)*s,vec2(15.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,13.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 51 :3\r\nvoid char_3(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(16.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,21.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 52 :4\r\nvoid char_4(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(13.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 53 :5\r\nvoid char_5(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 54 :6\r\nvoid char_6(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(11.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,13.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(5.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,10.0)*s,vec2(4.0,7.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 55 :7\r\nvoid char_7(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 56 :8\r\nvoid char_8(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(11.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,12.0)*s,vec2(14.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(17.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,4.0)*s,vec2(16.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,2.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(9.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(16.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,16.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 57 :9\r\nvoid char_9(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,9.0)*s,vec2(10.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,8.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(6.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,9.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(3.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,15.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(15.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,18.0)*s,vec2(16.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,4.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 58 ::\r\nvoid char_58(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 59 :;\r\nvoid char_59(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 60 :<\r\nvoid char_60(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,18.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 61 :=\r\nvoid char_61(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(22.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(22.0,6.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 62 :>\r\nvoid char_62(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(20.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,9.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 63 :?\r\nvoid char_63(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,17.0)*s,vec2(4.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,19.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(14.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,19.0)*s,vec2(15.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,17.0)*s,vec2(15.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,15.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,12.0)*s,vec2(9.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,10.0)*s,vec2(9.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(9.0,2.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 64 :@\r\nvoid char_64(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(17.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,15.0)*s,vec2(15.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,16.0)*s,vec2(12.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,15.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(8.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(9.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,5.0)*s,vec2(14.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,5.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(10.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,5.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(23.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,7.0)*s,vec2(24.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,10.0)*s,vec2(24.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,12.0)*s,vec2(23.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,15.0)*s,vec2(22.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,17.0)*s,vec2(20.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,19.0)*s,vec2(18.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,20.0)*s,vec2(15.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(7.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,19.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,15.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(9.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,0.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,2.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,16.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    cpos.x+=27.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 65 :A\r\nvoid char_A(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(1.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(14.0,7.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 66 :B\r\nvoid char_B(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(18.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,4.0)*s,vec2(17.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,2.0)*s,vec2(16.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,1.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 67 :C\r\nvoid char_C(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 68 :D\r\nvoid char_D(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(17.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,16.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(17.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,5.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 69 :E\r\nvoid char_E(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 70 :F\r\nvoid char_F(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 71 :G\r\nvoid char_G(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,8.0)*s,vec2(18.0,8.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 72 :H\r\nvoid char_H(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(18.0,11.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 73 :I\r\nvoid char_I(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 74 :J\r\nvoid char_J(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,5.0)*s,vec2(11.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,2.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,2.0)*s,vec2(2.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,5.0)*s,vec2(2.0,7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 75 :K\r\nvoid char_K(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 76 :L\r\nvoid char_L(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(16.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 77 :M\r\nvoid char_M(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 78 :N\r\nvoid char_N(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 79 :O\r\nvoid char_O(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 80 :P\r\nvoid char_P(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,14.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(4.0,10.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 81 :Q\r\nvoid char_Q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,4.0)*s,vec2(18.0,-2.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 82 :R\r\nvoid char_R(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,11.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 83 :S\r\nvoid char_S(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 84 :T\r\nvoid char_T(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(15.0,21.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 85 :U\r\nvoid char_U(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(18.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 86 :V\r\nvoid char_V(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 87 :W\r\nvoid char_W(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 88 :X\r\nvoid char_X(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 89 :Y\r\nvoid char_Y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 90 :Z\r\nvoid char_Z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 91 :[\r\nvoid char_91(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(5.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(11.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-7.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 92 :\\;\r\nvoid char_92(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,21.0)*s,vec2(14.0,-3.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 93 :]\r\nvoid char_93(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(9.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(10.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(10.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 94 :^\r\nvoid char_94(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,15.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 95 :_\r\nvoid char_95(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,-2.0)*s,vec2(16.0,-2.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 96 :`\r\nvoid char_96(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(6.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,16.0)*s,vec2(5.0,17.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 97 :a\r\nvoid char_a(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 98 :b\r\nvoid char_b(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 99 :c\r\nvoid char_c(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 100 :d\r\nvoid char_d(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 101 :e\r\nvoid char_e(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(15.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,8.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 102 :f\r\nvoid char_f(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 103 :g\r\nvoid char_g(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,-2.0)*s,vec2(14.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,-5.0)*s,vec2(13.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,-6.0)*s,vec2(11.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,-7.0)*s,vec2(8.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-7.0)*s,vec2(6.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 104 :h\r\nvoid char_h(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 105 :i\r\nvoid char_i(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,22.0)*s,vec2(3.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 106 :j\r\nvoid char_j(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-3.0)*s,vec2(5.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-6.0)*s,vec2(3.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 107 :k\r\nvoid char_k(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 108 :l\r\nvoid char_l(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 109 :m\r\nvoid char_m(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(20.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,14.0)*s,vec2(23.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,14.0)*s,vec2(25.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(25.0,13.0)*s,vec2(26.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(26.0,10.0)*s,vec2(26.0,0.0)*s));\r\n    cpos.x+=30.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 110 :n\r\nvoid char_n(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 111 :o\r\nvoid char_o(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 112 :p\r\nvoid char_p(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 113 :q\r\nvoid char_q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 114 :r\r\nvoid char_r(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,11.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=13.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 115 :s\r\nvoid char_s(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(3.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(11.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,7.0)*s,vec2(13.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 116 :t\r\nvoid char_t(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 117 :u\r\nvoid char_u(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,1.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 118 :v\r\nvoid char_v(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 119 :w\r\nvoid char_w(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 120 :x\r\nvoid char_x(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 121 :y\r\nvoid char_y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(4.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-6.0)*s,vec2(2.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 122 :z\r\nvoid char_z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(14.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 123 :{\r\nvoid char_123(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,23.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(6.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(8.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,7.0)*s,vec2(9.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,5.0)*s,vec2(9.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,3.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(6.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-2.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(8.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,6.0)*s,vec2(8.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(6.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(9.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n// CHAR: 124 :|\r\nvoid char_124(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n// CHAR: 125 :}\r\nvoid char_125(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,23.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(9.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,19.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(6.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,22.0)*s,vec2(8.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(10.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,9.0)*s,vec2(6.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,7.0)*s,vec2(5.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(8.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-2.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(6.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,6.0)*s,vec2(6.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-1.0)*s,vec2(9.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-3.0)*s,vec2(8.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(5.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 126 :~\r\nvoid char_126(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(14.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,8.0)*s,vec2(16.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(20.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,8.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(10.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,10.0)*s,vec2(14.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,7.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(20.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,7.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,10.0)*s,vec2(21.0,12.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n vec3 abc(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n    \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_A(uv,s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_B(uv,s);\r\n    \r\n\tchar_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_C(uv-vec2(-0.01,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    char_D(uv-vec2(-0.02,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    \r\n    \r\n    char_E(uv-vec2(-0.03,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_F(uv-vec2(-0.04,0.0),s);\r\n    \r\n    char_G(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_H(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_I(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_J(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_K(uv-vec2(-1.1,-0.12),s);\r\n\t\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_L(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_M(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n\tchar_N(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n\tchar_O(uv-vec2(-2.15,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n  \r\n\tchar_P(uv-vec2(-2.13,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\tchar_Q(uv-vec2(-2.1,-0.223),s);\r\n     \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n\tchar_R(uv-vec2(-2.08,-0.223),s);\r\n    \r\n    char_S(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n    char_T(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_U(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n    char_V(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_X(uv-vec2(-3.17,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_W(uv-vec2(-3.18,-0.34),s);\r\n    \r\n    char_Y(uv-vec2(-4.23,-0.45),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_z(uv-vec2(-4.23,-0.44),s);\r\n\r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\nvec3 help(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n     \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_H(uv,s);\r\n    char_E(uv,s);\r\n    char_L(uv,s);\r\n    char_P(uv,s);\r\n\r\n    \r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\n#define AA 1\r\nmat2 Rot(float a) {\r\n    float s = sin(a);\r\n    float c = cos(a);\r\n    return mat2(vec2(c, -s),vec2( s, c));\r\n}\r\nfloat sdBox( in vec2 p, in vec2 b )\r\n{\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nvec3 scene(vec2 p,vec2 iResolution,vec2 mouse){\r\n    vec3 col;\r\n   \r\n   p/=vec2(0.5);\r\n   mouse/=vec2(0.5);\r\n   mouse.y+=0.9;\r\n   p.y+=0.9;\r\n    \r\n  \r\n   float linha[15];\r\n   linha[0]=sdBox(p,vec2(1.8,0.01));\r\n   linha[1]=sdBox(p+vec2(0.0,0.33),vec2(1.8,0.01));\r\n   linha[2]=sdBox(p+vec2(0.0,0.66),vec2(1.8,0.01));\r\n   linha[3]=sdBox(p+vec2(0.0,-0.33),vec2(1.8,0.01));\r\n   linha[4]=sdBox(p+vec2(0.0,-0.66),vec2(1.8,0.01));\r\n   \r\n   \r\n   linha[5]=sdBox(p,vec2(0.01,1.0));\r\n   linha[6]=sdBox(p+vec2(0.60,0.0),vec2(0.01,1.0));\r\n   linha[7]=sdBox(p+vec2(1.2,0.0),vec2(0.01,1.0));\r\n   linha[8]=sdBox(p+vec2(-0.60,0.0),vec2(0.01,1.0));\r\n   linha[9]=sdBox(p+vec2(-1.20,0.0),vec2(0.01,1.0));\r\n    \r\n   linha[10]=sdBox(p+vec2(0.0,-1.0),vec2(1.8,0.01));\r\n   linha[11]=sdBox(p+vec2(0.0,1.0),vec2(1.8,0.01));\r\n   linha[12]=sdBox(p+vec2(-1.8,0.0),vec2(0.01,1.0));\r\n   linha[14]=sdBox(p+vec2(1.8,0.0),vec2(0.01,1.0));\r\n    \r\n    \r\n   float painel[26];\r\n   painel[0]=sdBox(p+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   painel[1]=sdBox(p+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   painel[2]=sdBox(p+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   painel[3]=sdBox(p+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   painel[4]=sdBox(p+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   painel[5]=sdBox(p+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   painel[6]=sdBox(p+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   painel[7]=sdBox(p+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[8]=sdBox(p+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[9]=sdBox(p+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[10]=sdBox(p+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[11]=sdBox(p+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   painel[12]=sdBox(p+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   painel[13]=sdBox(p+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[14]=sdBox(p+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[15]=sdBox(p+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[16]=sdBox(p+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[17]=sdBox(p+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   painel[18]=sdBox(p+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   painel[19]=sdBox(p+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   painel[20]=sdBox(p+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   painel[21]=sdBox(p+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   painel[22]=sdBox(p+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   painel[23]=sdBox(p+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   painel[24]=sdBox(p+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   painel[25]=sdBox(p+vec2(0.9,0.5),vec2(0.28,0.17)); \r\n    \r\n   float regiao[26];\r\n    \r\n   col=abc(p,iResolution,  vec3(0.82));\r\n   regiao[0]=sdBox(mouse+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   regiao[1]=sdBox(mouse+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[2]=sdBox(mouse+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[3]=sdBox(mouse+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[4]=sdBox(mouse+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[5]=sdBox(mouse+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   regiao[6]=sdBox(mouse+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   regiao[7]=sdBox(mouse+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[8]=sdBox(mouse+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[9]=sdBox(mouse+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[10]=sdBox(mouse+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[11]=sdBox(mouse+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   regiao[12]=sdBox(mouse+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   regiao[13]=sdBox(mouse+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[14]=sdBox(mouse+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[15]=sdBox(mouse+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[16]=sdBox(mouse+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[17]=sdBox(mouse+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   regiao[18]=sdBox(mouse+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   regiao[19]=sdBox(mouse+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[20]=sdBox(mouse+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   regiao[21]=sdBox(mouse+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   regiao[22]=sdBox(mouse+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[23]=sdBox(mouse+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   regiao[24]=sdBox(mouse+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   regiao[25]=sdBox(mouse+vec2(0.9,0.5),vec2(0.28,0.17));  \r\n    vec3 t=vec3(0.0);\r\n    float Output=sdBox(p-vec2(0.0,2.0),vec2(3.0,0.5));\r\n   \r\n   if(Output < 0.0) col=vec3(1.0);\r\n   \r\n    float caractere[24];\r\n    \r\n    caractere[0]=sdBox(p+vec2(0.0,-2.0),vec2(0.5,.5));\r\n\r\n    for(int i=0;i<painel.length();i++){\r\n   \t if(regiao[i]<=0.0 ){\r\n\r\n      \t  if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.1));\r\n         t=vec3(0.0,1.0,0.0);\r\n\r\n  \t  }else{ \r\n    \t    if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.82));\r\n   \t }\r\n\r\n    }\r\n    for(int i=0;i<linha.length();i++){\r\n  \r\n  \t\tif(linha[i] < 0.0) col=vec3(0.0);\r\n  \r\n    }\r\n   if(caractere[0] < 0.0) col=help(p+vec2(-1.2,-1.0),iResolution,  vec3(0.82));\r\n   return col;\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec3 tot = vec3(0.0);\r\n  \r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n     // pixel coordinates\r\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n     vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;   \r\n     vec2 mouse = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;   \r\n \t vec3 col=vec3(0.0);\r\n  \r\n  \t  col *= 1.5 - 0.2*length(p);\r\n      col = col*vec3(1.11,0.89,0.79);\r\n    \r\n      col=scene(p,iResolution.xy,mouse);\r\n        \r\n         tot += col;\r\n    }\r\n    \r\n    tot /= float(AA*AA);\r\n    \r\n  fragColor = vec4(tot,1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"//Font liberated from http://paulbourke.net/dataformats/hershey/\r\n\r\nfloat res=0.;\r\nvec2 cpos=vec2(0.);\r\n\r\nfloat antiAlias(float x,vec2 iResolution) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.);}\r\n\r\n#define PI 3.14159265359\r\n\r\n//float opU( float d1, float d2 )\r\n//{\r\n//    return max(d1,d2);\r\n//}\r\n#define opU(a,b) max(a,b)\r\n\r\nfloat width;\r\n\r\nfloat line( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p - a;\r\n    vec2 ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    float d = length( pa - ba*h );\r\n\r\n    return  1.00 + width - d;\r\n}\r\n// CHAR: 32 : \r\nvoid char_32(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 33 :!\r\nvoid char_33(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 34 :\"\r\nvoid char_34(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 35 :#\r\nvoid char_35(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(18.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(17.0,6.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 36 :$\r\nvoid char_36(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,25.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,25.0)*s,vec2(12.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 37 :%\r\nvoid char_37(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(21.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,19.0)*s,vec2(10.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(6.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,20.0)*s,vec2(13.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,19.0)*s,vec2(16.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,19.0)*s,vec2(19.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,20.0)*s,vec2(21.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(15.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,2.0)*s,vec2(16.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,0.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,0.0)*s,vec2(20.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,1.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,3.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(19.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,7.0)*s,vec2(17.0,7.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 38 :&\r\nvoid char_38(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(23.0,12.0)*s,vec2(23.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,13.0)*s,vec2(22.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,14.0)*s,vec2(21.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,14.0)*s,vec2(20.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,13.0)*s,vec2(19.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,11.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,9.0)*s,vec2(12.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,13.0)*s,vec2(13.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,14.0)*s,vec2(14.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,16.0)*s,vec2(14.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,18.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(8.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,16.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(11.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,10.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,0.0)*s,vec2(22.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,0.0)*s,vec2(23.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,1.0)*s,vec2(23.0,2.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 39 :'\r\nvoid char_39(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(6.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,18.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,15.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 40 :(\r\nvoid char_40(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(9.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(9.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-5.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 41 :)\r\nvoid char_41(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(5.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(9.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,16.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(10.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,7.0)*s,vec2(9.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(5.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-5.0)*s,vec2(3.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 42 :*\r\nvoid char_42(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(3.0,12.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 43 :+\r\nvoid char_43(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 44 :,\r\nvoid char_44(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 45 :-\r\nvoid char_45(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 46 :.\r\nvoid char_46(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 47 :/\r\nvoid char_47(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,25.0)*s,vec2(2.0,-7.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 48 :0\r\nvoid char_0(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,4.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 49 :1\r\nvoid char_1(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(11.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 50 :2\r\nvoid char_2(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(15.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,19.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(16.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,15.0)*s,vec2(15.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,13.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 51 :3\r\nvoid char_3(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(16.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,21.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 52 :4\r\nvoid char_4(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(13.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 53 :5\r\nvoid char_5(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 54 :6\r\nvoid char_6(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(11.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,13.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(5.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,10.0)*s,vec2(4.0,7.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 55 :7\r\nvoid char_7(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 56 :8\r\nvoid char_8(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(11.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,12.0)*s,vec2(14.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(17.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,4.0)*s,vec2(16.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,2.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(9.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(16.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,16.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 57 :9\r\nvoid char_9(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,9.0)*s,vec2(10.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,8.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(6.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,9.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(3.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,15.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(15.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,18.0)*s,vec2(16.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,4.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 58 ::\r\nvoid char_58(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 59 :;\r\nvoid char_59(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 60 :<\r\nvoid char_60(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,18.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 61 :=\r\nvoid char_61(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(22.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(22.0,6.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 62 :>\r\nvoid char_62(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(20.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,9.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 63 :?\r\nvoid char_63(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,17.0)*s,vec2(4.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,19.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(14.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,19.0)*s,vec2(15.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,17.0)*s,vec2(15.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,15.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,12.0)*s,vec2(9.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,10.0)*s,vec2(9.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(9.0,2.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 64 :@\r\nvoid char_64(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(17.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,15.0)*s,vec2(15.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,16.0)*s,vec2(12.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,15.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(8.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(9.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,5.0)*s,vec2(14.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,5.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(10.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,5.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(23.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,7.0)*s,vec2(24.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,10.0)*s,vec2(24.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,12.0)*s,vec2(23.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,15.0)*s,vec2(22.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,17.0)*s,vec2(20.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,19.0)*s,vec2(18.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,20.0)*s,vec2(15.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(7.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,19.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,15.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(9.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,0.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,2.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,16.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    cpos.x+=27.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 65 :A\r\nvoid char_A(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(1.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(14.0,7.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 66 :B\r\nvoid char_B(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(18.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,4.0)*s,vec2(17.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,2.0)*s,vec2(16.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,1.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 67 :C\r\nvoid char_C(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 68 :D\r\nvoid char_D(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(17.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,16.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(17.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,5.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 69 :E\r\nvoid char_E(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 70 :F\r\nvoid char_F(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 71 :G\r\nvoid char_G(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,8.0)*s,vec2(18.0,8.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 72 :H\r\nvoid char_H(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(18.0,11.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 73 :I\r\nvoid char_I(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 74 :J\r\nvoid char_J(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,5.0)*s,vec2(11.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,2.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,2.0)*s,vec2(2.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,5.0)*s,vec2(2.0,7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 75 :K\r\nvoid char_K(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 76 :L\r\nvoid char_L(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(16.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 77 :M\r\nvoid char_M(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 78 :N\r\nvoid char_N(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 79 :O\r\nvoid char_O(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 80 :P\r\nvoid char_P(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,14.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(4.0,10.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 81 :Q\r\nvoid char_Q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,4.0)*s,vec2(18.0,-2.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 82 :R\r\nvoid char_R(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,11.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 83 :S\r\nvoid char_S(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 84 :T\r\nvoid char_T(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(15.0,21.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 85 :U\r\nvoid char_U(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(18.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 86 :V\r\nvoid char_V(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 87 :W\r\nvoid char_W(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 88 :X\r\nvoid char_X(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 89 :Y\r\nvoid char_Y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 90 :Z\r\nvoid char_Z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 91 :[\r\nvoid char_91(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(5.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(11.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-7.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 92 :\\;\r\nvoid char_92(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,21.0)*s,vec2(14.0,-3.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 93 :]\r\nvoid char_93(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(9.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(10.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(10.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 94 :^\r\nvoid char_94(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,15.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 95 :_\r\nvoid char_95(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,-2.0)*s,vec2(16.0,-2.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 96 :`\r\nvoid char_96(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(6.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,16.0)*s,vec2(5.0,17.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 97 :a\r\nvoid char_a(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 98 :b\r\nvoid char_b(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 99 :c\r\nvoid char_c(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 100 :d\r\nvoid char_d(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 101 :e\r\nvoid char_e(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(15.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,8.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 102 :f\r\nvoid char_f(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 103 :g\r\nvoid char_g(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,-2.0)*s,vec2(14.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,-5.0)*s,vec2(13.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,-6.0)*s,vec2(11.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,-7.0)*s,vec2(8.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-7.0)*s,vec2(6.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 104 :h\r\nvoid char_h(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 105 :i\r\nvoid char_i(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,22.0)*s,vec2(3.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 106 :j\r\nvoid char_j(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-3.0)*s,vec2(5.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-6.0)*s,vec2(3.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 107 :k\r\nvoid char_k(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 108 :l\r\nvoid char_l(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 109 :m\r\nvoid char_m(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(20.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,14.0)*s,vec2(23.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,14.0)*s,vec2(25.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(25.0,13.0)*s,vec2(26.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(26.0,10.0)*s,vec2(26.0,0.0)*s));\r\n    cpos.x+=30.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 110 :n\r\nvoid char_n(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 111 :o\r\nvoid char_o(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 112 :p\r\nvoid char_p(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 113 :q\r\nvoid char_q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 114 :r\r\nvoid char_r(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,11.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=13.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 115 :s\r\nvoid char_s(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(3.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(11.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,7.0)*s,vec2(13.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 116 :t\r\nvoid char_t(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 117 :u\r\nvoid char_u(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,1.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 118 :v\r\nvoid char_v(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 119 :w\r\nvoid char_w(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 120 :x\r\nvoid char_x(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 121 :y\r\nvoid char_y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(4.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-6.0)*s,vec2(2.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 122 :z\r\nvoid char_z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(14.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 123 :{\r\nvoid char_123(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,23.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(6.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(8.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,7.0)*s,vec2(9.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,5.0)*s,vec2(9.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,3.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(6.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-2.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(8.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,6.0)*s,vec2(8.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(6.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(9.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n// CHAR: 124 :|\r\nvoid char_124(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n// CHAR: 125 :}\r\nvoid char_125(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,23.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(9.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,19.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(6.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,22.0)*s,vec2(8.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(10.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,9.0)*s,vec2(6.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,7.0)*s,vec2(5.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(8.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-2.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(6.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,6.0)*s,vec2(6.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-1.0)*s,vec2(9.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-3.0)*s,vec2(8.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(5.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 126 :~\r\nvoid char_126(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(14.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,8.0)*s,vec2(16.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(20.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,8.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(10.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,10.0)*s,vec2(14.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,7.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(20.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,7.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,10.0)*s,vec2(21.0,12.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n vec3 abc(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n    \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_A(uv,s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_B(uv,s);\r\n    \r\n\tchar_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_C(uv-vec2(-0.01,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    char_D(uv-vec2(-0.02,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    \r\n    \r\n    char_E(uv-vec2(-0.03,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_F(uv-vec2(-0.04,0.0),s);\r\n    \r\n    char_G(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_H(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_I(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_J(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_K(uv-vec2(-1.1,-0.12),s);\r\n\t\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_L(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_M(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n\tchar_N(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n\tchar_O(uv-vec2(-2.15,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n  \r\n\tchar_P(uv-vec2(-2.13,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\tchar_Q(uv-vec2(-2.1,-0.223),s);\r\n     \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n\tchar_R(uv-vec2(-2.08,-0.223),s);\r\n    \r\n    char_S(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n    char_T(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_U(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n    char_V(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_X(uv-vec2(-3.17,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_W(uv-vec2(-3.18,-0.34),s);\r\n    \r\n    char_Y(uv-vec2(-4.23,-0.45),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_z(uv-vec2(-4.23,-0.44),s);\r\n\r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\nvec3 help(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n     \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_H(uv,s);\r\n    char_E(uv,s);\r\n    char_L(uv,s);\r\n    char_P(uv,s);\r\n\r\n    \r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\n#define AA 1\r\nmat2 Rot(float a) {\r\n    float s = sin(a);\r\n    float c = cos(a);\r\n    return mat2(vec2(c, -s),vec2( s, c));\r\n}\r\nfloat sdBox( in vec2 p, in vec2 b )\r\n{\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nvec3 scene(vec2 p,vec2 iResolution,vec2 mouse){\r\n    vec3 col;\r\n   \r\n   p/=vec2(0.5);\r\n   mouse/=vec2(0.5);\r\n   mouse.y+=0.9;\r\n   p.y+=0.9;\r\n    \r\n  \r\n   float linha[15];\r\n   linha[0]=sdBox(p,vec2(1.8,0.01));\r\n   linha[1]=sdBox(p+vec2(0.0,0.33),vec2(1.8,0.01));\r\n   linha[2]=sdBox(p+vec2(0.0,0.66),vec2(1.8,0.01));\r\n   linha[3]=sdBox(p+vec2(0.0,-0.33),vec2(1.8,0.01));\r\n   linha[4]=sdBox(p+vec2(0.0,-0.66),vec2(1.8,0.01));\r\n   \r\n   \r\n   linha[5]=sdBox(p,vec2(0.01,1.0));\r\n   linha[6]=sdBox(p+vec2(0.60,0.0),vec2(0.01,1.0));\r\n   linha[7]=sdBox(p+vec2(1.2,0.0),vec2(0.01,1.0));\r\n   linha[8]=sdBox(p+vec2(-0.60,0.0),vec2(0.01,1.0));\r\n   linha[9]=sdBox(p+vec2(-1.20,0.0),vec2(0.01,1.0));\r\n    \r\n   linha[10]=sdBox(p+vec2(0.0,-1.0),vec2(1.8,0.01));\r\n   linha[11]=sdBox(p+vec2(0.0,1.0),vec2(1.8,0.01));\r\n   linha[12]=sdBox(p+vec2(-1.8,0.0),vec2(0.01,1.0));\r\n   linha[14]=sdBox(p+vec2(1.8,0.0),vec2(0.01,1.0));\r\n    \r\n    \r\n   float painel[26];\r\n   painel[0]=sdBox(p+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   painel[1]=sdBox(p+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   painel[2]=sdBox(p+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   painel[3]=sdBox(p+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   painel[4]=sdBox(p+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   painel[5]=sdBox(p+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   painel[6]=sdBox(p+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   painel[7]=sdBox(p+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[8]=sdBox(p+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[9]=sdBox(p+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[10]=sdBox(p+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[11]=sdBox(p+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   painel[12]=sdBox(p+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   painel[13]=sdBox(p+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[14]=sdBox(p+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[15]=sdBox(p+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[16]=sdBox(p+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[17]=sdBox(p+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   painel[18]=sdBox(p+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   painel[19]=sdBox(p+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   painel[20]=sdBox(p+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   painel[21]=sdBox(p+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   painel[22]=sdBox(p+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   painel[23]=sdBox(p+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   painel[24]=sdBox(p+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   painel[25]=sdBox(p+vec2(0.9,0.5),vec2(0.28,0.17)); \r\n    \r\n   float regiao[26];\r\n    \r\n   col=abc(p,iResolution,  vec3(0.82));\r\n   regiao[0]=sdBox(mouse+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   regiao[1]=sdBox(mouse+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[2]=sdBox(mouse+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[3]=sdBox(mouse+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[4]=sdBox(mouse+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[5]=sdBox(mouse+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   regiao[6]=sdBox(mouse+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   regiao[7]=sdBox(mouse+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[8]=sdBox(mouse+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[9]=sdBox(mouse+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[10]=sdBox(mouse+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[11]=sdBox(mouse+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   regiao[12]=sdBox(mouse+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   regiao[13]=sdBox(mouse+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[14]=sdBox(mouse+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[15]=sdBox(mouse+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[16]=sdBox(mouse+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[17]=sdBox(mouse+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   regiao[18]=sdBox(mouse+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   regiao[19]=sdBox(mouse+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[20]=sdBox(mouse+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   regiao[21]=sdBox(mouse+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   regiao[22]=sdBox(mouse+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[23]=sdBox(mouse+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   regiao[24]=sdBox(mouse+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   regiao[25]=sdBox(mouse+vec2(0.9,0.5),vec2(0.28,0.17));  \r\n    vec3 t=vec3(0.0);\r\n    float Output=sdBox(p-vec2(0.0,2.0),vec2(3.0,0.5));\r\n   \r\n   if(Output < 0.0) col=vec3(1.0);\r\n   \r\n    float caractere[24];\r\n    \r\n    caractere[0]=sdBox(p+vec2(0.0,-2.0),vec2(0.5,.5));\r\n\r\n    for(int i=0;i<painel.length();i++){\r\n   \t if(regiao[i]<=0.0 ){\r\n\r\n      \t  if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.1));\r\n         t=vec3(0.0,1.0,0.0);\r\n\r\n  \t  }else{ \r\n    \t    if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.82));\r\n   \t }\r\n\r\n    }\r\n    for(int i=0;i<linha.length();i++){\r\n  \r\n  \t\tif(linha[i] < 0.0) col=vec3(0.0);\r\n  \r\n    }\r\n   if(caractere[0] < 0.0) col=help(p+vec2(-1.2,-1.0),iResolution,  vec3(0.82));\r\n   return col;\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec3 tot = vec3(0.0);\r\n  \r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n     // pixel coordinates\r\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n     vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;   \r\n     vec2 mouse = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;   \r\n \t vec3 col=vec3(0.0);\r\n  \r\n  \t  col *= 1.5 - 0.2*length(p);\r\n      col = col*vec3(1.11,0.89,0.79);\r\n    \r\n      col=scene(p,iResolution.xy,mouse);\r\n        \r\n         tot += col;\r\n    }\r\n    \r\n    tot /= float(AA*AA);\r\n    \r\n  fragColor = vec4(tot,1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"virtual keyboard","id":"45a5dadf907b4dca8e5ae5beeac82b46","date":null,"viewed":0,"name":"virtual keyboard","description":"virtual keyboard\r\nhttps://www.shadertoy.com/view/3d3fD4","likes":0,"published":null,"tags":["keyboard"," virtual"]},"ver":null,"info":{"Name":"virtual keyboard","id":"45a5dadf907b4dca8e5ae5beeac82b46","date":null,"viewed":0,"name":"virtual keyboard","description":"virtual keyboard\r\nhttps://www.shadertoy.com/view/3d3fD4","likes":0,"published":null,"tags":["keyboard"," virtual"]},"renderpass":[{"Code":"//Font liberated from http://paulbourke.net/dataformats/hershey/\r\n\r\nfloat res=0.;\r\nvec2 cpos=vec2(0.);\r\n\r\nfloat antiAlias(float x,vec2 iResolution) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.);}\r\n\r\n#define PI 3.14159265359\r\n\r\n//float opU( float d1, float d2 )\r\n//{\r\n//    return max(d1,d2);\r\n//}\r\n#define opU(a,b) max(a,b)\r\n\r\nfloat width;\r\n\r\nfloat line( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p - a;\r\n    vec2 ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    float d = length( pa - ba*h );\r\n\r\n    return  1.00 + width - d;\r\n}\r\n// CHAR: 32 : \r\nvoid char_32(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 33 :!\r\nvoid char_33(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 34 :\"\r\nvoid char_34(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 35 :#\r\nvoid char_35(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(18.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(17.0,6.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 36 :$\r\nvoid char_36(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,25.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,25.0)*s,vec2(12.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 37 :%\r\nvoid char_37(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(21.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,19.0)*s,vec2(10.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(6.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,20.0)*s,vec2(13.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,19.0)*s,vec2(16.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,19.0)*s,vec2(19.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,20.0)*s,vec2(21.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(15.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,2.0)*s,vec2(16.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,0.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,0.0)*s,vec2(20.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,1.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,3.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(19.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,7.0)*s,vec2(17.0,7.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 38 :&\r\nvoid char_38(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(23.0,12.0)*s,vec2(23.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,13.0)*s,vec2(22.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,14.0)*s,vec2(21.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,14.0)*s,vec2(20.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,13.0)*s,vec2(19.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,11.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,9.0)*s,vec2(12.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,13.0)*s,vec2(13.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,14.0)*s,vec2(14.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,16.0)*s,vec2(14.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,18.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(8.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,16.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(11.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,10.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,0.0)*s,vec2(22.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,0.0)*s,vec2(23.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,1.0)*s,vec2(23.0,2.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 39 :'\r\nvoid char_39(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(6.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,18.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,15.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 40 :(\r\nvoid char_40(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(9.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(9.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-5.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 41 :)\r\nvoid char_41(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(5.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(9.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,16.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(10.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,7.0)*s,vec2(9.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(5.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-5.0)*s,vec2(3.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 42 :*\r\nvoid char_42(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(3.0,12.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 43 :+\r\nvoid char_43(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 44 :,\r\nvoid char_44(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 45 :-\r\nvoid char_45(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 46 :.\r\nvoid char_46(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 47 :/\r\nvoid char_47(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,25.0)*s,vec2(2.0,-7.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 48 :0\r\nvoid char_0(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,4.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 49 :1\r\nvoid char_1(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(11.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 50 :2\r\nvoid char_2(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(15.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,19.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(16.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,15.0)*s,vec2(15.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,13.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 51 :3\r\nvoid char_3(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(16.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,21.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 52 :4\r\nvoid char_4(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(13.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 53 :5\r\nvoid char_5(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 54 :6\r\nvoid char_6(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(11.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,13.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(5.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,10.0)*s,vec2(4.0,7.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 55 :7\r\nvoid char_7(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 56 :8\r\nvoid char_8(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(11.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,12.0)*s,vec2(14.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(17.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,4.0)*s,vec2(16.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,2.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(9.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(16.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,16.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 57 :9\r\nvoid char_9(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,9.0)*s,vec2(10.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,8.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(6.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,9.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(3.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,15.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(15.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,18.0)*s,vec2(16.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,4.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 58 ::\r\nvoid char_58(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 59 :;\r\nvoid char_59(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 60 :<\r\nvoid char_60(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,18.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 61 :=\r\nvoid char_61(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(22.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(22.0,6.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 62 :>\r\nvoid char_62(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(20.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,9.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 63 :?\r\nvoid char_63(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,17.0)*s,vec2(4.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,19.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(14.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,19.0)*s,vec2(15.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,17.0)*s,vec2(15.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,15.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,12.0)*s,vec2(9.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,10.0)*s,vec2(9.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(9.0,2.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 64 :@\r\nvoid char_64(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(17.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,15.0)*s,vec2(15.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,16.0)*s,vec2(12.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,15.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(8.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(9.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,5.0)*s,vec2(14.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,5.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(10.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,5.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(23.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,7.0)*s,vec2(24.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,10.0)*s,vec2(24.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,12.0)*s,vec2(23.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,15.0)*s,vec2(22.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,17.0)*s,vec2(20.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,19.0)*s,vec2(18.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,20.0)*s,vec2(15.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(7.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,19.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,15.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(9.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,0.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,2.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,16.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    cpos.x+=27.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 65 :A\r\nvoid char_A(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(1.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(14.0,7.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 66 :B\r\nvoid char_B(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(18.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,4.0)*s,vec2(17.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,2.0)*s,vec2(16.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,1.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 67 :C\r\nvoid char_C(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 68 :D\r\nvoid char_D(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(17.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,16.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(17.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,5.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 69 :E\r\nvoid char_E(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 70 :F\r\nvoid char_F(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 71 :G\r\nvoid char_G(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,8.0)*s,vec2(18.0,8.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 72 :H\r\nvoid char_H(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(18.0,11.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 73 :I\r\nvoid char_I(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 74 :J\r\nvoid char_J(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,5.0)*s,vec2(11.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,2.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,2.0)*s,vec2(2.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,5.0)*s,vec2(2.0,7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 75 :K\r\nvoid char_K(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 76 :L\r\nvoid char_L(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(16.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 77 :M\r\nvoid char_M(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 78 :N\r\nvoid char_N(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 79 :O\r\nvoid char_O(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 80 :P\r\nvoid char_P(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,14.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(4.0,10.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 81 :Q\r\nvoid char_Q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,4.0)*s,vec2(18.0,-2.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 82 :R\r\nvoid char_R(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,11.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 83 :S\r\nvoid char_S(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 84 :T\r\nvoid char_T(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(15.0,21.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 85 :U\r\nvoid char_U(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(18.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 86 :V\r\nvoid char_V(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 87 :W\r\nvoid char_W(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 88 :X\r\nvoid char_X(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 89 :Y\r\nvoid char_Y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 90 :Z\r\nvoid char_Z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 91 :[\r\nvoid char_91(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(5.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(11.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-7.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 92 :\\;\r\nvoid char_92(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,21.0)*s,vec2(14.0,-3.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 93 :]\r\nvoid char_93(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(9.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(10.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(10.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 94 :^\r\nvoid char_94(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,15.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 95 :_\r\nvoid char_95(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,-2.0)*s,vec2(16.0,-2.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 96 :`\r\nvoid char_96(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(6.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,16.0)*s,vec2(5.0,17.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 97 :a\r\nvoid char_a(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 98 :b\r\nvoid char_b(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 99 :c\r\nvoid char_c(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 100 :d\r\nvoid char_d(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 101 :e\r\nvoid char_e(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(15.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,8.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 102 :f\r\nvoid char_f(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 103 :g\r\nvoid char_g(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,-2.0)*s,vec2(14.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,-5.0)*s,vec2(13.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,-6.0)*s,vec2(11.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,-7.0)*s,vec2(8.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-7.0)*s,vec2(6.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 104 :h\r\nvoid char_h(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 105 :i\r\nvoid char_i(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,22.0)*s,vec2(3.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 106 :j\r\nvoid char_j(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-3.0)*s,vec2(5.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-6.0)*s,vec2(3.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 107 :k\r\nvoid char_k(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 108 :l\r\nvoid char_l(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 109 :m\r\nvoid char_m(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(20.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,14.0)*s,vec2(23.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,14.0)*s,vec2(25.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(25.0,13.0)*s,vec2(26.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(26.0,10.0)*s,vec2(26.0,0.0)*s));\r\n    cpos.x+=30.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 110 :n\r\nvoid char_n(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 111 :o\r\nvoid char_o(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 112 :p\r\nvoid char_p(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 113 :q\r\nvoid char_q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 114 :r\r\nvoid char_r(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,11.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=13.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 115 :s\r\nvoid char_s(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(3.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(11.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,7.0)*s,vec2(13.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 116 :t\r\nvoid char_t(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 117 :u\r\nvoid char_u(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,1.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 118 :v\r\nvoid char_v(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 119 :w\r\nvoid char_w(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 120 :x\r\nvoid char_x(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 121 :y\r\nvoid char_y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(4.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-6.0)*s,vec2(2.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 122 :z\r\nvoid char_z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(14.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 123 :{\r\nvoid char_123(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,23.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(6.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(8.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,7.0)*s,vec2(9.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,5.0)*s,vec2(9.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,3.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(6.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-2.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(8.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,6.0)*s,vec2(8.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(6.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(9.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n// CHAR: 124 :|\r\nvoid char_124(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n// CHAR: 125 :}\r\nvoid char_125(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,23.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(9.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,19.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(6.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,22.0)*s,vec2(8.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(10.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,9.0)*s,vec2(6.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,7.0)*s,vec2(5.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(8.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-2.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(6.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,6.0)*s,vec2(6.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-1.0)*s,vec2(9.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-3.0)*s,vec2(8.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(5.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 126 :~\r\nvoid char_126(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(14.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,8.0)*s,vec2(16.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(20.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,8.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(10.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,10.0)*s,vec2(14.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,7.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(20.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,7.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,10.0)*s,vec2(21.0,12.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n vec3 abc(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n    \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_A(uv,s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_B(uv,s);\r\n    \r\n\tchar_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_C(uv-vec2(-0.01,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    char_D(uv-vec2(-0.02,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    \r\n    \r\n    char_E(uv-vec2(-0.03,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_F(uv-vec2(-0.04,0.0),s);\r\n    \r\n    char_G(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_H(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_I(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_J(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_K(uv-vec2(-1.1,-0.12),s);\r\n\t\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_L(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_M(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n\tchar_N(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n\tchar_O(uv-vec2(-2.15,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n  \r\n\tchar_P(uv-vec2(-2.13,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\tchar_Q(uv-vec2(-2.1,-0.223),s);\r\n     \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n\tchar_R(uv-vec2(-2.08,-0.223),s);\r\n    \r\n    char_S(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n    char_T(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_U(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n    char_V(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_X(uv-vec2(-3.17,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_W(uv-vec2(-3.18,-0.34),s);\r\n    \r\n    char_Y(uv-vec2(-4.23,-0.45),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_z(uv-vec2(-4.23,-0.44),s);\r\n\r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\nvec3 help(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n     \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_H(uv,s);\r\n    char_E(uv,s);\r\n    char_L(uv,s);\r\n    char_P(uv,s);\r\n\r\n    \r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\n#define AA 1\r\nmat2 Rot(float a) {\r\n    float s = sin(a);\r\n    float c = cos(a);\r\n    return mat2(vec2(c, -s),vec2( s, c));\r\n}\r\nfloat sdBox( in vec2 p, in vec2 b )\r\n{\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nvec3 scene(vec2 p,vec2 iResolution,vec2 mouse){\r\n    vec3 col;\r\n   \r\n   p/=vec2(0.5);\r\n   mouse/=vec2(0.5);\r\n   mouse.y+=0.9;\r\n   p.y+=0.9;\r\n    \r\n  \r\n   float linha[15];\r\n   linha[0]=sdBox(p,vec2(1.8,0.01));\r\n   linha[1]=sdBox(p+vec2(0.0,0.33),vec2(1.8,0.01));\r\n   linha[2]=sdBox(p+vec2(0.0,0.66),vec2(1.8,0.01));\r\n   linha[3]=sdBox(p+vec2(0.0,-0.33),vec2(1.8,0.01));\r\n   linha[4]=sdBox(p+vec2(0.0,-0.66),vec2(1.8,0.01));\r\n   \r\n   \r\n   linha[5]=sdBox(p,vec2(0.01,1.0));\r\n   linha[6]=sdBox(p+vec2(0.60,0.0),vec2(0.01,1.0));\r\n   linha[7]=sdBox(p+vec2(1.2,0.0),vec2(0.01,1.0));\r\n   linha[8]=sdBox(p+vec2(-0.60,0.0),vec2(0.01,1.0));\r\n   linha[9]=sdBox(p+vec2(-1.20,0.0),vec2(0.01,1.0));\r\n    \r\n   linha[10]=sdBox(p+vec2(0.0,-1.0),vec2(1.8,0.01));\r\n   linha[11]=sdBox(p+vec2(0.0,1.0),vec2(1.8,0.01));\r\n   linha[12]=sdBox(p+vec2(-1.8,0.0),vec2(0.01,1.0));\r\n   linha[14]=sdBox(p+vec2(1.8,0.0),vec2(0.01,1.0));\r\n    \r\n    \r\n   float painel[26];\r\n   painel[0]=sdBox(p+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   painel[1]=sdBox(p+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   painel[2]=sdBox(p+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   painel[3]=sdBox(p+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   painel[4]=sdBox(p+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   painel[5]=sdBox(p+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   painel[6]=sdBox(p+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   painel[7]=sdBox(p+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[8]=sdBox(p+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[9]=sdBox(p+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[10]=sdBox(p+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[11]=sdBox(p+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   painel[12]=sdBox(p+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   painel[13]=sdBox(p+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[14]=sdBox(p+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[15]=sdBox(p+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[16]=sdBox(p+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[17]=sdBox(p+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   painel[18]=sdBox(p+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   painel[19]=sdBox(p+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   painel[20]=sdBox(p+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   painel[21]=sdBox(p+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   painel[22]=sdBox(p+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   painel[23]=sdBox(p+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   painel[24]=sdBox(p+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   painel[25]=sdBox(p+vec2(0.9,0.5),vec2(0.28,0.17)); \r\n    \r\n   float regiao[26];\r\n    \r\n   col=abc(p,iResolution,  vec3(0.82));\r\n   regiao[0]=sdBox(mouse+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   regiao[1]=sdBox(mouse+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[2]=sdBox(mouse+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[3]=sdBox(mouse+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[4]=sdBox(mouse+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[5]=sdBox(mouse+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   regiao[6]=sdBox(mouse+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   regiao[7]=sdBox(mouse+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[8]=sdBox(mouse+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[9]=sdBox(mouse+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[10]=sdBox(mouse+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[11]=sdBox(mouse+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   regiao[12]=sdBox(mouse+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   regiao[13]=sdBox(mouse+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[14]=sdBox(mouse+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[15]=sdBox(mouse+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[16]=sdBox(mouse+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[17]=sdBox(mouse+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   regiao[18]=sdBox(mouse+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   regiao[19]=sdBox(mouse+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[20]=sdBox(mouse+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   regiao[21]=sdBox(mouse+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   regiao[22]=sdBox(mouse+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[23]=sdBox(mouse+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   regiao[24]=sdBox(mouse+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   regiao[25]=sdBox(mouse+vec2(0.9,0.5),vec2(0.28,0.17));  \r\n    vec3 t=vec3(0.0);\r\n    float Output=sdBox(p-vec2(0.0,2.0),vec2(3.0,0.5));\r\n   \r\n   if(Output < 0.0) col=vec3(1.0);\r\n   \r\n    float caractere[24];\r\n    \r\n    caractere[0]=sdBox(p+vec2(0.0,-2.0),vec2(0.5,.5));\r\n\r\n    for(int i=0;i<painel.length();i++){\r\n   \t if(regiao[i]<=0.0 ){\r\n\r\n      \t  if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.1));\r\n         t=vec3(0.0,1.0,0.0);\r\n\r\n  \t  }else{ \r\n    \t    if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.82));\r\n   \t }\r\n\r\n    }\r\n    for(int i=0;i<linha.length();i++){\r\n  \r\n  \t\tif(linha[i] < 0.0) col=vec3(0.0);\r\n  \r\n    }\r\n   if(caractere[0] < 0.0) col=help(p+vec2(-1.2,-1.0),iResolution,  vec3(0.82));\r\n   return col;\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec3 tot = vec3(0.0);\r\n  \r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n     // pixel coordinates\r\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n     vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;   \r\n     vec2 mouse = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;   \r\n \t vec3 col=vec3(0.0);\r\n  \r\n  \t  col *= 1.5 - 0.2*length(p);\r\n      col = col*vec3(1.11,0.89,0.79);\r\n    \r\n      col=scene(p,iResolution.xy,mouse);\r\n        \r\n         tot += col;\r\n    }\r\n    \r\n    tot /= float(AA*AA);\r\n    \r\n  fragColor = vec4(tot,1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"//Font liberated from http://paulbourke.net/dataformats/hershey/\r\n\r\nfloat res=0.;\r\nvec2 cpos=vec2(0.);\r\n\r\nfloat antiAlias(float x,vec2 iResolution) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.);}\r\n\r\n#define PI 3.14159265359\r\n\r\n//float opU( float d1, float d2 )\r\n//{\r\n//    return max(d1,d2);\r\n//}\r\n#define opU(a,b) max(a,b)\r\n\r\nfloat width;\r\n\r\nfloat line( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p - a;\r\n    vec2 ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    float d = length( pa - ba*h );\r\n\r\n    return  1.00 + width - d;\r\n}\r\n// CHAR: 32 : \r\nvoid char_32(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 33 :!\r\nvoid char_33(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 34 :\"\r\nvoid char_34(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 35 :#\r\nvoid char_35(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(18.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(17.0,6.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 36 :$\r\nvoid char_36(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,25.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,25.0)*s,vec2(12.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 37 :%\r\nvoid char_37(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(21.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,19.0)*s,vec2(10.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(6.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,20.0)*s,vec2(13.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,19.0)*s,vec2(16.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,19.0)*s,vec2(19.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,20.0)*s,vec2(21.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(15.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,2.0)*s,vec2(16.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,0.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,0.0)*s,vec2(20.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,1.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,3.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(19.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,7.0)*s,vec2(17.0,7.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 38 :&\r\nvoid char_38(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(23.0,12.0)*s,vec2(23.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,13.0)*s,vec2(22.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,14.0)*s,vec2(21.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,14.0)*s,vec2(20.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,13.0)*s,vec2(19.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,11.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,9.0)*s,vec2(12.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,13.0)*s,vec2(13.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,14.0)*s,vec2(14.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,16.0)*s,vec2(14.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,18.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(8.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,16.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(11.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,10.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,0.0)*s,vec2(22.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,0.0)*s,vec2(23.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,1.0)*s,vec2(23.0,2.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 39 :'\r\nvoid char_39(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(6.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,18.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,15.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 40 :(\r\nvoid char_40(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(9.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(9.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-5.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 41 :)\r\nvoid char_41(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(5.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(9.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,16.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(10.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,7.0)*s,vec2(9.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(5.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-5.0)*s,vec2(3.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 42 :*\r\nvoid char_42(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(3.0,12.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 43 :+\r\nvoid char_43(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 44 :,\r\nvoid char_44(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 45 :-\r\nvoid char_45(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 46 :.\r\nvoid char_46(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 47 :/\r\nvoid char_47(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,25.0)*s,vec2(2.0,-7.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 48 :0\r\nvoid char_0(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,4.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 49 :1\r\nvoid char_1(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(11.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 50 :2\r\nvoid char_2(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(15.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,19.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(16.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,15.0)*s,vec2(15.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,13.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 51 :3\r\nvoid char_3(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(16.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,21.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 52 :4\r\nvoid char_4(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(13.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 53 :5\r\nvoid char_5(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 54 :6\r\nvoid char_6(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(11.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,13.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(5.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,10.0)*s,vec2(4.0,7.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 55 :7\r\nvoid char_7(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 56 :8\r\nvoid char_8(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(11.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,12.0)*s,vec2(14.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(17.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,4.0)*s,vec2(16.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,2.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(9.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(16.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,16.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 57 :9\r\nvoid char_9(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,9.0)*s,vec2(10.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,8.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(6.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,9.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(3.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,15.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(15.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,18.0)*s,vec2(16.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,4.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 58 ::\r\nvoid char_58(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 59 :;\r\nvoid char_59(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 60 :<\r\nvoid char_60(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,18.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 61 :=\r\nvoid char_61(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(22.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(22.0,6.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 62 :>\r\nvoid char_62(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(20.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,9.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 63 :?\r\nvoid char_63(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,17.0)*s,vec2(4.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,19.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(14.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,19.0)*s,vec2(15.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,17.0)*s,vec2(15.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,15.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,12.0)*s,vec2(9.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,10.0)*s,vec2(9.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(9.0,2.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 64 :@\r\nvoid char_64(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(17.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,15.0)*s,vec2(15.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,16.0)*s,vec2(12.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,15.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(8.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(9.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,5.0)*s,vec2(14.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,5.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(10.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,5.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(23.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,7.0)*s,vec2(24.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,10.0)*s,vec2(24.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,12.0)*s,vec2(23.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,15.0)*s,vec2(22.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,17.0)*s,vec2(20.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,19.0)*s,vec2(18.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,20.0)*s,vec2(15.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(7.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,19.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,15.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(9.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,0.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,2.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,16.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    cpos.x+=27.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 65 :A\r\nvoid char_A(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(1.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(14.0,7.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 66 :B\r\nvoid char_B(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(18.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,4.0)*s,vec2(17.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,2.0)*s,vec2(16.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,1.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 67 :C\r\nvoid char_C(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 68 :D\r\nvoid char_D(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(17.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,16.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(17.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,5.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 69 :E\r\nvoid char_E(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 70 :F\r\nvoid char_F(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 71 :G\r\nvoid char_G(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,8.0)*s,vec2(18.0,8.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 72 :H\r\nvoid char_H(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(18.0,11.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 73 :I\r\nvoid char_I(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 74 :J\r\nvoid char_J(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,5.0)*s,vec2(11.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,2.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,2.0)*s,vec2(2.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,5.0)*s,vec2(2.0,7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 75 :K\r\nvoid char_K(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 76 :L\r\nvoid char_L(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(16.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 77 :M\r\nvoid char_M(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 78 :N\r\nvoid char_N(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 79 :O\r\nvoid char_O(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 80 :P\r\nvoid char_P(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,14.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(4.0,10.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 81 :Q\r\nvoid char_Q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,4.0)*s,vec2(18.0,-2.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 82 :R\r\nvoid char_R(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,11.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 83 :S\r\nvoid char_S(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 84 :T\r\nvoid char_T(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(15.0,21.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 85 :U\r\nvoid char_U(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(18.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 86 :V\r\nvoid char_V(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 87 :W\r\nvoid char_W(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 88 :X\r\nvoid char_X(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 89 :Y\r\nvoid char_Y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 90 :Z\r\nvoid char_Z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 91 :[\r\nvoid char_91(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(5.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(11.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-7.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 92 :\\;\r\nvoid char_92(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,21.0)*s,vec2(14.0,-3.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 93 :]\r\nvoid char_93(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(9.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(10.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(10.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 94 :^\r\nvoid char_94(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,15.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 95 :_\r\nvoid char_95(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,-2.0)*s,vec2(16.0,-2.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 96 :`\r\nvoid char_96(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(6.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,16.0)*s,vec2(5.0,17.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 97 :a\r\nvoid char_a(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 98 :b\r\nvoid char_b(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 99 :c\r\nvoid char_c(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 100 :d\r\nvoid char_d(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 101 :e\r\nvoid char_e(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(15.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,8.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 102 :f\r\nvoid char_f(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 103 :g\r\nvoid char_g(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,-2.0)*s,vec2(14.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,-5.0)*s,vec2(13.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,-6.0)*s,vec2(11.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,-7.0)*s,vec2(8.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-7.0)*s,vec2(6.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 104 :h\r\nvoid char_h(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 105 :i\r\nvoid char_i(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,22.0)*s,vec2(3.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 106 :j\r\nvoid char_j(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-3.0)*s,vec2(5.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-6.0)*s,vec2(3.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 107 :k\r\nvoid char_k(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 108 :l\r\nvoid char_l(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 109 :m\r\nvoid char_m(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(20.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,14.0)*s,vec2(23.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,14.0)*s,vec2(25.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(25.0,13.0)*s,vec2(26.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(26.0,10.0)*s,vec2(26.0,0.0)*s));\r\n    cpos.x+=30.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 110 :n\r\nvoid char_n(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 111 :o\r\nvoid char_o(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 112 :p\r\nvoid char_p(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 113 :q\r\nvoid char_q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 114 :r\r\nvoid char_r(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,11.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=13.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 115 :s\r\nvoid char_s(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(3.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(11.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,7.0)*s,vec2(13.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 116 :t\r\nvoid char_t(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 117 :u\r\nvoid char_u(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,1.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 118 :v\r\nvoid char_v(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 119 :w\r\nvoid char_w(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 120 :x\r\nvoid char_x(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 121 :y\r\nvoid char_y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(4.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-6.0)*s,vec2(2.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 122 :z\r\nvoid char_z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(14.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 123 :{\r\nvoid char_123(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,23.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(6.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(8.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,7.0)*s,vec2(9.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,5.0)*s,vec2(9.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,3.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(6.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-2.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(8.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,6.0)*s,vec2(8.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(6.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(9.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n// CHAR: 124 :|\r\nvoid char_124(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n// CHAR: 125 :}\r\nvoid char_125(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,23.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(9.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,19.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(6.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,22.0)*s,vec2(8.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(10.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,9.0)*s,vec2(6.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,7.0)*s,vec2(5.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(8.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-2.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(6.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,6.0)*s,vec2(6.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-1.0)*s,vec2(9.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-3.0)*s,vec2(8.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(5.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 126 :~\r\nvoid char_126(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(14.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,8.0)*s,vec2(16.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(20.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,8.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(10.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,10.0)*s,vec2(14.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,7.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(20.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,7.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,10.0)*s,vec2(21.0,12.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n vec3 abc(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n    \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_A(uv,s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_B(uv,s);\r\n    \r\n\tchar_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_C(uv-vec2(-0.01,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    char_D(uv-vec2(-0.02,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    \r\n    \r\n    char_E(uv-vec2(-0.03,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_F(uv-vec2(-0.04,0.0),s);\r\n    \r\n    char_G(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_H(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_I(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_J(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_K(uv-vec2(-1.1,-0.12),s);\r\n\t\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_L(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_M(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n\tchar_N(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n\tchar_O(uv-vec2(-2.15,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n  \r\n\tchar_P(uv-vec2(-2.13,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\tchar_Q(uv-vec2(-2.1,-0.223),s);\r\n     \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n\tchar_R(uv-vec2(-2.08,-0.223),s);\r\n    \r\n    char_S(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n    char_T(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_U(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n    char_V(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_X(uv-vec2(-3.17,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_W(uv-vec2(-3.18,-0.34),s);\r\n    \r\n    char_Y(uv-vec2(-4.23,-0.45),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_z(uv-vec2(-4.23,-0.44),s);\r\n\r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\nvec3 help(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n     \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_H(uv,s);\r\n    char_E(uv,s);\r\n    char_L(uv,s);\r\n    char_P(uv,s);\r\n\r\n    \r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\n#define AA 1\r\nmat2 Rot(float a) {\r\n    float s = sin(a);\r\n    float c = cos(a);\r\n    return mat2(vec2(c, -s),vec2( s, c));\r\n}\r\nfloat sdBox( in vec2 p, in vec2 b )\r\n{\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nvec3 scene(vec2 p,vec2 iResolution,vec2 mouse){\r\n    vec3 col;\r\n   \r\n   p/=vec2(0.5);\r\n   mouse/=vec2(0.5);\r\n   mouse.y+=0.9;\r\n   p.y+=0.9;\r\n    \r\n  \r\n   float linha[15];\r\n   linha[0]=sdBox(p,vec2(1.8,0.01));\r\n   linha[1]=sdBox(p+vec2(0.0,0.33),vec2(1.8,0.01));\r\n   linha[2]=sdBox(p+vec2(0.0,0.66),vec2(1.8,0.01));\r\n   linha[3]=sdBox(p+vec2(0.0,-0.33),vec2(1.8,0.01));\r\n   linha[4]=sdBox(p+vec2(0.0,-0.66),vec2(1.8,0.01));\r\n   \r\n   \r\n   linha[5]=sdBox(p,vec2(0.01,1.0));\r\n   linha[6]=sdBox(p+vec2(0.60,0.0),vec2(0.01,1.0));\r\n   linha[7]=sdBox(p+vec2(1.2,0.0),vec2(0.01,1.0));\r\n   linha[8]=sdBox(p+vec2(-0.60,0.0),vec2(0.01,1.0));\r\n   linha[9]=sdBox(p+vec2(-1.20,0.0),vec2(0.01,1.0));\r\n    \r\n   linha[10]=sdBox(p+vec2(0.0,-1.0),vec2(1.8,0.01));\r\n   linha[11]=sdBox(p+vec2(0.0,1.0),vec2(1.8,0.01));\r\n   linha[12]=sdBox(p+vec2(-1.8,0.0),vec2(0.01,1.0));\r\n   linha[14]=sdBox(p+vec2(1.8,0.0),vec2(0.01,1.0));\r\n    \r\n    \r\n   float painel[26];\r\n   painel[0]=sdBox(p+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   painel[1]=sdBox(p+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   painel[2]=sdBox(p+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   painel[3]=sdBox(p+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   painel[4]=sdBox(p+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   painel[5]=sdBox(p+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   painel[6]=sdBox(p+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   painel[7]=sdBox(p+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[8]=sdBox(p+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[9]=sdBox(p+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[10]=sdBox(p+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[11]=sdBox(p+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   painel[12]=sdBox(p+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   painel[13]=sdBox(p+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[14]=sdBox(p+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[15]=sdBox(p+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[16]=sdBox(p+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[17]=sdBox(p+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   painel[18]=sdBox(p+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   painel[19]=sdBox(p+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   painel[20]=sdBox(p+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   painel[21]=sdBox(p+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   painel[22]=sdBox(p+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   painel[23]=sdBox(p+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   painel[24]=sdBox(p+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   painel[25]=sdBox(p+vec2(0.9,0.5),vec2(0.28,0.17)); \r\n    \r\n   float regiao[26];\r\n    \r\n   col=abc(p,iResolution,  vec3(0.82));\r\n   regiao[0]=sdBox(mouse+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   regiao[1]=sdBox(mouse+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[2]=sdBox(mouse+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[3]=sdBox(mouse+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[4]=sdBox(mouse+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[5]=sdBox(mouse+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   regiao[6]=sdBox(mouse+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   regiao[7]=sdBox(mouse+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[8]=sdBox(mouse+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[9]=sdBox(mouse+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[10]=sdBox(mouse+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[11]=sdBox(mouse+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   regiao[12]=sdBox(mouse+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   regiao[13]=sdBox(mouse+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[14]=sdBox(mouse+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[15]=sdBox(mouse+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[16]=sdBox(mouse+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[17]=sdBox(mouse+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   regiao[18]=sdBox(mouse+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   regiao[19]=sdBox(mouse+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[20]=sdBox(mouse+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   regiao[21]=sdBox(mouse+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   regiao[22]=sdBox(mouse+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[23]=sdBox(mouse+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   regiao[24]=sdBox(mouse+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   regiao[25]=sdBox(mouse+vec2(0.9,0.5),vec2(0.28,0.17));  \r\n    vec3 t=vec3(0.0);\r\n    float Output=sdBox(p-vec2(0.0,2.0),vec2(3.0,0.5));\r\n   \r\n   if(Output < 0.0) col=vec3(1.0);\r\n   \r\n    float caractere[24];\r\n    \r\n    caractere[0]=sdBox(p+vec2(0.0,-2.0),vec2(0.5,.5));\r\n\r\n    for(int i=0;i<painel.length();i++){\r\n   \t if(regiao[i]<=0.0 ){\r\n\r\n      \t  if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.1));\r\n         t=vec3(0.0,1.0,0.0);\r\n\r\n  \t  }else{ \r\n    \t    if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.82));\r\n   \t }\r\n\r\n    }\r\n    for(int i=0;i<linha.length();i++){\r\n  \r\n  \t\tif(linha[i] < 0.0) col=vec3(0.0);\r\n  \r\n    }\r\n   if(caractere[0] < 0.0) col=help(p+vec2(-1.2,-1.0),iResolution,  vec3(0.82));\r\n   return col;\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec3 tot = vec3(0.0);\r\n  \r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n     // pixel coordinates\r\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n     vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;   \r\n     vec2 mouse = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;   \r\n \t vec3 col=vec3(0.0);\r\n  \r\n  \t  col *= 1.5 - 0.2*length(p);\r\n      col = col*vec3(1.11,0.89,0.79);\r\n    \r\n      col=scene(p,iResolution.xy,mouse);\r\n        \r\n         tot += col;\r\n    }\r\n    \r\n    tot /= float(AA*AA);\r\n    \r\n  fragColor = vec4(tot,1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// based on SebH's https://www.shadertoy.com/view/MdKSzc\r\n//          h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor,  vec2 uv )\r\n{\r\n\tuv /= iResolution.xy;\r\n    \r\n    // Draw XYZ curves at the bottom\r\n\r\n    float wavelength = float(SPECTRUM_START) + uv.x * float(SPECTRUM_BIN*SPECTRUM_STEP);\r\n    \r\n    \r\n    // Display XYZ spectrum curve\r\n\r\n\tvec3 outColor = step( uv.y*4., xyzFit_1931(wavelength) );\r\n   \r\n\r\n    // Spectrum -> xyz -> rgb absorption gradient\r\n\r\n    float spectrum[SPECTRUM_BIN];\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n      #if 1\r\n        spectrum[i] = 0.014;// uniform band distribution\r\n      #else\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n    \t      X = xFit_1931(w),\r\n    \t      Y = yFit_1931(w),\r\n    \t      Z = zFit_1931(w);\r\n        spectrum[i] = (X+Y+Z) * 0.014;// follow xyz distribution\r\n      #endif\r\n    }\r\n    \r\n\r\n \r\n#define sqr(x) ((x)*(x))\r\n#define gauss(x,s) 1.14* exp(-.5*sqr((x)/(s))) / (s)\r\n#define S 1.\r\n//#define S ((2.*uv.y-1.)*10.)\r\n    \r\n    if (uv.y >.9) uv.x = 5./uv.x / float(SPECTRUM_BIN); // org by freqs instead of wavelengths\r\n        \r\n    // Compute spectrum perception along wavelengthes  ( was: Compute spectrum after absorption )\r\n    float spectrum2[SPECTRUM_BIN],\r\n        depth = uv.x * 1000.;\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n        // spectrum2[i] = spectrum[i]  * exp(-depth * getAbsorption(w));\r\n        // spectrum2[i] = spectrum[i]*float(int(uv.x*float(SPECTRUM_BIN))==i);\r\n        spectrum2[i] = spectrum[i] * gauss( uv.x*float(SPECTRUM_BIN)-float(i), S);\r\n    }\r\n    \r\n    vec3 colorXYZ = vec3(0),\r\n        color2XYZ = vec3(0);\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i),  \r\n             dw = float(SPECTRUM_STEP);\r\n\r\n        vec3 xyzFit = dw * xyzFit_1931(w);        \r\n        colorXYZ  += spectrum [i] * xyzFit;\r\n        color2XYZ += spectrum2[i] * xyzFit;\r\n\t}\r\n    \r\n    vec3 color = xyzToRgb(colorXYZ),\r\n        color2 = xyzToRgb(constrainXYZToSRGBGamut(color2XYZ));\r\n    \r\n\r\n    // perceived colors at the top\r\n\r\n    if(uv.y > .5) {\r\n\t\toutColor =  uv.y > .75 && uv.y < .9\r\n           ? color2                                  // without gamma transform\r\n           : pow(max(vec3(0),color2), vec3(1./2.2)); // with gamma\r\n        if ( uv.y < .55 || uv.y > .97 )           \r\n             outColor = vec3(pow((color2.r+color2.g+color2.b)/3., 1./2.2));\r\n    }\r\n\r\n    \r\n\tfragColor = vec4(outColor,1.);\r\n}","inputs":[],"outputs":[],"code":"// based on SebH's https://www.shadertoy.com/view/MdKSzc\r\n//          h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor,  vec2 uv )\r\n{\r\n\tuv /= iResolution.xy;\r\n    \r\n    // Draw XYZ curves at the bottom\r\n\r\n    float wavelength = float(SPECTRUM_START) + uv.x * float(SPECTRUM_BIN*SPECTRUM_STEP);\r\n    \r\n    \r\n    // Display XYZ spectrum curve\r\n\r\n\tvec3 outColor = step( uv.y*4., xyzFit_1931(wavelength) );\r\n   \r\n\r\n    // Spectrum -> xyz -> rgb absorption gradient\r\n\r\n    float spectrum[SPECTRUM_BIN];\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n      #if 1\r\n        spectrum[i] = 0.014;// uniform band distribution\r\n      #else\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n    \t      X = xFit_1931(w),\r\n    \t      Y = yFit_1931(w),\r\n    \t      Z = zFit_1931(w);\r\n        spectrum[i] = (X+Y+Z) * 0.014;// follow xyz distribution\r\n      #endif\r\n    }\r\n    \r\n\r\n \r\n#define sqr(x) ((x)*(x))\r\n#define gauss(x,s) 1.14* exp(-.5*sqr((x)/(s))) / (s)\r\n#define S 1.\r\n//#define S ((2.*uv.y-1.)*10.)\r\n    \r\n    if (uv.y >.9) uv.x = 5./uv.x / float(SPECTRUM_BIN); // org by freqs instead of wavelengths\r\n        \r\n    // Compute spectrum perception along wavelengthes  ( was: Compute spectrum after absorption )\r\n    float spectrum2[SPECTRUM_BIN],\r\n        depth = uv.x * 1000.;\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n        // spectrum2[i] = spectrum[i]  * exp(-depth * getAbsorption(w));\r\n        // spectrum2[i] = spectrum[i]*float(int(uv.x*float(SPECTRUM_BIN))==i);\r\n        spectrum2[i] = spectrum[i] * gauss( uv.x*float(SPECTRUM_BIN)-float(i), S);\r\n    }\r\n    \r\n    vec3 colorXYZ = vec3(0),\r\n        color2XYZ = vec3(0);\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i),  \r\n             dw = float(SPECTRUM_STEP);\r\n\r\n        vec3 xyzFit = dw * xyzFit_1931(w);        \r\n        colorXYZ  += spectrum [i] * xyzFit;\r\n        color2XYZ += spectrum2[i] * xyzFit;\r\n\t}\r\n    \r\n    vec3 color = xyzToRgb(colorXYZ),\r\n        color2 = xyzToRgb(constrainXYZToSRGBGamut(color2XYZ));\r\n    \r\n\r\n    // perceived colors at the top\r\n\r\n    if(uv.y > .5) {\r\n\t\toutColor =  uv.y > .75 && uv.y < .9\r\n           ? color2                                  // without gamma transform\r\n           : pow(max(vec3(0),color2), vec3(1./2.2)); // with gamma\r\n        if ( uv.y < .55 || uv.y > .97 )           \r\n             outColor = vec3(pow((color2.r+color2.g+color2.b)/3., 1./2.2));\r\n    }\r\n\r\n    \r\n\tfragColor = vec4(outColor,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"visible spectrum ","id":"170c58da0ae340b49b091a6e25035add","date":null,"viewed":0,"name":"visible spectrum ","description":"mid-height: perceived color associated to each wavelength from 360 to 790 nm\nabove: without the gamma conversion.\nvery top: perceived color associated to each frequency\n( based on h3r2tic's https://www.shadertoy.com/view/4dVSDy )\nhttps://www.shadertoy.com/view/llKSDz","likes":0,"published":null,"tags":["spectrum"," rainbow"," hue"," perception"," wavelength"," cie"," xyzcolorspace"]},"ver":null,"info":{"Name":"visible spectrum ","id":"170c58da0ae340b49b091a6e25035add","date":null,"viewed":0,"name":"visible spectrum ","description":"mid-height: perceived color associated to each wavelength from 360 to 790 nm\nabove: without the gamma conversion.\nvery top: perceived color associated to each frequency\n( based on h3r2tic's https://www.shadertoy.com/view/4dVSDy )\nhttps://www.shadertoy.com/view/llKSDz","likes":0,"published":null,"tags":["spectrum"," rainbow"," hue"," perception"," wavelength"," cie"," xyzcolorspace"]},"renderpass":[{"Code":"// based on SebH's https://www.shadertoy.com/view/MdKSzc\r\n//          h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor,  vec2 uv )\r\n{\r\n\tuv /= iResolution.xy;\r\n    \r\n    // Draw XYZ curves at the bottom\r\n\r\n    float wavelength = float(SPECTRUM_START) + uv.x * float(SPECTRUM_BIN*SPECTRUM_STEP);\r\n    \r\n    \r\n    // Display XYZ spectrum curve\r\n\r\n\tvec3 outColor = step( uv.y*4., xyzFit_1931(wavelength) );\r\n   \r\n\r\n    // Spectrum -> xyz -> rgb absorption gradient\r\n\r\n    float spectrum[SPECTRUM_BIN];\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n      #if 1\r\n        spectrum[i] = 0.014;// uniform band distribution\r\n      #else\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n    \t      X = xFit_1931(w),\r\n    \t      Y = yFit_1931(w),\r\n    \t      Z = zFit_1931(w);\r\n        spectrum[i] = (X+Y+Z) * 0.014;// follow xyz distribution\r\n      #endif\r\n    }\r\n    \r\n\r\n \r\n#define sqr(x) ((x)*(x))\r\n#define gauss(x,s) 1.14* exp(-.5*sqr((x)/(s))) / (s)\r\n#define S 1.\r\n//#define S ((2.*uv.y-1.)*10.)\r\n    \r\n    if (uv.y >.9) uv.x = 5./uv.x / float(SPECTRUM_BIN); // org by freqs instead of wavelengths\r\n        \r\n    // Compute spectrum perception along wavelengthes  ( was: Compute spectrum after absorption )\r\n    float spectrum2[SPECTRUM_BIN],\r\n        depth = uv.x * 1000.;\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n        // spectrum2[i] = spectrum[i]  * exp(-depth * getAbsorption(w));\r\n        // spectrum2[i] = spectrum[i]*float(int(uv.x*float(SPECTRUM_BIN))==i);\r\n        spectrum2[i] = spectrum[i] * gauss( uv.x*float(SPECTRUM_BIN)-float(i), S);\r\n    }\r\n    \r\n    vec3 colorXYZ = vec3(0),\r\n        color2XYZ = vec3(0);\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i),  \r\n             dw = float(SPECTRUM_STEP);\r\n\r\n        vec3 xyzFit = dw * xyzFit_1931(w);        \r\n        colorXYZ  += spectrum [i] * xyzFit;\r\n        color2XYZ += spectrum2[i] * xyzFit;\r\n\t}\r\n    \r\n    vec3 color = xyzToRgb(colorXYZ),\r\n        color2 = xyzToRgb(constrainXYZToSRGBGamut(color2XYZ));\r\n    \r\n\r\n    // perceived colors at the top\r\n\r\n    if(uv.y > .5) {\r\n\t\toutColor =  uv.y > .75 && uv.y < .9\r\n           ? color2                                  // without gamma transform\r\n           : pow(max(vec3(0),color2), vec3(1./2.2)); // with gamma\r\n        if ( uv.y < .55 || uv.y > .97 )           \r\n             outColor = vec3(pow((color2.r+color2.g+color2.b)/3., 1./2.2));\r\n    }\r\n\r\n    \r\n\tfragColor = vec4(outColor,1.);\r\n}","inputs":[],"outputs":[],"code":"// based on SebH's https://www.shadertoy.com/view/MdKSzc\r\n//          h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor,  vec2 uv )\r\n{\r\n\tuv /= iResolution.xy;\r\n    \r\n    // Draw XYZ curves at the bottom\r\n\r\n    float wavelength = float(SPECTRUM_START) + uv.x * float(SPECTRUM_BIN*SPECTRUM_STEP);\r\n    \r\n    \r\n    // Display XYZ spectrum curve\r\n\r\n\tvec3 outColor = step( uv.y*4., xyzFit_1931(wavelength) );\r\n   \r\n\r\n    // Spectrum -> xyz -> rgb absorption gradient\r\n\r\n    float spectrum[SPECTRUM_BIN];\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n      #if 1\r\n        spectrum[i] = 0.014;// uniform band distribution\r\n      #else\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n    \t      X = xFit_1931(w),\r\n    \t      Y = yFit_1931(w),\r\n    \t      Z = zFit_1931(w);\r\n        spectrum[i] = (X+Y+Z) * 0.014;// follow xyz distribution\r\n      #endif\r\n    }\r\n    \r\n\r\n \r\n#define sqr(x) ((x)*(x))\r\n#define gauss(x,s) 1.14* exp(-.5*sqr((x)/(s))) / (s)\r\n#define S 1.\r\n//#define S ((2.*uv.y-1.)*10.)\r\n    \r\n    if (uv.y >.9) uv.x = 5./uv.x / float(SPECTRUM_BIN); // org by freqs instead of wavelengths\r\n        \r\n    // Compute spectrum perception along wavelengthes  ( was: Compute spectrum after absorption )\r\n    float spectrum2[SPECTRUM_BIN],\r\n        depth = uv.x * 1000.;\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n        // spectrum2[i] = spectrum[i]  * exp(-depth * getAbsorption(w));\r\n        // spectrum2[i] = spectrum[i]*float(int(uv.x*float(SPECTRUM_BIN))==i);\r\n        spectrum2[i] = spectrum[i] * gauss( uv.x*float(SPECTRUM_BIN)-float(i), S);\r\n    }\r\n    \r\n    vec3 colorXYZ = vec3(0),\r\n        color2XYZ = vec3(0);\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i),  \r\n             dw = float(SPECTRUM_STEP);\r\n\r\n        vec3 xyzFit = dw * xyzFit_1931(w);        \r\n        colorXYZ  += spectrum [i] * xyzFit;\r\n        color2XYZ += spectrum2[i] * xyzFit;\r\n\t}\r\n    \r\n    vec3 color = xyzToRgb(colorXYZ),\r\n        color2 = xyzToRgb(constrainXYZToSRGBGamut(color2XYZ));\r\n    \r\n\r\n    // perceived colors at the top\r\n\r\n    if(uv.y > .5) {\r\n\t\toutColor =  uv.y > .75 && uv.y < .9\r\n           ? color2                                  // without gamma transform\r\n           : pow(max(vec3(0),color2), vec3(1./2.2)); // with gamma\r\n        if ( uv.y < .55 || uv.y > .97 )           \r\n             outColor = vec3(pow((color2.r+color2.g+color2.b)/3., 1./2.2));\r\n    }\r\n\r\n    \r\n\tfragColor = vec4(outColor,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":" #define SHQ\t\r\n //#define MEDQ\t\r\n //#define YUCKQ\t\r\n\r\nconst float tmax = 20.0;\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCappedCylinder( vec3 p, float h, float r )\r\n{\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nvec2 opU( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nvec2 sdScene(vec3 p)\r\n{\r\n    vec2 res = vec2(999.0);\r\n    float r = 7.4;\r\n    //res = opU(res, vec2(sdSphere(p-vec3(0.,0.,0.), r), r));\r\n    res = opU(res, vec2(sdCappedCylinder(p-vec3(0.,.0,0.), r,4.0), r));\r\n    return res;\r\n}\r\n\r\n/*\r\n//iq's LUT 3D noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 f = fract(x);\r\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\r\n    f = f*f*(3.0-2.0*f);\r\n     \r\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n    return mix( rg.x, rg.y, f.z );\r\n}\r\n*/\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// assign colour to the media\r\nvec3 computeColour( float density)\r\n{\r\n\tvec3 result = mix(vec3(.9,0.9,0.9), vec3(0.25,0.25,0.25), density );\r\n\t\r\n\treturn result;\r\n}\r\n\r\nfloat Turbulence(vec3 p)\r\n{\t\r\n\tfloat t = 0.;\r\n\tfloat oof = 1.;\r\n\tfor (int i=0; i<7; i++)\r\n\t{\r\n\t\tt += abs(noise(p))*oof;\r\n\t\toof *= 0.5;\r\n\t\tp *= 2.7;\t//bigger number, more detail\r\n\t}\r\n\t\r\n\treturn t-1.;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    //start of params\r\n    float rotateS = 2.6;\r\n    float riseS = 3.55;\r\n    float rmax = 4.2;\r\n    float rmin = 1.2;\r\n    //end of parms\r\n    \r\n    vec3 bottom = vec3(0.0,-4.4,0.0);\r\n    float den = 0.0;\r\n    float maxH = 8.8;  \r\n    vec3 lp = p;\r\n    float height = lp.y - bottom.y + noise(lp)*rmin*0.33;\r\n    float tease = height/maxH;\r\n    \r\n    float theta_s = iTime*rotateS;\r\n    float down = riseS*iTime;\r\n    float c = cos(-theta_s - p.y);\r\n    float s = sin(-theta_s - p.y);\r\n    float c1 = cos(-theta_s - p.y);\r\n    float s1 = sin(-theta_s - p.y);\r\n    \r\n    float noi = noise(p);\r\n    float scale = 1.0;\r\n    scale *= noi*0.01 + 0.77+0.23*abs(sin((p.y+sin(iTime*3.3)*0.1+noi*0.08)*1.9));\r\n    scale *= (0.56 + 0.44*abs(sin((tease+0.5)*3.14159)))*(1.0);\r\n    scale *= 0.6+tease*0.3;\r\n    \r\n    vec3 lp1 = lp;\r\n    lp.x *= scale;\r\n    lp.z *= scale;\r\n    lp1.x = lp.x*c-lp.z*s;\r\n    lp1.z = lp.x*s+lp.z*c;\r\n    lp1.y -= down;\r\n    float turb = Turbulence(lp1);    \r\n    \r\n    float r = rmax*scale + turb*0.3*rotateS;\r\n    float r_sq = r*r;\r\n    float roffset = r*0.2;\r\n    vec3 center = vec3(roffset*c1,p.y,roffset*s1);\r\n    center.x += turb*0.1;\r\n    center.y += turb*0.2;\r\n    center.z += turb*0.1;\r\n    vec3 diff = p - center;\r\n    float dist_sq = diff.x*diff.x + diff.y*diff.y + diff.z*diff.z;\r\n    den = (1.0-dist_sq/r_sq + turb*0.45)*1.11;\r\n    float rn_seq = (p.x*p.x + p.z*p.z)/r;\r\n    rn_seq = clamp(rn_seq,0.0,1.0);\r\n    den *= (0.22 + 0.78*abs(sin((rn_seq)*3.14159)));\r\n    den *= pow(rmax/r,2.0);\r\n    \r\n    den = clamp(den,0.0,1.0);\r\n    den = pow(den, 0.4);\r\n    \r\n    //make color\r\n    vec3 color = mix(vec3(.9,0.9,0.9), vec3(0.45,0.45,0.45), den );\r\n\treturn vec4(color,den);\r\n}\r\n\r\n\r\nvec4 raytraceVolumetric(in vec3 rayo, in vec3 rayd,in float t)\r\n{\r\n    vec3 pos = rayo+rayd*t;\r\n    float d = sdScene(pos).x;\r\n    vec4 sum = vec4( 0.0 );\r\n    \t\r\n    float last_t = t;\r\n    \r\n    #ifdef SHQ\r\n\t#define STEPS  128\r\n    float dt = 0.062;\r\n    #endif\t\r\n    #ifdef MEDQ\r\n\t#define STEPS\t64\r\n    float dt = 0.124;\r\n    #endif\t\r\n    #ifdef YUCKQ\t\r\n\t#define STEPS\t32\r\n    float dt = 0.248;\r\n    #endif\r\n    \r\n    for( int i = 0; i < STEPS && t < tmax && d<t*0.001; i++ )\r\n    {\r\n        if( sum.a > 0.99 ) continue;\r\n\t\t\t\t\r\n\t\tvec4 col = map(pos);\r\n\t\tcol.a*= (t-last_t)*1.5;\r\n        \r\n\t\t// colour by alpha\r\n\t\tcol.rgb *= col.a;\r\n\t\t\r\n\t\t// alpha blend in contribution\r\n\t\tsum = sum + col*(1.0 - sum.a);  \r\n\t\t\r\n\t\t// step along ray\r\n        last_t = t;\r\n\t\t//t += max(0.062, t*0.0096);\r\n        t += dt;\r\n\t\tpos = rayo + rayd * t;\r\n        d = sdScene(pos).x;\r\n    }\r\n\tvec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n\tsum = sum + bg*(1.0 - sum.a);  \r\n        \r\n    return clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\nvec4 raymarch( in vec3 rayo, in vec3 rayd)\r\n{\r\n    vec3 pos = rayo;\r\n    float t = 0.0;\r\n\t\r\n\tfor(int i = 0; i < 15 && t < tmax; i++)\r\n    {\r\n        vec2 h = sdScene(pos);\r\n        if( h.x < 0.0001*t)\r\n        { \r\n            return raytraceVolumetric(rayo,rayd,t); \r\n        }\r\n        t += h.x;\r\n        pos = rayo + rayd * t;\r\n    }\r\n    vec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n    return bg; \r\n}\r\n\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t\r\n    float camRadius = 9.8;\r\n\t// use mouse x coord\r\n\tfloat a = 0.0;// iTime * 20.;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\ta = iMouse.x;\r\n        camRadius = iMouse.y/iResolution.y*camRadius;\r\n    }\r\n\tfloat theta = (-a/iResolution.x)*3.1415926*2.+3.1415926*0.5;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,0.,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.,0.,0.);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get aspect corrected normalized pixel coordinate\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, cameraPos;\r\n    rayDir = computePixelRay( p, cameraPos );\r\n\t\r\n\tvec4 col = vec4(0.);\r\n\tcol = raymarch( cameraPos, rayDir);\r\n    // smoothstep final color to add contrast\r\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\r\n}\r\n","inputs":[],"outputs":[],"code":" #define SHQ\t\r\n //#define MEDQ\t\r\n //#define YUCKQ\t\r\n\r\nconst float tmax = 20.0;\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCappedCylinder( vec3 p, float h, float r )\r\n{\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nvec2 opU( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nvec2 sdScene(vec3 p)\r\n{\r\n    vec2 res = vec2(999.0);\r\n    float r = 7.4;\r\n    //res = opU(res, vec2(sdSphere(p-vec3(0.,0.,0.), r), r));\r\n    res = opU(res, vec2(sdCappedCylinder(p-vec3(0.,.0,0.), r,4.0), r));\r\n    return res;\r\n}\r\n\r\n/*\r\n//iq's LUT 3D noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 f = fract(x);\r\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\r\n    f = f*f*(3.0-2.0*f);\r\n     \r\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n    return mix( rg.x, rg.y, f.z );\r\n}\r\n*/\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// assign colour to the media\r\nvec3 computeColour( float density)\r\n{\r\n\tvec3 result = mix(vec3(.9,0.9,0.9), vec3(0.25,0.25,0.25), density );\r\n\t\r\n\treturn result;\r\n}\r\n\r\nfloat Turbulence(vec3 p)\r\n{\t\r\n\tfloat t = 0.;\r\n\tfloat oof = 1.;\r\n\tfor (int i=0; i<7; i++)\r\n\t{\r\n\t\tt += abs(noise(p))*oof;\r\n\t\toof *= 0.5;\r\n\t\tp *= 2.7;\t//bigger number, more detail\r\n\t}\r\n\t\r\n\treturn t-1.;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    //start of params\r\n    float rotateS = 2.6;\r\n    float riseS = 3.55;\r\n    float rmax = 4.2;\r\n    float rmin = 1.2;\r\n    //end of parms\r\n    \r\n    vec3 bottom = vec3(0.0,-4.4,0.0);\r\n    float den = 0.0;\r\n    float maxH = 8.8;  \r\n    vec3 lp = p;\r\n    float height = lp.y - bottom.y + noise(lp)*rmin*0.33;\r\n    float tease = height/maxH;\r\n    \r\n    float theta_s = iTime*rotateS;\r\n    float down = riseS*iTime;\r\n    float c = cos(-theta_s - p.y);\r\n    float s = sin(-theta_s - p.y);\r\n    float c1 = cos(-theta_s - p.y);\r\n    float s1 = sin(-theta_s - p.y);\r\n    \r\n    float noi = noise(p);\r\n    float scale = 1.0;\r\n    scale *= noi*0.01 + 0.77+0.23*abs(sin((p.y+sin(iTime*3.3)*0.1+noi*0.08)*1.9));\r\n    scale *= (0.56 + 0.44*abs(sin((tease+0.5)*3.14159)))*(1.0);\r\n    scale *= 0.6+tease*0.3;\r\n    \r\n    vec3 lp1 = lp;\r\n    lp.x *= scale;\r\n    lp.z *= scale;\r\n    lp1.x = lp.x*c-lp.z*s;\r\n    lp1.z = lp.x*s+lp.z*c;\r\n    lp1.y -= down;\r\n    float turb = Turbulence(lp1);    \r\n    \r\n    float r = rmax*scale + turb*0.3*rotateS;\r\n    float r_sq = r*r;\r\n    float roffset = r*0.2;\r\n    vec3 center = vec3(roffset*c1,p.y,roffset*s1);\r\n    center.x += turb*0.1;\r\n    center.y += turb*0.2;\r\n    center.z += turb*0.1;\r\n    vec3 diff = p - center;\r\n    float dist_sq = diff.x*diff.x + diff.y*diff.y + diff.z*diff.z;\r\n    den = (1.0-dist_sq/r_sq + turb*0.45)*1.11;\r\n    float rn_seq = (p.x*p.x + p.z*p.z)/r;\r\n    rn_seq = clamp(rn_seq,0.0,1.0);\r\n    den *= (0.22 + 0.78*abs(sin((rn_seq)*3.14159)));\r\n    den *= pow(rmax/r,2.0);\r\n    \r\n    den = clamp(den,0.0,1.0);\r\n    den = pow(den, 0.4);\r\n    \r\n    //make color\r\n    vec3 color = mix(vec3(.9,0.9,0.9), vec3(0.45,0.45,0.45), den );\r\n\treturn vec4(color,den);\r\n}\r\n\r\n\r\nvec4 raytraceVolumetric(in vec3 rayo, in vec3 rayd,in float t)\r\n{\r\n    vec3 pos = rayo+rayd*t;\r\n    float d = sdScene(pos).x;\r\n    vec4 sum = vec4( 0.0 );\r\n    \t\r\n    float last_t = t;\r\n    \r\n    #ifdef SHQ\r\n\t#define STEPS  128\r\n    float dt = 0.062;\r\n    #endif\t\r\n    #ifdef MEDQ\r\n\t#define STEPS\t64\r\n    float dt = 0.124;\r\n    #endif\t\r\n    #ifdef YUCKQ\t\r\n\t#define STEPS\t32\r\n    float dt = 0.248;\r\n    #endif\r\n    \r\n    for( int i = 0; i < STEPS && t < tmax && d<t*0.001; i++ )\r\n    {\r\n        if( sum.a > 0.99 ) continue;\r\n\t\t\t\t\r\n\t\tvec4 col = map(pos);\r\n\t\tcol.a*= (t-last_t)*1.5;\r\n        \r\n\t\t// colour by alpha\r\n\t\tcol.rgb *= col.a;\r\n\t\t\r\n\t\t// alpha blend in contribution\r\n\t\tsum = sum + col*(1.0 - sum.a);  \r\n\t\t\r\n\t\t// step along ray\r\n        last_t = t;\r\n\t\t//t += max(0.062, t*0.0096);\r\n        t += dt;\r\n\t\tpos = rayo + rayd * t;\r\n        d = sdScene(pos).x;\r\n    }\r\n\tvec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n\tsum = sum + bg*(1.0 - sum.a);  \r\n        \r\n    return clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\nvec4 raymarch( in vec3 rayo, in vec3 rayd)\r\n{\r\n    vec3 pos = rayo;\r\n    float t = 0.0;\r\n\t\r\n\tfor(int i = 0; i < 15 && t < tmax; i++)\r\n    {\r\n        vec2 h = sdScene(pos);\r\n        if( h.x < 0.0001*t)\r\n        { \r\n            return raytraceVolumetric(rayo,rayd,t); \r\n        }\r\n        t += h.x;\r\n        pos = rayo + rayd * t;\r\n    }\r\n    vec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n    return bg; \r\n}\r\n\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t\r\n    float camRadius = 9.8;\r\n\t// use mouse x coord\r\n\tfloat a = 0.0;// iTime * 20.;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\ta = iMouse.x;\r\n        camRadius = iMouse.y/iResolution.y*camRadius;\r\n    }\r\n\tfloat theta = (-a/iResolution.x)*3.1415926*2.+3.1415926*0.5;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,0.,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.,0.,0.);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get aspect corrected normalized pixel coordinate\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, cameraPos;\r\n    rayDir = computePixelRay( p, cameraPos );\r\n\t\r\n\tvec4 col = vec4(0.);\r\n\tcol = raymarch( cameraPos, rayDir);\r\n    // smoothstep final color to add contrast\r\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"volumetric tornado","id":"ad42ce50f9d1488d87d44be0403e79b8","date":null,"viewed":0,"name":"volumetric tornado","description":"volumetric tornado","likes":0,"published":null,"tags":["sdf"," volumetric"," tornade"]},"ver":null,"info":{"Name":"volumetric tornado","id":"ad42ce50f9d1488d87d44be0403e79b8","date":null,"viewed":0,"name":"volumetric tornado","description":"volumetric tornado","likes":0,"published":null,"tags":["sdf"," volumetric"," tornade"]},"renderpass":[{"Code":" #define SHQ\t\r\n //#define MEDQ\t\r\n //#define YUCKQ\t\r\n\r\nconst float tmax = 20.0;\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCappedCylinder( vec3 p, float h, float r )\r\n{\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nvec2 opU( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nvec2 sdScene(vec3 p)\r\n{\r\n    vec2 res = vec2(999.0);\r\n    float r = 7.4;\r\n    //res = opU(res, vec2(sdSphere(p-vec3(0.,0.,0.), r), r));\r\n    res = opU(res, vec2(sdCappedCylinder(p-vec3(0.,.0,0.), r,4.0), r));\r\n    return res;\r\n}\r\n\r\n/*\r\n//iq's LUT 3D noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 f = fract(x);\r\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\r\n    f = f*f*(3.0-2.0*f);\r\n     \r\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n    return mix( rg.x, rg.y, f.z );\r\n}\r\n*/\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// assign colour to the media\r\nvec3 computeColour( float density)\r\n{\r\n\tvec3 result = mix(vec3(.9,0.9,0.9), vec3(0.25,0.25,0.25), density );\r\n\t\r\n\treturn result;\r\n}\r\n\r\nfloat Turbulence(vec3 p)\r\n{\t\r\n\tfloat t = 0.;\r\n\tfloat oof = 1.;\r\n\tfor (int i=0; i<7; i++)\r\n\t{\r\n\t\tt += abs(noise(p))*oof;\r\n\t\toof *= 0.5;\r\n\t\tp *= 2.7;\t//bigger number, more detail\r\n\t}\r\n\t\r\n\treturn t-1.;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    //start of params\r\n    float rotateS = 2.6;\r\n    float riseS = 3.55;\r\n    float rmax = 4.2;\r\n    float rmin = 1.2;\r\n    //end of parms\r\n    \r\n    vec3 bottom = vec3(0.0,-4.4,0.0);\r\n    float den = 0.0;\r\n    float maxH = 8.8;  \r\n    vec3 lp = p;\r\n    float height = lp.y - bottom.y + noise(lp)*rmin*0.33;\r\n    float tease = height/maxH;\r\n    \r\n    float theta_s = iTime*rotateS;\r\n    float down = riseS*iTime;\r\n    float c = cos(-theta_s - p.y);\r\n    float s = sin(-theta_s - p.y);\r\n    float c1 = cos(-theta_s - p.y);\r\n    float s1 = sin(-theta_s - p.y);\r\n    \r\n    float noi = noise(p);\r\n    float scale = 1.0;\r\n    scale *= noi*0.01 + 0.77+0.23*abs(sin((p.y+sin(iTime*3.3)*0.1+noi*0.08)*1.9));\r\n    scale *= (0.56 + 0.44*abs(sin((tease+0.5)*3.14159)))*(1.0);\r\n    scale *= 0.6+tease*0.3;\r\n    \r\n    vec3 lp1 = lp;\r\n    lp.x *= scale;\r\n    lp.z *= scale;\r\n    lp1.x = lp.x*c-lp.z*s;\r\n    lp1.z = lp.x*s+lp.z*c;\r\n    lp1.y -= down;\r\n    float turb = Turbulence(lp1);    \r\n    \r\n    float r = rmax*scale + turb*0.3*rotateS;\r\n    float r_sq = r*r;\r\n    float roffset = r*0.2;\r\n    vec3 center = vec3(roffset*c1,p.y,roffset*s1);\r\n    center.x += turb*0.1;\r\n    center.y += turb*0.2;\r\n    center.z += turb*0.1;\r\n    vec3 diff = p - center;\r\n    float dist_sq = diff.x*diff.x + diff.y*diff.y + diff.z*diff.z;\r\n    den = (1.0-dist_sq/r_sq + turb*0.45)*1.11;\r\n    float rn_seq = (p.x*p.x + p.z*p.z)/r;\r\n    rn_seq = clamp(rn_seq,0.0,1.0);\r\n    den *= (0.22 + 0.78*abs(sin((rn_seq)*3.14159)));\r\n    den *= pow(rmax/r,2.0);\r\n    \r\n    den = clamp(den,0.0,1.0);\r\n    den = pow(den, 0.4);\r\n    \r\n    //make color\r\n    vec3 color = mix(vec3(.9,0.9,0.9), vec3(0.45,0.45,0.45), den );\r\n\treturn vec4(color,den);\r\n}\r\n\r\n\r\nvec4 raytraceVolumetric(in vec3 rayo, in vec3 rayd,in float t)\r\n{\r\n    vec3 pos = rayo+rayd*t;\r\n    float d = sdScene(pos).x;\r\n    vec4 sum = vec4( 0.0 );\r\n    \t\r\n    float last_t = t;\r\n    \r\n    #ifdef SHQ\r\n\t#define STEPS  128\r\n    float dt = 0.062;\r\n    #endif\t\r\n    #ifdef MEDQ\r\n\t#define STEPS\t64\r\n    float dt = 0.124;\r\n    #endif\t\r\n    #ifdef YUCKQ\t\r\n\t#define STEPS\t32\r\n    float dt = 0.248;\r\n    #endif\r\n    \r\n    for( int i = 0; i < STEPS && t < tmax && d<t*0.001; i++ )\r\n    {\r\n        if( sum.a > 0.99 ) continue;\r\n\t\t\t\t\r\n\t\tvec4 col = map(pos);\r\n\t\tcol.a*= (t-last_t)*1.5;\r\n        \r\n\t\t// colour by alpha\r\n\t\tcol.rgb *= col.a;\r\n\t\t\r\n\t\t// alpha blend in contribution\r\n\t\tsum = sum + col*(1.0 - sum.a);  \r\n\t\t\r\n\t\t// step along ray\r\n        last_t = t;\r\n\t\t//t += max(0.062, t*0.0096);\r\n        t += dt;\r\n\t\tpos = rayo + rayd * t;\r\n        d = sdScene(pos).x;\r\n    }\r\n\tvec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n\tsum = sum + bg*(1.0 - sum.a);  \r\n        \r\n    return clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\nvec4 raymarch( in vec3 rayo, in vec3 rayd)\r\n{\r\n    vec3 pos = rayo;\r\n    float t = 0.0;\r\n\t\r\n\tfor(int i = 0; i < 15 && t < tmax; i++)\r\n    {\r\n        vec2 h = sdScene(pos);\r\n        if( h.x < 0.0001*t)\r\n        { \r\n            return raytraceVolumetric(rayo,rayd,t); \r\n        }\r\n        t += h.x;\r\n        pos = rayo + rayd * t;\r\n    }\r\n    vec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n    return bg; \r\n}\r\n\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t\r\n    float camRadius = 9.8;\r\n\t// use mouse x coord\r\n\tfloat a = 0.0;// iTime * 20.;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\ta = iMouse.x;\r\n        camRadius = iMouse.y/iResolution.y*camRadius;\r\n    }\r\n\tfloat theta = (-a/iResolution.x)*3.1415926*2.+3.1415926*0.5;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,0.,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.,0.,0.);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get aspect corrected normalized pixel coordinate\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, cameraPos;\r\n    rayDir = computePixelRay( p, cameraPos );\r\n\t\r\n\tvec4 col = vec4(0.);\r\n\tcol = raymarch( cameraPos, rayDir);\r\n    // smoothstep final color to add contrast\r\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\r\n}\r\n","inputs":[],"outputs":[],"code":" #define SHQ\t\r\n //#define MEDQ\t\r\n //#define YUCKQ\t\r\n\r\nconst float tmax = 20.0;\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCappedCylinder( vec3 p, float h, float r )\r\n{\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nvec2 opU( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nvec2 sdScene(vec3 p)\r\n{\r\n    vec2 res = vec2(999.0);\r\n    float r = 7.4;\r\n    //res = opU(res, vec2(sdSphere(p-vec3(0.,0.,0.), r), r));\r\n    res = opU(res, vec2(sdCappedCylinder(p-vec3(0.,.0,0.), r,4.0), r));\r\n    return res;\r\n}\r\n\r\n/*\r\n//iq's LUT 3D noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 f = fract(x);\r\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\r\n    f = f*f*(3.0-2.0*f);\r\n     \r\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n    return mix( rg.x, rg.y, f.z );\r\n}\r\n*/\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// assign colour to the media\r\nvec3 computeColour( float density)\r\n{\r\n\tvec3 result = mix(vec3(.9,0.9,0.9), vec3(0.25,0.25,0.25), density );\r\n\t\r\n\treturn result;\r\n}\r\n\r\nfloat Turbulence(vec3 p)\r\n{\t\r\n\tfloat t = 0.;\r\n\tfloat oof = 1.;\r\n\tfor (int i=0; i<7; i++)\r\n\t{\r\n\t\tt += abs(noise(p))*oof;\r\n\t\toof *= 0.5;\r\n\t\tp *= 2.7;\t//bigger number, more detail\r\n\t}\r\n\t\r\n\treturn t-1.;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    //start of params\r\n    float rotateS = 2.6;\r\n    float riseS = 3.55;\r\n    float rmax = 4.2;\r\n    float rmin = 1.2;\r\n    //end of parms\r\n    \r\n    vec3 bottom = vec3(0.0,-4.4,0.0);\r\n    float den = 0.0;\r\n    float maxH = 8.8;  \r\n    vec3 lp = p;\r\n    float height = lp.y - bottom.y + noise(lp)*rmin*0.33;\r\n    float tease = height/maxH;\r\n    \r\n    float theta_s = iTime*rotateS;\r\n    float down = riseS*iTime;\r\n    float c = cos(-theta_s - p.y);\r\n    float s = sin(-theta_s - p.y);\r\n    float c1 = cos(-theta_s - p.y);\r\n    float s1 = sin(-theta_s - p.y);\r\n    \r\n    float noi = noise(p);\r\n    float scale = 1.0;\r\n    scale *= noi*0.01 + 0.77+0.23*abs(sin((p.y+sin(iTime*3.3)*0.1+noi*0.08)*1.9));\r\n    scale *= (0.56 + 0.44*abs(sin((tease+0.5)*3.14159)))*(1.0);\r\n    scale *= 0.6+tease*0.3;\r\n    \r\n    vec3 lp1 = lp;\r\n    lp.x *= scale;\r\n    lp.z *= scale;\r\n    lp1.x = lp.x*c-lp.z*s;\r\n    lp1.z = lp.x*s+lp.z*c;\r\n    lp1.y -= down;\r\n    float turb = Turbulence(lp1);    \r\n    \r\n    float r = rmax*scale + turb*0.3*rotateS;\r\n    float r_sq = r*r;\r\n    float roffset = r*0.2;\r\n    vec3 center = vec3(roffset*c1,p.y,roffset*s1);\r\n    center.x += turb*0.1;\r\n    center.y += turb*0.2;\r\n    center.z += turb*0.1;\r\n    vec3 diff = p - center;\r\n    float dist_sq = diff.x*diff.x + diff.y*diff.y + diff.z*diff.z;\r\n    den = (1.0-dist_sq/r_sq + turb*0.45)*1.11;\r\n    float rn_seq = (p.x*p.x + p.z*p.z)/r;\r\n    rn_seq = clamp(rn_seq,0.0,1.0);\r\n    den *= (0.22 + 0.78*abs(sin((rn_seq)*3.14159)));\r\n    den *= pow(rmax/r,2.0);\r\n    \r\n    den = clamp(den,0.0,1.0);\r\n    den = pow(den, 0.4);\r\n    \r\n    //make color\r\n    vec3 color = mix(vec3(.9,0.9,0.9), vec3(0.45,0.45,0.45), den );\r\n\treturn vec4(color,den);\r\n}\r\n\r\n\r\nvec4 raytraceVolumetric(in vec3 rayo, in vec3 rayd,in float t)\r\n{\r\n    vec3 pos = rayo+rayd*t;\r\n    float d = sdScene(pos).x;\r\n    vec4 sum = vec4( 0.0 );\r\n    \t\r\n    float last_t = t;\r\n    \r\n    #ifdef SHQ\r\n\t#define STEPS  128\r\n    float dt = 0.062;\r\n    #endif\t\r\n    #ifdef MEDQ\r\n\t#define STEPS\t64\r\n    float dt = 0.124;\r\n    #endif\t\r\n    #ifdef YUCKQ\t\r\n\t#define STEPS\t32\r\n    float dt = 0.248;\r\n    #endif\r\n    \r\n    for( int i = 0; i < STEPS && t < tmax && d<t*0.001; i++ )\r\n    {\r\n        if( sum.a > 0.99 ) continue;\r\n\t\t\t\t\r\n\t\tvec4 col = map(pos);\r\n\t\tcol.a*= (t-last_t)*1.5;\r\n        \r\n\t\t// colour by alpha\r\n\t\tcol.rgb *= col.a;\r\n\t\t\r\n\t\t// alpha blend in contribution\r\n\t\tsum = sum + col*(1.0 - sum.a);  \r\n\t\t\r\n\t\t// step along ray\r\n        last_t = t;\r\n\t\t//t += max(0.062, t*0.0096);\r\n        t += dt;\r\n\t\tpos = rayo + rayd * t;\r\n        d = sdScene(pos).x;\r\n    }\r\n\tvec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n\tsum = sum + bg*(1.0 - sum.a);  \r\n        \r\n    return clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\nvec4 raymarch( in vec3 rayo, in vec3 rayd)\r\n{\r\n    vec3 pos = rayo;\r\n    float t = 0.0;\r\n\t\r\n\tfor(int i = 0; i < 15 && t < tmax; i++)\r\n    {\r\n        vec2 h = sdScene(pos);\r\n        if( h.x < 0.0001*t)\r\n        { \r\n            return raytraceVolumetric(rayo,rayd,t); \r\n        }\r\n        t += h.x;\r\n        pos = rayo + rayd * t;\r\n    }\r\n    vec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n    return bg; \r\n}\r\n\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t\r\n    float camRadius = 9.8;\r\n\t// use mouse x coord\r\n\tfloat a = 0.0;// iTime * 20.;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\ta = iMouse.x;\r\n        camRadius = iMouse.y/iResolution.y*camRadius;\r\n    }\r\n\tfloat theta = (-a/iResolution.x)*3.1415926*2.+3.1415926*0.5;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,0.,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.,0.,0.);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get aspect corrected normalized pixel coordinate\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, cameraPos;\r\n    rayDir = computePixelRay( p, cameraPos );\r\n\t\r\n\tvec4 col = vec4(0.);\r\n\tcol = raymarch( cameraPos, rayDir);\r\n    // smoothstep final color to add contrast\r\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// 'Warp Speed' by David Hoskins 2013.\r\n// I tried to find gaps and variation in the star cloud for a feeling of structure.\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float time = (iTime+29.) * 60.0;\r\n\r\n    float s = 0.0, v = 0.0;\r\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\r\n\tfloat t = time*0.005;\r\n\tuv.x += sin(t) * 0.5;\r\n\tfloat si = sin(t + 2.17); // ...Squiffy rotation matrix!\r\n\tfloat co = cos(t);\r\n\tuv *= mat2(co, si, -si, co);\r\n\tvec3 col = vec3(0.0);\r\n\tvec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * 0.4, floor(time) * 0.0008);\r\n\tfor (int r = 0; r < 100; r++) \r\n\t{\r\n\t\tvec3 p = init + s * vec3(uv, 0.143);\r\n\t\tp.z = mod(p.z, 2.0);\r\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\r\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\r\n\t\t// Get a purple and cyan effect by biasing the RGB in different ways...\r\n\t\tcol +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\r\n\t\ts += .01;\r\n\t}\r\n\tfragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"// 'Warp Speed' by David Hoskins 2013.\r\n// I tried to find gaps and variation in the star cloud for a feeling of structure.\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float time = (iTime+29.) * 60.0;\r\n\r\n    float s = 0.0, v = 0.0;\r\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\r\n\tfloat t = time*0.005;\r\n\tuv.x += sin(t) * 0.5;\r\n\tfloat si = sin(t + 2.17); // ...Squiffy rotation matrix!\r\n\tfloat co = cos(t);\r\n\tuv *= mat2(co, si, -si, co);\r\n\tvec3 col = vec3(0.0);\r\n\tvec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * 0.4, floor(time) * 0.0008);\r\n\tfor (int r = 0; r < 100; r++) \r\n\t{\r\n\t\tvec3 p = init + s * vec3(uv, 0.143);\r\n\t\tp.z = mod(p.z, 2.0);\r\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\r\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\r\n\t\t// Get a purple and cyan effect by biasing the RGB in different ways...\r\n\t\tcol +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\r\n\t\ts += .01;\r\n\t}\r\n\tfragColor = vec4(col, 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Warp speed","id":"4e62f1edd5744b59b6d4c91633e536dc","date":null,"viewed":0,"name":"Warp speed","description":"I couldn't resist playing around with the \"Cosmos\" shadertoy!\nThanks for the fractal, Kali!\nVideo of it:-\nhttp://www.youtube.com/watch?v=1eZeqKvI5_4\nhttps://www.shadertoy.com/view/Msl3WH","likes":0,"published":null,"tags":["fractal"," kali"]},"ver":null,"info":{"Name":"Warp speed","id":"4e62f1edd5744b59b6d4c91633e536dc","date":null,"viewed":0,"name":"Warp speed","description":"I couldn't resist playing around with the \"Cosmos\" shadertoy!\nThanks for the fractal, Kali!\nVideo of it:-\nhttp://www.youtube.com/watch?v=1eZeqKvI5_4\nhttps://www.shadertoy.com/view/Msl3WH","likes":0,"published":null,"tags":["fractal"," kali"]},"renderpass":[{"Code":"// 'Warp Speed' by David Hoskins 2013.\r\n// I tried to find gaps and variation in the star cloud for a feeling of structure.\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float time = (iTime+29.) * 60.0;\r\n\r\n    float s = 0.0, v = 0.0;\r\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\r\n\tfloat t = time*0.005;\r\n\tuv.x += sin(t) * 0.5;\r\n\tfloat si = sin(t + 2.17); // ...Squiffy rotation matrix!\r\n\tfloat co = cos(t);\r\n\tuv *= mat2(co, si, -si, co);\r\n\tvec3 col = vec3(0.0);\r\n\tvec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * 0.4, floor(time) * 0.0008);\r\n\tfor (int r = 0; r < 100; r++) \r\n\t{\r\n\t\tvec3 p = init + s * vec3(uv, 0.143);\r\n\t\tp.z = mod(p.z, 2.0);\r\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\r\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\r\n\t\t// Get a purple and cyan effect by biasing the RGB in different ways...\r\n\t\tcol +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\r\n\t\ts += .01;\r\n\t}\r\n\tfragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"// 'Warp Speed' by David Hoskins 2013.\r\n// I tried to find gaps and variation in the star cloud for a feeling of structure.\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float time = (iTime+29.) * 60.0;\r\n\r\n    float s = 0.0, v = 0.0;\r\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\r\n\tfloat t = time*0.005;\r\n\tuv.x += sin(t) * 0.5;\r\n\tfloat si = sin(t + 2.17); // ...Squiffy rotation matrix!\r\n\tfloat co = cos(t);\r\n\tuv *= mat2(co, si, -si, co);\r\n\tvec3 col = vec3(0.0);\r\n\tvec3 init = vec3(0.25, 0.25 + sin(time * 0.001) * 0.4, floor(time) * 0.0008);\r\n\tfor (int r = 0; r < 100; r++) \r\n\t{\r\n\t\tvec3 p = init + s * vec3(uv, 0.143);\r\n\t\tp.z = mod(p.z, 2.0);\r\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\r\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\r\n\t\t// Get a purple and cyan effect by biasing the RGB in different ways...\r\n\t\tcol +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\r\n\t\ts += .01;\r\n\t}\r\n\tfragColor = vec4(col, 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// See here for a tutorial on how to make this:\r\n//\r\n// http://www.iquilezles.org/www/articles/warp/warp.htm\r\n\r\n//====================================================================\r\n\r\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat noise( in vec2 p )\r\n{\r\n\treturn sin(p.x)*sin(p.y);\r\n}\r\n\r\nfloat fbm4( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm6( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\r\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\r\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\r\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.015625*(0.5+0.5*noise( p ));\r\n    return f/0.96875;\r\n}\r\n\r\nvec2 fbm4_2( vec2 p )\r\n{\r\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\r\n}\r\n\r\nvec2 fbm6_2( vec2 p )\r\n{\r\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\r\n}\r\n\r\n//====================================================================\r\n\r\nfloat func( vec2 q, out vec4 ron )\r\n{\r\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\r\n\r\n\tvec2 o = fbm4_2( 0.9*q );\r\n\r\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\r\n\r\n    vec2 n = fbm6_2( 3.0*o );\r\n\r\n\tron = vec4( o, n );\r\n\r\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\r\n\r\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    float e = 2.0/iResolution.y;\r\n\r\n    vec4 on = vec4(0.0);\r\n    float f = func(p, on);\r\n\r\n\tvec3 col = vec3(0.0);\r\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\r\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\r\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\r\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\r\n    col = clamp( col*f*2.0, 0.0, 1.0 );\r\n    \r\n#if 0\r\n    // gpu derivatives - bad quality, but fast\r\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\r\n#else    \r\n    // manual derivatives - better quality, but slower\r\n    vec4 kk;\r\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \r\n                                2.0*e,\r\n                                func(p+vec2(0.0,e),kk)-f ) );\r\n#endif    \r\n\r\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\r\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\r\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\r\n    col *= 1.2*lin;\r\n\tcol = 1.0 - col;\r\n\tcol = 1.1*col*col;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// See here for a tutorial on how to make this:\r\n//\r\n// http://www.iquilezles.org/www/articles/warp/warp.htm\r\n\r\n//====================================================================\r\n\r\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat noise( in vec2 p )\r\n{\r\n\treturn sin(p.x)*sin(p.y);\r\n}\r\n\r\nfloat fbm4( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm6( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\r\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\r\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\r\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.015625*(0.5+0.5*noise( p ));\r\n    return f/0.96875;\r\n}\r\n\r\nvec2 fbm4_2( vec2 p )\r\n{\r\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\r\n}\r\n\r\nvec2 fbm6_2( vec2 p )\r\n{\r\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\r\n}\r\n\r\n//====================================================================\r\n\r\nfloat func( vec2 q, out vec4 ron )\r\n{\r\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\r\n\r\n\tvec2 o = fbm4_2( 0.9*q );\r\n\r\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\r\n\r\n    vec2 n = fbm6_2( 3.0*o );\r\n\r\n\tron = vec4( o, n );\r\n\r\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\r\n\r\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    float e = 2.0/iResolution.y;\r\n\r\n    vec4 on = vec4(0.0);\r\n    float f = func(p, on);\r\n\r\n\tvec3 col = vec3(0.0);\r\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\r\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\r\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\r\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\r\n    col = clamp( col*f*2.0, 0.0, 1.0 );\r\n    \r\n#if 0\r\n    // gpu derivatives - bad quality, but fast\r\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\r\n#else    \r\n    // manual derivatives - better quality, but slower\r\n    vec4 kk;\r\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \r\n                                2.0*e,\r\n                                func(p+vec2(0.0,e),kk)-f ) );\r\n#endif    \r\n\r\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\r\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\r\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\r\n    col *= 1.2*lin;\r\n\tcol = 1.0 - col;\r\n\tcol = 1.1*col*col;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Warping - procedural 2 ","id":"563b6883cdf642908ce4f7f30ba4781a","date":null,"viewed":0,"name":"Warping - procedural 2 ","description":"Warp. Tutorial here: \nhttps://www.shadertoy.com/view/lsl3RH","likes":0,"published":null,"tags":["procedural"," 2d"," fbm"]},"ver":null,"info":{"Name":"Warping - procedural 2 ","id":"563b6883cdf642908ce4f7f30ba4781a","date":null,"viewed":0,"name":"Warping - procedural 2 ","description":"Warp. Tutorial here: \nhttps://www.shadertoy.com/view/lsl3RH","likes":0,"published":null,"tags":["procedural"," 2d"," fbm"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// See here for a tutorial on how to make this:\r\n//\r\n// http://www.iquilezles.org/www/articles/warp/warp.htm\r\n\r\n//====================================================================\r\n\r\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat noise( in vec2 p )\r\n{\r\n\treturn sin(p.x)*sin(p.y);\r\n}\r\n\r\nfloat fbm4( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm6( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\r\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\r\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\r\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.015625*(0.5+0.5*noise( p ));\r\n    return f/0.96875;\r\n}\r\n\r\nvec2 fbm4_2( vec2 p )\r\n{\r\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\r\n}\r\n\r\nvec2 fbm6_2( vec2 p )\r\n{\r\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\r\n}\r\n\r\n//====================================================================\r\n\r\nfloat func( vec2 q, out vec4 ron )\r\n{\r\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\r\n\r\n\tvec2 o = fbm4_2( 0.9*q );\r\n\r\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\r\n\r\n    vec2 n = fbm6_2( 3.0*o );\r\n\r\n\tron = vec4( o, n );\r\n\r\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\r\n\r\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    float e = 2.0/iResolution.y;\r\n\r\n    vec4 on = vec4(0.0);\r\n    float f = func(p, on);\r\n\r\n\tvec3 col = vec3(0.0);\r\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\r\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\r\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\r\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\r\n    col = clamp( col*f*2.0, 0.0, 1.0 );\r\n    \r\n#if 0\r\n    // gpu derivatives - bad quality, but fast\r\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\r\n#else    \r\n    // manual derivatives - better quality, but slower\r\n    vec4 kk;\r\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \r\n                                2.0*e,\r\n                                func(p+vec2(0.0,e),kk)-f ) );\r\n#endif    \r\n\r\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\r\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\r\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\r\n    col *= 1.2*lin;\r\n\tcol = 1.0 - col;\r\n\tcol = 1.1*col*col;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// See here for a tutorial on how to make this:\r\n//\r\n// http://www.iquilezles.org/www/articles/warp/warp.htm\r\n\r\n//====================================================================\r\n\r\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat noise( in vec2 p )\r\n{\r\n\treturn sin(p.x)*sin(p.y);\r\n}\r\n\r\nfloat fbm4( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm6( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\r\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\r\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\r\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.015625*(0.5+0.5*noise( p ));\r\n    return f/0.96875;\r\n}\r\n\r\nvec2 fbm4_2( vec2 p )\r\n{\r\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\r\n}\r\n\r\nvec2 fbm6_2( vec2 p )\r\n{\r\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\r\n}\r\n\r\n//====================================================================\r\n\r\nfloat func( vec2 q, out vec4 ron )\r\n{\r\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\r\n\r\n\tvec2 o = fbm4_2( 0.9*q );\r\n\r\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\r\n\r\n    vec2 n = fbm6_2( 3.0*o );\r\n\r\n\tron = vec4( o, n );\r\n\r\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\r\n\r\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    float e = 2.0/iResolution.y;\r\n\r\n    vec4 on = vec4(0.0);\r\n    float f = func(p, on);\r\n\r\n\tvec3 col = vec3(0.0);\r\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\r\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\r\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\r\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\r\n    col = clamp( col*f*2.0, 0.0, 1.0 );\r\n    \r\n#if 0\r\n    // gpu derivatives - bad quality, but fast\r\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\r\n#else    \r\n    // manual derivatives - better quality, but slower\r\n    vec4 kk;\r\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \r\n                                2.0*e,\r\n                                func(p+vec2(0.0,e),kk)-f ) );\r\n#endif    \r\n\r\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\r\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\r\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\r\n    col *= 1.2*lin;\r\n\tcol = 1.0 - col;\r\n\tcol = 1.1*col*col;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// different wavelengths travels at different speed: this is dispersion\r\n// there are 2 main cases: gravity waves + capillary waves\r\n// (+ mix case + shallow water + mix case + soliton + ... ok, forget theses :-p )\r\n// Physics of dispersion here: https://en.wikipedia.org/wiki/Capillary_wave\r\n\r\n// in 2D, add 1/r modulation. Or better: use Bessels instead of sines.\r\n\r\n\r\n#define W(x,k,c) A*sin(k*(X=x-c*t))*exp(-X*X)\r\n\r\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-uv.y))\r\n// #define plot(Y) o +=exp(-max(0.,Y-uv.y))\r\n\r\nvoid mainImage( out vec4 o, vec2 uv )\r\n{\r\n    float A=.8,X,y,Y=0.,  t=mod(iTime,10.); \r\n    vec2 R = iResolution.xy;    o = vec4(0.0);\r\n    uv = 10.* (2.*uv-R)/R.y; \r\n    \r\n    for (float k=1.; k<10.; k++) {\r\n        Y += y = W(abs(uv.x), k, sqrt(k))/k;   // dispertion for capillary waves\r\n     // Y += y = W(abs(uv.x), k, 1./sqrt(k))/k;// dispertion for gravity waves\r\n\t    plot( y - 3.  ); \r\n    }\r\n\r\n    plot( Y + 3. );\r\n    \r\n    o.b += .2;\r\n}","inputs":[],"outputs":[],"code":"// different wavelengths travels at different speed: this is dispersion\r\n// there are 2 main cases: gravity waves + capillary waves\r\n// (+ mix case + shallow water + mix case + soliton + ... ok, forget theses :-p )\r\n// Physics of dispersion here: https://en.wikipedia.org/wiki/Capillary_wave\r\n\r\n// in 2D, add 1/r modulation. Or better: use Bessels instead of sines.\r\n\r\n\r\n#define W(x,k,c) A*sin(k*(X=x-c*t))*exp(-X*X)\r\n\r\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-uv.y))\r\n// #define plot(Y) o +=exp(-max(0.,Y-uv.y))\r\n\r\nvoid mainImage( out vec4 o, vec2 uv )\r\n{\r\n    float A=.8,X,y,Y=0.,  t=mod(iTime,10.); \r\n    vec2 R = iResolution.xy;    o = vec4(0.0);\r\n    uv = 10.* (2.*uv-R)/R.y; \r\n    \r\n    for (float k=1.; k<10.; k++) {\r\n        Y += y = W(abs(uv.x), k, sqrt(k))/k;   // dispertion for capillary waves\r\n     // Y += y = W(abs(uv.x), k, 1./sqrt(k))/k;// dispertion for gravity waves\r\n\t    plot( y - 3.  ); \r\n    }\r\n\r\n    plot( Y + 3. );\r\n    \r\n    o.b += .2;\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"waves dispersion","id":"c7ee26be7bb34748b1d8896cb42b5ec5","date":null,"viewed":0,"name":"waves dispersion","description":"Different wavelengths travels at different speed: this is dispersion.\r\nHere, a 1D ripple made of capillary waves (i.e. raindrop fall, not asteroid ;-) ).\r\nTop: sum.   Bottom: decomposition .\r\nhttps://www.shadertoy.com/view/MtBSDG","likes":0,"published":null,"tags":["wave"," dispersion"]},"ver":null,"info":{"Name":"waves dispersion","id":"c7ee26be7bb34748b1d8896cb42b5ec5","date":null,"viewed":0,"name":"waves dispersion","description":"Different wavelengths travels at different speed: this is dispersion.\r\nHere, a 1D ripple made of capillary waves (i.e. raindrop fall, not asteroid ;-) ).\r\nTop: sum.   Bottom: decomposition .\r\nhttps://www.shadertoy.com/view/MtBSDG","likes":0,"published":null,"tags":["wave"," dispersion"]},"renderpass":[{"Code":"// different wavelengths travels at different speed: this is dispersion\r\n// there are 2 main cases: gravity waves + capillary waves\r\n// (+ mix case + shallow water + mix case + soliton + ... ok, forget theses :-p )\r\n// Physics of dispersion here: https://en.wikipedia.org/wiki/Capillary_wave\r\n\r\n// in 2D, add 1/r modulation. Or better: use Bessels instead of sines.\r\n\r\n\r\n#define W(x,k,c) A*sin(k*(X=x-c*t))*exp(-X*X)\r\n\r\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-uv.y))\r\n// #define plot(Y) o +=exp(-max(0.,Y-uv.y))\r\n\r\nvoid mainImage( out vec4 o, vec2 uv )\r\n{\r\n    float A=.8,X,y,Y=0.,  t=mod(iTime,10.); \r\n    vec2 R = iResolution.xy;    o = vec4(0.0);\r\n    uv = 10.* (2.*uv-R)/R.y; \r\n    \r\n    for (float k=1.; k<10.; k++) {\r\n        Y += y = W(abs(uv.x), k, sqrt(k))/k;   // dispertion for capillary waves\r\n     // Y += y = W(abs(uv.x), k, 1./sqrt(k))/k;// dispertion for gravity waves\r\n\t    plot( y - 3.  ); \r\n    }\r\n\r\n    plot( Y + 3. );\r\n    \r\n    o.b += .2;\r\n}","inputs":[],"outputs":[],"code":"// different wavelengths travels at different speed: this is dispersion\r\n// there are 2 main cases: gravity waves + capillary waves\r\n// (+ mix case + shallow water + mix case + soliton + ... ok, forget theses :-p )\r\n// Physics of dispersion here: https://en.wikipedia.org/wiki/Capillary_wave\r\n\r\n// in 2D, add 1/r modulation. Or better: use Bessels instead of sines.\r\n\r\n\r\n#define W(x,k,c) A*sin(k*(X=x-c*t))*exp(-X*X)\r\n\r\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-uv.y))\r\n// #define plot(Y) o +=exp(-max(0.,Y-uv.y))\r\n\r\nvoid mainImage( out vec4 o, vec2 uv )\r\n{\r\n    float A=.8,X,y,Y=0.,  t=mod(iTime,10.); \r\n    vec2 R = iResolution.xy;    o = vec4(0.0);\r\n    uv = 10.* (2.*uv-R)/R.y; \r\n    \r\n    for (float k=1.; k<10.; k++) {\r\n        Y += y = W(abs(uv.x), k, sqrt(k))/k;   // dispertion for capillary waves\r\n     // Y += y = W(abs(uv.x), k, 1./sqrt(k))/k;// dispertion for gravity waves\r\n\t    plot( y - 3.  ); \r\n    }\r\n\r\n    plot( Y + 3. );\r\n    \r\n    o.b += .2;\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n       _\r\n\\^/ILD|-LOWER\r\n\r\nby Hazel Quantock 2020\r\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\r\n*/\r\n\r\n// create a simple repetetive patch of grass,\r\n// then blend it with copies of itself randomly offset and rotated\r\n\r\n\r\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\r\n#define M1 1597334677U     //1719413*929\r\n#define M2 3812015801U     //140473*2467*11\r\n#define M3 3299493293U     //467549*7057\r\n\r\n#define F0 (1.0/float(0xffffffffU))\r\n\r\n#define hash(n) n*(n^(n>>15))\r\n\r\n#define coord1(p) (uint(p)*M1)\r\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\r\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\r\n\r\nfloat hash1(uint n){return float(hash(n))*F0;}\r\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\r\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\r\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\r\n\r\n\r\nfloat BladeOfGrass( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool stalk )\r\n{\r\n    // cone, curved from vertical to tip\r\n    // subtract a second cone, offset away from tip\r\n    // maybe curve more on shorter ones\r\n\r\n    float v = (pos.y-base.y) / (tip.y - base.y);\r\n    \r\n    // curve the blade\r\n    v = pow(v,1.5);\r\n\r\n    // apply the curved slope\r\n    pos.xz -= mix(base.xz,tip.xz,v);\r\n\r\n    // wrap space here, so it can follow the curve without needing duplicate blades\r\n    // even if blade curves enough to lean into next repeat!\r\n//    pos.xz = (abs(fract(pos.xz/(tile*2.)-.25)-.5)-.25)*tile*2.;    // this flips the crease inside out but makes the sdf continuous\r\n    pos.xz = (fract(pos.xz/tile+.5)-.5)*tile;\r\n    \r\n    float r = .03*tip.y;\r\n    vec2 cutBase = -normalize(tip.xz)*r*.3;\r\n    \r\n    if ( stalk )\r\n        r = .0005;\r\n    else\r\n        r *= (1.-v);\r\n    \r\n    float f = length(pos.xz) - r;\r\n\r\n    if ( !stalk )\r\n    {\r\n        f = max(f, -(length(pos.xz - cutBase*(1.-v)) - r*1.2) );\r\n    }\r\n        \r\n    return max(pos.y-tip.y-.0, // improve distance values above tip (with a fudge because this is too low!?)\r\n              f*.8); // HACK gradient too high because of tilt - todo: do this analytically (curve of v is a problem)\r\n    \t\t\t\t// this breaks looking top-down if pow(,2) or more\r\n    \t\t\t\t// better options: tilt plane of the circle, maybe sweep it along a circular curve\r\n}\r\n\r\n\r\nfloat Flower( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool grass )\r\n{\r\n    vec3 tpos = pos-tip-vec3(0,-.0004,0);\r\n    tpos.xz = (fract(tpos.xz/tile+.5)-.5)*tile;\r\n    \r\n//\tfloat f = length(tpos)-.003;\r\n    \r\n    // tilt, so the flower sits at a nice angle\r\n    tpos.yz = tpos.yz*sqrt(2./4.) + tpos.zy*sqrt(2./4.)*vec2(-1,1);\r\n    \r\n    // petals: mirror tpos in a circle around z\r\n    tpos.xy = abs(tpos.xy);\r\n\tif ( tpos.x > tpos.y ) tpos.xy = tpos.yx;\r\n\r\n// too thin at the edges\r\n// better to intersect a thin sphere with a sphere to cut the shape\r\n/*    float f = max(\r\n            length(tpos-vec3(.001,.002,.002)*1.1) - .002,\r\n            -(length(tpos-vec3(.001,.002,.003)) - .0028)\r\n        );*/\r\n    float f = max(\r\n            length(tpos-vec3(.001,.002,.0005)*1.1) - .002, // cut shape\r\n            abs( length(tpos-vec3(.001,.002,.003)) - .003)-.0001\r\n        );\r\n    f = min( f,\r\n            max(\r\n\t            length(tpos-vec3(0,0,.000)) -.001,\r\n\t            length(tpos-vec3(0,0,.001)) -.001\r\n            )\r\n            )*.9;\r\n\r\n\tif ( grass ) f = min(min( f,\r\n                             BladeOfGrass( base, tip, tile, pos, true )),\r\n                             BladeOfGrass( base, tip+vec3(.003,-.008,-.001), tile, pos, false )\r\n                            );\r\n    \r\n\treturn f;\r\n}\r\n\r\n\r\nfloat Tile( vec3 pos, float invWeight, vec4 rand, bool grass )\r\n{\r\n//    if ( rand.w > .2 ) invWeight = 1.; // isolate some of the blades\r\n    \r\n//    invWeight = invWeight*invWeight; // should be 0 until about .5\r\n//    invWeight = smoothstep(.5,1.,invWeight); // should be 0 until about .5\r\n\r\n    // vary the height a little to make it look less even\r\n    pos.y += sqrt(rand.w)*.07;\r\n    \r\n    pos.xz += rand.xy;\r\n    float a = rand.z*6.283;\r\n    pos.xz = pos.xz*cos(a) + sin(a)*vec2(-1,1)*pos.zx;\r\n    \r\n    float f = 1e20;\r\n    \r\n    if ( grass )\r\n    {\r\n        f = min(f,min(min(min(min(\r\n            BladeOfGrass(vec3(.01,0,0),vec3(.03,.15,.04),vec2(.06),pos,false),\r\n            BladeOfGrass(vec3(0),vec3(-.05,.17,.02),vec2(.06),pos,false)),\r\n            BladeOfGrass(vec3(0),vec3(-.01,.10,.02),vec2(.04),pos,false)),\r\n            BladeOfGrass(vec3(0,0,-.01),vec3(-.01,.12,-.03),vec2(.03),pos,false)),\r\n            BladeOfGrass(vec3(.005,0,0),vec3(.03,.16,-.05),vec2(.04),pos,false)\r\n        )) + (1.-invWeight)*.0;\r\n    }\r\n    \r\n    // flowers\r\n    f = min(f, Flower(vec3(.1,0,0),vec3(.1,.2,.05),vec2(.13),pos,grass) + (1.-invWeight)*.0 );\r\n    \r\n    return mix( max(.03,pos.y-.2), f, invWeight );\r\n//    return f;\r\n}\r\n\r\nfloat SDF( vec3 pos, bool grass )\r\n{\r\n    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations\r\n    \r\n    vec2 gridSize = vec2(.1);//.04);\r\n    vec2 uv = pos.xz/gridSize;\r\n    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);\r\n    uv -= floor(uv);\r\n    \r\n    uvec2 d = uvec2(0,1);\r\n    vec4 rand00 = hash4(coord2(idx00+d.xx));\r\n    vec4 rand01 = hash4(coord2(idx00+d.yx));\r\n    vec4 rand10 = hash4(coord2(idx00+d.xy));\r\n    vec4 rand11 = hash4(coord2(idx00+d.yy));\r\n\r\n//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it\r\n\r\n    vec2 uvlo = smoothstep(1.,.5,uv);\r\n    vec2 uvhi = smoothstep(0.,.5,uv);\r\n\r\n    return min( pos.y,\r\n                min(\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),\r\n                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )\r\n                    ),\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),\r\n                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )\r\n                    )\r\n                )\r\n\t\t\t) * 1.;\r\n/*    return mix(\r\n                    mix(\r\n                        Tile( pos, uv.x*uv.y, rand00, grass ),\r\n                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),\r\n                        uv.x\r\n                    ),\r\n                    mix(\r\n                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),\r\n                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),\r\n                        uv.x\r\n                    ),\r\n        \t\t\tuv.y\r\n                );*/\r\n}\r\n\r\n// adjust trace quality/performance\r\nconst float epsilon = .00005;\r\nconst int loopCount = 200;\r\n\r\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\r\n{\r\n\tfloat t = epsilon;\r\n    for ( int i=0; i < loopCount; i++ )\r\n    {\r\n        float h = SDF( rayDirection*t+rayStart, true );\r\n        t += h;\r\n        if ( t > far || h < epsilon ) // *t )\r\n            return t;\r\n    }\r\n    \r\n    return t;\r\n}\r\n\r\n\r\nvec3 Normal( vec3 pos )\r\n{\r\n    vec2 d = vec2(-1,1) * .000004;\r\n    return\r\n        normalize(\r\n            SDF( pos + d.xxx, true )*d.xxx +\r\n            SDF( pos + d.xyy, true )*d.xyy +\r\n            SDF( pos + d.yxy, true )*d.yxy +\r\n            SDF( pos + d.yyx, true )*d.yyx\r\n        );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\r\n{\r\n    vec2 camAngle = vec2(.5-.03*(iTime/8.-sin(iTime/8.))*8.,.15-cos(iTime/8.)*.08);\r\n\tif ( iMouse.z > 0. ) camAngle = pow(iMouse.xy/iResolution.xy,vec2(1.,.5))*vec2(6,-1.57) + vec2(0,1.57);\r\n    vec3 camPos = 1.*vec3(cos(camAngle.y)*sin(camAngle.x),sin(camAngle.y),cos(camAngle.y)*cos(camAngle.x));\r\n    vec3 camLook = vec3(0,.10,0)+camPos*vec3(1,0,1)*.3;\r\n    float camZoom = 2.;\r\n    \r\n    vec3 camK = normalize(camLook-camPos);\r\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\r\n    vec3 camJ = cross(camK,camI);\r\n\r\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,camZoom);\r\n    ray = normalize(ray);\r\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\r\n    \r\n    float t = Trace( camPos, ray, 1e20 );\r\n    \r\n    float far = 20.;\r\n    if ( t < far )\r\n    {\r\n        vec3 pos = camPos+ray*t;\r\n\r\n        float sdf = SDF(pos,true);\r\n        float sdfnograss = SDF(pos,false);\r\n\r\n        vec3 flowerColour = sin(pos/.03)*.1+.9;\r\n        vec3 grassColour = mix( vec3(.2,.6,.01), vec3(.5,.7,.2), .5+.5*sin(pos.yxz/.025+2.5) );\r\n\r\n        vec3 albedo = mix( grassColour, mix( vec3(.03,.0,.0), flowerColour, smoothstep(.0,.05,pos.y)), step(sdfnograss,sdf) );\r\n\r\n        vec3 n = Normal( camPos+ray*t );\r\n        vec3 ambient = mix( vec3(.06,.1,.02), vec3(.15,.2,.25), n.y*.5+.5 );\r\n        float nl = dot(n,normalize(vec3(1,3,2)));\r\n\r\n        fragColour.rgb = ambient;\r\n        fragColour.rgb += vec3(.9)*max(0.,nl); // direct light\r\n        fragColour.rgb += vec3(.3)*pow(albedo*.99,vec3(4))*smoothstep(-1.,.1,nl); // subsurface light\r\n        fragColour.rgb *= smoothstep(.0,.18,pos.y); // fake combined shadows & AO\r\n        fragColour.rgb *= albedo;\r\n    }\r\n    else\r\n    {\r\n        fragColour.rgb = vec3(1);\r\n        t = far; // so it gets fog applied\r\n    }\r\n    \r\n    fragColour.rgb = mix( vec3(.7,.8,1), fragColour.rgb, exp2(-t/5.)*1.08 );\r\n \r\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\r\n    fragColour.a = 1.;\r\n\r\n//float f = BladeOfGrass( vec3(.8,0,0), vec3(.9,.5,0), vec3(fragCoord/iResolution.y,0) );\r\n//float f = SDF(vec3(fragCoord/1000.,.1+.1*sin(iTime)).xzy,true);\r\n//fragColour.rgb = vec3( .5+.5*f/(abs(f)+.001) );\r\n}\r\n","inputs":[],"outputs":[],"code":"/*\r\n       _\r\n\\^/ILD|-LOWER\r\n\r\nby Hazel Quantock 2020\r\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\r\n*/\r\n\r\n// create a simple repetetive patch of grass,\r\n// then blend it with copies of itself randomly offset and rotated\r\n\r\n\r\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\r\n#define M1 1597334677U     //1719413*929\r\n#define M2 3812015801U     //140473*2467*11\r\n#define M3 3299493293U     //467549*7057\r\n\r\n#define F0 (1.0/float(0xffffffffU))\r\n\r\n#define hash(n) n*(n^(n>>15))\r\n\r\n#define coord1(p) (uint(p)*M1)\r\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\r\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\r\n\r\nfloat hash1(uint n){return float(hash(n))*F0;}\r\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\r\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\r\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\r\n\r\n\r\nfloat BladeOfGrass( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool stalk )\r\n{\r\n    // cone, curved from vertical to tip\r\n    // subtract a second cone, offset away from tip\r\n    // maybe curve more on shorter ones\r\n\r\n    float v = (pos.y-base.y) / (tip.y - base.y);\r\n    \r\n    // curve the blade\r\n    v = pow(v,1.5);\r\n\r\n    // apply the curved slope\r\n    pos.xz -= mix(base.xz,tip.xz,v);\r\n\r\n    // wrap space here, so it can follow the curve without needing duplicate blades\r\n    // even if blade curves enough to lean into next repeat!\r\n//    pos.xz = (abs(fract(pos.xz/(tile*2.)-.25)-.5)-.25)*tile*2.;    // this flips the crease inside out but makes the sdf continuous\r\n    pos.xz = (fract(pos.xz/tile+.5)-.5)*tile;\r\n    \r\n    float r = .03*tip.y;\r\n    vec2 cutBase = -normalize(tip.xz)*r*.3;\r\n    \r\n    if ( stalk )\r\n        r = .0005;\r\n    else\r\n        r *= (1.-v);\r\n    \r\n    float f = length(pos.xz) - r;\r\n\r\n    if ( !stalk )\r\n    {\r\n        f = max(f, -(length(pos.xz - cutBase*(1.-v)) - r*1.2) );\r\n    }\r\n        \r\n    return max(pos.y-tip.y-.0, // improve distance values above tip (with a fudge because this is too low!?)\r\n              f*.8); // HACK gradient too high because of tilt - todo: do this analytically (curve of v is a problem)\r\n    \t\t\t\t// this breaks looking top-down if pow(,2) or more\r\n    \t\t\t\t// better options: tilt plane of the circle, maybe sweep it along a circular curve\r\n}\r\n\r\n\r\nfloat Flower( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool grass )\r\n{\r\n    vec3 tpos = pos-tip-vec3(0,-.0004,0);\r\n    tpos.xz = (fract(tpos.xz/tile+.5)-.5)*tile;\r\n    \r\n//\tfloat f = length(tpos)-.003;\r\n    \r\n    // tilt, so the flower sits at a nice angle\r\n    tpos.yz = tpos.yz*sqrt(2./4.) + tpos.zy*sqrt(2./4.)*vec2(-1,1);\r\n    \r\n    // petals: mirror tpos in a circle around z\r\n    tpos.xy = abs(tpos.xy);\r\n\tif ( tpos.x > tpos.y ) tpos.xy = tpos.yx;\r\n\r\n// too thin at the edges\r\n// better to intersect a thin sphere with a sphere to cut the shape\r\n/*    float f = max(\r\n            length(tpos-vec3(.001,.002,.002)*1.1) - .002,\r\n            -(length(tpos-vec3(.001,.002,.003)) - .0028)\r\n        );*/\r\n    float f = max(\r\n            length(tpos-vec3(.001,.002,.0005)*1.1) - .002, // cut shape\r\n            abs( length(tpos-vec3(.001,.002,.003)) - .003)-.0001\r\n        );\r\n    f = min( f,\r\n            max(\r\n\t            length(tpos-vec3(0,0,.000)) -.001,\r\n\t            length(tpos-vec3(0,0,.001)) -.001\r\n            )\r\n            )*.9;\r\n\r\n\tif ( grass ) f = min(min( f,\r\n                             BladeOfGrass( base, tip, tile, pos, true )),\r\n                             BladeOfGrass( base, tip+vec3(.003,-.008,-.001), tile, pos, false )\r\n                            );\r\n    \r\n\treturn f;\r\n}\r\n\r\n\r\nfloat Tile( vec3 pos, float invWeight, vec4 rand, bool grass )\r\n{\r\n//    if ( rand.w > .2 ) invWeight = 1.; // isolate some of the blades\r\n    \r\n//    invWeight = invWeight*invWeight; // should be 0 until about .5\r\n//    invWeight = smoothstep(.5,1.,invWeight); // should be 0 until about .5\r\n\r\n    // vary the height a little to make it look less even\r\n    pos.y += sqrt(rand.w)*.07;\r\n    \r\n    pos.xz += rand.xy;\r\n    float a = rand.z*6.283;\r\n    pos.xz = pos.xz*cos(a) + sin(a)*vec2(-1,1)*pos.zx;\r\n    \r\n    float f = 1e20;\r\n    \r\n    if ( grass )\r\n    {\r\n        f = min(f,min(min(min(min(\r\n            BladeOfGrass(vec3(.01,0,0),vec3(.03,.15,.04),vec2(.06),pos,false),\r\n            BladeOfGrass(vec3(0),vec3(-.05,.17,.02),vec2(.06),pos,false)),\r\n            BladeOfGrass(vec3(0),vec3(-.01,.10,.02),vec2(.04),pos,false)),\r\n            BladeOfGrass(vec3(0,0,-.01),vec3(-.01,.12,-.03),vec2(.03),pos,false)),\r\n            BladeOfGrass(vec3(.005,0,0),vec3(.03,.16,-.05),vec2(.04),pos,false)\r\n        )) + (1.-invWeight)*.0;\r\n    }\r\n    \r\n    // flowers\r\n    f = min(f, Flower(vec3(.1,0,0),vec3(.1,.2,.05),vec2(.13),pos,grass) + (1.-invWeight)*.0 );\r\n    \r\n    return mix( max(.03,pos.y-.2), f, invWeight );\r\n//    return f;\r\n}\r\n\r\nfloat SDF( vec3 pos, bool grass )\r\n{\r\n    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations\r\n    \r\n    vec2 gridSize = vec2(.1);//.04);\r\n    vec2 uv = pos.xz/gridSize;\r\n    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);\r\n    uv -= floor(uv);\r\n    \r\n    uvec2 d = uvec2(0,1);\r\n    vec4 rand00 = hash4(coord2(idx00+d.xx));\r\n    vec4 rand01 = hash4(coord2(idx00+d.yx));\r\n    vec4 rand10 = hash4(coord2(idx00+d.xy));\r\n    vec4 rand11 = hash4(coord2(idx00+d.yy));\r\n\r\n//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it\r\n\r\n    vec2 uvlo = smoothstep(1.,.5,uv);\r\n    vec2 uvhi = smoothstep(0.,.5,uv);\r\n\r\n    return min( pos.y,\r\n                min(\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),\r\n                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )\r\n                    ),\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),\r\n                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )\r\n                    )\r\n                )\r\n\t\t\t) * 1.;\r\n/*    return mix(\r\n                    mix(\r\n                        Tile( pos, uv.x*uv.y, rand00, grass ),\r\n                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),\r\n                        uv.x\r\n                    ),\r\n                    mix(\r\n                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),\r\n                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),\r\n                        uv.x\r\n                    ),\r\n        \t\t\tuv.y\r\n                );*/\r\n}\r\n\r\n// adjust trace quality/performance\r\nconst float epsilon = .00005;\r\nconst int loopCount = 200;\r\n\r\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\r\n{\r\n\tfloat t = epsilon;\r\n    for ( int i=0; i < loopCount; i++ )\r\n    {\r\n        float h = SDF( rayDirection*t+rayStart, true );\r\n        t += h;\r\n        if ( t > far || h < epsilon ) // *t )\r\n            return t;\r\n    }\r\n    \r\n    return t;\r\n}\r\n\r\n\r\nvec3 Normal( vec3 pos )\r\n{\r\n    vec2 d = vec2(-1,1) * .000004;\r\n    return\r\n        normalize(\r\n            SDF( pos + d.xxx, true )*d.xxx +\r\n            SDF( pos + d.xyy, true )*d.xyy +\r\n            SDF( pos + d.yxy, true )*d.yxy +\r\n            SDF( pos + d.yyx, true )*d.yyx\r\n        );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\r\n{\r\n    vec2 camAngle = vec2(.5-.03*(iTime/8.-sin(iTime/8.))*8.,.15-cos(iTime/8.)*.08);\r\n\tif ( iMouse.z > 0. ) camAngle = pow(iMouse.xy/iResolution.xy,vec2(1.,.5))*vec2(6,-1.57) + vec2(0,1.57);\r\n    vec3 camPos = 1.*vec3(cos(camAngle.y)*sin(camAngle.x),sin(camAngle.y),cos(camAngle.y)*cos(camAngle.x));\r\n    vec3 camLook = vec3(0,.10,0)+camPos*vec3(1,0,1)*.3;\r\n    float camZoom = 2.;\r\n    \r\n    vec3 camK = normalize(camLook-camPos);\r\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\r\n    vec3 camJ = cross(camK,camI);\r\n\r\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,camZoom);\r\n    ray = normalize(ray);\r\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\r\n    \r\n    float t = Trace( camPos, ray, 1e20 );\r\n    \r\n    float far = 20.;\r\n    if ( t < far )\r\n    {\r\n        vec3 pos = camPos+ray*t;\r\n\r\n        float sdf = SDF(pos,true);\r\n        float sdfnograss = SDF(pos,false);\r\n\r\n        vec3 flowerColour = sin(pos/.03)*.1+.9;\r\n        vec3 grassColour = mix( vec3(.2,.6,.01), vec3(.5,.7,.2), .5+.5*sin(pos.yxz/.025+2.5) );\r\n\r\n        vec3 albedo = mix( grassColour, mix( vec3(.03,.0,.0), flowerColour, smoothstep(.0,.05,pos.y)), step(sdfnograss,sdf) );\r\n\r\n        vec3 n = Normal( camPos+ray*t );\r\n        vec3 ambient = mix( vec3(.06,.1,.02), vec3(.15,.2,.25), n.y*.5+.5 );\r\n        float nl = dot(n,normalize(vec3(1,3,2)));\r\n\r\n        fragColour.rgb = ambient;\r\n        fragColour.rgb += vec3(.9)*max(0.,nl); // direct light\r\n        fragColour.rgb += vec3(.3)*pow(albedo*.99,vec3(4))*smoothstep(-1.,.1,nl); // subsurface light\r\n        fragColour.rgb *= smoothstep(.0,.18,pos.y); // fake combined shadows & AO\r\n        fragColour.rgb *= albedo;\r\n    }\r\n    else\r\n    {\r\n        fragColour.rgb = vec3(1);\r\n        t = far; // so it gets fog applied\r\n    }\r\n    \r\n    fragColour.rgb = mix( vec3(.7,.8,1), fragColour.rgb, exp2(-t/5.)*1.08 );\r\n \r\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\r\n    fragColour.a = 1.;\r\n\r\n//float f = BladeOfGrass( vec3(.8,0,0), vec3(.9,.5,0), vec3(fragCoord/iResolution.y,0) );\r\n//float f = SDF(vec3(fragCoord/1000.,.1+.1*sin(iTime)).xzy,true);\r\n//fragColour.rgb = vec3( .5+.5*f/(abs(f)+.001) );\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Wildflower","id":"2817b55017af4f769ca466b8dfcce7a0","date":null,"viewed":0,"name":"Wildflower","description":"An experiment in creating a dense detailed organic scene.\r\nhttps://www.shadertoy.com/view/tlVGz1","likes":0,"published":null,"tags":["raymarching"," flower"," grass"," organic"," natural"]},"ver":null,"info":{"Name":"Wildflower","id":"2817b55017af4f769ca466b8dfcce7a0","date":null,"viewed":0,"name":"Wildflower","description":"An experiment in creating a dense detailed organic scene.\r\nhttps://www.shadertoy.com/view/tlVGz1","likes":0,"published":null,"tags":["raymarching"," flower"," grass"," organic"," natural"]},"renderpass":[{"Code":"/*\r\n       _\r\n\\^/ILD|-LOWER\r\n\r\nby Hazel Quantock 2020\r\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\r\n*/\r\n\r\n// create a simple repetetive patch of grass,\r\n// then blend it with copies of itself randomly offset and rotated\r\n\r\n\r\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\r\n#define M1 1597334677U     //1719413*929\r\n#define M2 3812015801U     //140473*2467*11\r\n#define M3 3299493293U     //467549*7057\r\n\r\n#define F0 (1.0/float(0xffffffffU))\r\n\r\n#define hash(n) n*(n^(n>>15))\r\n\r\n#define coord1(p) (uint(p)*M1)\r\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\r\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\r\n\r\nfloat hash1(uint n){return float(hash(n))*F0;}\r\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\r\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\r\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\r\n\r\n\r\nfloat BladeOfGrass( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool stalk )\r\n{\r\n    // cone, curved from vertical to tip\r\n    // subtract a second cone, offset away from tip\r\n    // maybe curve more on shorter ones\r\n\r\n    float v = (pos.y-base.y) / (tip.y - base.y);\r\n    \r\n    // curve the blade\r\n    v = pow(v,1.5);\r\n\r\n    // apply the curved slope\r\n    pos.xz -= mix(base.xz,tip.xz,v);\r\n\r\n    // wrap space here, so it can follow the curve without needing duplicate blades\r\n    // even if blade curves enough to lean into next repeat!\r\n//    pos.xz = (abs(fract(pos.xz/(tile*2.)-.25)-.5)-.25)*tile*2.;    // this flips the crease inside out but makes the sdf continuous\r\n    pos.xz = (fract(pos.xz/tile+.5)-.5)*tile;\r\n    \r\n    float r = .03*tip.y;\r\n    vec2 cutBase = -normalize(tip.xz)*r*.3;\r\n    \r\n    if ( stalk )\r\n        r = .0005;\r\n    else\r\n        r *= (1.-v);\r\n    \r\n    float f = length(pos.xz) - r;\r\n\r\n    if ( !stalk )\r\n    {\r\n        f = max(f, -(length(pos.xz - cutBase*(1.-v)) - r*1.2) );\r\n    }\r\n        \r\n    return max(pos.y-tip.y-.0, // improve distance values above tip (with a fudge because this is too low!?)\r\n              f*.8); // HACK gradient too high because of tilt - todo: do this analytically (curve of v is a problem)\r\n    \t\t\t\t// this breaks looking top-down if pow(,2) or more\r\n    \t\t\t\t// better options: tilt plane of the circle, maybe sweep it along a circular curve\r\n}\r\n\r\n\r\nfloat Flower( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool grass )\r\n{\r\n    vec3 tpos = pos-tip-vec3(0,-.0004,0);\r\n    tpos.xz = (fract(tpos.xz/tile+.5)-.5)*tile;\r\n    \r\n//\tfloat f = length(tpos)-.003;\r\n    \r\n    // tilt, so the flower sits at a nice angle\r\n    tpos.yz = tpos.yz*sqrt(2./4.) + tpos.zy*sqrt(2./4.)*vec2(-1,1);\r\n    \r\n    // petals: mirror tpos in a circle around z\r\n    tpos.xy = abs(tpos.xy);\r\n\tif ( tpos.x > tpos.y ) tpos.xy = tpos.yx;\r\n\r\n// too thin at the edges\r\n// better to intersect a thin sphere with a sphere to cut the shape\r\n/*    float f = max(\r\n            length(tpos-vec3(.001,.002,.002)*1.1) - .002,\r\n            -(length(tpos-vec3(.001,.002,.003)) - .0028)\r\n        );*/\r\n    float f = max(\r\n            length(tpos-vec3(.001,.002,.0005)*1.1) - .002, // cut shape\r\n            abs( length(tpos-vec3(.001,.002,.003)) - .003)-.0001\r\n        );\r\n    f = min( f,\r\n            max(\r\n\t            length(tpos-vec3(0,0,.000)) -.001,\r\n\t            length(tpos-vec3(0,0,.001)) -.001\r\n            )\r\n            )*.9;\r\n\r\n\tif ( grass ) f = min(min( f,\r\n                             BladeOfGrass( base, tip, tile, pos, true )),\r\n                             BladeOfGrass( base, tip+vec3(.003,-.008,-.001), tile, pos, false )\r\n                            );\r\n    \r\n\treturn f;\r\n}\r\n\r\n\r\nfloat Tile( vec3 pos, float invWeight, vec4 rand, bool grass )\r\n{\r\n//    if ( rand.w > .2 ) invWeight = 1.; // isolate some of the blades\r\n    \r\n//    invWeight = invWeight*invWeight; // should be 0 until about .5\r\n//    invWeight = smoothstep(.5,1.,invWeight); // should be 0 until about .5\r\n\r\n    // vary the height a little to make it look less even\r\n    pos.y += sqrt(rand.w)*.07;\r\n    \r\n    pos.xz += rand.xy;\r\n    float a = rand.z*6.283;\r\n    pos.xz = pos.xz*cos(a) + sin(a)*vec2(-1,1)*pos.zx;\r\n    \r\n    float f = 1e20;\r\n    \r\n    if ( grass )\r\n    {\r\n        f = min(f,min(min(min(min(\r\n            BladeOfGrass(vec3(.01,0,0),vec3(.03,.15,.04),vec2(.06),pos,false),\r\n            BladeOfGrass(vec3(0),vec3(-.05,.17,.02),vec2(.06),pos,false)),\r\n            BladeOfGrass(vec3(0),vec3(-.01,.10,.02),vec2(.04),pos,false)),\r\n            BladeOfGrass(vec3(0,0,-.01),vec3(-.01,.12,-.03),vec2(.03),pos,false)),\r\n            BladeOfGrass(vec3(.005,0,0),vec3(.03,.16,-.05),vec2(.04),pos,false)\r\n        )) + (1.-invWeight)*.0;\r\n    }\r\n    \r\n    // flowers\r\n    f = min(f, Flower(vec3(.1,0,0),vec3(.1,.2,.05),vec2(.13),pos,grass) + (1.-invWeight)*.0 );\r\n    \r\n    return mix( max(.03,pos.y-.2), f, invWeight );\r\n//    return f;\r\n}\r\n\r\nfloat SDF( vec3 pos, bool grass )\r\n{\r\n    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations\r\n    \r\n    vec2 gridSize = vec2(.1);//.04);\r\n    vec2 uv = pos.xz/gridSize;\r\n    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);\r\n    uv -= floor(uv);\r\n    \r\n    uvec2 d = uvec2(0,1);\r\n    vec4 rand00 = hash4(coord2(idx00+d.xx));\r\n    vec4 rand01 = hash4(coord2(idx00+d.yx));\r\n    vec4 rand10 = hash4(coord2(idx00+d.xy));\r\n    vec4 rand11 = hash4(coord2(idx00+d.yy));\r\n\r\n//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it\r\n\r\n    vec2 uvlo = smoothstep(1.,.5,uv);\r\n    vec2 uvhi = smoothstep(0.,.5,uv);\r\n\r\n    return min( pos.y,\r\n                min(\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),\r\n                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )\r\n                    ),\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),\r\n                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )\r\n                    )\r\n                )\r\n\t\t\t) * 1.;\r\n/*    return mix(\r\n                    mix(\r\n                        Tile( pos, uv.x*uv.y, rand00, grass ),\r\n                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),\r\n                        uv.x\r\n                    ),\r\n                    mix(\r\n                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),\r\n                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),\r\n                        uv.x\r\n                    ),\r\n        \t\t\tuv.y\r\n                );*/\r\n}\r\n\r\n// adjust trace quality/performance\r\nconst float epsilon = .00005;\r\nconst int loopCount = 200;\r\n\r\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\r\n{\r\n\tfloat t = epsilon;\r\n    for ( int i=0; i < loopCount; i++ )\r\n    {\r\n        float h = SDF( rayDirection*t+rayStart, true );\r\n        t += h;\r\n        if ( t > far || h < epsilon ) // *t )\r\n            return t;\r\n    }\r\n    \r\n    return t;\r\n}\r\n\r\n\r\nvec3 Normal( vec3 pos )\r\n{\r\n    vec2 d = vec2(-1,1) * .000004;\r\n    return\r\n        normalize(\r\n            SDF( pos + d.xxx, true )*d.xxx +\r\n            SDF( pos + d.xyy, true )*d.xyy +\r\n            SDF( pos + d.yxy, true )*d.yxy +\r\n            SDF( pos + d.yyx, true )*d.yyx\r\n        );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\r\n{\r\n    vec2 camAngle = vec2(.5-.03*(iTime/8.-sin(iTime/8.))*8.,.15-cos(iTime/8.)*.08);\r\n\tif ( iMouse.z > 0. ) camAngle = pow(iMouse.xy/iResolution.xy,vec2(1.,.5))*vec2(6,-1.57) + vec2(0,1.57);\r\n    vec3 camPos = 1.*vec3(cos(camAngle.y)*sin(camAngle.x),sin(camAngle.y),cos(camAngle.y)*cos(camAngle.x));\r\n    vec3 camLook = vec3(0,.10,0)+camPos*vec3(1,0,1)*.3;\r\n    float camZoom = 2.;\r\n    \r\n    vec3 camK = normalize(camLook-camPos);\r\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\r\n    vec3 camJ = cross(camK,camI);\r\n\r\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,camZoom);\r\n    ray = normalize(ray);\r\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\r\n    \r\n    float t = Trace( camPos, ray, 1e20 );\r\n    \r\n    float far = 20.;\r\n    if ( t < far )\r\n    {\r\n        vec3 pos = camPos+ray*t;\r\n\r\n        float sdf = SDF(pos,true);\r\n        float sdfnograss = SDF(pos,false);\r\n\r\n        vec3 flowerColour = sin(pos/.03)*.1+.9;\r\n        vec3 grassColour = mix( vec3(.2,.6,.01), vec3(.5,.7,.2), .5+.5*sin(pos.yxz/.025+2.5) );\r\n\r\n        vec3 albedo = mix( grassColour, mix( vec3(.03,.0,.0), flowerColour, smoothstep(.0,.05,pos.y)), step(sdfnograss,sdf) );\r\n\r\n        vec3 n = Normal( camPos+ray*t );\r\n        vec3 ambient = mix( vec3(.06,.1,.02), vec3(.15,.2,.25), n.y*.5+.5 );\r\n        float nl = dot(n,normalize(vec3(1,3,2)));\r\n\r\n        fragColour.rgb = ambient;\r\n        fragColour.rgb += vec3(.9)*max(0.,nl); // direct light\r\n        fragColour.rgb += vec3(.3)*pow(albedo*.99,vec3(4))*smoothstep(-1.,.1,nl); // subsurface light\r\n        fragColour.rgb *= smoothstep(.0,.18,pos.y); // fake combined shadows & AO\r\n        fragColour.rgb *= albedo;\r\n    }\r\n    else\r\n    {\r\n        fragColour.rgb = vec3(1);\r\n        t = far; // so it gets fog applied\r\n    }\r\n    \r\n    fragColour.rgb = mix( vec3(.7,.8,1), fragColour.rgb, exp2(-t/5.)*1.08 );\r\n \r\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\r\n    fragColour.a = 1.;\r\n\r\n//float f = BladeOfGrass( vec3(.8,0,0), vec3(.9,.5,0), vec3(fragCoord/iResolution.y,0) );\r\n//float f = SDF(vec3(fragCoord/1000.,.1+.1*sin(iTime)).xzy,true);\r\n//fragColour.rgb = vec3( .5+.5*f/(abs(f)+.001) );\r\n}\r\n","inputs":[],"outputs":[],"code":"/*\r\n       _\r\n\\^/ILD|-LOWER\r\n\r\nby Hazel Quantock 2020\r\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\r\n*/\r\n\r\n// create a simple repetetive patch of grass,\r\n// then blend it with copies of itself randomly offset and rotated\r\n\r\n\r\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\r\n#define M1 1597334677U     //1719413*929\r\n#define M2 3812015801U     //140473*2467*11\r\n#define M3 3299493293U     //467549*7057\r\n\r\n#define F0 (1.0/float(0xffffffffU))\r\n\r\n#define hash(n) n*(n^(n>>15))\r\n\r\n#define coord1(p) (uint(p)*M1)\r\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\r\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\r\n\r\nfloat hash1(uint n){return float(hash(n))*F0;}\r\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\r\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\r\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\r\n\r\n\r\nfloat BladeOfGrass( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool stalk )\r\n{\r\n    // cone, curved from vertical to tip\r\n    // subtract a second cone, offset away from tip\r\n    // maybe curve more on shorter ones\r\n\r\n    float v = (pos.y-base.y) / (tip.y - base.y);\r\n    \r\n    // curve the blade\r\n    v = pow(v,1.5);\r\n\r\n    // apply the curved slope\r\n    pos.xz -= mix(base.xz,tip.xz,v);\r\n\r\n    // wrap space here, so it can follow the curve without needing duplicate blades\r\n    // even if blade curves enough to lean into next repeat!\r\n//    pos.xz = (abs(fract(pos.xz/(tile*2.)-.25)-.5)-.25)*tile*2.;    // this flips the crease inside out but makes the sdf continuous\r\n    pos.xz = (fract(pos.xz/tile+.5)-.5)*tile;\r\n    \r\n    float r = .03*tip.y;\r\n    vec2 cutBase = -normalize(tip.xz)*r*.3;\r\n    \r\n    if ( stalk )\r\n        r = .0005;\r\n    else\r\n        r *= (1.-v);\r\n    \r\n    float f = length(pos.xz) - r;\r\n\r\n    if ( !stalk )\r\n    {\r\n        f = max(f, -(length(pos.xz - cutBase*(1.-v)) - r*1.2) );\r\n    }\r\n        \r\n    return max(pos.y-tip.y-.0, // improve distance values above tip (with a fudge because this is too low!?)\r\n              f*.8); // HACK gradient too high because of tilt - todo: do this analytically (curve of v is a problem)\r\n    \t\t\t\t// this breaks looking top-down if pow(,2) or more\r\n    \t\t\t\t// better options: tilt plane of the circle, maybe sweep it along a circular curve\r\n}\r\n\r\n\r\nfloat Flower( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool grass )\r\n{\r\n    vec3 tpos = pos-tip-vec3(0,-.0004,0);\r\n    tpos.xz = (fract(tpos.xz/tile+.5)-.5)*tile;\r\n    \r\n//\tfloat f = length(tpos)-.003;\r\n    \r\n    // tilt, so the flower sits at a nice angle\r\n    tpos.yz = tpos.yz*sqrt(2./4.) + tpos.zy*sqrt(2./4.)*vec2(-1,1);\r\n    \r\n    // petals: mirror tpos in a circle around z\r\n    tpos.xy = abs(tpos.xy);\r\n\tif ( tpos.x > tpos.y ) tpos.xy = tpos.yx;\r\n\r\n// too thin at the edges\r\n// better to intersect a thin sphere with a sphere to cut the shape\r\n/*    float f = max(\r\n            length(tpos-vec3(.001,.002,.002)*1.1) - .002,\r\n            -(length(tpos-vec3(.001,.002,.003)) - .0028)\r\n        );*/\r\n    float f = max(\r\n            length(tpos-vec3(.001,.002,.0005)*1.1) - .002, // cut shape\r\n            abs( length(tpos-vec3(.001,.002,.003)) - .003)-.0001\r\n        );\r\n    f = min( f,\r\n            max(\r\n\t            length(tpos-vec3(0,0,.000)) -.001,\r\n\t            length(tpos-vec3(0,0,.001)) -.001\r\n            )\r\n            )*.9;\r\n\r\n\tif ( grass ) f = min(min( f,\r\n                             BladeOfGrass( base, tip, tile, pos, true )),\r\n                             BladeOfGrass( base, tip+vec3(.003,-.008,-.001), tile, pos, false )\r\n                            );\r\n    \r\n\treturn f;\r\n}\r\n\r\n\r\nfloat Tile( vec3 pos, float invWeight, vec4 rand, bool grass )\r\n{\r\n//    if ( rand.w > .2 ) invWeight = 1.; // isolate some of the blades\r\n    \r\n//    invWeight = invWeight*invWeight; // should be 0 until about .5\r\n//    invWeight = smoothstep(.5,1.,invWeight); // should be 0 until about .5\r\n\r\n    // vary the height a little to make it look less even\r\n    pos.y += sqrt(rand.w)*.07;\r\n    \r\n    pos.xz += rand.xy;\r\n    float a = rand.z*6.283;\r\n    pos.xz = pos.xz*cos(a) + sin(a)*vec2(-1,1)*pos.zx;\r\n    \r\n    float f = 1e20;\r\n    \r\n    if ( grass )\r\n    {\r\n        f = min(f,min(min(min(min(\r\n            BladeOfGrass(vec3(.01,0,0),vec3(.03,.15,.04),vec2(.06),pos,false),\r\n            BladeOfGrass(vec3(0),vec3(-.05,.17,.02),vec2(.06),pos,false)),\r\n            BladeOfGrass(vec3(0),vec3(-.01,.10,.02),vec2(.04),pos,false)),\r\n            BladeOfGrass(vec3(0,0,-.01),vec3(-.01,.12,-.03),vec2(.03),pos,false)),\r\n            BladeOfGrass(vec3(.005,0,0),vec3(.03,.16,-.05),vec2(.04),pos,false)\r\n        )) + (1.-invWeight)*.0;\r\n    }\r\n    \r\n    // flowers\r\n    f = min(f, Flower(vec3(.1,0,0),vec3(.1,.2,.05),vec2(.13),pos,grass) + (1.-invWeight)*.0 );\r\n    \r\n    return mix( max(.03,pos.y-.2), f, invWeight );\r\n//    return f;\r\n}\r\n\r\nfloat SDF( vec3 pos, bool grass )\r\n{\r\n    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations\r\n    \r\n    vec2 gridSize = vec2(.1);//.04);\r\n    vec2 uv = pos.xz/gridSize;\r\n    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);\r\n    uv -= floor(uv);\r\n    \r\n    uvec2 d = uvec2(0,1);\r\n    vec4 rand00 = hash4(coord2(idx00+d.xx));\r\n    vec4 rand01 = hash4(coord2(idx00+d.yx));\r\n    vec4 rand10 = hash4(coord2(idx00+d.xy));\r\n    vec4 rand11 = hash4(coord2(idx00+d.yy));\r\n\r\n//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it\r\n\r\n    vec2 uvlo = smoothstep(1.,.5,uv);\r\n    vec2 uvhi = smoothstep(0.,.5,uv);\r\n\r\n    return min( pos.y,\r\n                min(\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),\r\n                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )\r\n                    ),\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),\r\n                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )\r\n                    )\r\n                )\r\n\t\t\t) * 1.;\r\n/*    return mix(\r\n                    mix(\r\n                        Tile( pos, uv.x*uv.y, rand00, grass ),\r\n                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),\r\n                        uv.x\r\n                    ),\r\n                    mix(\r\n                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),\r\n                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),\r\n                        uv.x\r\n                    ),\r\n        \t\t\tuv.y\r\n                );*/\r\n}\r\n\r\n// adjust trace quality/performance\r\nconst float epsilon = .00005;\r\nconst int loopCount = 200;\r\n\r\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\r\n{\r\n\tfloat t = epsilon;\r\n    for ( int i=0; i < loopCount; i++ )\r\n    {\r\n        float h = SDF( rayDirection*t+rayStart, true );\r\n        t += h;\r\n        if ( t > far || h < epsilon ) // *t )\r\n            return t;\r\n    }\r\n    \r\n    return t;\r\n}\r\n\r\n\r\nvec3 Normal( vec3 pos )\r\n{\r\n    vec2 d = vec2(-1,1) * .000004;\r\n    return\r\n        normalize(\r\n            SDF( pos + d.xxx, true )*d.xxx +\r\n            SDF( pos + d.xyy, true )*d.xyy +\r\n            SDF( pos + d.yxy, true )*d.yxy +\r\n            SDF( pos + d.yyx, true )*d.yyx\r\n        );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\r\n{\r\n    vec2 camAngle = vec2(.5-.03*(iTime/8.-sin(iTime/8.))*8.,.15-cos(iTime/8.)*.08);\r\n\tif ( iMouse.z > 0. ) camAngle = pow(iMouse.xy/iResolution.xy,vec2(1.,.5))*vec2(6,-1.57) + vec2(0,1.57);\r\n    vec3 camPos = 1.*vec3(cos(camAngle.y)*sin(camAngle.x),sin(camAngle.y),cos(camAngle.y)*cos(camAngle.x));\r\n    vec3 camLook = vec3(0,.10,0)+camPos*vec3(1,0,1)*.3;\r\n    float camZoom = 2.;\r\n    \r\n    vec3 camK = normalize(camLook-camPos);\r\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\r\n    vec3 camJ = cross(camK,camI);\r\n\r\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,camZoom);\r\n    ray = normalize(ray);\r\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\r\n    \r\n    float t = Trace( camPos, ray, 1e20 );\r\n    \r\n    float far = 20.;\r\n    if ( t < far )\r\n    {\r\n        vec3 pos = camPos+ray*t;\r\n\r\n        float sdf = SDF(pos,true);\r\n        float sdfnograss = SDF(pos,false);\r\n\r\n        vec3 flowerColour = sin(pos/.03)*.1+.9;\r\n        vec3 grassColour = mix( vec3(.2,.6,.01), vec3(.5,.7,.2), .5+.5*sin(pos.yxz/.025+2.5) );\r\n\r\n        vec3 albedo = mix( grassColour, mix( vec3(.03,.0,.0), flowerColour, smoothstep(.0,.05,pos.y)), step(sdfnograss,sdf) );\r\n\r\n        vec3 n = Normal( camPos+ray*t );\r\n        vec3 ambient = mix( vec3(.06,.1,.02), vec3(.15,.2,.25), n.y*.5+.5 );\r\n        float nl = dot(n,normalize(vec3(1,3,2)));\r\n\r\n        fragColour.rgb = ambient;\r\n        fragColour.rgb += vec3(.9)*max(0.,nl); // direct light\r\n        fragColour.rgb += vec3(.3)*pow(albedo*.99,vec3(4))*smoothstep(-1.,.1,nl); // subsurface light\r\n        fragColour.rgb *= smoothstep(.0,.18,pos.y); // fake combined shadows & AO\r\n        fragColour.rgb *= albedo;\r\n    }\r\n    else\r\n    {\r\n        fragColour.rgb = vec3(1);\r\n        t = far; // so it gets fog applied\r\n    }\r\n    \r\n    fragColour.rgb = mix( vec3(.7,.8,1), fragColour.rgb, exp2(-t/5.)*1.08 );\r\n \r\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\r\n    fragColour.a = 1.;\r\n\r\n//float f = BladeOfGrass( vec3(.8,0,0), vec3(.9,.5,0), vec3(fragCoord/iResolution.y,0) );\r\n//float f = SDF(vec3(fragCoord/1000.,.1+.1*sin(iTime)).xzy,true);\r\n//fragColour.rgb = vec3( .5+.5*f/(abs(f)+.001) );\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Worley Cellular Noise 2D","id":"tt3GRj","date":"1577105511","viewed":35,"name":"Worley Cellular Noise 2D","description":"Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["2d","noise","worley","cellular"]},"ver":"0.1","info":{"Name":"Worley Cellular Noise 2D","id":"tt3GRj","date":"1577105511","viewed":35,"name":"Worley Cellular Noise 2D","description":"Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["2d","noise","worley","cellular"]},"renderpass":[{"Code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Worley Cellular Noise 3D","id":"3ldGRl","date":"1577259203","viewed":50,"name":"Worley Cellular Noise 3D","description":"3d Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["3d","noise","worley","cellular"]},"ver":"0.1","info":{"Name":"Worley Cellular Noise 3D","id":"3ldGRl","date":"1577259203","viewed":50,"name":"Worley Cellular Noise 3D","description":"3d Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["3d","noise","worley","cellular"]},"renderpass":[{"Code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// --- Workey noise ---    Fabrice Neyret, July 2013\r\n\r\n#define TYPE -1    // shader tunings: 1,11,12,  2,21,22,  3,31,32,33,34, 4,41\r\n                   //                 -1 = autodemo\r\n\r\n#define MODULATE 1\r\n#define ANIM true\r\nfloat time;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\n// gives a random 1..N integer for index i\r\n//#define rnd(i,N) int(1.+float(N)*hash(float(i)))\r\nint rnd(float i,int N) { return int(1.+float(N)*hash(i)); }\r\n\r\n// gives a random 1..N integer every T seconds, starting at i.\r\n//#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(iTime/(T))))\r\nint rndT(float i,int N,float T) { return int(1.+float(N)*hash(i+floor(iTime/(T)))); }\r\n\r\nvec2 noise2_2( vec2 p )     // 2 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_2( vec2 p )     // 3 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    float fz = noise(pos+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec2 noise2_3( vec3 p )     // 2 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_3( vec3 p )     // 3 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\n\r\nvec2 fbm2( vec2 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(vec3(p,.5));\r\n    float fy = fbm(vec3(p,.5)+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec2 perturb2(vec2 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm2(p/scaleX); // usually, to be added to p\r\n}\r\n\r\n// --- Worley -------------------------------------------------\r\n\r\n#define id(i,j,k)   (float(128+i)+256.*float(128+j)+65536.*float(k))  \r\n#define id2cell(id) vec3(mod(id,256.)-128.,mod(floor(id/256.),256.)-128.,id/65536.)\r\n\r\n// d2 and id are vectors or 4 sorted distances + corresponding cell id\r\n// id is relative to current position (add floor(p) to get absolute cell id).\r\nvoid sort(float tmp_d2, int i, int j, int k, inout vec4 d2, inout vec4 id)\r\n{\r\n\tif (tmp_d2 < d2.x)\r\n\t{                                         // nearest point\r\n\t\td2.yzw = d2.xyz; d2.x = tmp_d2;\r\n\t\tid.yzw = id.xyz; id.x = id(i,j,k);\r\n\t}\r\n\telse if (tmp_d2 < d2.y)\r\n\t{                                         // 2nd nearest point\r\n\t\td2.zw = d2.yz; d2.y = tmp_d2;\r\n\t\tid.zw = id.yz; id.y = id(i,j,k);\r\n\t}\t\r\n\telse if (tmp_d2 < d2.z)\r\n\t{                                         // 3rd nearest point\r\n\t\td2.w = d2.z; d2.z = tmp_d2;\r\n\t\tid.w = id.z; id.z = id(i,j,k);\r\n\t}\r\n\telse \r\n\t{                                         // 4th nearest point\r\n\t\td2.w = tmp_d2;\r\n\t\tid.w = id(i,j,k);\r\n\t}\r\n}\r\n\r\nvec4 worley2( in vec2 p, out vec4 id ) // 2D procedural texture\r\n{\r\n\tvec2 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int j=-2; j<=2; j++)          // browse points in neighborhood cells\r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec2 tmp_p   = ip+vec2(float(i),float(j)); // one cell\r\n\t\t\tvec2 tmp_pos = tmp_p+noise2_2(tmp_p)-p;    // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);       // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,0, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec4 worley3( in vec3 p, out vec4 id ) // 3D procedural texture\r\n{\r\n\tvec3 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int k=-2; k<=2; k++)          // browse points in neighborhood cells\r\n\t  for (int j=-2; j<=2; j++)       \r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec3 tmp_p   = ip+vec3(float(i),float(j),float(k));  // one cell\r\n\t\t\tvec3 tmp_pos = tmp_p+noise3_3(tmp_p)-p;   // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);      // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,k, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y+65536.*ip.z); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec3 cellId2Color(float id)\r\n{\r\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\ttime = iTime;\r\n    vec2 uv  = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy / iResolution.y;\r\n\tuv  = (uv  - mouse)/(1.+mouse.y);\r\n\tvec3 col;\r\n\tfloat c;\r\n\r\n\t\r\n#if TYPE == -1 // demo mode \r\n\tfloat duv = -.3*sin(4.*uv.y+uv.x+time) - .1*sin(10.*uv.y+6.*uv.x+10.*time);\r\n\tfloat k = floor(.7*(uv.x+duv)+time/5.); \r\n    int demo = rnd(k,13);\r\n#else\r\n\tconst int demo=0;\r\n#endif\r\n\t\r\n#if MODULATE\r\n\ttime = 1.*(2.*time + .5*sin(1.*time+10.*length(uv)));\r\n#endif\r\n\t\r\n\tvec4 id; vec4 D = worley2(10.*uv, id);\r\n\r\n    if((TYPE == 1)||(demo==1))\r\n\t{\r\n\t\tcol = vec3(D.x);\r\n\t}\r\n    else if ((TYPE == 11)||(demo==2))\r\n\t{\r\n\t\tc = D.x + .5*worley2(20.*uv, id).x + .25*worley2(40.*uv, id).x;\r\n\t\tc = 1.-c;\r\n\t\tcol = vec3(c);\r\n\t}\r\n\telse if ((TYPE == 12)||(demo==3))\r\n\t{\r\n\t\tcol = vec3(D.x, worley2(20.*uv, id).x, worley2(40.*uv, id).x);\r\n\t}\r\n\t\r\n\t\r\n\telse if ((TYPE == 2)||(demo==4))\r\n\t{\r\n\t\tcol = vec3(D.y-D.x);\r\n\t}\r\n\telse if ((TYPE == 21)||(demo==5))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = .75*vec3(c);\r\n\t}\r\n\telse if ((TYPE == 22)||(demo==6))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c -= (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = vec3(c);\r\n\t}\r\n\t\r\n\tif ((TYPE == 3)||(demo==7))\r\n\t{\r\n\t\tc =.7*D.y-D.x; \r\n\t\tcol = (c<0.)? -c*vec3(2.,.5,0.) : 2.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 31)||(demo==8))\r\n\t{\r\n\t\t//c = (.7*D.y-D.x); \r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 32)||(demo==9))\r\n\t{\r\n\t\tc=pow(D.x,.5)*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : 9.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 33)||(demo==10))\t\r\n\t{\r\n\t\tc=.7*D.y-D.x; \r\n\t\tD = worley2(40.*uv, id); c -= .5*D.x;\r\n\t\tcol = (c<0.)? vec3(0.) : 4.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 34)||(demo==11))\r\n\t{\r\n\t\tfloat id0=id.x;\r\n\t\tc= (.7*D.y-D.x); \r\n\t\tD = worley2(60.*uv, id); c -= .2*D.x;\r\n\t\tc = mix(-.1,1.,c);\r\n\t\tcol = (c<0.)? -c*vec3(1.,.5,0.) : 3.*(1.-sqrt(c))*cellId2Color(id0);\r\n\t}\r\n\t\r\n\telse if ((TYPE == 4)||(demo==12))\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc = pow(D.y-D.x,.1);\r\n\t\t// c += pow(1.-D.x,5.);\r\n\t\tcol = c*texture(iChannel1,uv).rgb;\r\n\t}\r\n\telse if ((TYPE == 41)||(demo==13))\t\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x)*2.*texture(iChannel1,uv).rgb;\r\n\t}\r\n\t\t\t   \r\n    fragColor = vec4(col, 0.); \r\n}","inputs":[],"outputs":[],"code":"// --- Workey noise ---    Fabrice Neyret, July 2013\r\n\r\n#define TYPE -1    // shader tunings: 1,11,12,  2,21,22,  3,31,32,33,34, 4,41\r\n                   //                 -1 = autodemo\r\n\r\n#define MODULATE 1\r\n#define ANIM true\r\nfloat time;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\n// gives a random 1..N integer for index i\r\n//#define rnd(i,N) int(1.+float(N)*hash(float(i)))\r\nint rnd(float i,int N) { return int(1.+float(N)*hash(i)); }\r\n\r\n// gives a random 1..N integer every T seconds, starting at i.\r\n//#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(iTime/(T))))\r\nint rndT(float i,int N,float T) { return int(1.+float(N)*hash(i+floor(iTime/(T)))); }\r\n\r\nvec2 noise2_2( vec2 p )     // 2 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_2( vec2 p )     // 3 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    float fz = noise(pos+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec2 noise2_3( vec3 p )     // 2 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_3( vec3 p )     // 3 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\n\r\nvec2 fbm2( vec2 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(vec3(p,.5));\r\n    float fy = fbm(vec3(p,.5)+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec2 perturb2(vec2 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm2(p/scaleX); // usually, to be added to p\r\n}\r\n\r\n// --- Worley -------------------------------------------------\r\n\r\n#define id(i,j,k)   (float(128+i)+256.*float(128+j)+65536.*float(k))  \r\n#define id2cell(id) vec3(mod(id,256.)-128.,mod(floor(id/256.),256.)-128.,id/65536.)\r\n\r\n// d2 and id are vectors or 4 sorted distances + corresponding cell id\r\n// id is relative to current position (add floor(p) to get absolute cell id).\r\nvoid sort(float tmp_d2, int i, int j, int k, inout vec4 d2, inout vec4 id)\r\n{\r\n\tif (tmp_d2 < d2.x)\r\n\t{                                         // nearest point\r\n\t\td2.yzw = d2.xyz; d2.x = tmp_d2;\r\n\t\tid.yzw = id.xyz; id.x = id(i,j,k);\r\n\t}\r\n\telse if (tmp_d2 < d2.y)\r\n\t{                                         // 2nd nearest point\r\n\t\td2.zw = d2.yz; d2.y = tmp_d2;\r\n\t\tid.zw = id.yz; id.y = id(i,j,k);\r\n\t}\t\r\n\telse if (tmp_d2 < d2.z)\r\n\t{                                         // 3rd nearest point\r\n\t\td2.w = d2.z; d2.z = tmp_d2;\r\n\t\tid.w = id.z; id.z = id(i,j,k);\r\n\t}\r\n\telse \r\n\t{                                         // 4th nearest point\r\n\t\td2.w = tmp_d2;\r\n\t\tid.w = id(i,j,k);\r\n\t}\r\n}\r\n\r\nvec4 worley2( in vec2 p, out vec4 id ) // 2D procedural texture\r\n{\r\n\tvec2 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int j=-2; j<=2; j++)          // browse points in neighborhood cells\r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec2 tmp_p   = ip+vec2(float(i),float(j)); // one cell\r\n\t\t\tvec2 tmp_pos = tmp_p+noise2_2(tmp_p)-p;    // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);       // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,0, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec4 worley3( in vec3 p, out vec4 id ) // 3D procedural texture\r\n{\r\n\tvec3 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int k=-2; k<=2; k++)          // browse points in neighborhood cells\r\n\t  for (int j=-2; j<=2; j++)       \r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec3 tmp_p   = ip+vec3(float(i),float(j),float(k));  // one cell\r\n\t\t\tvec3 tmp_pos = tmp_p+noise3_3(tmp_p)-p;   // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);      // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,k, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y+65536.*ip.z); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec3 cellId2Color(float id)\r\n{\r\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\ttime = iTime;\r\n    vec2 uv  = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy / iResolution.y;\r\n\tuv  = (uv  - mouse)/(1.+mouse.y);\r\n\tvec3 col;\r\n\tfloat c;\r\n\r\n\t\r\n#if TYPE == -1 // demo mode \r\n\tfloat duv = -.3*sin(4.*uv.y+uv.x+time) - .1*sin(10.*uv.y+6.*uv.x+10.*time);\r\n\tfloat k = floor(.7*(uv.x+duv)+time/5.); \r\n    int demo = rnd(k,13);\r\n#else\r\n\tconst int demo=0;\r\n#endif\r\n\t\r\n#if MODULATE\r\n\ttime = 1.*(2.*time + .5*sin(1.*time+10.*length(uv)));\r\n#endif\r\n\t\r\n\tvec4 id; vec4 D = worley2(10.*uv, id);\r\n\r\n    if((TYPE == 1)||(demo==1))\r\n\t{\r\n\t\tcol = vec3(D.x);\r\n\t}\r\n    else if ((TYPE == 11)||(demo==2))\r\n\t{\r\n\t\tc = D.x + .5*worley2(20.*uv, id).x + .25*worley2(40.*uv, id).x;\r\n\t\tc = 1.-c;\r\n\t\tcol = vec3(c);\r\n\t}\r\n\telse if ((TYPE == 12)||(demo==3))\r\n\t{\r\n\t\tcol = vec3(D.x, worley2(20.*uv, id).x, worley2(40.*uv, id).x);\r\n\t}\r\n\t\r\n\t\r\n\telse if ((TYPE == 2)||(demo==4))\r\n\t{\r\n\t\tcol = vec3(D.y-D.x);\r\n\t}\r\n\telse if ((TYPE == 21)||(demo==5))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = .75*vec3(c);\r\n\t}\r\n\telse if ((TYPE == 22)||(demo==6))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c -= (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = vec3(c);\r\n\t}\r\n\t\r\n\tif ((TYPE == 3)||(demo==7))\r\n\t{\r\n\t\tc =.7*D.y-D.x; \r\n\t\tcol = (c<0.)? -c*vec3(2.,.5,0.) : 2.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 31)||(demo==8))\r\n\t{\r\n\t\t//c = (.7*D.y-D.x); \r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 32)||(demo==9))\r\n\t{\r\n\t\tc=pow(D.x,.5)*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : 9.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 33)||(demo==10))\t\r\n\t{\r\n\t\tc=.7*D.y-D.x; \r\n\t\tD = worley2(40.*uv, id); c -= .5*D.x;\r\n\t\tcol = (c<0.)? vec3(0.) : 4.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 34)||(demo==11))\r\n\t{\r\n\t\tfloat id0=id.x;\r\n\t\tc= (.7*D.y-D.x); \r\n\t\tD = worley2(60.*uv, id); c -= .2*D.x;\r\n\t\tc = mix(-.1,1.,c);\r\n\t\tcol = (c<0.)? -c*vec3(1.,.5,0.) : 3.*(1.-sqrt(c))*cellId2Color(id0);\r\n\t}\r\n\t\r\n\telse if ((TYPE == 4)||(demo==12))\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc = pow(D.y-D.x,.1);\r\n\t\t// c += pow(1.-D.x,5.);\r\n\t\tcol = c*texture(iChannel1,uv).rgb;\r\n\t}\r\n\telse if ((TYPE == 41)||(demo==13))\t\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x)*2.*texture(iChannel1,uv).rgb;\r\n\t}\r\n\t\t\t   \r\n    fragColor = vec4(col, 0.); \r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Worley noise","id":"5d2ddb3072ba4fb3921f121fc70dc814","date":null,"viewed":0,"name":"Worley noise","description":"Worley cellular noise (same spirit than Perlin noise, but discontinuities-oriented).\nThe #define TYPE on line 3 set the tuning choice. -1 (auto-demo) explore them randomly.\nhttps://www.shadertoy.com/view/ldX3R2","likes":0,"published":null,"tags":["procedural"," noise"," worley"," cellular"]},"ver":null,"info":{"Name":"Worley noise","id":"5d2ddb3072ba4fb3921f121fc70dc814","date":null,"viewed":0,"name":"Worley noise","description":"Worley cellular noise (same spirit than Perlin noise, but discontinuities-oriented).\nThe #define TYPE on line 3 set the tuning choice. -1 (auto-demo) explore them randomly.\nhttps://www.shadertoy.com/view/ldX3R2","likes":0,"published":null,"tags":["procedural"," noise"," worley"," cellular"]},"renderpass":[{"Code":"// --- Workey noise ---    Fabrice Neyret, July 2013\r\n\r\n#define TYPE -1    // shader tunings: 1,11,12,  2,21,22,  3,31,32,33,34, 4,41\r\n                   //                 -1 = autodemo\r\n\r\n#define MODULATE 1\r\n#define ANIM true\r\nfloat time;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\n// gives a random 1..N integer for index i\r\n//#define rnd(i,N) int(1.+float(N)*hash(float(i)))\r\nint rnd(float i,int N) { return int(1.+float(N)*hash(i)); }\r\n\r\n// gives a random 1..N integer every T seconds, starting at i.\r\n//#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(iTime/(T))))\r\nint rndT(float i,int N,float T) { return int(1.+float(N)*hash(i+floor(iTime/(T)))); }\r\n\r\nvec2 noise2_2( vec2 p )     // 2 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_2( vec2 p )     // 3 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    float fz = noise(pos+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec2 noise2_3( vec3 p )     // 2 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_3( vec3 p )     // 3 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\n\r\nvec2 fbm2( vec2 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(vec3(p,.5));\r\n    float fy = fbm(vec3(p,.5)+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec2 perturb2(vec2 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm2(p/scaleX); // usually, to be added to p\r\n}\r\n\r\n// --- Worley -------------------------------------------------\r\n\r\n#define id(i,j,k)   (float(128+i)+256.*float(128+j)+65536.*float(k))  \r\n#define id2cell(id) vec3(mod(id,256.)-128.,mod(floor(id/256.),256.)-128.,id/65536.)\r\n\r\n// d2 and id are vectors or 4 sorted distances + corresponding cell id\r\n// id is relative to current position (add floor(p) to get absolute cell id).\r\nvoid sort(float tmp_d2, int i, int j, int k, inout vec4 d2, inout vec4 id)\r\n{\r\n\tif (tmp_d2 < d2.x)\r\n\t{                                         // nearest point\r\n\t\td2.yzw = d2.xyz; d2.x = tmp_d2;\r\n\t\tid.yzw = id.xyz; id.x = id(i,j,k);\r\n\t}\r\n\telse if (tmp_d2 < d2.y)\r\n\t{                                         // 2nd nearest point\r\n\t\td2.zw = d2.yz; d2.y = tmp_d2;\r\n\t\tid.zw = id.yz; id.y = id(i,j,k);\r\n\t}\t\r\n\telse if (tmp_d2 < d2.z)\r\n\t{                                         // 3rd nearest point\r\n\t\td2.w = d2.z; d2.z = tmp_d2;\r\n\t\tid.w = id.z; id.z = id(i,j,k);\r\n\t}\r\n\telse \r\n\t{                                         // 4th nearest point\r\n\t\td2.w = tmp_d2;\r\n\t\tid.w = id(i,j,k);\r\n\t}\r\n}\r\n\r\nvec4 worley2( in vec2 p, out vec4 id ) // 2D procedural texture\r\n{\r\n\tvec2 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int j=-2; j<=2; j++)          // browse points in neighborhood cells\r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec2 tmp_p   = ip+vec2(float(i),float(j)); // one cell\r\n\t\t\tvec2 tmp_pos = tmp_p+noise2_2(tmp_p)-p;    // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);       // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,0, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec4 worley3( in vec3 p, out vec4 id ) // 3D procedural texture\r\n{\r\n\tvec3 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int k=-2; k<=2; k++)          // browse points in neighborhood cells\r\n\t  for (int j=-2; j<=2; j++)       \r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec3 tmp_p   = ip+vec3(float(i),float(j),float(k));  // one cell\r\n\t\t\tvec3 tmp_pos = tmp_p+noise3_3(tmp_p)-p;   // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);      // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,k, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y+65536.*ip.z); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec3 cellId2Color(float id)\r\n{\r\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\ttime = iTime;\r\n    vec2 uv  = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy / iResolution.y;\r\n\tuv  = (uv  - mouse)/(1.+mouse.y);\r\n\tvec3 col;\r\n\tfloat c;\r\n\r\n\t\r\n#if TYPE == -1 // demo mode \r\n\tfloat duv = -.3*sin(4.*uv.y+uv.x+time) - .1*sin(10.*uv.y+6.*uv.x+10.*time);\r\n\tfloat k = floor(.7*(uv.x+duv)+time/5.); \r\n    int demo = rnd(k,13);\r\n#else\r\n\tconst int demo=0;\r\n#endif\r\n\t\r\n#if MODULATE\r\n\ttime = 1.*(2.*time + .5*sin(1.*time+10.*length(uv)));\r\n#endif\r\n\t\r\n\tvec4 id; vec4 D = worley2(10.*uv, id);\r\n\r\n    if((TYPE == 1)||(demo==1))\r\n\t{\r\n\t\tcol = vec3(D.x);\r\n\t}\r\n    else if ((TYPE == 11)||(demo==2))\r\n\t{\r\n\t\tc = D.x + .5*worley2(20.*uv, id).x + .25*worley2(40.*uv, id).x;\r\n\t\tc = 1.-c;\r\n\t\tcol = vec3(c);\r\n\t}\r\n\telse if ((TYPE == 12)||(demo==3))\r\n\t{\r\n\t\tcol = vec3(D.x, worley2(20.*uv, id).x, worley2(40.*uv, id).x);\r\n\t}\r\n\t\r\n\t\r\n\telse if ((TYPE == 2)||(demo==4))\r\n\t{\r\n\t\tcol = vec3(D.y-D.x);\r\n\t}\r\n\telse if ((TYPE == 21)||(demo==5))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = .75*vec3(c);\r\n\t}\r\n\telse if ((TYPE == 22)||(demo==6))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c -= (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = vec3(c);\r\n\t}\r\n\t\r\n\tif ((TYPE == 3)||(demo==7))\r\n\t{\r\n\t\tc =.7*D.y-D.x; \r\n\t\tcol = (c<0.)? -c*vec3(2.,.5,0.) : 2.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 31)||(demo==8))\r\n\t{\r\n\t\t//c = (.7*D.y-D.x); \r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 32)||(demo==9))\r\n\t{\r\n\t\tc=pow(D.x,.5)*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : 9.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 33)||(demo==10))\t\r\n\t{\r\n\t\tc=.7*D.y-D.x; \r\n\t\tD = worley2(40.*uv, id); c -= .5*D.x;\r\n\t\tcol = (c<0.)? vec3(0.) : 4.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 34)||(demo==11))\r\n\t{\r\n\t\tfloat id0=id.x;\r\n\t\tc= (.7*D.y-D.x); \r\n\t\tD = worley2(60.*uv, id); c -= .2*D.x;\r\n\t\tc = mix(-.1,1.,c);\r\n\t\tcol = (c<0.)? -c*vec3(1.,.5,0.) : 3.*(1.-sqrt(c))*cellId2Color(id0);\r\n\t}\r\n\t\r\n\telse if ((TYPE == 4)||(demo==12))\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc = pow(D.y-D.x,.1);\r\n\t\t// c += pow(1.-D.x,5.);\r\n\t\tcol = c*texture(iChannel1,uv).rgb;\r\n\t}\r\n\telse if ((TYPE == 41)||(demo==13))\t\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x)*2.*texture(iChannel1,uv).rgb;\r\n\t}\r\n\t\t\t   \r\n    fragColor = vec4(col, 0.); \r\n}","inputs":[],"outputs":[],"code":"// --- Workey noise ---    Fabrice Neyret, July 2013\r\n\r\n#define TYPE -1    // shader tunings: 1,11,12,  2,21,22,  3,31,32,33,34, 4,41\r\n                   //                 -1 = autodemo\r\n\r\n#define MODULATE 1\r\n#define ANIM true\r\nfloat time;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\n// gives a random 1..N integer for index i\r\n//#define rnd(i,N) int(1.+float(N)*hash(float(i)))\r\nint rnd(float i,int N) { return int(1.+float(N)*hash(i)); }\r\n\r\n// gives a random 1..N integer every T seconds, starting at i.\r\n//#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(iTime/(T))))\r\nint rndT(float i,int N,float T) { return int(1.+float(N)*hash(i+floor(iTime/(T)))); }\r\n\r\nvec2 noise2_2( vec2 p )     // 2 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_2( vec2 p )     // 3 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    float fz = noise(pos+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec2 noise2_3( vec3 p )     // 2 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_3( vec3 p )     // 3 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\n\r\nvec2 fbm2( vec2 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(vec3(p,.5));\r\n    float fy = fbm(vec3(p,.5)+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec2 perturb2(vec2 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm2(p/scaleX); // usually, to be added to p\r\n}\r\n\r\n// --- Worley -------------------------------------------------\r\n\r\n#define id(i,j,k)   (float(128+i)+256.*float(128+j)+65536.*float(k))  \r\n#define id2cell(id) vec3(mod(id,256.)-128.,mod(floor(id/256.),256.)-128.,id/65536.)\r\n\r\n// d2 and id are vectors or 4 sorted distances + corresponding cell id\r\n// id is relative to current position (add floor(p) to get absolute cell id).\r\nvoid sort(float tmp_d2, int i, int j, int k, inout vec4 d2, inout vec4 id)\r\n{\r\n\tif (tmp_d2 < d2.x)\r\n\t{                                         // nearest point\r\n\t\td2.yzw = d2.xyz; d2.x = tmp_d2;\r\n\t\tid.yzw = id.xyz; id.x = id(i,j,k);\r\n\t}\r\n\telse if (tmp_d2 < d2.y)\r\n\t{                                         // 2nd nearest point\r\n\t\td2.zw = d2.yz; d2.y = tmp_d2;\r\n\t\tid.zw = id.yz; id.y = id(i,j,k);\r\n\t}\t\r\n\telse if (tmp_d2 < d2.z)\r\n\t{                                         // 3rd nearest point\r\n\t\td2.w = d2.z; d2.z = tmp_d2;\r\n\t\tid.w = id.z; id.z = id(i,j,k);\r\n\t}\r\n\telse \r\n\t{                                         // 4th nearest point\r\n\t\td2.w = tmp_d2;\r\n\t\tid.w = id(i,j,k);\r\n\t}\r\n}\r\n\r\nvec4 worley2( in vec2 p, out vec4 id ) // 2D procedural texture\r\n{\r\n\tvec2 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int j=-2; j<=2; j++)          // browse points in neighborhood cells\r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec2 tmp_p   = ip+vec2(float(i),float(j)); // one cell\r\n\t\t\tvec2 tmp_pos = tmp_p+noise2_2(tmp_p)-p;    // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);       // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,0, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec4 worley3( in vec3 p, out vec4 id ) // 3D procedural texture\r\n{\r\n\tvec3 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int k=-2; k<=2; k++)          // browse points in neighborhood cells\r\n\t  for (int j=-2; j<=2; j++)       \r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec3 tmp_p   = ip+vec3(float(i),float(j),float(k));  // one cell\r\n\t\t\tvec3 tmp_pos = tmp_p+noise3_3(tmp_p)-p;   // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);      // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,k, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y+65536.*ip.z); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec3 cellId2Color(float id)\r\n{\r\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\ttime = iTime;\r\n    vec2 uv  = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy / iResolution.y;\r\n\tuv  = (uv  - mouse)/(1.+mouse.y);\r\n\tvec3 col;\r\n\tfloat c;\r\n\r\n\t\r\n#if TYPE == -1 // demo mode \r\n\tfloat duv = -.3*sin(4.*uv.y+uv.x+time) - .1*sin(10.*uv.y+6.*uv.x+10.*time);\r\n\tfloat k = floor(.7*(uv.x+duv)+time/5.); \r\n    int demo = rnd(k,13);\r\n#else\r\n\tconst int demo=0;\r\n#endif\r\n\t\r\n#if MODULATE\r\n\ttime = 1.*(2.*time + .5*sin(1.*time+10.*length(uv)));\r\n#endif\r\n\t\r\n\tvec4 id; vec4 D = worley2(10.*uv, id);\r\n\r\n    if((TYPE == 1)||(demo==1))\r\n\t{\r\n\t\tcol = vec3(D.x);\r\n\t}\r\n    else if ((TYPE == 11)||(demo==2))\r\n\t{\r\n\t\tc = D.x + .5*worley2(20.*uv, id).x + .25*worley2(40.*uv, id).x;\r\n\t\tc = 1.-c;\r\n\t\tcol = vec3(c);\r\n\t}\r\n\telse if ((TYPE == 12)||(demo==3))\r\n\t{\r\n\t\tcol = vec3(D.x, worley2(20.*uv, id).x, worley2(40.*uv, id).x);\r\n\t}\r\n\t\r\n\t\r\n\telse if ((TYPE == 2)||(demo==4))\r\n\t{\r\n\t\tcol = vec3(D.y-D.x);\r\n\t}\r\n\telse if ((TYPE == 21)||(demo==5))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = .75*vec3(c);\r\n\t}\r\n\telse if ((TYPE == 22)||(demo==6))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c -= (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = vec3(c);\r\n\t}\r\n\t\r\n\tif ((TYPE == 3)||(demo==7))\r\n\t{\r\n\t\tc =.7*D.y-D.x; \r\n\t\tcol = (c<0.)? -c*vec3(2.,.5,0.) : 2.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 31)||(demo==8))\r\n\t{\r\n\t\t//c = (.7*D.y-D.x); \r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 32)||(demo==9))\r\n\t{\r\n\t\tc=pow(D.x,.5)*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : 9.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 33)||(demo==10))\t\r\n\t{\r\n\t\tc=.7*D.y-D.x; \r\n\t\tD = worley2(40.*uv, id); c -= .5*D.x;\r\n\t\tcol = (c<0.)? vec3(0.) : 4.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 34)||(demo==11))\r\n\t{\r\n\t\tfloat id0=id.x;\r\n\t\tc= (.7*D.y-D.x); \r\n\t\tD = worley2(60.*uv, id); c -= .2*D.x;\r\n\t\tc = mix(-.1,1.,c);\r\n\t\tcol = (c<0.)? -c*vec3(1.,.5,0.) : 3.*(1.-sqrt(c))*cellId2Color(id0);\r\n\t}\r\n\t\r\n\telse if ((TYPE == 4)||(demo==12))\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc = pow(D.y-D.x,.1);\r\n\t\t// c += pow(1.-D.x,5.);\r\n\t\tcol = c*texture(iChannel1,uv).rgb;\r\n\t}\r\n\telse if ((TYPE == 41)||(demo==13))\t\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x)*2.*texture(iChannel1,uv).rgb;\r\n\t}\r\n\t\t\t   \r\n    fragColor = vec4(col, 0.); \r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"float rnd(float x) { return fract(1000.*sin(234.56*x)); }\r\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\r\nfloat hash(float x,float y,float z) { return (x+432.432*y-1178.65*z); }\r\nfloat hash(vec3 v) { return dot(v,vec3(1., 32.432, -1178.65)); }\n\r\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 x)\r\n{\r\n    return vec3(value_noise(x),value_noise(x+1.11),value_noise(x+2.22));\r\n}\r\n\r\nvec4 Worley(vec3 uvw) {\r\n    \r\n   vec3 uvwi = floor(uvw);\t\t\t\t\t\t\t// cell coords\r\n   float dmin = 1e9, d2min=1e9, nmin=-1.;\r\n    \r\n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t// visit neighborhood\r\n      for (int j=-1; j<=1; j++)\t\t\t\t\t\t// to find the closest point\r\n          for (int k=-1; k<=1; k++) \r\n          {\r\n              vec3 c = uvwi + vec3(float(i),float(j),float(k)); // neighbor cells\r\n              float n = hash(c);\t \t\t\t\t\t\t\t// cell ID\r\n              vec3 p = c + rnd3(n+.1);\t\t\t\t\t\t\t// random point in cell\r\n              float d = length(p-uvw);\t\t\t\t\t\t\t// dist to point\r\n              if (d<dmin) { d2min=dmin; dmin=d; nmin=n; }\t\t// 2 closest dists\r\n              else if (d<d2min) { d2min=d; }\r\n          }\r\n\treturn vec4(dmin,d2min,d2min-dmin, nmin);\t\t\t// 2 closest dists + closest ID\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 uvw = vec3(2.*(fragCoord.xy / iResolution.y-vec2(.9,.5)), .2*iTime);\r\n    float a = .2*iTime,c=cos(a),s=sin(a); uvw.xy *= mat2(c,-s,s,c);\t// rotate\r\n    uvw *= 4.*(.7+.5*vec3(vec2(cos(.5*iTime)),0.));\t\t\t\t\t// zoom\r\n\r\n    vec3 uvw0=uvw; \r\n    //uvw += .2*texture(iChannel0,.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    uvw += .2*noise23(.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    vec4 wor = Worley(uvw);         \r\n    vec3 col = mix(vec3(1.), rnd3(wor.a+.4), .4);\r\n    float v = wor.z;\r\n    int mode = int(mod(.25*iTime,4.));\t\t\t\t\t\t\t\t// demo mode\r\n    if      (mode==0) v *= 2.;\r\n    else if (mode==1) v = pow(v,.025);\r\n    else if (mode==2) { v -= .3*sin(30.*uvw0.x)*sin(30.*uvw0.y); v = pow(v,.025); }\r\n    else              { v -= .02; v = pow(v,.025); }\r\n    //v = 1.-pow(1.-v,40.);    \r\n\r\n\tfragColor = vec4(v*col,1.0);\r\n}","inputs":[],"outputs":[],"code":"float rnd(float x) { return fract(1000.*sin(234.56*x)); }\r\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\r\nfloat hash(float x,float y,float z) { return (x+432.432*y-1178.65*z); }\r\nfloat hash(vec3 v) { return dot(v,vec3(1., 32.432, -1178.65)); }\n\r\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 x)\r\n{\r\n    return vec3(value_noise(x),value_noise(x+1.11),value_noise(x+2.22));\r\n}\r\n\r\nvec4 Worley(vec3 uvw) {\r\n    \r\n   vec3 uvwi = floor(uvw);\t\t\t\t\t\t\t// cell coords\r\n   float dmin = 1e9, d2min=1e9, nmin=-1.;\r\n    \r\n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t// visit neighborhood\r\n      for (int j=-1; j<=1; j++)\t\t\t\t\t\t// to find the closest point\r\n          for (int k=-1; k<=1; k++) \r\n          {\r\n              vec3 c = uvwi + vec3(float(i),float(j),float(k)); // neighbor cells\r\n              float n = hash(c);\t \t\t\t\t\t\t\t// cell ID\r\n              vec3 p = c + rnd3(n+.1);\t\t\t\t\t\t\t// random point in cell\r\n              float d = length(p-uvw);\t\t\t\t\t\t\t// dist to point\r\n              if (d<dmin) { d2min=dmin; dmin=d; nmin=n; }\t\t// 2 closest dists\r\n              else if (d<d2min) { d2min=d; }\r\n          }\r\n\treturn vec4(dmin,d2min,d2min-dmin, nmin);\t\t\t// 2 closest dists + closest ID\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 uvw = vec3(2.*(fragCoord.xy / iResolution.y-vec2(.9,.5)), .2*iTime);\r\n    float a = .2*iTime,c=cos(a),s=sin(a); uvw.xy *= mat2(c,-s,s,c);\t// rotate\r\n    uvw *= 4.*(.7+.5*vec3(vec2(cos(.5*iTime)),0.));\t\t\t\t\t// zoom\r\n\r\n    vec3 uvw0=uvw; \r\n    //uvw += .2*texture(iChannel0,.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    uvw += .2*noise23(.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    vec4 wor = Worley(uvw);         \r\n    vec3 col = mix(vec3(1.), rnd3(wor.a+.4), .4);\r\n    float v = wor.z;\r\n    int mode = int(mod(.25*iTime,4.));\t\t\t\t\t\t\t\t// demo mode\r\n    if      (mode==0) v *= 2.;\r\n    else if (mode==1) v = pow(v,.025);\r\n    else if (mode==2) { v -= .3*sin(30.*uvw0.x)*sin(30.*uvw0.y); v = pow(v,.025); }\r\n    else              { v -= .02; v = pow(v,.025); }\r\n    //v = 1.-pow(1.-v,40.);    \r\n\r\n\tfragColor = vec4(v*col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Worley noise 3","id":"aabbd86ccf4c4a2cb7fb81dbb2442788","date":null,"viewed":0,"name":"Worley noise 3","description":"variant from https://www.shadertoy.com/view/Md2SDz\nhttps://www.shadertoy.com/view/XdSSW1","likes":0,"published":null,"tags":["voronoi"," worley"]},"ver":null,"info":{"Name":"Worley noise 3","id":"aabbd86ccf4c4a2cb7fb81dbb2442788","date":null,"viewed":0,"name":"Worley noise 3","description":"variant from https://www.shadertoy.com/view/Md2SDz\nhttps://www.shadertoy.com/view/XdSSW1","likes":0,"published":null,"tags":["voronoi"," worley"]},"renderpass":[{"Code":"float rnd(float x) { return fract(1000.*sin(234.56*x)); }\r\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\r\nfloat hash(float x,float y,float z) { return (x+432.432*y-1178.65*z); }\r\nfloat hash(vec3 v) { return dot(v,vec3(1., 32.432, -1178.65)); }\n\r\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 x)\r\n{\r\n    return vec3(value_noise(x),value_noise(x+1.11),value_noise(x+2.22));\r\n}\r\n\r\nvec4 Worley(vec3 uvw) {\r\n    \r\n   vec3 uvwi = floor(uvw);\t\t\t\t\t\t\t// cell coords\r\n   float dmin = 1e9, d2min=1e9, nmin=-1.;\r\n    \r\n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t// visit neighborhood\r\n      for (int j=-1; j<=1; j++)\t\t\t\t\t\t// to find the closest point\r\n          for (int k=-1; k<=1; k++) \r\n          {\r\n              vec3 c = uvwi + vec3(float(i),float(j),float(k)); // neighbor cells\r\n              float n = hash(c);\t \t\t\t\t\t\t\t// cell ID\r\n              vec3 p = c + rnd3(n+.1);\t\t\t\t\t\t\t// random point in cell\r\n              float d = length(p-uvw);\t\t\t\t\t\t\t// dist to point\r\n              if (d<dmin) { d2min=dmin; dmin=d; nmin=n; }\t\t// 2 closest dists\r\n              else if (d<d2min) { d2min=d; }\r\n          }\r\n\treturn vec4(dmin,d2min,d2min-dmin, nmin);\t\t\t// 2 closest dists + closest ID\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 uvw = vec3(2.*(fragCoord.xy / iResolution.y-vec2(.9,.5)), .2*iTime);\r\n    float a = .2*iTime,c=cos(a),s=sin(a); uvw.xy *= mat2(c,-s,s,c);\t// rotate\r\n    uvw *= 4.*(.7+.5*vec3(vec2(cos(.5*iTime)),0.));\t\t\t\t\t// zoom\r\n\r\n    vec3 uvw0=uvw; \r\n    //uvw += .2*texture(iChannel0,.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    uvw += .2*noise23(.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    vec4 wor = Worley(uvw);         \r\n    vec3 col = mix(vec3(1.), rnd3(wor.a+.4), .4);\r\n    float v = wor.z;\r\n    int mode = int(mod(.25*iTime,4.));\t\t\t\t\t\t\t\t// demo mode\r\n    if      (mode==0) v *= 2.;\r\n    else if (mode==1) v = pow(v,.025);\r\n    else if (mode==2) { v -= .3*sin(30.*uvw0.x)*sin(30.*uvw0.y); v = pow(v,.025); }\r\n    else              { v -= .02; v = pow(v,.025); }\r\n    //v = 1.-pow(1.-v,40.);    \r\n\r\n\tfragColor = vec4(v*col,1.0);\r\n}","inputs":[],"outputs":[],"code":"float rnd(float x) { return fract(1000.*sin(234.56*x)); }\r\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\r\nfloat hash(float x,float y,float z) { return (x+432.432*y-1178.65*z); }\r\nfloat hash(vec3 v) { return dot(v,vec3(1., 32.432, -1178.65)); }\n\r\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 x)\r\n{\r\n    return vec3(value_noise(x),value_noise(x+1.11),value_noise(x+2.22));\r\n}\r\n\r\nvec4 Worley(vec3 uvw) {\r\n    \r\n   vec3 uvwi = floor(uvw);\t\t\t\t\t\t\t// cell coords\r\n   float dmin = 1e9, d2min=1e9, nmin=-1.;\r\n    \r\n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t// visit neighborhood\r\n      for (int j=-1; j<=1; j++)\t\t\t\t\t\t// to find the closest point\r\n          for (int k=-1; k<=1; k++) \r\n          {\r\n              vec3 c = uvwi + vec3(float(i),float(j),float(k)); // neighbor cells\r\n              float n = hash(c);\t \t\t\t\t\t\t\t// cell ID\r\n              vec3 p = c + rnd3(n+.1);\t\t\t\t\t\t\t// random point in cell\r\n              float d = length(p-uvw);\t\t\t\t\t\t\t// dist to point\r\n              if (d<dmin) { d2min=dmin; dmin=d; nmin=n; }\t\t// 2 closest dists\r\n              else if (d<d2min) { d2min=d; }\r\n          }\r\n\treturn vec4(dmin,d2min,d2min-dmin, nmin);\t\t\t// 2 closest dists + closest ID\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 uvw = vec3(2.*(fragCoord.xy / iResolution.y-vec2(.9,.5)), .2*iTime);\r\n    float a = .2*iTime,c=cos(a),s=sin(a); uvw.xy *= mat2(c,-s,s,c);\t// rotate\r\n    uvw *= 4.*(.7+.5*vec3(vec2(cos(.5*iTime)),0.));\t\t\t\t\t// zoom\r\n\r\n    vec3 uvw0=uvw; \r\n    //uvw += .2*texture(iChannel0,.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    uvw += .2*noise23(.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    vec4 wor = Worley(uvw);         \r\n    vec3 col = mix(vec3(1.), rnd3(wor.a+.4), .4);\r\n    float v = wor.z;\r\n    int mode = int(mod(.25*iTime,4.));\t\t\t\t\t\t\t\t// demo mode\r\n    if      (mode==0) v *= 2.;\r\n    else if (mode==1) v = pow(v,.025);\r\n    else if (mode==2) { v -= .3*sin(30.*uvw0.x)*sin(30.*uvw0.y); v = pow(v,.025); }\r\n    else              { v -= .02; v = pow(v,.025); }\r\n    //v = 1.-pow(1.-v,40.);    \r\n\r\n\tfragColor = vec4(v*col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]}]}