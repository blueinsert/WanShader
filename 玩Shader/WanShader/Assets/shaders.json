{"userName":"bluebean","date":"2020-01-09T02:25:12.900Z","numShaders":36,"shaders":[{"Ver":null,"ImageRenderpass":{"Code":"// Interesting findings from original NES Super Mario Bros.:\r\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\r\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\r\n// -Overworld (main theme) drum sound uses only the APU noise generator\r\n\r\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\r\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\r\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\r\n\r\nconst float MARIO_SPEED\t = 89.0;\r\nconst float GOOMBA_SPEED = 32.0;\r\nconst float INTRO_LENGTH = 2.0;\r\n\r\nvoid SpriteBlock( inout vec3 color, float x, float y )\r\n{\r\n    // black\r\n    float idx = 1.0;\r\n    \r\n    // light orange\r\n    idx = x < y ? 3.0 : idx;\r\n    \r\n    // dark orange\r\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\r\n    idx = x == 15.0 - y ? 2.0 : idx;\r\n    \r\n    color = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteHill( inout vec3 color, float x, float y )\r\n{\r\n    float idx = 0.0;\r\n    \r\n    // dark green\r\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\r\n    \r\n    // black\r\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\r\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\r\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\r\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\r\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n}\r\n\r\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\r\n{\r\n    float offset = h * 16.0;\r\n\r\n    // light green\r\n\tfloat idx = 3.0;\r\n    \r\n    // dark green\r\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\r\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \r\n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\r\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \r\n    \r\n    // black\r\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\r\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\r\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \r\n    \r\n    // transparent\r\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\r\n{\r\n\tfloat idx = 0.0;\r\n    \r\n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\r\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\r\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\r\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\r\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\r\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\r\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\r\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\r\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\r\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\r\n\tcolor = idx == 2.0 ? colorB \t\t: color;\r\n\tcolor = idx == 3.0 ? colorC \t\t: color;\r\n}\r\n\r\nvoid SpriteFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? 43690.0 : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\r\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\r\n{\r\n\tfloat idx = 0.0;\r\n\r\n    // second frame is flipped first frame\r\n    x = frame == 1.0 ? 15.0 - x : x;\r\n\r\n    if ( frame <= 1.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\r\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\r\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\r\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\r\n        idx = y ==  6.0 ? 43690.0 : idx;\r\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\r\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\r\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\r\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\r\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\r\n\t\tidx = y == 3.0 ? 43690.0 : idx;\r\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\r\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\r\n}\r\n\r\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\r\n{    \r\n\tfloat idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\r\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\r\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\r\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\r\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\r\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\r\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\r\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\r\n    }\r\n\telse\r\n\t{\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\r\n\t}\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 0.0 ? 21845.0 : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\r\n}\r\n\r\nvoid SpriteMushroom( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\r\n\tidx = y == 5.0 ? 43690.0 : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGround( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\r\n\tidx = y == 7.0 ? 1360.0  : idx;\r\n\tidx = y == 6.0 ? 6836.0  : idx;\r\n\tidx = y == 5.0 ? 27309.0 : idx;\r\n\tidx = y == 4.0 ? 27309.0 : idx;\r\n\tidx = y == 3.0 ? 27305.0 : idx;\r\n\tidx = y == 2.0 ? 27305.0 : idx;\r\n\tidx = y == 1.0 ? 6820.0  : idx;\r\n\tidx = y == 0.0 ? 1360.0  : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 3.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 4.0 )\r\n    {\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\r\n    }\r\n    else if ( frame == 5.0 )\r\n    {\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\r\n    }\r\n    else if ( frame == 6.0 )\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \r\n}\r\n\r\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n    }\r\n    \r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteBrick( inout vec3 color, float x, float y )\r\n{    \r\n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \r\n    float xmod8 = floor( mod( x, 8.0 ) );\r\n    float ymod8 = floor( mod( y, 8.0 ) );\r\n    \r\n    // dark orange\r\n    float idx = 2.0;\r\n   \r\n    // black\r\n    idx = ymod4 == 0.0 ? 1.0 : idx;\r\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\r\n\r\n    // light orange\r\n    idx = y == 15.0 ? 3.0 : idx;\r\n\r\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid DrawCastle( inout vec3 color, float x, float y )\r\n{\r\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\r\n\t{\r\n\t\tfloat ymod4    = mod( y, 4.0 );\r\n\t\tfloat xmod8    = mod( x, 8.0 );\r\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\r\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\r\n\t\tfloat ymod8    = mod( y, 8.0 );\r\n\r\n\t\t// dark orange\r\n\t\tfloat idx = 2.0;\r\n\r\n\t\t// black\r\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\r\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\r\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \r\n\r\n\t\t// white\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\r\n\r\n\t\t// transparent\r\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\r\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\r\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \r\n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\r\n\r\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\r\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n\t}\r\n}\r\n\r\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\r\n{\r\n    if ( x >= 0.0 && x <= 15.0 )\r\n    {\r\n        SpriteKoopa( color, x, y, frame );\r\n    }\r\n}\r\n\r\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\r\n{\r\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\r\n    DrawKoopa( color, x, worldY - 16.0, frame );    \r\n}\r\n\r\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\r\n{\r\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\r\n    t = 1.0 - abs( 2.0 * t - 1.0 );\r\n\r\n    questionY -= floor( t * 8.0 );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {            \r\n    \tif ( time >= questionHitTime )\r\n        {                \r\n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\r\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n            {\r\n                color = RGB( 231, 90, 16 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n         \tSpriteQuestion( color, questionX, questionY, questionT );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawW( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 || x >= 10.0 ) \r\n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawO( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\r\n             || ( x >= 2.0 && x <= 4.0 )\r\n             || ( x >= 9.0 && x <= 11.0 )\r\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawR( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 )\r\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\r\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\r\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\r\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\r\n             || ( x >= 8.0  && y <= 1.0 )\r\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawL( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( x <= 3.0 || y <= 1.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawD( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n    \tcolor = RGB( 255, 255, 255 );        \r\n        \r\n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \r\n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \r\n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\r\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\r\n           )\r\n        {\r\n            color = RGB( 0, 0, 0 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid Draw1( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( y <= 1.0 )\r\n             || ( x >= 5.0 && x <= 8.0 )\r\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawM( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( y >= 4.0 && y <= 7.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\r\n{\r\n    color = RGB( 0, 0, 0 );\r\n        \r\n    float offset \t= 18.0;     \r\n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\r\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\r\n    float marioX\t= textX - offset * 4.0;\r\n    float marioY\t= textY + 16.0 * 3.0;\r\n\t\r\n    DrawW( color, textX - offset * 0.0, textY );\r\n    DrawO( color, textX - offset * 1.0, textY );\r\n    DrawR( color, textX - offset * 2.0, textY );\r\n    DrawL( color, textX - offset * 3.0, textY );\r\n    DrawD( color, textX - offset * 4.0, textY );\r\n    Draw1( color, textX - offset * 6.0, textY );\r\n    DrawM( color, textX - offset * 7.0, textY );\r\n    Draw1( color, textX - offset * 8.0, textY );\r\n    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 )\r\n    {\r\n    \tSpriteMario( color, marioX, marioY, 4.0 );\r\n    }\r\n}\r\n\r\nfloat CoinAnimY( float worldY, float time, float coinTime )\r\n{\r\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\r\n}\r\n\r\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\r\n{\r\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\r\n}\r\n\r\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\r\n{\r\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\r\n}\r\n\r\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\r\n{\r\n    float mushroomPauseStart \t= 16.25;    \r\n    float mushroomPauseLength \t= 2.0;    \r\n    float flagPauseStart\t\t= 38.95;\r\n    float flagPauseLength\t\t= 1.5;\r\n\r\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\r\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\r\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\r\n    float worldX \t\t= pixelX + cameraX;\r\n    float worldY  \t\t= pixelY - 8.0;\r\n    float tileX\t\t\t= floor( worldX / 16.0 );\r\n    float tileY\t\t\t= floor( worldY / 16.0 );\r\n    float tile2X\t\t= floor( worldX / 32.0 );\r\n    float tile2Y\t\t= floor( worldY / 32.0 );    \r\n    float worldXMod16\t= mod( worldX, 16.0 );\r\n    float worldYMod16 \t= mod( worldY, 16.0 );\r\n\r\n\r\n    // default background color\r\n    color = RGB( 92, 148, 252 );\r\n\r\n    \r\n    // draw hills\r\n    float bigHillX \t = mod( worldX, 768.0 );\r\n    float smallHillX = mod( worldX - 240.0, 768.0 );\r\n    float hillX \t = min( bigHillX, smallHillX );\r\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\r\n    SpriteHill( color, hillX, hillY );\r\n\r\n\r\n    // draw clouds and bushes\r\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\r\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\r\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\r\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \r\n    float scCloudX  = min( sc1CloudX, sc2CloudX );\r\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\r\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \r\n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\r\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\r\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\r\n    float sCloudX\t= min( scCloudX, sbCloudX );\r\n    float mCloudX\t= min( mcCloudX, mbCloudX );\r\n    float lCloudX\t= min( lcCloudX, lbCloudX );\r\n    float cloudX\t= min( cCloudX, bCloudX );\r\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\r\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\r\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\r\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\r\n    {\r\n        if ( cloudSeg == 1.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\r\n        }\r\n        if ( cloudSeg == 2.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\r\n        }\r\n        \r\n    \tSpriteCloud( color, cloudX, cloudY, isBush );\r\n    }\r\n\r\n    \r\n    \r\n    // draw flag pole\r\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \r\n    {\r\n        color = RGB( 189, 255, 24 );\r\n    }\r\n    \r\n    // draw flag\r\n    float flagX = worldX - 3160.0;\r\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( flagX >= 0.0 && flagX <= 15.0 )\r\n    {\r\n    \tSpriteFlag( color, flagX, flagY );\r\n    }     \r\n    \r\n    // draw flagpole end\r\n    float flagpoleEndX = worldX - 3172.0;\r\n    float flagpoleEndY = worldY - 176.0;\r\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\r\n    {\r\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\r\n    }\r\n    \r\n    \r\n\r\n    // draw blocks\r\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\r\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\r\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\r\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \r\n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\r\n         || ( tileX == 198.0 && tileY == 1.0 )\r\n       )\r\n    {\r\n        SpriteBlock( color, worldXMod16, worldYMod16 );\r\n    }\r\n    \r\n    \r\n    // draw pipes\r\n    float pipeY = worldY - 16.0;  \r\n    float pipeH\t= 0.0;    \r\n    float pipeX = worldX - 179.0 * 16.0;\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 163.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 57.0 * 16.0;\r\n        pipeH = 2.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 46.0 * 16.0;\r\n        pipeH = 2.0;\r\n    } \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 38.0 * 16.0;\r\n        pipeH = 1.0;\r\n    }         \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 28.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\r\n\t{\r\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\r\n\t}\r\n    \r\n    \r\n    // draw mushroom\r\n    float mushroomStart = 15.7;    \r\n    if ( time >= mushroomStart && time <= 17.0 )\r\n    {\r\n        float jumpTime = 0.5;\r\n        \r\n        float mushroomX = worldX - 1248.0;\r\n        float mushroomY = worldY - 4.0 * 16.0;\r\n        if ( time >= mushroomStart )\r\n        {\r\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 )\r\n        {\r\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 + 0.4 )\r\n        {\r\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\r\n        }\r\n        \r\n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\r\n        {\r\n        \tSpriteMushroom( color, mushroomX, mushroomY );\r\n        }\r\n    }\r\n\r\n    \r\n    // draw coins\r\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\r\n    float coinX \t= worldX - 2720.0;\r\n    float coinTime \t= 33.9;    \r\n    float coinY \t= CoinAnimY( worldY, time, coinTime );\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 1696.0;\r\n    \tcoinTime \t= 22.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \r\n    }\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 352.0;\r\n    \tcoinTime \t= 5.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\r\n    } \r\n    \r\n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\r\n    {   \r\n        SpriteCoin( color, coinX, coinY, coinFrame );\r\n    }\r\n\r\n    \r\n    // draw questions\r\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \r\n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\r\n    }\r\n    \r\n    \r\n    // draw hitted questions\r\n    float questionHitTime \t= 33.9;\r\n    float questionX \t\t= worldX - 2720.0;\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 22.4;\r\n        questionX\t\t= worldX - 1696.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 15.4;\r\n        questionX\t\t= worldX - 1248.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 5.3;\r\n        questionX\t\t= worldX - 352.0;\r\n    }    \r\n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \r\n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {\r\n    \tSpriteQuestion( color, questionX, questionY, questionT );\r\n    }\r\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n    {\r\n        color = RGB( 231, 90, 16 );\r\n    }    \r\n\r\n    \r\n    // draw bricks\r\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteBrick( color, worldXMod16, worldYMod16 );\r\n    }   \r\n    \r\n    \r\n    // draw castle flag\r\n    float castleFlagX = worldX - 3264.0;\r\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\r\n    {\r\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\r\n\t}\r\n    \r\n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\r\n\r\n    // draw ground\r\n    if ( tileY <= 0.0\r\n         && !( tileX >= 69.0  && tileX < 71.0 )\r\n         && !( tileX >= 86.0  && tileX < 89.0 ) \r\n         && !( tileX >= 153.0 && tileX < 155.0 ) \r\n       )\r\n    {\r\n        SpriteGround( color, worldXMod16, worldYMod16 );\r\n    }    \r\n    \r\n\r\n    // draw Koopa\r\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\r\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\r\n    \r\n    \r\n    // draw stomped walking Goombas\r\n    float goombaY \t\t\t= worldY - 16.0;        \r\n    float goombaLifeTime \t= 26.3;\r\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 25.3;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n\t\tgoombaLifeTime \t= 23.5;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n        goombaLifeTime \t= 20.29;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 10.3;\r\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    }\r\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }    \r\n    \r\n    // draw walking Goombas\r\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\r\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\r\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }\r\n    \r\n\r\n    \r\n    // Mario jump\r\n    float marioBigJump1 \t= 27.1;\r\n    float marioBigJump2 \t= 29.75;\r\n    float marioBigJump3 \t= 35.05;    \r\n    float marioJumpTime \t= 0.0;\r\n    float marioJumpScale\t= 0.0;\r\n    \r\n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\r\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\r\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\r\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\r\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\r\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\r\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\r\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\r\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\r\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\r\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\r\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\r\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\r\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\r\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\r\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\r\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\r\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\r\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\r\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \r\n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\r\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\r\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\r\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\r\n    \r\n    float marioJumpOffset \t\t= 0.0;\r\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\r\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\r\n    {\r\n        float t = ( time - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n    \r\n    // Mario land\r\n    float marioLandTime \t= 0.0;\r\n    float marioLandAplitude = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\r\n    \r\n    float marioLandLength = marioLandAplitude / 120.0;\r\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\r\n    {\r\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\r\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\r\n    }\r\n    \r\n    \r\n    // Mario flag jump\r\n    marioJumpTime \t\t= flagPauseStart - 0.3;\r\n    marioJumpLength \t= 1.5  * 0.45;\r\n    marioJumpAmplitude\t= 76.0 * 0.45;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \r\n    {\r\n        float time2 = time;\r\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \r\n        {\r\n            time2 = flagPauseStart;\r\n        }\r\n        else if ( time >= flagPauseStart )\r\n        {\r\n            time2 = time - flagPauseLength;\r\n        }\r\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n\r\n    // Mario base (ground offset)\r\n    float marioBase = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }\r\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\r\n    {\r\n        marioBase = 16.0 * 3.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\r\n    {\r\n        marioBase = 16.0 * 7.0;\r\n    }\r\n\r\n    float marioX\t\t= pixelX - 112.0;\r\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \r\n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\r\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\r\n    {\r\n    \tmarioFrame = 1.0;\r\n    }    \r\n    if ( time > mushroomPauseStart + 0.7 )\r\n    {\r\n        float t = time - mushroomPauseStart - 0.7;\r\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\r\n        {\r\n            // super mario offset\r\n            marioFrame += 4.0;\r\n        }\r\n    }    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\r\n    {\r\n        SpriteMario( color, marioX, marioY, marioFrame );\r\n    }\r\n}\r\n\r\nvec2 CRTCurveUV( vec2 uv )\r\n{\r\n    uv = uv * 2.0 - 1.0;\r\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\r\n    uv = uv + uv * offset * offset;\r\n    uv = uv * 0.5 + 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid DrawVignette( inout vec3 color, vec2 uv )\r\n{    \r\n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\r\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\r\n    color *= vignette;\r\n}\r\n\r\nvoid DrawScanline( inout vec3 color, vec2 uv )\r\n{\r\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\r\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \r\n    color *= scanline * grille * 1.2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\r\n    float resMultX  = floor( iResolution.x / 224.0 );\r\n    float resMultY  = floor( iResolution.y / 192.0 );\r\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\r\n    \r\n    float time\t\t\t= iTime;\r\n    float screenWidth\t= floor( iResolution.x * resRcp );\r\n    float screenHeight\t= floor( iResolution.y * resRcp );\r\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\r\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\r\n\r\n    vec3 color = RGB( 92, 148, 252 );\r\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\r\n    if ( time < INTRO_LENGTH )\r\n    {\r\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\r\n    }    \r\n\r\n    \r\n    // CRT effects (curvature, vignette, scanlines and CRT grille)\r\n    vec2 uv    = fragCoord.xy / iResolution.xy;\r\n    vec2 crtUV = CRTCurveUV( uv );\r\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\r\n    {\r\n        color = vec3( 0.0, 0.0, 0.0 );\r\n    }\r\n    DrawVignette( color, crtUV );\r\n    DrawScanline( color, uv );\r\n    \r\n\tfragColor.xyz \t= color;\r\n    fragColor.w\t\t= 1.0;\r\n}","inputs":[],"outputs":[],"code":"// Interesting findings from original NES Super Mario Bros.:\r\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\r\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\r\n// -Overworld (main theme) drum sound uses only the APU noise generator\r\n\r\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\r\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\r\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\r\n\r\nconst float MARIO_SPEED\t = 89.0;\r\nconst float GOOMBA_SPEED = 32.0;\r\nconst float INTRO_LENGTH = 2.0;\r\n\r\nvoid SpriteBlock( inout vec3 color, float x, float y )\r\n{\r\n    // black\r\n    float idx = 1.0;\r\n    \r\n    // light orange\r\n    idx = x < y ? 3.0 : idx;\r\n    \r\n    // dark orange\r\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\r\n    idx = x == 15.0 - y ? 2.0 : idx;\r\n    \r\n    color = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteHill( inout vec3 color, float x, float y )\r\n{\r\n    float idx = 0.0;\r\n    \r\n    // dark green\r\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\r\n    \r\n    // black\r\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\r\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\r\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\r\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\r\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n}\r\n\r\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\r\n{\r\n    float offset = h * 16.0;\r\n\r\n    // light green\r\n\tfloat idx = 3.0;\r\n    \r\n    // dark green\r\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\r\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \r\n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\r\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \r\n    \r\n    // black\r\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\r\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\r\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \r\n    \r\n    // transparent\r\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\r\n{\r\n\tfloat idx = 0.0;\r\n    \r\n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\r\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\r\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\r\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\r\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\r\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\r\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\r\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\r\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\r\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\r\n\tcolor = idx == 2.0 ? colorB \t\t: color;\r\n\tcolor = idx == 3.0 ? colorC \t\t: color;\r\n}\r\n\r\nvoid SpriteFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? 43690.0 : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\r\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\r\n{\r\n\tfloat idx = 0.0;\r\n\r\n    // second frame is flipped first frame\r\n    x = frame == 1.0 ? 15.0 - x : x;\r\n\r\n    if ( frame <= 1.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\r\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\r\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\r\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\r\n        idx = y ==  6.0 ? 43690.0 : idx;\r\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\r\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\r\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\r\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\r\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\r\n\t\tidx = y == 3.0 ? 43690.0 : idx;\r\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\r\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\r\n}\r\n\r\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\r\n{    \r\n\tfloat idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\r\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\r\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\r\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\r\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\r\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\r\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\r\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\r\n    }\r\n\telse\r\n\t{\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\r\n\t}\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 0.0 ? 21845.0 : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\r\n}\r\n\r\nvoid SpriteMushroom( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\r\n\tidx = y == 5.0 ? 43690.0 : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGround( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\r\n\tidx = y == 7.0 ? 1360.0  : idx;\r\n\tidx = y == 6.0 ? 6836.0  : idx;\r\n\tidx = y == 5.0 ? 27309.0 : idx;\r\n\tidx = y == 4.0 ? 27309.0 : idx;\r\n\tidx = y == 3.0 ? 27305.0 : idx;\r\n\tidx = y == 2.0 ? 27305.0 : idx;\r\n\tidx = y == 1.0 ? 6820.0  : idx;\r\n\tidx = y == 0.0 ? 1360.0  : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 3.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 4.0 )\r\n    {\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\r\n    }\r\n    else if ( frame == 5.0 )\r\n    {\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\r\n    }\r\n    else if ( frame == 6.0 )\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \r\n}\r\n\r\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n    }\r\n    \r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteBrick( inout vec3 color, float x, float y )\r\n{    \r\n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \r\n    float xmod8 = floor( mod( x, 8.0 ) );\r\n    float ymod8 = floor( mod( y, 8.0 ) );\r\n    \r\n    // dark orange\r\n    float idx = 2.0;\r\n   \r\n    // black\r\n    idx = ymod4 == 0.0 ? 1.0 : idx;\r\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\r\n\r\n    // light orange\r\n    idx = y == 15.0 ? 3.0 : idx;\r\n\r\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid DrawCastle( inout vec3 color, float x, float y )\r\n{\r\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\r\n\t{\r\n\t\tfloat ymod4    = mod( y, 4.0 );\r\n\t\tfloat xmod8    = mod( x, 8.0 );\r\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\r\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\r\n\t\tfloat ymod8    = mod( y, 8.0 );\r\n\r\n\t\t// dark orange\r\n\t\tfloat idx = 2.0;\r\n\r\n\t\t// black\r\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\r\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\r\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \r\n\r\n\t\t// white\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\r\n\r\n\t\t// transparent\r\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\r\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\r\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \r\n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\r\n\r\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\r\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n\t}\r\n}\r\n\r\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\r\n{\r\n    if ( x >= 0.0 && x <= 15.0 )\r\n    {\r\n        SpriteKoopa( color, x, y, frame );\r\n    }\r\n}\r\n\r\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\r\n{\r\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\r\n    DrawKoopa( color, x, worldY - 16.0, frame );    \r\n}\r\n\r\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\r\n{\r\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\r\n    t = 1.0 - abs( 2.0 * t - 1.0 );\r\n\r\n    questionY -= floor( t * 8.0 );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {            \r\n    \tif ( time >= questionHitTime )\r\n        {                \r\n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\r\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n            {\r\n                color = RGB( 231, 90, 16 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n         \tSpriteQuestion( color, questionX, questionY, questionT );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawW( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 || x >= 10.0 ) \r\n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawO( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\r\n             || ( x >= 2.0 && x <= 4.0 )\r\n             || ( x >= 9.0 && x <= 11.0 )\r\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawR( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 )\r\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\r\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\r\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\r\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\r\n             || ( x >= 8.0  && y <= 1.0 )\r\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawL( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( x <= 3.0 || y <= 1.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawD( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n    \tcolor = RGB( 255, 255, 255 );        \r\n        \r\n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \r\n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \r\n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\r\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\r\n           )\r\n        {\r\n            color = RGB( 0, 0, 0 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid Draw1( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( y <= 1.0 )\r\n             || ( x >= 5.0 && x <= 8.0 )\r\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawM( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( y >= 4.0 && y <= 7.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\r\n{\r\n    color = RGB( 0, 0, 0 );\r\n        \r\n    float offset \t= 18.0;     \r\n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\r\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\r\n    float marioX\t= textX - offset * 4.0;\r\n    float marioY\t= textY + 16.0 * 3.0;\r\n\t\r\n    DrawW( color, textX - offset * 0.0, textY );\r\n    DrawO( color, textX - offset * 1.0, textY );\r\n    DrawR( color, textX - offset * 2.0, textY );\r\n    DrawL( color, textX - offset * 3.0, textY );\r\n    DrawD( color, textX - offset * 4.0, textY );\r\n    Draw1( color, textX - offset * 6.0, textY );\r\n    DrawM( color, textX - offset * 7.0, textY );\r\n    Draw1( color, textX - offset * 8.0, textY );\r\n    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 )\r\n    {\r\n    \tSpriteMario( color, marioX, marioY, 4.0 );\r\n    }\r\n}\r\n\r\nfloat CoinAnimY( float worldY, float time, float coinTime )\r\n{\r\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\r\n}\r\n\r\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\r\n{\r\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\r\n}\r\n\r\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\r\n{\r\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\r\n}\r\n\r\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\r\n{\r\n    float mushroomPauseStart \t= 16.25;    \r\n    float mushroomPauseLength \t= 2.0;    \r\n    float flagPauseStart\t\t= 38.95;\r\n    float flagPauseLength\t\t= 1.5;\r\n\r\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\r\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\r\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\r\n    float worldX \t\t= pixelX + cameraX;\r\n    float worldY  \t\t= pixelY - 8.0;\r\n    float tileX\t\t\t= floor( worldX / 16.0 );\r\n    float tileY\t\t\t= floor( worldY / 16.0 );\r\n    float tile2X\t\t= floor( worldX / 32.0 );\r\n    float tile2Y\t\t= floor( worldY / 32.0 );    \r\n    float worldXMod16\t= mod( worldX, 16.0 );\r\n    float worldYMod16 \t= mod( worldY, 16.0 );\r\n\r\n\r\n    // default background color\r\n    color = RGB( 92, 148, 252 );\r\n\r\n    \r\n    // draw hills\r\n    float bigHillX \t = mod( worldX, 768.0 );\r\n    float smallHillX = mod( worldX - 240.0, 768.0 );\r\n    float hillX \t = min( bigHillX, smallHillX );\r\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\r\n    SpriteHill( color, hillX, hillY );\r\n\r\n\r\n    // draw clouds and bushes\r\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\r\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\r\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\r\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \r\n    float scCloudX  = min( sc1CloudX, sc2CloudX );\r\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\r\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \r\n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\r\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\r\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\r\n    float sCloudX\t= min( scCloudX, sbCloudX );\r\n    float mCloudX\t= min( mcCloudX, mbCloudX );\r\n    float lCloudX\t= min( lcCloudX, lbCloudX );\r\n    float cloudX\t= min( cCloudX, bCloudX );\r\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\r\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\r\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\r\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\r\n    {\r\n        if ( cloudSeg == 1.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\r\n        }\r\n        if ( cloudSeg == 2.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\r\n        }\r\n        \r\n    \tSpriteCloud( color, cloudX, cloudY, isBush );\r\n    }\r\n\r\n    \r\n    \r\n    // draw flag pole\r\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \r\n    {\r\n        color = RGB( 189, 255, 24 );\r\n    }\r\n    \r\n    // draw flag\r\n    float flagX = worldX - 3160.0;\r\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( flagX >= 0.0 && flagX <= 15.0 )\r\n    {\r\n    \tSpriteFlag( color, flagX, flagY );\r\n    }     \r\n    \r\n    // draw flagpole end\r\n    float flagpoleEndX = worldX - 3172.0;\r\n    float flagpoleEndY = worldY - 176.0;\r\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\r\n    {\r\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\r\n    }\r\n    \r\n    \r\n\r\n    // draw blocks\r\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\r\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\r\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\r\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \r\n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\r\n         || ( tileX == 198.0 && tileY == 1.0 )\r\n       )\r\n    {\r\n        SpriteBlock( color, worldXMod16, worldYMod16 );\r\n    }\r\n    \r\n    \r\n    // draw pipes\r\n    float pipeY = worldY - 16.0;  \r\n    float pipeH\t= 0.0;    \r\n    float pipeX = worldX - 179.0 * 16.0;\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 163.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 57.0 * 16.0;\r\n        pipeH = 2.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 46.0 * 16.0;\r\n        pipeH = 2.0;\r\n    } \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 38.0 * 16.0;\r\n        pipeH = 1.0;\r\n    }         \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 28.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\r\n\t{\r\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\r\n\t}\r\n    \r\n    \r\n    // draw mushroom\r\n    float mushroomStart = 15.7;    \r\n    if ( time >= mushroomStart && time <= 17.0 )\r\n    {\r\n        float jumpTime = 0.5;\r\n        \r\n        float mushroomX = worldX - 1248.0;\r\n        float mushroomY = worldY - 4.0 * 16.0;\r\n        if ( time >= mushroomStart )\r\n        {\r\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 )\r\n        {\r\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 + 0.4 )\r\n        {\r\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\r\n        }\r\n        \r\n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\r\n        {\r\n        \tSpriteMushroom( color, mushroomX, mushroomY );\r\n        }\r\n    }\r\n\r\n    \r\n    // draw coins\r\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\r\n    float coinX \t= worldX - 2720.0;\r\n    float coinTime \t= 33.9;    \r\n    float coinY \t= CoinAnimY( worldY, time, coinTime );\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 1696.0;\r\n    \tcoinTime \t= 22.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \r\n    }\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 352.0;\r\n    \tcoinTime \t= 5.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\r\n    } \r\n    \r\n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\r\n    {   \r\n        SpriteCoin( color, coinX, coinY, coinFrame );\r\n    }\r\n\r\n    \r\n    // draw questions\r\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \r\n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\r\n    }\r\n    \r\n    \r\n    // draw hitted questions\r\n    float questionHitTime \t= 33.9;\r\n    float questionX \t\t= worldX - 2720.0;\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 22.4;\r\n        questionX\t\t= worldX - 1696.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 15.4;\r\n        questionX\t\t= worldX - 1248.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 5.3;\r\n        questionX\t\t= worldX - 352.0;\r\n    }    \r\n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \r\n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {\r\n    \tSpriteQuestion( color, questionX, questionY, questionT );\r\n    }\r\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n    {\r\n        color = RGB( 231, 90, 16 );\r\n    }    \r\n\r\n    \r\n    // draw bricks\r\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteBrick( color, worldXMod16, worldYMod16 );\r\n    }   \r\n    \r\n    \r\n    // draw castle flag\r\n    float castleFlagX = worldX - 3264.0;\r\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\r\n    {\r\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\r\n\t}\r\n    \r\n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\r\n\r\n    // draw ground\r\n    if ( tileY <= 0.0\r\n         && !( tileX >= 69.0  && tileX < 71.0 )\r\n         && !( tileX >= 86.0  && tileX < 89.0 ) \r\n         && !( tileX >= 153.0 && tileX < 155.0 ) \r\n       )\r\n    {\r\n        SpriteGround( color, worldXMod16, worldYMod16 );\r\n    }    \r\n    \r\n\r\n    // draw Koopa\r\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\r\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\r\n    \r\n    \r\n    // draw stomped walking Goombas\r\n    float goombaY \t\t\t= worldY - 16.0;        \r\n    float goombaLifeTime \t= 26.3;\r\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 25.3;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n\t\tgoombaLifeTime \t= 23.5;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n        goombaLifeTime \t= 20.29;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 10.3;\r\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    }\r\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }    \r\n    \r\n    // draw walking Goombas\r\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\r\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\r\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }\r\n    \r\n\r\n    \r\n    // Mario jump\r\n    float marioBigJump1 \t= 27.1;\r\n    float marioBigJump2 \t= 29.75;\r\n    float marioBigJump3 \t= 35.05;    \r\n    float marioJumpTime \t= 0.0;\r\n    float marioJumpScale\t= 0.0;\r\n    \r\n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\r\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\r\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\r\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\r\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\r\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\r\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\r\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\r\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\r\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\r\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\r\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\r\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\r\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\r\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\r\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\r\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\r\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\r\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\r\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \r\n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\r\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\r\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\r\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\r\n    \r\n    float marioJumpOffset \t\t= 0.0;\r\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\r\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\r\n    {\r\n        float t = ( time - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n    \r\n    // Mario land\r\n    float marioLandTime \t= 0.0;\r\n    float marioLandAplitude = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\r\n    \r\n    float marioLandLength = marioLandAplitude / 120.0;\r\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\r\n    {\r\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\r\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\r\n    }\r\n    \r\n    \r\n    // Mario flag jump\r\n    marioJumpTime \t\t= flagPauseStart - 0.3;\r\n    marioJumpLength \t= 1.5  * 0.45;\r\n    marioJumpAmplitude\t= 76.0 * 0.45;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \r\n    {\r\n        float time2 = time;\r\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \r\n        {\r\n            time2 = flagPauseStart;\r\n        }\r\n        else if ( time >= flagPauseStart )\r\n        {\r\n            time2 = time - flagPauseLength;\r\n        }\r\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n\r\n    // Mario base (ground offset)\r\n    float marioBase = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }\r\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\r\n    {\r\n        marioBase = 16.0 * 3.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\r\n    {\r\n        marioBase = 16.0 * 7.0;\r\n    }\r\n\r\n    float marioX\t\t= pixelX - 112.0;\r\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \r\n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\r\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\r\n    {\r\n    \tmarioFrame = 1.0;\r\n    }    \r\n    if ( time > mushroomPauseStart + 0.7 )\r\n    {\r\n        float t = time - mushroomPauseStart - 0.7;\r\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\r\n        {\r\n            // super mario offset\r\n            marioFrame += 4.0;\r\n        }\r\n    }    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\r\n    {\r\n        SpriteMario( color, marioX, marioY, marioFrame );\r\n    }\r\n}\r\n\r\nvec2 CRTCurveUV( vec2 uv )\r\n{\r\n    uv = uv * 2.0 - 1.0;\r\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\r\n    uv = uv + uv * offset * offset;\r\n    uv = uv * 0.5 + 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid DrawVignette( inout vec3 color, vec2 uv )\r\n{    \r\n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\r\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\r\n    color *= vignette;\r\n}\r\n\r\nvoid DrawScanline( inout vec3 color, vec2 uv )\r\n{\r\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\r\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \r\n    color *= scanline * grille * 1.2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\r\n    float resMultX  = floor( iResolution.x / 224.0 );\r\n    float resMultY  = floor( iResolution.y / 192.0 );\r\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\r\n    \r\n    float time\t\t\t= iTime;\r\n    float screenWidth\t= floor( iResolution.x * resRcp );\r\n    float screenHeight\t= floor( iResolution.y * resRcp );\r\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\r\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\r\n\r\n    vec3 color = RGB( 92, 148, 252 );\r\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\r\n    if ( time < INTRO_LENGTH )\r\n    {\r\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\r\n    }    \r\n\r\n    \r\n    // CRT effects (curvature, vignette, scanlines and CRT grille)\r\n    vec2 uv    = fragCoord.xy / iResolution.xy;\r\n    vec2 crtUV = CRTCurveUV( uv );\r\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\r\n    {\r\n        color = vec3( 0.0, 0.0, 0.0 );\r\n    }\r\n    DrawVignette( color, crtUV );\r\n    DrawScanline( color, uv );\r\n    \r\n\tfragColor.xyz \t= color;\r\n    fragColor.w\t\t= 1.0;\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"[SIG15] Mario World 1-1","id":"44193e25748d40dd99347ab7fcb82422","date":null,"viewed":0,"name":"[SIG15] Mario World 1-1","description":"NES Super Mario Bros. World 1-1. My favorite game moment (just like for most kids in the early 90s). 20 years later implemented in a single shader.\nhttps://www.shadertoy.com/view/XtlSD7","likes":0,"published":null,"tags":["2d"," sound"," music"," crt"," sprite"," mario"," nes"," sig15"]},"ver":null,"info":{"Name":"[SIG15] Mario World 1-1","id":"44193e25748d40dd99347ab7fcb82422","date":null,"viewed":0,"name":"[SIG15] Mario World 1-1","description":"NES Super Mario Bros. World 1-1. My favorite game moment (just like for most kids in the early 90s). 20 years later implemented in a single shader.\nhttps://www.shadertoy.com/view/XtlSD7","likes":0,"published":null,"tags":["2d"," sound"," music"," crt"," sprite"," mario"," nes"," sig15"]},"renderpass":[{"Code":"// Interesting findings from original NES Super Mario Bros.:\r\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\r\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\r\n// -Overworld (main theme) drum sound uses only the APU noise generator\r\n\r\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\r\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\r\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\r\n\r\nconst float MARIO_SPEED\t = 89.0;\r\nconst float GOOMBA_SPEED = 32.0;\r\nconst float INTRO_LENGTH = 2.0;\r\n\r\nvoid SpriteBlock( inout vec3 color, float x, float y )\r\n{\r\n    // black\r\n    float idx = 1.0;\r\n    \r\n    // light orange\r\n    idx = x < y ? 3.0 : idx;\r\n    \r\n    // dark orange\r\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\r\n    idx = x == 15.0 - y ? 2.0 : idx;\r\n    \r\n    color = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteHill( inout vec3 color, float x, float y )\r\n{\r\n    float idx = 0.0;\r\n    \r\n    // dark green\r\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\r\n    \r\n    // black\r\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\r\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\r\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\r\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\r\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n}\r\n\r\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\r\n{\r\n    float offset = h * 16.0;\r\n\r\n    // light green\r\n\tfloat idx = 3.0;\r\n    \r\n    // dark green\r\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\r\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \r\n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\r\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \r\n    \r\n    // black\r\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\r\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\r\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \r\n    \r\n    // transparent\r\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\r\n{\r\n\tfloat idx = 0.0;\r\n    \r\n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\r\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\r\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\r\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\r\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\r\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\r\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\r\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\r\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\r\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\r\n\tcolor = idx == 2.0 ? colorB \t\t: color;\r\n\tcolor = idx == 3.0 ? colorC \t\t: color;\r\n}\r\n\r\nvoid SpriteFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? 43690.0 : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\r\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\r\n{\r\n\tfloat idx = 0.0;\r\n\r\n    // second frame is flipped first frame\r\n    x = frame == 1.0 ? 15.0 - x : x;\r\n\r\n    if ( frame <= 1.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\r\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\r\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\r\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\r\n        idx = y ==  6.0 ? 43690.0 : idx;\r\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\r\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\r\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\r\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\r\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\r\n\t\tidx = y == 3.0 ? 43690.0 : idx;\r\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\r\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\r\n}\r\n\r\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\r\n{    \r\n\tfloat idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\r\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\r\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\r\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\r\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\r\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\r\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\r\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\r\n    }\r\n\telse\r\n\t{\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\r\n\t}\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 0.0 ? 21845.0 : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\r\n}\r\n\r\nvoid SpriteMushroom( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\r\n\tidx = y == 5.0 ? 43690.0 : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGround( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\r\n\tidx = y == 7.0 ? 1360.0  : idx;\r\n\tidx = y == 6.0 ? 6836.0  : idx;\r\n\tidx = y == 5.0 ? 27309.0 : idx;\r\n\tidx = y == 4.0 ? 27309.0 : idx;\r\n\tidx = y == 3.0 ? 27305.0 : idx;\r\n\tidx = y == 2.0 ? 27305.0 : idx;\r\n\tidx = y == 1.0 ? 6820.0  : idx;\r\n\tidx = y == 0.0 ? 1360.0  : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 3.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 4.0 )\r\n    {\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\r\n    }\r\n    else if ( frame == 5.0 )\r\n    {\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\r\n    }\r\n    else if ( frame == 6.0 )\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \r\n}\r\n\r\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n    }\r\n    \r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteBrick( inout vec3 color, float x, float y )\r\n{    \r\n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \r\n    float xmod8 = floor( mod( x, 8.0 ) );\r\n    float ymod8 = floor( mod( y, 8.0 ) );\r\n    \r\n    // dark orange\r\n    float idx = 2.0;\r\n   \r\n    // black\r\n    idx = ymod4 == 0.0 ? 1.0 : idx;\r\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\r\n\r\n    // light orange\r\n    idx = y == 15.0 ? 3.0 : idx;\r\n\r\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid DrawCastle( inout vec3 color, float x, float y )\r\n{\r\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\r\n\t{\r\n\t\tfloat ymod4    = mod( y, 4.0 );\r\n\t\tfloat xmod8    = mod( x, 8.0 );\r\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\r\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\r\n\t\tfloat ymod8    = mod( y, 8.0 );\r\n\r\n\t\t// dark orange\r\n\t\tfloat idx = 2.0;\r\n\r\n\t\t// black\r\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\r\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\r\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \r\n\r\n\t\t// white\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\r\n\r\n\t\t// transparent\r\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\r\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\r\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \r\n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\r\n\r\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\r\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n\t}\r\n}\r\n\r\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\r\n{\r\n    if ( x >= 0.0 && x <= 15.0 )\r\n    {\r\n        SpriteKoopa( color, x, y, frame );\r\n    }\r\n}\r\n\r\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\r\n{\r\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\r\n    DrawKoopa( color, x, worldY - 16.0, frame );    \r\n}\r\n\r\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\r\n{\r\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\r\n    t = 1.0 - abs( 2.0 * t - 1.0 );\r\n\r\n    questionY -= floor( t * 8.0 );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {            \r\n    \tif ( time >= questionHitTime )\r\n        {                \r\n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\r\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n            {\r\n                color = RGB( 231, 90, 16 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n         \tSpriteQuestion( color, questionX, questionY, questionT );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawW( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 || x >= 10.0 ) \r\n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawO( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\r\n             || ( x >= 2.0 && x <= 4.0 )\r\n             || ( x >= 9.0 && x <= 11.0 )\r\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawR( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 )\r\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\r\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\r\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\r\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\r\n             || ( x >= 8.0  && y <= 1.0 )\r\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawL( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( x <= 3.0 || y <= 1.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawD( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n    \tcolor = RGB( 255, 255, 255 );        \r\n        \r\n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \r\n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \r\n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\r\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\r\n           )\r\n        {\r\n            color = RGB( 0, 0, 0 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid Draw1( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( y <= 1.0 )\r\n             || ( x >= 5.0 && x <= 8.0 )\r\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawM( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( y >= 4.0 && y <= 7.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\r\n{\r\n    color = RGB( 0, 0, 0 );\r\n        \r\n    float offset \t= 18.0;     \r\n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\r\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\r\n    float marioX\t= textX - offset * 4.0;\r\n    float marioY\t= textY + 16.0 * 3.0;\r\n\t\r\n    DrawW( color, textX - offset * 0.0, textY );\r\n    DrawO( color, textX - offset * 1.0, textY );\r\n    DrawR( color, textX - offset * 2.0, textY );\r\n    DrawL( color, textX - offset * 3.0, textY );\r\n    DrawD( color, textX - offset * 4.0, textY );\r\n    Draw1( color, textX - offset * 6.0, textY );\r\n    DrawM( color, textX - offset * 7.0, textY );\r\n    Draw1( color, textX - offset * 8.0, textY );\r\n    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 )\r\n    {\r\n    \tSpriteMario( color, marioX, marioY, 4.0 );\r\n    }\r\n}\r\n\r\nfloat CoinAnimY( float worldY, float time, float coinTime )\r\n{\r\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\r\n}\r\n\r\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\r\n{\r\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\r\n}\r\n\r\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\r\n{\r\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\r\n}\r\n\r\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\r\n{\r\n    float mushroomPauseStart \t= 16.25;    \r\n    float mushroomPauseLength \t= 2.0;    \r\n    float flagPauseStart\t\t= 38.95;\r\n    float flagPauseLength\t\t= 1.5;\r\n\r\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\r\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\r\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\r\n    float worldX \t\t= pixelX + cameraX;\r\n    float worldY  \t\t= pixelY - 8.0;\r\n    float tileX\t\t\t= floor( worldX / 16.0 );\r\n    float tileY\t\t\t= floor( worldY / 16.0 );\r\n    float tile2X\t\t= floor( worldX / 32.0 );\r\n    float tile2Y\t\t= floor( worldY / 32.0 );    \r\n    float worldXMod16\t= mod( worldX, 16.0 );\r\n    float worldYMod16 \t= mod( worldY, 16.0 );\r\n\r\n\r\n    // default background color\r\n    color = RGB( 92, 148, 252 );\r\n\r\n    \r\n    // draw hills\r\n    float bigHillX \t = mod( worldX, 768.0 );\r\n    float smallHillX = mod( worldX - 240.0, 768.0 );\r\n    float hillX \t = min( bigHillX, smallHillX );\r\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\r\n    SpriteHill( color, hillX, hillY );\r\n\r\n\r\n    // draw clouds and bushes\r\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\r\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\r\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\r\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \r\n    float scCloudX  = min( sc1CloudX, sc2CloudX );\r\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\r\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \r\n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\r\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\r\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\r\n    float sCloudX\t= min( scCloudX, sbCloudX );\r\n    float mCloudX\t= min( mcCloudX, mbCloudX );\r\n    float lCloudX\t= min( lcCloudX, lbCloudX );\r\n    float cloudX\t= min( cCloudX, bCloudX );\r\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\r\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\r\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\r\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\r\n    {\r\n        if ( cloudSeg == 1.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\r\n        }\r\n        if ( cloudSeg == 2.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\r\n        }\r\n        \r\n    \tSpriteCloud( color, cloudX, cloudY, isBush );\r\n    }\r\n\r\n    \r\n    \r\n    // draw flag pole\r\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \r\n    {\r\n        color = RGB( 189, 255, 24 );\r\n    }\r\n    \r\n    // draw flag\r\n    float flagX = worldX - 3160.0;\r\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( flagX >= 0.0 && flagX <= 15.0 )\r\n    {\r\n    \tSpriteFlag( color, flagX, flagY );\r\n    }     \r\n    \r\n    // draw flagpole end\r\n    float flagpoleEndX = worldX - 3172.0;\r\n    float flagpoleEndY = worldY - 176.0;\r\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\r\n    {\r\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\r\n    }\r\n    \r\n    \r\n\r\n    // draw blocks\r\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\r\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\r\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\r\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \r\n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\r\n         || ( tileX == 198.0 && tileY == 1.0 )\r\n       )\r\n    {\r\n        SpriteBlock( color, worldXMod16, worldYMod16 );\r\n    }\r\n    \r\n    \r\n    // draw pipes\r\n    float pipeY = worldY - 16.0;  \r\n    float pipeH\t= 0.0;    \r\n    float pipeX = worldX - 179.0 * 16.0;\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 163.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 57.0 * 16.0;\r\n        pipeH = 2.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 46.0 * 16.0;\r\n        pipeH = 2.0;\r\n    } \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 38.0 * 16.0;\r\n        pipeH = 1.0;\r\n    }         \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 28.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\r\n\t{\r\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\r\n\t}\r\n    \r\n    \r\n    // draw mushroom\r\n    float mushroomStart = 15.7;    \r\n    if ( time >= mushroomStart && time <= 17.0 )\r\n    {\r\n        float jumpTime = 0.5;\r\n        \r\n        float mushroomX = worldX - 1248.0;\r\n        float mushroomY = worldY - 4.0 * 16.0;\r\n        if ( time >= mushroomStart )\r\n        {\r\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 )\r\n        {\r\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 + 0.4 )\r\n        {\r\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\r\n        }\r\n        \r\n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\r\n        {\r\n        \tSpriteMushroom( color, mushroomX, mushroomY );\r\n        }\r\n    }\r\n\r\n    \r\n    // draw coins\r\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\r\n    float coinX \t= worldX - 2720.0;\r\n    float coinTime \t= 33.9;    \r\n    float coinY \t= CoinAnimY( worldY, time, coinTime );\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 1696.0;\r\n    \tcoinTime \t= 22.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \r\n    }\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 352.0;\r\n    \tcoinTime \t= 5.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\r\n    } \r\n    \r\n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\r\n    {   \r\n        SpriteCoin( color, coinX, coinY, coinFrame );\r\n    }\r\n\r\n    \r\n    // draw questions\r\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \r\n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\r\n    }\r\n    \r\n    \r\n    // draw hitted questions\r\n    float questionHitTime \t= 33.9;\r\n    float questionX \t\t= worldX - 2720.0;\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 22.4;\r\n        questionX\t\t= worldX - 1696.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 15.4;\r\n        questionX\t\t= worldX - 1248.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 5.3;\r\n        questionX\t\t= worldX - 352.0;\r\n    }    \r\n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \r\n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {\r\n    \tSpriteQuestion( color, questionX, questionY, questionT );\r\n    }\r\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n    {\r\n        color = RGB( 231, 90, 16 );\r\n    }    \r\n\r\n    \r\n    // draw bricks\r\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteBrick( color, worldXMod16, worldYMod16 );\r\n    }   \r\n    \r\n    \r\n    // draw castle flag\r\n    float castleFlagX = worldX - 3264.0;\r\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\r\n    {\r\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\r\n\t}\r\n    \r\n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\r\n\r\n    // draw ground\r\n    if ( tileY <= 0.0\r\n         && !( tileX >= 69.0  && tileX < 71.0 )\r\n         && !( tileX >= 86.0  && tileX < 89.0 ) \r\n         && !( tileX >= 153.0 && tileX < 155.0 ) \r\n       )\r\n    {\r\n        SpriteGround( color, worldXMod16, worldYMod16 );\r\n    }    \r\n    \r\n\r\n    // draw Koopa\r\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\r\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\r\n    \r\n    \r\n    // draw stomped walking Goombas\r\n    float goombaY \t\t\t= worldY - 16.0;        \r\n    float goombaLifeTime \t= 26.3;\r\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 25.3;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n\t\tgoombaLifeTime \t= 23.5;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n        goombaLifeTime \t= 20.29;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 10.3;\r\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    }\r\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }    \r\n    \r\n    // draw walking Goombas\r\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\r\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\r\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }\r\n    \r\n\r\n    \r\n    // Mario jump\r\n    float marioBigJump1 \t= 27.1;\r\n    float marioBigJump2 \t= 29.75;\r\n    float marioBigJump3 \t= 35.05;    \r\n    float marioJumpTime \t= 0.0;\r\n    float marioJumpScale\t= 0.0;\r\n    \r\n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\r\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\r\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\r\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\r\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\r\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\r\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\r\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\r\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\r\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\r\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\r\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\r\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\r\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\r\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\r\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\r\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\r\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\r\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\r\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \r\n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\r\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\r\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\r\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\r\n    \r\n    float marioJumpOffset \t\t= 0.0;\r\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\r\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\r\n    {\r\n        float t = ( time - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n    \r\n    // Mario land\r\n    float marioLandTime \t= 0.0;\r\n    float marioLandAplitude = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\r\n    \r\n    float marioLandLength = marioLandAplitude / 120.0;\r\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\r\n    {\r\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\r\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\r\n    }\r\n    \r\n    \r\n    // Mario flag jump\r\n    marioJumpTime \t\t= flagPauseStart - 0.3;\r\n    marioJumpLength \t= 1.5  * 0.45;\r\n    marioJumpAmplitude\t= 76.0 * 0.45;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \r\n    {\r\n        float time2 = time;\r\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \r\n        {\r\n            time2 = flagPauseStart;\r\n        }\r\n        else if ( time >= flagPauseStart )\r\n        {\r\n            time2 = time - flagPauseLength;\r\n        }\r\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n\r\n    // Mario base (ground offset)\r\n    float marioBase = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }\r\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\r\n    {\r\n        marioBase = 16.0 * 3.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\r\n    {\r\n        marioBase = 16.0 * 7.0;\r\n    }\r\n\r\n    float marioX\t\t= pixelX - 112.0;\r\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \r\n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\r\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\r\n    {\r\n    \tmarioFrame = 1.0;\r\n    }    \r\n    if ( time > mushroomPauseStart + 0.7 )\r\n    {\r\n        float t = time - mushroomPauseStart - 0.7;\r\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\r\n        {\r\n            // super mario offset\r\n            marioFrame += 4.0;\r\n        }\r\n    }    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\r\n    {\r\n        SpriteMario( color, marioX, marioY, marioFrame );\r\n    }\r\n}\r\n\r\nvec2 CRTCurveUV( vec2 uv )\r\n{\r\n    uv = uv * 2.0 - 1.0;\r\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\r\n    uv = uv + uv * offset * offset;\r\n    uv = uv * 0.5 + 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid DrawVignette( inout vec3 color, vec2 uv )\r\n{    \r\n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\r\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\r\n    color *= vignette;\r\n}\r\n\r\nvoid DrawScanline( inout vec3 color, vec2 uv )\r\n{\r\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\r\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \r\n    color *= scanline * grille * 1.2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\r\n    float resMultX  = floor( iResolution.x / 224.0 );\r\n    float resMultY  = floor( iResolution.y / 192.0 );\r\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\r\n    \r\n    float time\t\t\t= iTime;\r\n    float screenWidth\t= floor( iResolution.x * resRcp );\r\n    float screenHeight\t= floor( iResolution.y * resRcp );\r\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\r\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\r\n\r\n    vec3 color = RGB( 92, 148, 252 );\r\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\r\n    if ( time < INTRO_LENGTH )\r\n    {\r\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\r\n    }    \r\n\r\n    \r\n    // CRT effects (curvature, vignette, scanlines and CRT grille)\r\n    vec2 uv    = fragCoord.xy / iResolution.xy;\r\n    vec2 crtUV = CRTCurveUV( uv );\r\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\r\n    {\r\n        color = vec3( 0.0, 0.0, 0.0 );\r\n    }\r\n    DrawVignette( color, crtUV );\r\n    DrawScanline( color, uv );\r\n    \r\n\tfragColor.xyz \t= color;\r\n    fragColor.w\t\t= 1.0;\r\n}","inputs":[],"outputs":[],"code":"// Interesting findings from original NES Super Mario Bros.:\r\n// -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\r\n// -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\r\n// -Overworld (main theme) drum sound uses only the APU noise generator\r\n\r\n#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\r\n#define SPRITE_DEC2( x, i ) mod( floor( i / pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\r\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\r\n\r\nconst float MARIO_SPEED\t = 89.0;\r\nconst float GOOMBA_SPEED = 32.0;\r\nconst float INTRO_LENGTH = 2.0;\r\n\r\nvoid SpriteBlock( inout vec3 color, float x, float y )\r\n{\r\n    // black\r\n    float idx = 1.0;\r\n    \r\n    // light orange\r\n    idx = x < y ? 3.0 : idx;\r\n    \r\n    // dark orange\r\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\r\n    idx = x == 15.0 - y ? 2.0 : idx;\r\n    \r\n    color = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteHill( inout vec3 color, float x, float y )\r\n{\r\n    float idx = 0.0;\r\n    \r\n    // dark green\r\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\r\n    \r\n    // black\r\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\r\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\r\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\r\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\r\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\r\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\r\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\r\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n}\r\n\r\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\r\n{\r\n    float offset = h * 16.0;\r\n\r\n    // light green\r\n\tfloat idx = 3.0;\r\n    \r\n    // dark green\r\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\r\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \r\n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\r\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \r\n    \r\n    // black\r\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\r\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\r\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \r\n    \r\n    // transparent\r\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\r\n{\r\n\tfloat idx = 0.0;\r\n    \r\n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\r\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\r\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\r\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\r\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\r\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\r\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\r\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\r\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\r\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\r\n\tcolor = idx == 2.0 ? colorB \t\t: color;\r\n\tcolor = idx == 3.0 ? colorC \t\t: color;\r\n}\r\n\r\nvoid SpriteFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? 43690.0 : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC2( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\r\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\r\n{\r\n\tfloat idx = 0.0;\r\n\r\n    // second frame is flipped first frame\r\n    x = frame == 1.0 ? 15.0 - x : x;\r\n\r\n    if ( frame <= 1.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\r\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\r\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\r\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\r\n        idx = y ==  6.0 ? 43690.0 : idx;\r\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\r\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\r\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\r\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\r\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\r\n\t\tidx = y == 3.0 ? 43690.0 : idx;\r\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\r\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\r\n}\r\n\r\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\r\n{    \r\n\tfloat idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\r\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\r\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\r\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\r\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\r\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\r\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\r\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\r\n    }\r\n\telse\r\n\t{\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\r\n\t}\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\r\n\tidx = y == 0.0 ? 21845.0 : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\r\n}\r\n\r\nvoid SpriteMushroom( inout vec3 color, float x, float y )\r\n{\r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\r\n\tidx = y == 5.0 ? 43690.0 : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\r\n}\r\n\r\nvoid SpriteGround( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\r\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\r\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\r\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\r\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\r\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\r\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\r\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\r\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\r\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\r\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = RGB( 0, 0, 0 );\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\r\n{   \r\n\tfloat idx = 0.0;\r\n\r\n\tidx = y == 7.0 ? 1360.0  : idx;\r\n\tidx = y == 6.0 ? 6836.0  : idx;\r\n\tidx = y == 5.0 ? 27309.0 : idx;\r\n\tidx = y == 4.0 ? 27309.0 : idx;\r\n\tidx = y == 3.0 ? 27305.0 : idx;\r\n\tidx = y == 2.0 ? 27305.0 : idx;\r\n\tidx = y == 1.0 ? 6820.0  : idx;\r\n\tidx = y == 0.0 ? 1360.0  : idx;\r\n\r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\r\n}\r\n\r\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 3.0 )\r\n    {\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\r\n    }\r\n    else if ( frame == 4.0 )\r\n    {\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\r\n    }\r\n    else if ( frame == 5.0 )\r\n    {\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\r\n    }\r\n    else if ( frame == 6.0 )\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\r\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\r\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\r\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\r\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\r\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\r\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\r\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\r\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\r\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\r\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\r\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\r\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\r\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\r\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\r\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\r\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\r\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\r\n    }\r\n    \r\n    idx = SPRITE_DEC( x, idx );\r\n    \r\n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \r\n}\r\n\r\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\r\n{    \r\n    float idx = 0.0;\r\n\tif ( frame == 0.0 )\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\r\n\t}\r\n    else if ( frame == 1.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\r\n    }\r\n    else if ( frame == 2.0 ) \r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\r\n    }\r\n    else\r\n    {\r\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\r\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\r\n    }\r\n    \r\n\tidx = SPRITE_DEC( x, idx );\r\n\r\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \r\n}\r\n\r\nvoid SpriteBrick( inout vec3 color, float x, float y )\r\n{    \r\n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \r\n    float xmod8 = floor( mod( x, 8.0 ) );\r\n    float ymod8 = floor( mod( y, 8.0 ) );\r\n    \r\n    // dark orange\r\n    float idx = 2.0;\r\n   \r\n    // black\r\n    idx = ymod4 == 0.0 ? 1.0 : idx;\r\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\r\n\r\n    // light orange\r\n    idx = y == 15.0 ? 3.0 : idx;\r\n\r\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\r\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n}\r\n\r\nvoid DrawCastle( inout vec3 color, float x, float y )\r\n{\r\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\r\n\t{\r\n\t\tfloat ymod4    = mod( y, 4.0 );\r\n\t\tfloat xmod8    = mod( x, 8.0 );\r\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\r\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\r\n\t\tfloat ymod8    = mod( y, 8.0 );\r\n\r\n\t\t// dark orange\r\n\t\tfloat idx = 2.0;\r\n\r\n\t\t// black\r\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\r\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\r\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\r\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \r\n\r\n\t\t// white\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\r\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\r\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\r\n\r\n\t\t// transparent\r\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\r\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\r\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \r\n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\r\n\r\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\r\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\r\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\r\n\t}\r\n}\r\n\r\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\r\n{\r\n    if ( x >= 0.0 && x <= 15.0 )\r\n    {\r\n        SpriteKoopa( color, x, y, frame );\r\n    }\r\n}\r\n\r\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\r\n{\r\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\r\n    DrawKoopa( color, x, worldY - 16.0, frame );    \r\n}\r\n\r\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\r\n{\r\n\tfloat t = clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 );\r\n    t = 1.0 - abs( 2.0 * t - 1.0 );\r\n\r\n    questionY -= floor( t * 8.0 );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {            \r\n    \tif ( time >= questionHitTime )\r\n        {                \r\n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\r\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n            {\r\n                color = RGB( 231, 90, 16 );\r\n            }\r\n        }\r\n        else\r\n        {\r\n         \tSpriteQuestion( color, questionX, questionY, questionT );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawW( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 || x >= 10.0 ) \r\n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\r\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawO( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\r\n             || ( x >= 2.0 && x <= 4.0 )\r\n             || ( x >= 9.0 && x <= 11.0 )\r\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawR( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( x <= 3.0 )\r\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\r\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\r\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\r\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\r\n             || ( x >= 8.0  && y <= 1.0 )\r\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawL( inout vec3 color, float x, float y )\r\n{\r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( x <= 3.0 || y <= 1.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawD( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n    \tcolor = RGB( 255, 255, 255 );        \r\n        \r\n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \r\n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \r\n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\r\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\r\n           )\r\n        {\r\n            color = RGB( 0, 0, 0 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid Draw1( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if (    ( y <= 1.0 )\r\n             || ( x >= 5.0 && x <= 8.0 )\r\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\r\n           )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawM( inout vec3 color, float x, float y )\r\n{    \r\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\r\n    {\r\n        if ( y >= 4.0 && y <= 7.0 )\r\n        {\r\n            color = RGB( 255, 255, 255 );\r\n        }\r\n    }\r\n}\r\n\r\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\r\n{\r\n    color = RGB( 0, 0, 0 );\r\n        \r\n    float offset \t= 18.0;     \r\n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) / 2.0 );\r\n    float textY \t= floor( y - ( screenHeight - 7.0 ) / 2.0 - 16.0 * 2.0 );\r\n    float marioX\t= textX - offset * 4.0;\r\n    float marioY\t= textY + 16.0 * 3.0;\r\n\t\r\n    DrawW( color, textX - offset * 0.0, textY );\r\n    DrawO( color, textX - offset * 1.0, textY );\r\n    DrawR( color, textX - offset * 2.0, textY );\r\n    DrawL( color, textX - offset * 3.0, textY );\r\n    DrawD( color, textX - offset * 4.0, textY );\r\n    Draw1( color, textX - offset * 6.0, textY );\r\n    DrawM( color, textX - offset * 7.0, textY );\r\n    Draw1( color, textX - offset * 8.0, textY );\r\n    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 )\r\n    {\r\n    \tSpriteMario( color, marioX, marioY, 4.0 );\r\n    }\r\n}\r\n\r\nfloat CoinAnimY( float worldY, float time, float coinTime )\r\n{\r\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) / 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\r\n}\r\n\r\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\r\n{\r\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) / 0.25, 0.0, 1.0 ) - 1.0 ) ) );\r\n}\r\n\r\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\r\n{\r\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\r\n}\r\n\r\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\r\n{\r\n    float mushroomPauseStart \t= 16.25;    \r\n    float mushroomPauseLength \t= 2.0;    \r\n    float flagPauseStart\t\t= 38.95;\r\n    float flagPauseLength\t\t= 1.5;\r\n\r\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\r\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\r\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\r\n    float worldX \t\t= pixelX + cameraX;\r\n    float worldY  \t\t= pixelY - 8.0;\r\n    float tileX\t\t\t= floor( worldX / 16.0 );\r\n    float tileY\t\t\t= floor( worldY / 16.0 );\r\n    float tile2X\t\t= floor( worldX / 32.0 );\r\n    float tile2Y\t\t= floor( worldY / 32.0 );    \r\n    float worldXMod16\t= mod( worldX, 16.0 );\r\n    float worldYMod16 \t= mod( worldY, 16.0 );\r\n\r\n\r\n    // default background color\r\n    color = RGB( 92, 148, 252 );\r\n\r\n    \r\n    // draw hills\r\n    float bigHillX \t = mod( worldX, 768.0 );\r\n    float smallHillX = mod( worldX - 240.0, 768.0 );\r\n    float hillX \t = min( bigHillX, smallHillX );\r\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\r\n    SpriteHill( color, hillX, hillY );\r\n\r\n\r\n    // draw clouds and bushes\r\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\r\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\r\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\r\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \r\n    float scCloudX  = min( sc1CloudX, sc2CloudX );\r\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\r\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \r\n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\r\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\r\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\r\n    float sCloudX\t= min( scCloudX, sbCloudX );\r\n    float mCloudX\t= min( mcCloudX, mbCloudX );\r\n    float lCloudX\t= min( lcCloudX, lbCloudX );\r\n    float cloudX\t= min( cCloudX, bCloudX );\r\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\r\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\r\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\r\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\r\n    {\r\n        if ( cloudSeg == 1.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\r\n        }\r\n        if ( cloudSeg == 2.0 )\r\n        {\r\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\r\n        }\r\n        \r\n    \tSpriteCloud( color, cloudX, cloudY, isBush );\r\n    }\r\n\r\n    \r\n    \r\n    // draw flag pole\r\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \r\n    {\r\n        color = RGB( 189, 255, 24 );\r\n    }\r\n    \r\n    // draw flag\r\n    float flagX = worldX - 3160.0;\r\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( flagX >= 0.0 && flagX <= 15.0 )\r\n    {\r\n    \tSpriteFlag( color, flagX, flagY );\r\n    }     \r\n    \r\n    // draw flagpole end\r\n    float flagpoleEndX = worldX - 3172.0;\r\n    float flagpoleEndY = worldY - 176.0;\r\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\r\n    {\r\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\r\n    }\r\n    \r\n    \r\n\r\n    // draw blocks\r\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\r\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\r\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\r\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \r\n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\r\n         || ( tileX == 198.0 && tileY == 1.0 )\r\n       )\r\n    {\r\n        SpriteBlock( color, worldXMod16, worldYMod16 );\r\n    }\r\n    \r\n    \r\n    // draw pipes\r\n    float pipeY = worldY - 16.0;  \r\n    float pipeH\t= 0.0;    \r\n    float pipeX = worldX - 179.0 * 16.0;\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 163.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 57.0 * 16.0;\r\n        pipeH = 2.0;\r\n    }\r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 46.0 * 16.0;\r\n        pipeH = 2.0;\r\n    } \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 38.0 * 16.0;\r\n        pipeH = 1.0;\r\n    }         \r\n    if ( pipeX < 0.0 )\r\n    {\r\n        pipeX = worldX - 28.0 * 16.0;\r\n        pipeH = 0.0;\r\n    }\r\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\r\n\t{\r\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\r\n\t}\r\n    \r\n    \r\n    // draw mushroom\r\n    float mushroomStart = 15.7;    \r\n    if ( time >= mushroomStart && time <= 17.0 )\r\n    {\r\n        float jumpTime = 0.5;\r\n        \r\n        float mushroomX = worldX - 1248.0;\r\n        float mushroomY = worldY - 4.0 * 16.0;\r\n        if ( time >= mushroomStart )\r\n        {\r\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) / 0.5, 0.0, 1.0 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 )\r\n        {\r\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\r\n        }\r\n        if ( time >= mushroomStart + 0.5 + 0.4 )\r\n        {\r\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\r\n        }\r\n        \r\n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\r\n        {\r\n        \tSpriteMushroom( color, mushroomX, mushroomY );\r\n        }\r\n    }\r\n\r\n    \r\n    // draw coins\r\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\r\n    float coinX \t= worldX - 2720.0;\r\n    float coinTime \t= 33.9;    \r\n    float coinY \t= CoinAnimY( worldY, time, coinTime );\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 1696.0;\r\n    \tcoinTime \t= 22.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \r\n    }\r\n    if ( coinX < 0.0 )\r\n    {\r\n    \tcoinX \t\t= worldX - 352.0;\r\n    \tcoinTime \t= 5.4;    \r\n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\r\n    } \r\n    \r\n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\r\n    {   \r\n        SpriteCoin( color, coinX, coinY, coinFrame );\r\n    }\r\n\r\n    \r\n    // draw questions\r\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \r\n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\r\n    }\r\n    \r\n    \r\n    // draw hitted questions\r\n    float questionHitTime \t= 33.9;\r\n    float questionX \t\t= worldX - 2720.0;\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 22.4;\r\n        questionX\t\t= worldX - 1696.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 15.4;\r\n        questionX\t\t= worldX - 1248.0;\r\n    }\r\n    if ( questionX < 0.0 )\r\n    {\r\n        questionHitTime = 5.3;\r\n        questionX\t\t= worldX - 352.0;\r\n    }    \r\n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \r\n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\r\n    if ( questionX >= 0.0 && questionX <= 15.0 )\r\n    {\r\n    \tSpriteQuestion( color, questionX, questionY, questionT );\r\n    }\r\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\r\n    {\r\n        color = RGB( 231, 90, 16 );\r\n    }    \r\n\r\n    \r\n    // draw bricks\r\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\r\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\r\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\r\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\r\n       )\r\n    {\r\n        SpriteBrick( color, worldXMod16, worldYMod16 );\r\n    }   \r\n    \r\n    \r\n    // draw castle flag\r\n    float castleFlagX = worldX - 3264.0;\r\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) / 1.0, 0.0, 1.0 ) );\r\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\r\n    {\r\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\r\n\t}\r\n    \r\n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\r\n\r\n    // draw ground\r\n    if ( tileY <= 0.0\r\n         && !( tileX >= 69.0  && tileX < 71.0 )\r\n         && !( tileX >= 86.0  && tileX < 89.0 ) \r\n         && !( tileX >= 153.0 && tileX < 155.0 ) \r\n       )\r\n    {\r\n        SpriteGround( color, worldXMod16, worldYMod16 );\r\n    }    \r\n    \r\n\r\n    // draw Koopa\r\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\r\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\r\n    \r\n    \r\n    // draw stomped walking Goombas\r\n    float goombaY \t\t\t= worldY - 16.0;        \r\n    float goombaLifeTime \t= 26.3;\r\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 25.3;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n\t\tgoombaLifeTime \t= 23.5;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 ) \r\n    {\r\n        goombaLifeTime \t= 20.29;\r\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\r\n    }\r\n    if ( goombaX < 0.0 )\r\n    {\r\n        goombaLifeTime \t= 10.3;\r\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    }\r\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }    \r\n    \r\n    // draw walking Goombas\r\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\r\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\r\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\r\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\r\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\r\n    {\r\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\r\n    }\r\n    \r\n\r\n    \r\n    // Mario jump\r\n    float marioBigJump1 \t= 27.1;\r\n    float marioBigJump2 \t= 29.75;\r\n    float marioBigJump3 \t= 35.05;    \r\n    float marioJumpTime \t= 0.0;\r\n    float marioJumpScale\t= 0.0;\r\n    \r\n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\r\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\r\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\r\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\r\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\r\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\r\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\r\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\r\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\r\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\r\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\r\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\r\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\r\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\r\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\r\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\r\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\r\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\r\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\r\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\r\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \r\n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\r\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\r\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\r\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\r\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\r\n    \r\n    float marioJumpOffset \t\t= 0.0;\r\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\r\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\r\n    {\r\n        float t = ( time - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n    \r\n    // Mario land\r\n    float marioLandTime \t= 0.0;\r\n    float marioLandAplitude = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\r\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\r\n    \r\n    float marioLandLength = marioLandAplitude / 120.0;\r\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\r\n    {\r\n        float t = 0.5 * ( time - marioLandTime ) / marioLandLength + 0.5;\r\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\r\n    }\r\n    \r\n    \r\n    // Mario flag jump\r\n    marioJumpTime \t\t= flagPauseStart - 0.3;\r\n    marioJumpLength \t= 1.5  * 0.45;\r\n    marioJumpAmplitude\t= 76.0 * 0.45;\r\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \r\n    {\r\n        float time2 = time;\r\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \r\n        {\r\n            time2 = flagPauseStart;\r\n        }\r\n        else if ( time >= flagPauseStart )\r\n        {\r\n            time2 = time - flagPauseLength;\r\n        }\r\n\t\tfloat t = ( time2 - marioJumpTime ) / marioJumpLength;\r\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\r\n    }\r\n    \r\n\r\n    // Mario base (ground offset)\r\n    float marioBase = 0.0;\r\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }\r\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\r\n    {\r\n        marioBase = 16.0 * 4.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\r\n    {\r\n        marioBase = 16.0 * 3.0;\r\n    }    \r\n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\r\n    {\r\n        marioBase = 16.0 * 7.0;\r\n    }\r\n\r\n    float marioX\t\t= pixelX - 112.0;\r\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \r\n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\r\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\r\n    {\r\n    \tmarioFrame = 1.0;\r\n    }    \r\n    if ( time > mushroomPauseStart + 0.7 )\r\n    {\r\n        float t = time - mushroomPauseStart - 0.7;\r\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t / 1.3, 0.0, 1.0 ) ) )\r\n        {\r\n            // super mario offset\r\n            marioFrame += 4.0;\r\n        }\r\n    }    \r\n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\r\n    {\r\n        SpriteMario( color, marioX, marioY, marioFrame );\r\n    }\r\n}\r\n\r\nvec2 CRTCurveUV( vec2 uv )\r\n{\r\n    uv = uv * 2.0 - 1.0;\r\n    vec2 offset = abs( uv.yx ) / vec2( 6.0, 4.0 );\r\n    uv = uv + uv * offset * offset;\r\n    uv = uv * 0.5 + 0.5;\r\n    return uv;\r\n}\r\n\r\nvoid DrawVignette( inout vec3 color, vec2 uv )\r\n{    \r\n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\r\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\r\n    color *= vignette;\r\n}\r\n\r\nvoid DrawScanline( inout vec3 color, vec2 uv )\r\n{\r\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\r\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \r\n    color *= scanline * grille * 1.2;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // we want to see at least 224x192 (overscan) and we want multiples of pixel size\r\n    float resMultX  = floor( iResolution.x / 224.0 );\r\n    float resMultY  = floor( iResolution.y / 192.0 );\r\n    float resRcp\t= 1.0 / max( min( resMultX, resMultY ), 1.0 );\r\n    \r\n    float time\t\t\t= iTime;\r\n    float screenWidth\t= floor( iResolution.x * resRcp );\r\n    float screenHeight\t= floor( iResolution.y * resRcp );\r\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\r\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\r\n\r\n    vec3 color = RGB( 92, 148, 252 );\r\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\r\n    if ( time < INTRO_LENGTH )\r\n    {\r\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\r\n    }    \r\n\r\n    \r\n    // CRT effects (curvature, vignette, scanlines and CRT grille)\r\n    vec2 uv    = fragCoord.xy / iResolution.xy;\r\n    vec2 crtUV = CRTCurveUV( uv );\r\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\r\n    {\r\n        color = vec3( 0.0, 0.0, 0.0 );\r\n    }\r\n    DrawVignette( color, crtUV );\r\n    DrawScanline( color, uv );\r\n    \r\n\tfragColor.xyz \t= color;\r\n    fragColor.w\t\t= 1.0;\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// simplification of https://www.shadertoy.com/view/lt2GDt\r\n// used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define H(n) fract( 1e4 * sin( n.x+n.y/.7 +vec2(1,12.34) ) )\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, p,c;\r\n    U = 5.* (U+U - R ) / R.y + iTime; \r\n    float l;\r\n    \r\n    O += 1e9-O;  // --- Worley noise: return O.xyz = sorted distance to first 3 nodes\r\n    for (int k=0; k<9; k++) // replace loops i,j: -1..1\r\n    { // windows Angle bug with ,, instead of {}\r\n                p = ceil(U) + vec2(k-k/3*3,k/3)-2., // cell id = floor(U)+vec2(i,j)\r\n                l = dot(c = H(p) + p-U , c);        // distance^2 to its node\r\n                  l < O.x  ? O.yz=O.xy, O.x=l       // ordered 3 min distances\r\n                : l < O.y  ? O.z =O.y , O.y=l \r\n                : l < O.z  ?            O.z=l : l;\r\n    }\r\n    O = 5.*sqrt(O); \r\n    \r\n    \r\n    // --- smooth distance to borders and nodes\r\n    \r\n // l = 1./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\r\n // O += smoothstep(.0,.3, l-.5) -O;\r\n    O -= O.x;  O += 4.*( O.y/(O.y/O.z+1.) - .5 ) - O;  // simplified form\r\n}","inputs":[],"outputs":[],"code":"// simplification of https://www.shadertoy.com/view/lt2GDt\r\n// used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define H(n) fract( 1e4 * sin( n.x+n.y/.7 +vec2(1,12.34) ) )\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, p,c;\r\n    U = 5.* (U+U - R ) / R.y + iTime; \r\n    float l;\r\n    \r\n    O += 1e9-O;  // --- Worley noise: return O.xyz = sorted distance to first 3 nodes\r\n    for (int k=0; k<9; k++) // replace loops i,j: -1..1\r\n    { // windows Angle bug with ,, instead of {}\r\n                p = ceil(U) + vec2(k-k/3*3,k/3)-2., // cell id = floor(U)+vec2(i,j)\r\n                l = dot(c = H(p) + p-U , c);        // distance^2 to its node\r\n                  l < O.x  ? O.yz=O.xy, O.x=l       // ordered 3 min distances\r\n                : l < O.y  ? O.z =O.y , O.y=l \r\n                : l < O.z  ?            O.z=l : l;\r\n    }\r\n    O = 5.*sqrt(O); \r\n    \r\n    \r\n    // --- smooth distance to borders and nodes\r\n    \r\n // l = 1./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\r\n // O += smoothstep(.0,.3, l-.5) -O;\r\n    O -= O.x;  O += 4.*( O.y/(O.y/O.z+1.) - .5 ) - O;  // simplified form\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"2D trabeculum","id":"8f2874314c8447419d13dfcdb8ca4e19","date":null,"viewed":0,"name":"2D trabeculum","description":"Voronoi diagram are nice, but for CG use several goodies are welcome. \nHere, I show how to make an organic look (no sharp angle), i.e., trabeculum patterns. \nhttps://www.shadertoy.com/view/4dKSDV","likes":0,"published":null,"tags":["procedural"," voronoi"," noise"," worley"," short"," trabeculum"]},"ver":null,"info":{"Name":"2D trabeculum","id":"8f2874314c8447419d13dfcdb8ca4e19","date":null,"viewed":0,"name":"2D trabeculum","description":"Voronoi diagram are nice, but for CG use several goodies are welcome. \nHere, I show how to make an organic look (no sharp angle), i.e., trabeculum patterns. \nhttps://www.shadertoy.com/view/4dKSDV","likes":0,"published":null,"tags":["procedural"," voronoi"," noise"," worley"," short"," trabeculum"]},"renderpass":[{"Code":"// simplification of https://www.shadertoy.com/view/lt2GDt\r\n// used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define H(n) fract( 1e4 * sin( n.x+n.y/.7 +vec2(1,12.34) ) )\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, p,c;\r\n    U = 5.* (U+U - R ) / R.y + iTime; \r\n    float l;\r\n    \r\n    O += 1e9-O;  // --- Worley noise: return O.xyz = sorted distance to first 3 nodes\r\n    for (int k=0; k<9; k++) // replace loops i,j: -1..1\r\n    { // windows Angle bug with ,, instead of {}\r\n                p = ceil(U) + vec2(k-k/3*3,k/3)-2., // cell id = floor(U)+vec2(i,j)\r\n                l = dot(c = H(p) + p-U , c);        // distance^2 to its node\r\n                  l < O.x  ? O.yz=O.xy, O.x=l       // ordered 3 min distances\r\n                : l < O.y  ? O.z =O.y , O.y=l \r\n                : l < O.z  ?            O.z=l : l;\r\n    }\r\n    O = 5.*sqrt(O); \r\n    \r\n    \r\n    // --- smooth distance to borders and nodes\r\n    \r\n // l = 1./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\r\n // O += smoothstep(.0,.3, l-.5) -O;\r\n    O -= O.x;  O += 4.*( O.y/(O.y/O.z+1.) - .5 ) - O;  // simplified form\r\n}","inputs":[],"outputs":[],"code":"// simplification of https://www.shadertoy.com/view/lt2GDt\r\n// used for 3D trabeculum here : https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define H(n) fract( 1e4 * sin( n.x+n.y/.7 +vec2(1,12.34) ) )\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, p,c;\r\n    U = 5.* (U+U - R ) / R.y + iTime; \r\n    float l;\r\n    \r\n    O += 1e9-O;  // --- Worley noise: return O.xyz = sorted distance to first 3 nodes\r\n    for (int k=0; k<9; k++) // replace loops i,j: -1..1\r\n    { // windows Angle bug with ,, instead of {}\r\n                p = ceil(U) + vec2(k-k/3*3,k/3)-2., // cell id = floor(U)+vec2(i,j)\r\n                l = dot(c = H(p) + p-U , c);        // distance^2 to its node\r\n                  l < O.x  ? O.yz=O.xy, O.x=l       // ordered 3 min distances\r\n                : l < O.y  ? O.z =O.y , O.y=l \r\n                : l < O.z  ?            O.z=l : l;\r\n    }\r\n    O = 5.*sqrt(O); \r\n    \r\n    \r\n    // --- smooth distance to borders and nodes\r\n    \r\n // l = 1./(1./(O.y-O.x)+1./(O.z-O.x)); // Formula (c) Fabrice NEYRET - BSD3:mention author.\r\n // O += smoothstep(.0,.3, l-.5) -O;\r\n    O -= O.x;  O += 4.*( O.y/(O.y/O.z+1.) - .5 ) - O;  // simplified form\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// better trabeculum ( compare to https://www.shadertoy.com/view/4dKSDV )\r\n// relying on simplification ( cf https://www.shadertoy.com/view/llGGDw )\r\n// of IQ's Voronoi distance https://www.shadertoy.com/view/ldl3W8\r\n\r\n#define ANIMATE\r\n\r\nvec2 hash2( vec2 p )\r\n{\r\n\t// texture based white noise\r\n\t//return texture( iChannel0, (p+.5)/256., -100. ).xy;\r\n\t\r\n    // procedural white noise\t\r\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\r\n}\r\n\r\nvec2 dist(vec2 g, vec2 x) {\r\n    vec2 n = floor(x), f = fract(x),\r\n         o = hash2( n + g );\r\n\t#ifdef ANIMATE\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 voronoi( vec2 x )\r\n{\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec2 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec2  g = vec2(i,j), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    md = 8.;\r\n    for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ ) {\r\n            vec2 g = mg + vec2(i,j),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d = dot( .5*(mr+r), normalize(r-mr) );\r\n                if ( d < md ) md3=md2, md2=md, md=d;\r\n                else if (d < md2 ) md3 = md2, md2=d;\r\n                else  if (d < md3 ) md3 = d;\r\n            }\r\n        }\r\n  //return vec3( md, md2, md3 );           // 3 distances to border: useful in 3D\r\n    return vec4( md, md2, mr );            // 2 distances to border + seed pos\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 p )\r\n{\r\n    p /= iResolution.x;\r\n\r\n    vec4 c = voronoi( 8.*p );\r\n    float d = c.x;              // original IQ's constant border width Vorono\u00EF \r\n    d = 2./(1./c.x+1./c.y);     // trabeculum distance adapted from https://www.shadertoy.com/view/4dKSDV\r\n                                // ( Formula (c) Fabrice NEYRET - BSD3:mention author. )\r\n    // d = 2./(1./c.y+1./c.z);  // 3D\r\n    //float K = 1.3; d = pow( (pow(c.x,-K)+pow(c.y,-K))/5., -K );\r\n    //float K = .7; d = pow( (pow(c.x,-K)+pow(c.y,-K))*2., -K );\r\n    \r\n\t// isolines\r\n    vec3 col = vec3(d)*(.5 + .5*sin(64.*d));\r\n    // borders\t\r\n  //col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d*(1.+.5*sin(iTime)) ) );\r\n    col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d-.06-.1*sin(iTime) ) );\r\n\r\n    // feature points\r\n\tfloat dd = length( c.zw );\r\n\tcol =   mix( vec3(1,.6,.1), col, smoothstep( .0, .12, dd) )\r\n\t      + vec3(1,.6,.1)*smoothstep( .04, .0, dd);\r\n\r\n\tO = vec4(col,1.);\r\n}\r\n","inputs":[],"outputs":[],"code":"// better trabeculum ( compare to https://www.shadertoy.com/view/4dKSDV )\r\n// relying on simplification ( cf https://www.shadertoy.com/view/llGGDw )\r\n// of IQ's Voronoi distance https://www.shadertoy.com/view/ldl3W8\r\n\r\n#define ANIMATE\r\n\r\nvec2 hash2( vec2 p )\r\n{\r\n\t// texture based white noise\r\n\t//return texture( iChannel0, (p+.5)/256., -100. ).xy;\r\n\t\r\n    // procedural white noise\t\r\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\r\n}\r\n\r\nvec2 dist(vec2 g, vec2 x) {\r\n    vec2 n = floor(x), f = fract(x),\r\n         o = hash2( n + g );\r\n\t#ifdef ANIMATE\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 voronoi( vec2 x )\r\n{\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec2 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec2  g = vec2(i,j), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    md = 8.;\r\n    for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ ) {\r\n            vec2 g = mg + vec2(i,j),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d = dot( .5*(mr+r), normalize(r-mr) );\r\n                if ( d < md ) md3=md2, md2=md, md=d;\r\n                else if (d < md2 ) md3 = md2, md2=d;\r\n                else  if (d < md3 ) md3 = d;\r\n            }\r\n        }\r\n  //return vec3( md, md2, md3 );           // 3 distances to border: useful in 3D\r\n    return vec4( md, md2, mr );            // 2 distances to border + seed pos\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 p )\r\n{\r\n    p /= iResolution.x;\r\n\r\n    vec4 c = voronoi( 8.*p );\r\n    float d = c.x;              // original IQ's constant border width Vorono\u00EF \r\n    d = 2./(1./c.x+1./c.y);     // trabeculum distance adapted from https://www.shadertoy.com/view/4dKSDV\r\n                                // ( Formula (c) Fabrice NEYRET - BSD3:mention author. )\r\n    // d = 2./(1./c.y+1./c.z);  // 3D\r\n    //float K = 1.3; d = pow( (pow(c.x,-K)+pow(c.y,-K))/5., -K );\r\n    //float K = .7; d = pow( (pow(c.x,-K)+pow(c.y,-K))*2., -K );\r\n    \r\n\t// isolines\r\n    vec3 col = vec3(d)*(.5 + .5*sin(64.*d));\r\n    // borders\t\r\n  //col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d*(1.+.5*sin(iTime)) ) );\r\n    col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d-.06-.1*sin(iTime) ) );\r\n\r\n    // feature points\r\n\tfloat dd = length( c.zw );\r\n\tcol =   mix( vec3(1,.6,.1), col, smoothstep( .0, .12, dd) )\r\n\t      + vec3(1,.6,.1)*smoothstep( .04, .0, dd);\r\n\r\n\tO = vec4(col,1.);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"2D trabeculum - 2","id":"e468274b143a49b8b519b65a5eabb9a5","date":null,"viewed":0,"name":"2D trabeculum - 2","description":"Voronoi diagram are nice, but for CG use several goodies are welcome. \nIQ shown how to regularize the distance to border. \nI shown how to make an organic look (no sharp angle), i.e., trabeculum patterns. \nHere, I join both ideas.\nhttps://www.shadertoy.com/view/MlGGDw","likes":0,"published":null,"tags":["procedural"," 2d"," voronoi"," noise"," worley"," short"," trabeculum"]},"ver":null,"info":{"Name":"2D trabeculum - 2","id":"e468274b143a49b8b519b65a5eabb9a5","date":null,"viewed":0,"name":"2D trabeculum - 2","description":"Voronoi diagram are nice, but for CG use several goodies are welcome. \nIQ shown how to regularize the distance to border. \nI shown how to make an organic look (no sharp angle), i.e., trabeculum patterns. \nHere, I join both ideas.\nhttps://www.shadertoy.com/view/MlGGDw","likes":0,"published":null,"tags":["procedural"," 2d"," voronoi"," noise"," worley"," short"," trabeculum"]},"renderpass":[{"Code":"// better trabeculum ( compare to https://www.shadertoy.com/view/4dKSDV )\r\n// relying on simplification ( cf https://www.shadertoy.com/view/llGGDw )\r\n// of IQ's Voronoi distance https://www.shadertoy.com/view/ldl3W8\r\n\r\n#define ANIMATE\r\n\r\nvec2 hash2( vec2 p )\r\n{\r\n\t// texture based white noise\r\n\t//return texture( iChannel0, (p+.5)/256., -100. ).xy;\r\n\t\r\n    // procedural white noise\t\r\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\r\n}\r\n\r\nvec2 dist(vec2 g, vec2 x) {\r\n    vec2 n = floor(x), f = fract(x),\r\n         o = hash2( n + g );\r\n\t#ifdef ANIMATE\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 voronoi( vec2 x )\r\n{\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec2 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec2  g = vec2(i,j), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    md = 8.;\r\n    for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ ) {\r\n            vec2 g = mg + vec2(i,j),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d = dot( .5*(mr+r), normalize(r-mr) );\r\n                if ( d < md ) md3=md2, md2=md, md=d;\r\n                else if (d < md2 ) md3 = md2, md2=d;\r\n                else  if (d < md3 ) md3 = d;\r\n            }\r\n        }\r\n  //return vec3( md, md2, md3 );           // 3 distances to border: useful in 3D\r\n    return vec4( md, md2, mr );            // 2 distances to border + seed pos\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 p )\r\n{\r\n    p /= iResolution.x;\r\n\r\n    vec4 c = voronoi( 8.*p );\r\n    float d = c.x;              // original IQ's constant border width Vorono\u00EF \r\n    d = 2./(1./c.x+1./c.y);     // trabeculum distance adapted from https://www.shadertoy.com/view/4dKSDV\r\n                                // ( Formula (c) Fabrice NEYRET - BSD3:mention author. )\r\n    // d = 2./(1./c.y+1./c.z);  // 3D\r\n    //float K = 1.3; d = pow( (pow(c.x,-K)+pow(c.y,-K))/5., -K );\r\n    //float K = .7; d = pow( (pow(c.x,-K)+pow(c.y,-K))*2., -K );\r\n    \r\n\t// isolines\r\n    vec3 col = vec3(d)*(.5 + .5*sin(64.*d));\r\n    // borders\t\r\n  //col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d*(1.+.5*sin(iTime)) ) );\r\n    col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d-.06-.1*sin(iTime) ) );\r\n\r\n    // feature points\r\n\tfloat dd = length( c.zw );\r\n\tcol =   mix( vec3(1,.6,.1), col, smoothstep( .0, .12, dd) )\r\n\t      + vec3(1,.6,.1)*smoothstep( .04, .0, dd);\r\n\r\n\tO = vec4(col,1.);\r\n}\r\n","inputs":[],"outputs":[],"code":"// better trabeculum ( compare to https://www.shadertoy.com/view/4dKSDV )\r\n// relying on simplification ( cf https://www.shadertoy.com/view/llGGDw )\r\n// of IQ's Voronoi distance https://www.shadertoy.com/view/ldl3W8\r\n\r\n#define ANIMATE\r\n\r\nvec2 hash2( vec2 p )\r\n{\r\n\t// texture based white noise\r\n\t//return texture( iChannel0, (p+.5)/256., -100. ).xy;\r\n\t\r\n    // procedural white noise\t\r\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\r\n}\r\n\r\nvec2 dist(vec2 g, vec2 x) {\r\n    vec2 n = floor(x), f = fract(x),\r\n         o = hash2( n + g );\r\n\t#ifdef ANIMATE\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 voronoi( vec2 x )\r\n{\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec2 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec2  g = vec2(i,j), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    md = 8.;\r\n    for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ ) {\r\n            vec2 g = mg + vec2(i,j),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d = dot( .5*(mr+r), normalize(r-mr) );\r\n                if ( d < md ) md3=md2, md2=md, md=d;\r\n                else if (d < md2 ) md3 = md2, md2=d;\r\n                else  if (d < md3 ) md3 = d;\r\n            }\r\n        }\r\n  //return vec3( md, md2, md3 );           // 3 distances to border: useful in 3D\r\n    return vec4( md, md2, mr );            // 2 distances to border + seed pos\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 p )\r\n{\r\n    p /= iResolution.x;\r\n\r\n    vec4 c = voronoi( 8.*p );\r\n    float d = c.x;              // original IQ's constant border width Vorono\u00EF \r\n    d = 2./(1./c.x+1./c.y);     // trabeculum distance adapted from https://www.shadertoy.com/view/4dKSDV\r\n                                // ( Formula (c) Fabrice NEYRET - BSD3:mention author. )\r\n    // d = 2./(1./c.y+1./c.z);  // 3D\r\n    //float K = 1.3; d = pow( (pow(c.x,-K)+pow(c.y,-K))/5., -K );\r\n    //float K = .7; d = pow( (pow(c.x,-K)+pow(c.y,-K))*2., -K );\r\n    \r\n\t// isolines\r\n    vec3 col = vec3(d)*(.5 + .5*sin(64.*d));\r\n    // borders\t\r\n  //col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d*(1.+.5*sin(iTime)) ) );\r\n    col = mix( vec3(1,.6,0), col, smoothstep( .04, .07, d-.06-.1*sin(iTime) ) );\r\n\r\n    // feature points\r\n\tfloat dd = length( c.zw );\r\n\tcol =   mix( vec3(1,.6,.1), col, smoothstep( .0, .12, dd) )\r\n\t      + vec3(1,.6,.1)*smoothstep( .04, .0, dd);\r\n\r\n\tO = vec4(col,1.);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// The MIT License\r\n// Copyright \u00A9 2016 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n// Computing normals analytically has the benefit of being faster if you need them often, \r\n// while numerical normals are easier to filter for antialiasing. See line 200.\r\n//\r\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\r\n//\r\n// See this too: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\r\n\r\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\r\n\r\n\r\n//---------------------------------------------------------------\r\n// value noise, and its analytical derivatives\r\n//---------------------------------------------------------------\r\n\r\nvec4 noised( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n\tvec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    \r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    \r\n    float a = hash(n+  0.0);\r\n    float b = hash(n+  1.0);\r\n    float c = hash(n+157.0);\r\n    float d = hash(n+158.0);\r\n    float e = hash(n+113.0);\r\n\tfloat f = hash(n+114.0);\r\n    float g = hash(n+270.0);\r\n    float h = hash(n+271.0);\r\n\t\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\r\n}\r\n\r\n//---------------------------------------------------------------\r\n\r\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\r\n{\r\n    vec3 d = abs(p) - b;\r\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\r\n    return vec4( x, n );\r\n}\r\n\r\nvec4 fbmd( in vec3 x )\r\n{\r\n    const float scale  = 1.5;\r\n\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n\tfloat f = 1.0;\r\n    vec3  d = vec3(0.0);\r\n    for( int i=0; i<8; i++ )\r\n    {\r\n        vec4 n = noised(f*x*scale);\r\n        a += b*n.x;           // accumulate values\t\t\r\n        d += b*n.yzw*f*scale; // accumulate derivatives\r\n        b *= 0.5;             // amplitude decrease\r\n        f *= 1.8;             // frequency increase\r\n    }\r\n\r\n\treturn vec4( a, d );\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tvec4 d1 = fbmd( p );\r\n    d1.x -= 0.37;\r\n\td1.x *= 0.7;\r\n    d1.yzw = normalize(d1.yzw);\r\n\r\n    // clip to box\r\n    vec4 d2 = sdBox( p, vec3(1.5) );\r\n    return (d1.x>d2.x) ? d1 : d2;\r\n}\r\n\r\n// ray-box intersection in box space\r\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \r\n{\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\r\n\treturn vec2( tN, tF );\r\n}\r\n\r\n// raymarch\r\nvec4 interesect( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 res = vec4(-1.0);\r\n\r\n    // bounding volume    \r\n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\r\n    if( dis.y<0.0 ) return res;\r\n\r\n    // raymarch\r\n    float tmax = dis.y;\r\n    float t = dis.x;\r\n\tfor( int i=0; i<128; i++ )\r\n\t{\r\n        vec3 pos = ro + t*rd;\r\n\t\tvec4 hnor = map( pos );\r\n        res = vec4(t,hnor.yzw);\r\n        \r\n\t\tif( hnor.x<0.001 ) break;\r\n\t\tt += hnor.x;\r\n        if( t>tmax ) break;\r\n\t}\r\n\r\n\tif( t>tmax ) res = vec4(-1.0);\r\n\treturn res;\r\n}\r\n\r\n// compute normal numerically\r\n#ifdef SHOW_NUMERICAL_NORMALS\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n\tvec2 eps = vec2( 0.0001, 0.0 );\r\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n#endif\r\n\r\n// fibonazzi points in s aphsre, more info:\r\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\r\nvec3 forwardSF( float i, float n) \r\n{\r\n    const float PI  = 3.141592653589793238;\r\n    const float PHI = 1.618033988749894848;\r\n    float phi = 2.0*PI*fract(i/PHI);\r\n    float zi = 1.0 - (2.0*i+1.0)/n;\r\n    float sinTheta = sqrt( 1.0 - zi*zi);\r\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat ao = 0.0;\r\n    for( int i=0; i<32; i++ )\r\n    {\r\n        vec3 ap = forwardSF( float(i), 32.0 );\r\n        float h = hash(float(i));\r\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\r\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\r\n    }\r\n\tao /= 32.0;\r\n\t\r\n    return clamp( ao*5.0, 0.0, 1.0 );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n   \r\n\t// camera anim\r\n    float an = 0.1*iTime;\r\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\r\n\tvec3 ta = vec3( 0.0 );\r\n\t\r\n    // camera matrix\t\r\n\tvec3  cw = normalize( ta-ro );\r\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\r\n\tvec3  cv = normalize( cross(cu,cw) );\r\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\r\n\r\n\t// render\r\n\tvec3 col = vec3(0.0);\r\n    vec4 tnor = interesect( ro, rd );\r\n\tfloat t = tnor.x;\r\n\r\n    if( t>0.0 )\r\n\t{\r\n\t\tvec3 pos = ro + t*rd;\r\n        #ifndef SHOW_NUMERICAL_NORMALS\r\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\r\n        #else\r\n        vec3 nor = calcNormal( pos );\r\n        #endif\r\n        float occ = calcAO( pos, nor );\r\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\r\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\r\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\r\n        //col = 0.5+0.5*nor;\r\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\r\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\r\n\t}\r\n\r\n    col = sqrt(col);\r\n\t\r\n    fragColor=vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// The MIT License\r\n// Copyright \u00A9 2016 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n// Computing normals analytically has the benefit of being faster if you need them often, \r\n// while numerical normals are easier to filter for antialiasing. See line 200.\r\n//\r\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\r\n//\r\n// See this too: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\r\n\r\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\r\n\r\n\r\n//---------------------------------------------------------------\r\n// value noise, and its analytical derivatives\r\n//---------------------------------------------------------------\r\n\r\nvec4 noised( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n\tvec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    \r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    \r\n    float a = hash(n+  0.0);\r\n    float b = hash(n+  1.0);\r\n    float c = hash(n+157.0);\r\n    float d = hash(n+158.0);\r\n    float e = hash(n+113.0);\r\n\tfloat f = hash(n+114.0);\r\n    float g = hash(n+270.0);\r\n    float h = hash(n+271.0);\r\n\t\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\r\n}\r\n\r\n//---------------------------------------------------------------\r\n\r\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\r\n{\r\n    vec3 d = abs(p) - b;\r\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\r\n    return vec4( x, n );\r\n}\r\n\r\nvec4 fbmd( in vec3 x )\r\n{\r\n    const float scale  = 1.5;\r\n\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n\tfloat f = 1.0;\r\n    vec3  d = vec3(0.0);\r\n    for( int i=0; i<8; i++ )\r\n    {\r\n        vec4 n = noised(f*x*scale);\r\n        a += b*n.x;           // accumulate values\t\t\r\n        d += b*n.yzw*f*scale; // accumulate derivatives\r\n        b *= 0.5;             // amplitude decrease\r\n        f *= 1.8;             // frequency increase\r\n    }\r\n\r\n\treturn vec4( a, d );\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tvec4 d1 = fbmd( p );\r\n    d1.x -= 0.37;\r\n\td1.x *= 0.7;\r\n    d1.yzw = normalize(d1.yzw);\r\n\r\n    // clip to box\r\n    vec4 d2 = sdBox( p, vec3(1.5) );\r\n    return (d1.x>d2.x) ? d1 : d2;\r\n}\r\n\r\n// ray-box intersection in box space\r\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \r\n{\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\r\n\treturn vec2( tN, tF );\r\n}\r\n\r\n// raymarch\r\nvec4 interesect( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 res = vec4(-1.0);\r\n\r\n    // bounding volume    \r\n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\r\n    if( dis.y<0.0 ) return res;\r\n\r\n    // raymarch\r\n    float tmax = dis.y;\r\n    float t = dis.x;\r\n\tfor( int i=0; i<128; i++ )\r\n\t{\r\n        vec3 pos = ro + t*rd;\r\n\t\tvec4 hnor = map( pos );\r\n        res = vec4(t,hnor.yzw);\r\n        \r\n\t\tif( hnor.x<0.001 ) break;\r\n\t\tt += hnor.x;\r\n        if( t>tmax ) break;\r\n\t}\r\n\r\n\tif( t>tmax ) res = vec4(-1.0);\r\n\treturn res;\r\n}\r\n\r\n// compute normal numerically\r\n#ifdef SHOW_NUMERICAL_NORMALS\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n\tvec2 eps = vec2( 0.0001, 0.0 );\r\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n#endif\r\n\r\n// fibonazzi points in s aphsre, more info:\r\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\r\nvec3 forwardSF( float i, float n) \r\n{\r\n    const float PI  = 3.141592653589793238;\r\n    const float PHI = 1.618033988749894848;\r\n    float phi = 2.0*PI*fract(i/PHI);\r\n    float zi = 1.0 - (2.0*i+1.0)/n;\r\n    float sinTheta = sqrt( 1.0 - zi*zi);\r\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat ao = 0.0;\r\n    for( int i=0; i<32; i++ )\r\n    {\r\n        vec3 ap = forwardSF( float(i), 32.0 );\r\n        float h = hash(float(i));\r\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\r\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\r\n    }\r\n\tao /= 32.0;\r\n\t\r\n    return clamp( ao*5.0, 0.0, 1.0 );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n   \r\n\t// camera anim\r\n    float an = 0.1*iTime;\r\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\r\n\tvec3 ta = vec3( 0.0 );\r\n\t\r\n    // camera matrix\t\r\n\tvec3  cw = normalize( ta-ro );\r\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\r\n\tvec3  cv = normalize( cross(cu,cw) );\r\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\r\n\r\n\t// render\r\n\tvec3 col = vec3(0.0);\r\n    vec4 tnor = interesect( ro, rd );\r\n\tfloat t = tnor.x;\r\n\r\n    if( t>0.0 )\r\n\t{\r\n\t\tvec3 pos = ro + t*rd;\r\n        #ifndef SHOW_NUMERICAL_NORMALS\r\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\r\n        #else\r\n        vec3 nor = calcNormal( pos );\r\n        #endif\r\n        float occ = calcAO( pos, nor );\r\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\r\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\r\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\r\n        //col = 0.5+0.5*nor;\r\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\r\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\r\n\t}\r\n\r\n    col = sqrt(col);\r\n\t\r\n    fragColor=vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Analytic Normals 3D","id":"9802cc4ad5894ac888f546b6e1863ec9","date":null,"viewed":0,"name":"Analytic Normals 3D","description":"Left, analytical normals of Value Noise. Right, numerical normals (central differences). See http://iquilezles.org/www/articles/morenoise/morenoise.htm for more info. See https://www.shadertoy.com/view/MdsSRs for the 2D case.\nhttps://www.shadertoy.com/view/XttSz2","likes":0,"published":null,"tags":["3d"," noise"," normals"," analytical"," numerical"]},"ver":null,"info":{"Name":"Analytic Normals 3D","id":"9802cc4ad5894ac888f546b6e1863ec9","date":null,"viewed":0,"name":"Analytic Normals 3D","description":"Left, analytical normals of Value Noise. Right, numerical normals (central differences). See http://iquilezles.org/www/articles/morenoise/morenoise.htm for more info. See https://www.shadertoy.com/view/MdsSRs for the 2D case.\nhttps://www.shadertoy.com/view/XttSz2","likes":0,"published":null,"tags":["3d"," noise"," normals"," analytical"," numerical"]},"renderpass":[{"Code":"// The MIT License\r\n// Copyright \u00A9 2016 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n// Computing normals analytically has the benefit of being faster if you need them often, \r\n// while numerical normals are easier to filter for antialiasing. See line 200.\r\n//\r\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\r\n//\r\n// See this too: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\r\n\r\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\r\n\r\n\r\n//---------------------------------------------------------------\r\n// value noise, and its analytical derivatives\r\n//---------------------------------------------------------------\r\n\r\nvec4 noised( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n\tvec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    \r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    \r\n    float a = hash(n+  0.0);\r\n    float b = hash(n+  1.0);\r\n    float c = hash(n+157.0);\r\n    float d = hash(n+158.0);\r\n    float e = hash(n+113.0);\r\n\tfloat f = hash(n+114.0);\r\n    float g = hash(n+270.0);\r\n    float h = hash(n+271.0);\r\n\t\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\r\n}\r\n\r\n//---------------------------------------------------------------\r\n\r\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\r\n{\r\n    vec3 d = abs(p) - b;\r\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\r\n    return vec4( x, n );\r\n}\r\n\r\nvec4 fbmd( in vec3 x )\r\n{\r\n    const float scale  = 1.5;\r\n\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n\tfloat f = 1.0;\r\n    vec3  d = vec3(0.0);\r\n    for( int i=0; i<8; i++ )\r\n    {\r\n        vec4 n = noised(f*x*scale);\r\n        a += b*n.x;           // accumulate values\t\t\r\n        d += b*n.yzw*f*scale; // accumulate derivatives\r\n        b *= 0.5;             // amplitude decrease\r\n        f *= 1.8;             // frequency increase\r\n    }\r\n\r\n\treturn vec4( a, d );\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tvec4 d1 = fbmd( p );\r\n    d1.x -= 0.37;\r\n\td1.x *= 0.7;\r\n    d1.yzw = normalize(d1.yzw);\r\n\r\n    // clip to box\r\n    vec4 d2 = sdBox( p, vec3(1.5) );\r\n    return (d1.x>d2.x) ? d1 : d2;\r\n}\r\n\r\n// ray-box intersection in box space\r\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \r\n{\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\r\n\treturn vec2( tN, tF );\r\n}\r\n\r\n// raymarch\r\nvec4 interesect( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 res = vec4(-1.0);\r\n\r\n    // bounding volume    \r\n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\r\n    if( dis.y<0.0 ) return res;\r\n\r\n    // raymarch\r\n    float tmax = dis.y;\r\n    float t = dis.x;\r\n\tfor( int i=0; i<128; i++ )\r\n\t{\r\n        vec3 pos = ro + t*rd;\r\n\t\tvec4 hnor = map( pos );\r\n        res = vec4(t,hnor.yzw);\r\n        \r\n\t\tif( hnor.x<0.001 ) break;\r\n\t\tt += hnor.x;\r\n        if( t>tmax ) break;\r\n\t}\r\n\r\n\tif( t>tmax ) res = vec4(-1.0);\r\n\treturn res;\r\n}\r\n\r\n// compute normal numerically\r\n#ifdef SHOW_NUMERICAL_NORMALS\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n\tvec2 eps = vec2( 0.0001, 0.0 );\r\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n#endif\r\n\r\n// fibonazzi points in s aphsre, more info:\r\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\r\nvec3 forwardSF( float i, float n) \r\n{\r\n    const float PI  = 3.141592653589793238;\r\n    const float PHI = 1.618033988749894848;\r\n    float phi = 2.0*PI*fract(i/PHI);\r\n    float zi = 1.0 - (2.0*i+1.0)/n;\r\n    float sinTheta = sqrt( 1.0 - zi*zi);\r\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat ao = 0.0;\r\n    for( int i=0; i<32; i++ )\r\n    {\r\n        vec3 ap = forwardSF( float(i), 32.0 );\r\n        float h = hash(float(i));\r\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\r\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\r\n    }\r\n\tao /= 32.0;\r\n\t\r\n    return clamp( ao*5.0, 0.0, 1.0 );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n   \r\n\t// camera anim\r\n    float an = 0.1*iTime;\r\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\r\n\tvec3 ta = vec3( 0.0 );\r\n\t\r\n    // camera matrix\t\r\n\tvec3  cw = normalize( ta-ro );\r\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\r\n\tvec3  cv = normalize( cross(cu,cw) );\r\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\r\n\r\n\t// render\r\n\tvec3 col = vec3(0.0);\r\n    vec4 tnor = interesect( ro, rd );\r\n\tfloat t = tnor.x;\r\n\r\n    if( t>0.0 )\r\n\t{\r\n\t\tvec3 pos = ro + t*rd;\r\n        #ifndef SHOW_NUMERICAL_NORMALS\r\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\r\n        #else\r\n        vec3 nor = calcNormal( pos );\r\n        #endif\r\n        float occ = calcAO( pos, nor );\r\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\r\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\r\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\r\n        //col = 0.5+0.5*nor;\r\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\r\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\r\n\t}\r\n\r\n    col = sqrt(col);\r\n\t\r\n    fragColor=vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// The MIT License\r\n// Copyright \u00A9 2016 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n// Computing normals analytically has the benefit of being faster if you need them often, \r\n// while numerical normals are easier to filter for antialiasing. See line 200.\r\n//\r\n// More info: http://iquilezles.org/www/articles/morenoise/morenoise.htm\r\n//\r\n// See this too: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n// Proper noise code isolated here: https://www.shadertoy.com/view/XsXfRH\r\n//\r\n//#define SHOW_NUMERICAL_NORMALS  // for comparison purposes\r\n\r\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\r\n\r\n\r\n//---------------------------------------------------------------\r\n// value noise, and its analytical derivatives\r\n//---------------------------------------------------------------\r\n\r\nvec4 noised( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n\tvec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    \r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    \r\n    float a = hash(n+  0.0);\r\n    float b = hash(n+  1.0);\r\n    float c = hash(n+157.0);\r\n    float d = hash(n+158.0);\r\n    float e = hash(n+113.0);\r\n\tfloat f = hash(n+114.0);\r\n    float g = hash(n+270.0);\r\n    float h = hash(n+271.0);\r\n\t\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\r\n}\r\n\r\n//---------------------------------------------------------------\r\n\r\nvec4 sdBox( vec3 p, vec3 b ) // distance and normal\r\n{\r\n    vec3 d = abs(p) - b;\r\n    float x = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n    vec3  n = step(d.yzx,d.xyz)*step(d.zxy,d.xyz)*sign(p);\r\n    return vec4( x, n );\r\n}\r\n\r\nvec4 fbmd( in vec3 x )\r\n{\r\n    const float scale  = 1.5;\r\n\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n\tfloat f = 1.0;\r\n    vec3  d = vec3(0.0);\r\n    for( int i=0; i<8; i++ )\r\n    {\r\n        vec4 n = noised(f*x*scale);\r\n        a += b*n.x;           // accumulate values\t\t\r\n        d += b*n.yzw*f*scale; // accumulate derivatives\r\n        b *= 0.5;             // amplitude decrease\r\n        f *= 1.8;             // frequency increase\r\n    }\r\n\r\n\treturn vec4( a, d );\r\n}\r\n\r\nvec4 map( in vec3 p )\r\n{\r\n\tvec4 d1 = fbmd( p );\r\n    d1.x -= 0.37;\r\n\td1.x *= 0.7;\r\n    d1.yzw = normalize(d1.yzw);\r\n\r\n    // clip to box\r\n    vec4 d2 = sdBox( p, vec3(1.5) );\r\n    return (d1.x>d2.x) ? d1 : d2;\r\n}\r\n\r\n// ray-box intersection in box space\r\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \r\n{\r\n    vec3 m = 1.0/rd;\r\n    vec3 n = m*ro;\r\n    vec3 k = abs(m)*rad;\r\n    vec3 t1 = -n - k;\r\n    vec3 t2 = -n + k;\r\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\r\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\r\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\r\n\treturn vec2( tN, tF );\r\n}\r\n\r\n// raymarch\r\nvec4 interesect( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 res = vec4(-1.0);\r\n\r\n    // bounding volume    \r\n    vec2 dis = iBox( ro, rd, vec3(1.5) ) ;\r\n    if( dis.y<0.0 ) return res;\r\n\r\n    // raymarch\r\n    float tmax = dis.y;\r\n    float t = dis.x;\r\n\tfor( int i=0; i<128; i++ )\r\n\t{\r\n        vec3 pos = ro + t*rd;\r\n\t\tvec4 hnor = map( pos );\r\n        res = vec4(t,hnor.yzw);\r\n        \r\n\t\tif( hnor.x<0.001 ) break;\r\n\t\tt += hnor.x;\r\n        if( t>tmax ) break;\r\n\t}\r\n\r\n\tif( t>tmax ) res = vec4(-1.0);\r\n\treturn res;\r\n}\r\n\r\n// compute normal numerically\r\n#ifdef SHOW_NUMERICAL_NORMALS\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n\tvec2 eps = vec2( 0.0001, 0.0 );\r\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n#endif\r\n\r\n// fibonazzi points in s aphsre, more info:\r\n// http://lgdv.cs.fau.de/uploads/publications/spherical_fibonacci_mapping_opt.pdf\r\nvec3 forwardSF( float i, float n) \r\n{\r\n    const float PI  = 3.141592653589793238;\r\n    const float PHI = 1.618033988749894848;\r\n    float phi = 2.0*PI*fract(i/PHI);\r\n    float zi = 1.0 - (2.0*i+1.0)/n;\r\n    float sinTheta = sqrt( 1.0 - zi*zi);\r\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat ao = 0.0;\r\n    for( int i=0; i<32; i++ )\r\n    {\r\n        vec3 ap = forwardSF( float(i), 32.0 );\r\n        float h = hash(float(i));\r\n\t\tap *= sign( dot(ap,nor) ) * h*0.25;\r\n        ao += clamp( map( pos + nor*0.001 + ap ).x*3.0, 0.0, 1.0 );\r\n    }\r\n\tao /= 32.0;\r\n\t\r\n    return clamp( ao*5.0, 0.0, 1.0 );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\r\n   \r\n\t// camera anim\r\n    float an = 0.1*iTime;\r\n\tvec3 ro = 3.0*vec3( cos(an), 0.8, sin(an) );\r\n\tvec3 ta = vec3( 0.0 );\r\n\t\r\n    // camera matrix\t\r\n\tvec3  cw = normalize( ta-ro );\r\n\tvec3  cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\r\n\tvec3  cv = normalize( cross(cu,cw) );\r\n\tvec3  rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\r\n\r\n\t// render\r\n\tvec3 col = vec3(0.0);\r\n    vec4 tnor = interesect( ro, rd );\r\n\tfloat t = tnor.x;\r\n\r\n    if( t>0.0 )\r\n\t{\r\n\t\tvec3 pos = ro + t*rd;\r\n        #ifndef SHOW_NUMERICAL_NORMALS\r\n        vec3 nor = tnor.yzw; // no need to call calcNormal( pos );\r\n        #else\r\n        vec3 nor = calcNormal( pos );\r\n        #endif\r\n        float occ = calcAO( pos, nor );\r\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\r\n        float fro = clamp( dot(nor,-rd), 0.0, 1.0 );\r\n        col = mix( vec3(0.05,0.2,0.3), vec3(1.0,0.95,0.85), 0.5+0.5*nor.y );\r\n        //col = 0.5+0.5*nor;\r\n        col += 10.0*pow(fro,12.0)*(0.04+0.96*pow(fre,5.0));\r\n        col *= pow(vec3(occ),vec3(1.0,1.1,1.1) );\r\n\t}\r\n\r\n    col = sqrt(col);\r\n\t\r\n    fragColor=vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","inputs":[],"outputs":[],"code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Annotated Ray Tracing","id":"9b37e05ade204245a09c06921a913d6e","date":null,"viewed":0,"name":"Annotated Ray Tracing","description":"See https://www.tinycranes.com/blog/2015/05/annotated-realtime-raytracing/","likes":0,"published":null,"tags":["raytracing"," spheres"]},"ver":null,"info":{"Name":"Annotated Ray Tracing","id":"9b37e05ade204245a09c06921a913d6e","date":null,"viewed":0,"name":"Annotated Ray Tracing","description":"See https://www.tinycranes.com/blog/2015/05/annotated-realtime-raytracing/","likes":0,"published":null,"tags":["raytracing"," spheres"]},"renderpass":[{"Code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","inputs":[],"outputs":[],"code":"// Ray tracing is a topic I have always wanted to explore, but never really had\r\n// the opportunity to do so until now. What exactly is ray tracing? Consider a\r\n// lamp hanging from the ceiling. Light is constantly being emitted from the\r\n// lamp in the form of light rays, which bounce around the room until they hit\r\n// your eye. Ray tracing follows a similar concept by simulating the path of\r\n// light through a scene, except in reverse. There is no point in doing the math\r\n// for light rays you cannot see!\r\n\r\n// Algorithmically, ray tracing is very elegant. For each pixel, shoot a light\r\n// ray from the camera through each pixel on screen. If the ray collides with\r\n// geometry in the scene, create new rays that perform the same process for both\r\n// reflection, as in a mirror, and refraction, as in through water. Repeat\r\n// to your satisfaction.\r\n\r\n// Having worked extensively with OpenCL in the past, this seemed like a good\r\n// candidate to port to a parallel runtime on a GPU. Inspired by the [smallpt](http://www.kevinbeason.com/smallpt/#moreinfo)\r\n// line-by-line explanation, I decided to write a parallel ray tracer with\r\n// extensive annotations. The results are below ...\r\n\r\n// ![screenshot](/uploads/raytracer.png)\r\n\r\n// I start with a simple ray definition, consisting of an origin point and a\r\n// direction vector. I also define a directional light to illuminate my scene.\r\nstruct Ray {\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nstruct Light {\r\n    vec3 color;\r\n    vec3 direction;\r\n};\r\n\r\n// In real life, objects have many different material properties. Some objects\r\n// respond very differently to light than others. For instance, a sheet of paper\r\n// and a polished mirror. The former exhibits a strong *diffuse* response;\r\n// incoming light is reflected at many angles. The latter is an example of a\r\n// *specular* response, where incoming light is reflected in a single direction.\r\n// To model this, I create a basic material definition. Objects in my scene\r\n// share a single (RGB) color with diffuse and specular weights.\r\nstruct Material {\r\n    vec3 color;\r\n    float diffuse;\r\n    float specular;\r\n};\r\n\r\n// To render the scene, I need to know where a ray intersects with an object.\r\n// Since rays have infinite length from an origin, I can model the point of\r\n// intersection by storing the distance along the ray. I also need to store the\r\n// surface normal so I know which way to bounce! Once I create a ray, it loses\r\n// the concept of scene geometry, so one more thing I do is forward the surface\r\n// material properties.\r\nstruct Intersect {\r\n    float len;\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// The last data structures I create are for objects used to fill my scene. The\r\n// most basic object I can model is a sphere, which is defined as a radius at\r\n// some center position, with some material properties. To draw the floor, I\r\n// also define a simple horizontal plane centered at the origin, with a normal\r\n// vector pointing upwards.\r\nstruct Sphere {\r\n    float radius;\r\n    vec3 position;\r\n    Material material;\r\n};\r\n\r\nstruct Plane {\r\n    vec3 normal;\r\n    Material material;\r\n};\r\n\r\n// At this point, I define some global variables. A more advanced program might\r\n// pass these values in as uniforms, but for now, this is easier to tinker with.\r\n// Due to floating point precision errors, when a ray intersects geometry at a\r\n// surface, the point of intersection could possibly be just below the surface.\r\n// The subsequent reflection ray would then bounce off the *inside* wall of the\r\n// surface. This is known as self-intersection. When creating new rays, I\r\n// initialize them at a slightly offset origin to help mitigate this problem.\r\nconst float epsilon = 1e-3;\r\n\r\n// The classical ray tracing algorithm is recursive. However, GLSL does not\r\n// support recursion, so I instead use an iterative approach to control the\r\n// number of light bounces.\r\nconst int iterations = 16;\r\n\r\n// Next, I define an exposure time and gamma value. At this point, I also create\r\n// a basic directional light and define the ambient light color; the color here\r\n// is mostly a matter of taste. Basically ... lighting controls.\r\nconst float exposure = 1e-2;\r\nconst float gamma = 2.2;\r\nconst float intensity = 100.0;\r\nconst vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\r\n\r\n// For a Static Light\r\nLight light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\r\n\r\n// For a Rotating Light\r\n// Light light = Light(vec3(1.0) * intensity, normalize(\r\n//                vec3(-1.0 + 4.0 * cos(iTime), 4.75,\r\n//                      1.0 + 4.0 * sin(iTime))));\r\n\r\n// I strongly dislike this line. I needed to know when a ray hits or misses a\r\n// surface. If it hits geometry, I returned the point at the surface. Otherwise,\r\n// the ray misses all geometry and instead hits the sky box. In a language that\r\n// supports dynamic return values, I could `return false`, but that is not an\r\n// option in GLSL. In the interests of making progress, I created an intersect\r\n// of distance zero to represent a miss and moved on.\r\nconst Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\r\n\r\n// As indicated earlier, I implement ray tracing for spheres. I need to compute\r\n// the point at which a ray intersects with a sphere. [Line-Sphere](http://en.wikipedia.org/wiki/Line-sphere_intersection)\r\n// intersection is relatively straightforward. For reflection purposes, a ray\r\n// either hits or misses, so I need to check for no solutions, or two solutions.\r\n// In the latter case, I need to determine which solution is \"in front\" so I can\r\n// return an intersection of appropriate distance from the ray origin.\r\nIntersect intersect(Ray ray, Sphere sphere) {\r\n    // Check for a Negative Square Root\r\n    vec3 oc = sphere.position - ray.origin;\r\n    float l = dot(ray.direction, oc);\r\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\r\n    if (det < 0.0) return miss;\r\n\r\n    // Find the Closer of Two Solutions\r\n             float len = l - sqrt(det);\r\n    if (len < 0.0) len = l + sqrt(det);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\r\n}\r\n\r\n// Since I created a floor plane, I likewise have to handle reflections for\r\n// planes by implementing [Line-Plane](http://en.wikipedia.org/wiki/Line-plane_intersection)\r\n// intersection. I only care about the intersect for the purposes of reflection,\r\n// so I only check if the quotient is non-zero.\r\nIntersect intersect(Ray ray, Plane plane) {\r\n    float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\r\n    if (len < 0.0) return miss;\r\n    return Intersect(len, plane.normal, plane.material);\r\n}\r\n\r\n// In a *real* ray tracing renderer, geometry would be passed in from the host\r\n// as a mesh containing vertices, normals, and texture coordinates, but for the\r\n// sake of simplicity, I hand-coded the scene-graph. In this function, I take an\r\n// input ray and iterate through all geometry to determine intersections.\r\nIntersect trace(Ray ray) {\r\n    const int num_spheres = 3;\r\n    Sphere spheres[num_spheres];\r\n\r\n    // I initially started with the [smallpt](www.kevinbeason.com/smallpt/)\r\n    // scene definition, but soon found performance was abysmal on very large\r\n    // spheres. I kept the general format, modified to fit my data structures.\r\n\r\n    spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\r\n    spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\r\n    spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\r\n\r\n    // Since my ray tracing approach involves drawing to a 2D quad, I can no\r\n    // longer use the OpenGL Depth and Stencil buffers to control the draw\r\n    // order. Drawing is therefore sensitive to z-indexing, so I first intersect\r\n    // with the plane, then loop through all spheres back-to-front.\r\n\r\n    Intersect intersection = miss;\r\n    Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\r\n    if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\r\n    for (int i = 0; i < num_spheres; i++) {\r\n        Intersect sphere = intersect(ray, spheres[i]);\r\n        if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\r\n            intersection = sphere;\r\n    }\r\n    return intersection;\r\n}\r\n\r\n// This is the critical part of writing a ray tracer. I start with some empty\r\n// scratch vectors for color data and the Fresnel factor. I trace the scene with\r\n// using an input ray, and continue to fire new rays until the iteration depth\r\n// is reached, at which point I return the total sum of the color values from\r\n// computed at each bounce.\r\nvec3 radiance(Ray ray) {\r\n    vec3 color = vec3(0.0), fresnel = vec3(0.0);\r\n    vec3 mask = vec3(1.0);\r\n    for (int i = 0; i <= iterations; ++i) {\r\n        Intersect hit = trace(ray);\r\n\r\n        // This goes back to the dummy \"miss\" intersect. Basically, if the scene\r\n        // trace returns an intersection with either a diffuse or specular\r\n        // coefficient, then it has encountered a surface of a sphere or plane.\r\n        // Otherwise, the current ray has reached the ambient-colored sky box.\r\n\r\n        if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\r\n\r\n            // Here I use the [Schlick Approximation](http://en.wikipedia.org/wiki/Schlick's_approximation)\r\n            // to determine the Fresnel specular contribution factor, a measure\r\n            // of how much incoming light is reflected or refracted. I compute\r\n            // the Fresnel term and use a mask to track the fraction of\r\n            // reflected light in the current ray with respect to the original.\r\n\r\n            vec3 r0 = hit.material.color.rgb * hit.material.specular;\r\n            float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\r\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\r\n            mask *= fresnel;\r\n\r\n            // I handle shadows and diffuse colors next. I condensed this part\r\n            // into one conditional evaluation for brevity. Remember `epsilon`?\r\n            // I use it to trace a ray slightly offset from the point of\r\n            // intersection to the light source. If the shadow ray does not hit\r\n            // an object, it will be a \"miss\" as it hits the skybox. This means\r\n            // there are no objects between the point and the light, at which\r\n            // point I can add the diffuse color to the fragment color since the\r\n            // object is not in shadow.\r\n\r\n            if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\r\n                color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\r\n                       * hit.material.color.rgb * hit.material.diffuse\r\n                       * (1.0 - fresnel) * mask / fresnel;\r\n            }\r\n\r\n            // After computing diffuse colors, I then generate a new reflection\r\n            // ray and overwrite the original ray that was passed in as an\r\n            // argument to the radiance(...) function. Then I repeat until I\r\n            // reach the iteration depth.\r\n\r\n            vec3 reflection = reflect(ray.direction, hit.normal);\r\n            ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\r\n\r\n        } else {\r\n\r\n            // This is the other half of the tracing branch. If the trace failed\r\n            // to return an intersection with an attached material, then it is\r\n            // safe to assume that the ray points at the sky, or out of bounds\r\n            // of the scene. At this point I realized that real objects have a\r\n            // small sheen to them, so I hard-coded a small spotlight pointing\r\n            // in the same direction as the main light for pseudo-realism.\r\n\r\n            vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\r\n            color += mask * (ambient + spotlight); break;\r\n        }\r\n    }\r\n    return color;\r\n}\r\n\r\n// The main function primarily deals with organizing data from OpenGL into a\r\n// format that the ray tracer can use. For ray tracing, I need to fire a ray for\r\n// each pixel, or more precisely, a ray for every fragment. However, pixels to\r\n// fragment coordinates do not map one a one-to-one basis, so I need to divide\r\n// the fragment coordinates by the viewport resolution. I then offset that by a\r\n// fixed value to re-center the coordinate system.\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\r\n         uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // For each fragment, create a ray at a fixed point of origin directed at\r\n    // the coordinates of each fragment. The last thing before writing the color\r\n    // to the fragment is to post-process the pixel values using tone-mapping.\r\n    // In this case, I adjust for exposure and perform linear gamma correction.\r\n\r\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\r\n    fragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\r\n}\r\n\r\n// If all goes well, you should see an animated scene below!\r\n// <iframe src=\"https://www.shadertoy.com/embed/4ljGRd?gui=true&paused=false\"\r\n//         width=\"100%\" height=\"380px\" frameborder=\"0\" allowfullscreen></iframe>\r\n\r\n// This was my first foray into ray tracing. Originally, I wanted to write this\r\n// using the OpenGL Compute Shader. That was harder to setup than I originally\r\n// realized, and I spent a fair bit of time mucking around with OpenGL and cmake\r\n// before deciding to just sit down and start programming.\r\n\r\n// All things considered, this is a pretty limited ray tracer. Some low hanging\r\n// fruit might be to add anti-aliasing and soft shadows. The former was not an\r\n// issue until I ported this from a HiDPI display onto the WebGL canvas. The\r\n// latter involves finding a quality random number generator. Maybe a summer\r\n// project before I start working ...\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define BUMP 0\r\n\r\n#define PI acos(-1.0)\r\n#define TAU PI*2.0\r\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\r\n\r\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\r\n#define hash(n)fract(sin(n+1234.5)*55555.0)\r\n\r\nvec3 randVec(float n)\r\n{\r\n\tvec3 v=vec3(1,0,0);\r\n    v.xy*=rot(asin(hash(n)*2.-1.));\r\n    n+=123.0;\r\n    v.xz*=rot((hash(n)*2.-1.)*PI);\r\n\treturn v;\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    vec3 r=vec3(1,99,999);\r\n    vec4 s=dot(floor(p),r)+vec4(0,r.y,r.z,r.y+r.z);\r\n    p=smoothstep(0.,1.,fract(p));\r\n    s=mix(hash(s),hash(s+1.),p.x);\r\n    s.xy=mix(s.xz,s.yw,p.y);\r\n    return mix(s.x,s.y,p.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n   \tfloat n = 0.0;\r\n    float amp = 0.8;\r\n\tfor (int i=0; i<4; i++)\r\n\t{\r\n\t\tn += noise(p)*amp;\r\n\t\tamp *= 0.5;\r\n\t}\r\n\treturn min(n, 1.0);\r\n}\r\n\r\nfloat deRing(vec3 p)\r\n{\r\n    p.x-=clamp(p.x,-1.0,1.0);\r\n    return length(vec2(length(p.xy)-1.0,p.z))-0.5;\r\n}\r\n\r\nfloat deChain(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    vec3 q;\r\n    q=p;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q));\r\n    q=p;\r\n    q.x-=3.0;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q.xzy));\r\n#if BUMP\r\n    de+=fbm(p*5.0)*0.01;\r\n#endif\r\n    return de;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    for(float i=0.0; i<10.0; i++)\r\n    {\r\n        vec3 q = p;\r\n        q+=randVec(i*3.22)*10.0-5.0;\r\n        vec3 v = randVec(i+7753.2223);\r\n        vec3 w=normalize(v);\r\n        vec3 u=normalize(cross(w,v.yzx));\r\n        q *= mat3(u,cross(u,w),w);\r\n        de=min(de, deChain(q));\r\n    }    \r\n    return de;\r\n}\r\n\r\nvec3 calcNormal(vec3 pos){\r\n  vec2 e = vec2(1,-1) * 0.002;\r\n  return normalize(\r\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \r\n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\r\n  );\r\n}\r\n\r\n#define quantize(t, a)floor(t*a)/a\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\r\n    float s=uv.y;\r\n    float g=quantize(fract(uv.y+iTime*0.5),30.0);\r\n    uv.x += 0.1*sin(iTime*8.0+g*10.0)*\r\n        step(hash(floor(iTime*2.0))*0.4+0.6,hash(g))*\r\n        step(0.95,sin(iTime*0.5+1.5*sin(iTime*2.0)));\r\n    vec3 ro=vec3(0,5,-10);\r\n    ro= vec3(cos(iTime*0.5+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.8+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\r\n    ro*=3.5;\r\n    vec3 ta=vec3(3);\r\n    ta.xz*=rot(iTime);\r\n    ta.xy*=rot(iTime*0.3);\r\n    vec3 w = normalize(ta-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\r\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\r\n    vec3 col=vec3(0.12,0.1,0.03)+fbm(vec3(uv,iTime*0.5)*0.8)*0.3;\r\n    float t=1.0,d;\r\n    for(int i=0;i<96;i++)\r\n    {\r\n        t+=d=map(ro+rd*t);\r\n        if (d<0.001) break;\r\n    }\r\n    if(d<0.001)\r\n    {\r\n        vec3 p=ro+rd*t;\r\n        vec3 nor = calcNormal(p);\r\n        vec3 li = normalize(vec3(1));\r\n        vec3 bg=col;\r\n        col= vec3(1,0.95,0.85);\r\n        col*=exp2(-2.*pow(max(0.0, 1.0-map(p+nor*0.3)/0.3),2.0));\r\n        col*=max(0.,dot(nor,li));\r\n        col*=max(0.0,0.5+nor.y*0.5);\r\n        col+=pow(max(0.0,dot(reflect(normalize(p-ro),nor),li)),20.0);\r\n        col = mix(bg, col, exp(-t*t*0.0003));\r\n    }\r\n    col *= sin(s * 250.0 - iTime * 5.0) * 0.2 + 0.9;\r\n    fragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"#define BUMP 0\r\n\r\n#define PI acos(-1.0)\r\n#define TAU PI*2.0\r\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\r\n\r\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\r\n#define hash(n)fract(sin(n+1234.5)*55555.0)\r\n\r\nvec3 randVec(float n)\r\n{\r\n\tvec3 v=vec3(1,0,0);\r\n    v.xy*=rot(asin(hash(n)*2.-1.));\r\n    n+=123.0;\r\n    v.xz*=rot((hash(n)*2.-1.)*PI);\r\n\treturn v;\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    vec3 r=vec3(1,99,999);\r\n    vec4 s=dot(floor(p),r)+vec4(0,r.y,r.z,r.y+r.z);\r\n    p=smoothstep(0.,1.,fract(p));\r\n    s=mix(hash(s),hash(s+1.),p.x);\r\n    s.xy=mix(s.xz,s.yw,p.y);\r\n    return mix(s.x,s.y,p.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n   \tfloat n = 0.0;\r\n    float amp = 0.8;\r\n\tfor (int i=0; i<4; i++)\r\n\t{\r\n\t\tn += noise(p)*amp;\r\n\t\tamp *= 0.5;\r\n\t}\r\n\treturn min(n, 1.0);\r\n}\r\n\r\nfloat deRing(vec3 p)\r\n{\r\n    p.x-=clamp(p.x,-1.0,1.0);\r\n    return length(vec2(length(p.xy)-1.0,p.z))-0.5;\r\n}\r\n\r\nfloat deChain(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    vec3 q;\r\n    q=p;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q));\r\n    q=p;\r\n    q.x-=3.0;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q.xzy));\r\n#if BUMP\r\n    de+=fbm(p*5.0)*0.01;\r\n#endif\r\n    return de;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    for(float i=0.0; i<10.0; i++)\r\n    {\r\n        vec3 q = p;\r\n        q+=randVec(i*3.22)*10.0-5.0;\r\n        vec3 v = randVec(i+7753.2223);\r\n        vec3 w=normalize(v);\r\n        vec3 u=normalize(cross(w,v.yzx));\r\n        q *= mat3(u,cross(u,w),w);\r\n        de=min(de, deChain(q));\r\n    }    \r\n    return de;\r\n}\r\n\r\nvec3 calcNormal(vec3 pos){\r\n  vec2 e = vec2(1,-1) * 0.002;\r\n  return normalize(\r\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \r\n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\r\n  );\r\n}\r\n\r\n#define quantize(t, a)floor(t*a)/a\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\r\n    float s=uv.y;\r\n    float g=quantize(fract(uv.y+iTime*0.5),30.0);\r\n    uv.x += 0.1*sin(iTime*8.0+g*10.0)*\r\n        step(hash(floor(iTime*2.0))*0.4+0.6,hash(g))*\r\n        step(0.95,sin(iTime*0.5+1.5*sin(iTime*2.0)));\r\n    vec3 ro=vec3(0,5,-10);\r\n    ro= vec3(cos(iTime*0.5+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.8+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\r\n    ro*=3.5;\r\n    vec3 ta=vec3(3);\r\n    ta.xz*=rot(iTime);\r\n    ta.xy*=rot(iTime*0.3);\r\n    vec3 w = normalize(ta-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\r\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\r\n    vec3 col=vec3(0.12,0.1,0.03)+fbm(vec3(uv,iTime*0.5)*0.8)*0.3;\r\n    float t=1.0,d;\r\n    for(int i=0;i<96;i++)\r\n    {\r\n        t+=d=map(ro+rd*t);\r\n        if (d<0.001) break;\r\n    }\r\n    if(d<0.001)\r\n    {\r\n        vec3 p=ro+rd*t;\r\n        vec3 nor = calcNormal(p);\r\n        vec3 li = normalize(vec3(1));\r\n        vec3 bg=col;\r\n        col= vec3(1,0.95,0.85);\r\n        col*=exp2(-2.*pow(max(0.0, 1.0-map(p+nor*0.3)/0.3),2.0));\r\n        col*=max(0.,dot(nor,li));\r\n        col*=max(0.0,0.5+nor.y*0.5);\r\n        col+=pow(max(0.0,dot(reflect(normalize(p-ro),nor),li)),20.0);\r\n        col = mix(bg, col, exp(-t*t*0.0003));\r\n    }\r\n    col *= sin(s * 250.0 - iTime * 5.0) * 0.2 + 0.9;\r\n    fragColor = vec4(col, 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Blocked with chains","id":"12f19e8a384c47ad9bff11f467050212","date":null,"viewed":0,"name":"Blocked with chains","description":"Blocked with chains","likes":0,"published":null,"tags":[""]},"ver":null,"info":{"Name":"Blocked with chains","id":"12f19e8a384c47ad9bff11f467050212","date":null,"viewed":0,"name":"Blocked with chains","description":"Blocked with chains","likes":0,"published":null,"tags":[""]},"renderpass":[{"Code":"#define BUMP 0\r\n\r\n#define PI acos(-1.0)\r\n#define TAU PI*2.0\r\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\r\n\r\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\r\n#define hash(n)fract(sin(n+1234.5)*55555.0)\r\n\r\nvec3 randVec(float n)\r\n{\r\n\tvec3 v=vec3(1,0,0);\r\n    v.xy*=rot(asin(hash(n)*2.-1.));\r\n    n+=123.0;\r\n    v.xz*=rot((hash(n)*2.-1.)*PI);\r\n\treturn v;\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    vec3 r=vec3(1,99,999);\r\n    vec4 s=dot(floor(p),r)+vec4(0,r.y,r.z,r.y+r.z);\r\n    p=smoothstep(0.,1.,fract(p));\r\n    s=mix(hash(s),hash(s+1.),p.x);\r\n    s.xy=mix(s.xz,s.yw,p.y);\r\n    return mix(s.x,s.y,p.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n   \tfloat n = 0.0;\r\n    float amp = 0.8;\r\n\tfor (int i=0; i<4; i++)\r\n\t{\r\n\t\tn += noise(p)*amp;\r\n\t\tamp *= 0.5;\r\n\t}\r\n\treturn min(n, 1.0);\r\n}\r\n\r\nfloat deRing(vec3 p)\r\n{\r\n    p.x-=clamp(p.x,-1.0,1.0);\r\n    return length(vec2(length(p.xy)-1.0,p.z))-0.5;\r\n}\r\n\r\nfloat deChain(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    vec3 q;\r\n    q=p;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q));\r\n    q=p;\r\n    q.x-=3.0;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q.xzy));\r\n#if BUMP\r\n    de+=fbm(p*5.0)*0.01;\r\n#endif\r\n    return de;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    for(float i=0.0; i<10.0; i++)\r\n    {\r\n        vec3 q = p;\r\n        q+=randVec(i*3.22)*10.0-5.0;\r\n        vec3 v = randVec(i+7753.2223);\r\n        vec3 w=normalize(v);\r\n        vec3 u=normalize(cross(w,v.yzx));\r\n        q *= mat3(u,cross(u,w),w);\r\n        de=min(de, deChain(q));\r\n    }    \r\n    return de;\r\n}\r\n\r\nvec3 calcNormal(vec3 pos){\r\n  vec2 e = vec2(1,-1) * 0.002;\r\n  return normalize(\r\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \r\n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\r\n  );\r\n}\r\n\r\n#define quantize(t, a)floor(t*a)/a\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\r\n    float s=uv.y;\r\n    float g=quantize(fract(uv.y+iTime*0.5),30.0);\r\n    uv.x += 0.1*sin(iTime*8.0+g*10.0)*\r\n        step(hash(floor(iTime*2.0))*0.4+0.6,hash(g))*\r\n        step(0.95,sin(iTime*0.5+1.5*sin(iTime*2.0)));\r\n    vec3 ro=vec3(0,5,-10);\r\n    ro= vec3(cos(iTime*0.5+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.8+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\r\n    ro*=3.5;\r\n    vec3 ta=vec3(3);\r\n    ta.xz*=rot(iTime);\r\n    ta.xy*=rot(iTime*0.3);\r\n    vec3 w = normalize(ta-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\r\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\r\n    vec3 col=vec3(0.12,0.1,0.03)+fbm(vec3(uv,iTime*0.5)*0.8)*0.3;\r\n    float t=1.0,d;\r\n    for(int i=0;i<96;i++)\r\n    {\r\n        t+=d=map(ro+rd*t);\r\n        if (d<0.001) break;\r\n    }\r\n    if(d<0.001)\r\n    {\r\n        vec3 p=ro+rd*t;\r\n        vec3 nor = calcNormal(p);\r\n        vec3 li = normalize(vec3(1));\r\n        vec3 bg=col;\r\n        col= vec3(1,0.95,0.85);\r\n        col*=exp2(-2.*pow(max(0.0, 1.0-map(p+nor*0.3)/0.3),2.0));\r\n        col*=max(0.,dot(nor,li));\r\n        col*=max(0.0,0.5+nor.y*0.5);\r\n        col+=pow(max(0.0,dot(reflect(normalize(p-ro),nor),li)),20.0);\r\n        col = mix(bg, col, exp(-t*t*0.0003));\r\n    }\r\n    col *= sin(s * 250.0 - iTime * 5.0) * 0.2 + 0.9;\r\n    fragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"#define BUMP 0\r\n\r\n#define PI acos(-1.0)\r\n#define TAU PI*2.0\r\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\r\n\r\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\r\n#define hash(n)fract(sin(n+1234.5)*55555.0)\r\n\r\nvec3 randVec(float n)\r\n{\r\n\tvec3 v=vec3(1,0,0);\r\n    v.xy*=rot(asin(hash(n)*2.-1.));\r\n    n+=123.0;\r\n    v.xz*=rot((hash(n)*2.-1.)*PI);\r\n\treturn v;\r\n}\r\n\r\nfloat noise(vec3 p)\r\n{\r\n    vec3 r=vec3(1,99,999);\r\n    vec4 s=dot(floor(p),r)+vec4(0,r.y,r.z,r.y+r.z);\r\n    p=smoothstep(0.,1.,fract(p));\r\n    s=mix(hash(s),hash(s+1.),p.x);\r\n    s.xy=mix(s.xz,s.yw,p.y);\r\n    return mix(s.x,s.y,p.z);\r\n}\r\n\r\nfloat fbm(vec3 p)\r\n{\r\n   \tfloat n = 0.0;\r\n    float amp = 0.8;\r\n\tfor (int i=0; i<4; i++)\r\n\t{\r\n\t\tn += noise(p)*amp;\r\n\t\tamp *= 0.5;\r\n\t}\r\n\treturn min(n, 1.0);\r\n}\r\n\r\nfloat deRing(vec3 p)\r\n{\r\n    p.x-=clamp(p.x,-1.0,1.0);\r\n    return length(vec2(length(p.xy)-1.0,p.z))-0.5;\r\n}\r\n\r\nfloat deChain(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    vec3 q;\r\n    q=p;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q));\r\n    q=p;\r\n    q.x-=3.0;\r\n    q.x=opRepLim(q.x,6.0,8.0);\r\n    de=min(de, deRing(q.xzy));\r\n#if BUMP\r\n    de+=fbm(p*5.0)*0.01;\r\n#endif\r\n    return de;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float de = 1e9;\r\n    for(float i=0.0; i<10.0; i++)\r\n    {\r\n        vec3 q = p;\r\n        q+=randVec(i*3.22)*10.0-5.0;\r\n        vec3 v = randVec(i+7753.2223);\r\n        vec3 w=normalize(v);\r\n        vec3 u=normalize(cross(w,v.yzx));\r\n        q *= mat3(u,cross(u,w),w);\r\n        de=min(de, deChain(q));\r\n    }    \r\n    return de;\r\n}\r\n\r\nvec3 calcNormal(vec3 pos){\r\n  vec2 e = vec2(1,-1) * 0.002;\r\n  return normalize(\r\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \r\n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\r\n  );\r\n}\r\n\r\n#define quantize(t, a)floor(t*a)/a\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\r\n    float s=uv.y;\r\n    float g=quantize(fract(uv.y+iTime*0.5),30.0);\r\n    uv.x += 0.1*sin(iTime*8.0+g*10.0)*\r\n        step(hash(floor(iTime*2.0))*0.4+0.6,hash(g))*\r\n        step(0.95,sin(iTime*0.5+1.5*sin(iTime*2.0)));\r\n    vec3 ro=vec3(0,5,-10);\r\n    ro= vec3(cos(iTime*0.5+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.8+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\r\n    ro*=3.5;\r\n    vec3 ta=vec3(3);\r\n    ta.xz*=rot(iTime);\r\n    ta.xy*=rot(iTime*0.3);\r\n    vec3 w = normalize(ta-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\r\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\r\n    vec3 col=vec3(0.12,0.1,0.03)+fbm(vec3(uv,iTime*0.5)*0.8)*0.3;\r\n    float t=1.0,d;\r\n    for(int i=0;i<96;i++)\r\n    {\r\n        t+=d=map(ro+rd*t);\r\n        if (d<0.001) break;\r\n    }\r\n    if(d<0.001)\r\n    {\r\n        vec3 p=ro+rd*t;\r\n        vec3 nor = calcNormal(p);\r\n        vec3 li = normalize(vec3(1));\r\n        vec3 bg=col;\r\n        col= vec3(1,0.95,0.85);\r\n        col*=exp2(-2.*pow(max(0.0, 1.0-map(p+nor*0.3)/0.3),2.0));\r\n        col*=max(0.,dot(nor,li));\r\n        col*=max(0.0,0.5+nor.y*0.5);\r\n        col+=pow(max(0.0,dot(reflect(normalize(p-ro),nor),li)),20.0);\r\n        col = mix(bg, col, exp(-t*t*0.0003));\r\n    }\r\n    col *= sin(s * 250.0 - iTime * 5.0) * 0.2 + 0.9;\r\n    fragColor = vec4(col, 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Brush Experiment 3","id":"967daff3cc654ceba92483c53cab5825","date":null,"viewed":0,"name":"Brush Experiment 3","description":"Expanding on experiment 2, but for drawing circles. Mouse X controls falloff. Code is heavily commented showing the concept, not optimized at all.\nhttps://www.shadertoy.com/view/ltj3Wc","likes":0,"published":null,"tags":["2d"," brush"," calligraphy"]},"ver":null,"info":{"Name":"Brush Experiment 3","id":"967daff3cc654ceba92483c53cab5825","date":null,"viewed":0,"name":"Brush Experiment 3","description":"Expanding on experiment 2, but for drawing circles. Mouse X controls falloff. Code is heavily commented showing the concept, not optimized at all.\nhttps://www.shadertoy.com/view/ltj3Wc","likes":0,"published":null,"tags":["2d"," brush"," calligraphy"]},"renderpass":[{"Code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","inputs":[],"outputs":[],"code":"// todo: implement sweep amt\r\nvec2 mouse;\r\n\r\n////////////////////////////////////////////////////////////////\r\n// BOILERPLATE UTILITIES...................\r\nconst float pi = 3.14159;\r\nconst float pi2 = pi * 2.;\r\n\r\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\r\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\r\nfloat opI( float d1, float d2) { return max(d1,d2); }\r\n\r\n\r\n// from \"Magic Fractal\" by dgreensp\r\n// https://www.shadertoy.com/view/4ljGDd\r\nfloat magicBox(vec3 p) {\r\n    const int MAGIC_BOX_ITERS = 13;\r\n    const float MAGIC_BOX_MAGIC = 0.55;\r\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\r\n    // Take p anywhere in space and calculate the corresponding position\r\n    // inside the box, 0<(x,y,z)<1\r\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\r\n    \r\n    float lastLength = length(p);\r\n    float tot = 0.0;\r\n    // This is the fractal.  More iterations gives a more detailed\r\n    // fractal at the expense of more computation.\r\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\r\n      // The number subtracted here is a \"magic\" paremeter that\r\n      // produces rather different fractals for different values.\r\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\r\n      float newLength = length(p);\r\n      tot += abs(newLength-lastLength);\r\n      lastLength = newLength;\r\n    }\r\n\r\n    return tot;\r\n}\r\n\r\n\r\nfloat magicBox(vec2 uv){\r\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\r\n    // volume along the same axes as the fractal's bounding box.\r\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\r\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\r\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\r\n    vec3 p = 0.5*M*vec3(uv, 0.0);\r\n    return magicBox(p);\r\n}\r\n\r\n\r\n\r\n\r\nmat2 rot2D(float r)\r\n{\r\n    float c = cos(r), s = sin(r);\r\n    return mat2(c, s, -s, c);\r\n}\r\nfloat nsin(float a){return .5+.5*sin(a);}\r\nfloat ncos(float a){return .5+.5*cos(a);}\r\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\r\nfloat rand(vec2 co){\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\nfloat rand(float n){\r\n \treturn fract(cos(n*89.42)*343.42);\r\n}\r\nfloat dtoa(float d, float amount)\r\n{\r\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\r\n}\r\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\r\n{\r\n    vec2 d = max(tl-uv, uv-br);\r\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\r\n}\r\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\r\n{\r\n    return length(uv - origin) - radius;\r\n}\r\n// 0-1 1-0\r\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\r\n{\r\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\r\n}\r\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\r\nvec2 hash( vec2 p )\r\n{\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n}\r\n// returns -.5 to 1.5. i think.\r\nfloat noise( in vec2 p )\r\n{\r\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n\r\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\r\n\t\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n    vec2 b = a - o + K2;\r\n\tvec2 c = a - 1.0 + 2.0*K2;\r\n\r\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n\r\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n\r\n    return dot( n, vec3(70.0) );\t\r\n}\r\nfloat noise01(vec2 p)\r\n{\r\n    return clamp((noise(p)+.5)*.5, 0.,1.);\r\n}\r\n// debug function to convert distance to color, revealing sign.\r\nvec3 dtocolor(vec3 inpColor, float dist)\r\n{\r\n    vec3 ret;\r\n    if(dist > 0.)\r\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\r\n    else\r\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\r\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\r\n    return ret;\r\n}\r\n\r\nfloat smoothf(float x)\r\n{\r\n    return x*x*x*(x*(x*6. - 15.) + 10.);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////\r\n// APP CODE ...................\r\n\r\n// this function will produce a line with brush strokes. the inputs are such\r\n// that you can apply it to pretty much any line; the geometry is separated from this function.\r\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\r\n{\r\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\r\n\r\n    if(iMouse.z > 0.)\r\n    {\r\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\r\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\r\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\r\n    \tfloat okthen = 42.;// NOP\r\n    }\r\n    \r\n    // warp the position-in-line, to control the curve of the brush falloff.\r\n    if(posInLineY > 0.)\r\n    {\r\n        float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x);\r\n\t    posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\r\n    }\r\n\r\n    // brush stroke fibers effect.\r\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\r\n    float strokeTexture = 0.\r\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\r\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\r\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\r\n        ;\r\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\r\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\r\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\r\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\r\n    // fade out the end of the stroke by shifting the noise curve below 0\r\n    const float strokeAlphaBoost = 1.09;\r\n    if(posInLineY > 0.)\r\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5));// fade out\r\n    else\r\n        strokeAlpha *= strokeAlphaBoost;\r\n\r\n    strokeAlpha = smoothf(strokeAlpha);\r\n    \r\n    // paper bleed effect.\r\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\r\n//    amt = 500.;// disable paper bleed    \r\n    \r\n    // blotches (per stroke)\r\n    //float blotchAmt = smoothstep(17.,18.5,magicBox(vec3(uvPaper, uvLine.x)));\r\n    //blotchAmt *= 0.4;\r\n    //strokeAlpha += blotchAmt;\r\n\r\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\r\n    alpha = clamp(alpha, 0.,1.);\r\n    return mix(inpColor, brushColor.rgb, alpha);\r\n}\r\n\r\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\r\n{\r\n    // flatten the line to be axis-aligned.\r\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\r\n    mat2 rotMat = rot2D(lineAngle);\r\n\r\n    float lineLength = distance(p2_, p1_);\r\n    // make an axis-aligned line from this line.\r\n    vec2 tl = (p1_ * rotMat);// top left\r\n    vec2 br = tl + vec2(0,lineLength);// bottom right\r\n    vec2 uvLine = uv * rotMat;\r\n\r\n    // make line slightly narrower at end.\r\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\r\n    \r\n    // wobble it around, humanize\r\n    float res = min(iResolution.y,iResolution.x);\r\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\r\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\r\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n\r\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\r\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\r\n    uvLine = tl - uvLine;\r\n    \r\n    vec2 lineSize = vec2(lineWidth, lineLength);\r\n    \r\n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\r\n                                d, inpColor, brushColor);\r\n    return ret;\r\n}\r\n\r\n// returns:\r\n// xy = uvLine\r\n// z = radius\r\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\r\n{\r\n    vec2 humanizedUVLine = uvLine;\r\n    \r\n\t// offsetting the circle along its path creates a twisting effect.\r\n    float twistAmt = .24;\r\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\r\n    humanizedUVLine.x += linePosY * twistAmt;\r\n    \r\n    // perturb radius / x\r\n    float humanizedRadius = radius_;\r\n    float res = min(iResolution.y,iResolution.x);\r\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\r\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\r\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\r\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\r\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\r\n    \r\n    return vec3(humanizedUVLine, humanizedRadius);\r\n}\r\n\r\n// there's something about calling an Enso a \"donut\" that makes me giggle.\r\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\r\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\r\n{\r\n\tvec2 uvLine = uv - o;\r\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\r\n    angle = mod(angle-angleStart+pi, pi2);\r\n    if(!clockwise)\r\n        angle = pi2 - angle;\r\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\r\n    uvLine = vec2(\r\n        radius_ - length(uvLine),\r\n        angle / pi2 * lineLength\r\n    );\r\n    \r\n    // make line slightly narrower at end.\r\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\r\n    \r\n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n    vec2 humanizedUVLine = hu.xy;\r\n    float humanizedRadius = hu.z;\r\n\r\n    float d = opS(sdCircle(uv, o, humanizedRadius),\r\n                  sdCircle(uv, o, humanizedRadius));\r\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\r\n\r\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\r\n    \r\n    // do the same but for before the beginning of the line. distance field is just a single point\r\n    vec3 ret2 = vec3(1);\r\n    if(angle > pi)\r\n    {\r\n        uvLine.y -= lineLength;\r\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\r\n        humanizedUVLine = hu.xy;\r\n        humanizedRadius = hu.z;\r\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\r\n        d = distance(uv, strokeStartPos);\r\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\r\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\r\n\t}\r\n    return min(ret, ret2);\r\n}\r\n\r\n\r\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\r\n{\r\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\r\n    ret *= newSize;// scale up to new dimensions\r\n    float aspect = iResolution.x / iResolution.y;\r\n    ret.x *= aspect;// orig aspect ratio\r\n    float newWidth = newSize.x * aspect;\r\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvSignature = (fragCoord / iResolution.y * 2.0) - 1.;\r\n    mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2));// (iMouse.xy / iResolution.y * 2.0) - 1.;\r\n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));// 0-1 centered\r\n    \r\n    vec3 col = vec3(1.,1.,0.875);// bg\r\n    float dist;\r\n    \r\n\t// geometry on display...\r\n\tfloat yo = sin(-uv.x*pi*0.5)*0.2;\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red fixed line\r\n                           vec2(-1.4, -.4+yo),\r\n                           vec2(2.6, -.4+yo), 0.3);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red fixed line\r\n                           vec2(1.3, 0.+yo),\r\n                           vec2(-2.9, 0.+yo), 0.03);\r\n\r\n    col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red fixed line\r\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\r\n                           vec2(-2.9, .3+yo), 0.1);\r\n\r\n\r\n    col = colorBrushStrokeDonut(uv, col, vec4(0,0,0,.9),\r\n                                vec2(0,0),// origin\r\n                                0.6,// radius\r\n                                0.2,// angle of brush start\r\n                                0.5,// sweep amt 0-1\r\n                                0.3,// width\r\n                                false);// clockwise\r\n    \r\n    // paint blotches\r\n    float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.));// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\r\n    blotchAmt = pow(blotchAmt, 3.);// attenuate\r\n    blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\r\n    col *= 1.-blotchAmt;\r\n    \r\n\t// signature\r\n    dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55));\r\n    float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.);\r\n    float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047;\r\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt) * 0.3);\r\n    col = mix(col, vec3(0.8,.1, 0.0), dtoa(dist, amt*4.) * 0.95);\r\n\r\n    // grain\r\n    col.rgb += (rand(uv)-.5)*.08;\r\n    col.rgb = saturate(col.rgb);\r\n\r\n    // vignette\r\n    vec2 uvScreen = (fragCoord / iResolution.xy * 2.)-1.;\r\n\tfloat vignetteAmt = 1.-dot(uvScreen*0.5,uvScreen* 0.62);\r\n    col *= vignetteAmt;\r\n    \r\n    fragColor = vec4(col, 1.);\r\n}\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tuv.x *=  iResolution.x / iResolution.y;\r\n\r\n    // background\t \r\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\r\n\r\n    // bubbles\t\r\n\tfor( int i=0; i<40; i++ )\r\n\t{\r\n        // bubble seeds\r\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\r\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\r\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\r\n\r\n        // buble size, position and color\r\n\t\tfloat rad = 0.1 + 0.5*siz;\r\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\r\n\t\tfloat dis = length( uv - pos );\r\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\r\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\r\n\t\t\r\n        // render\r\n\t\tfloat f = length(uv-pos)/rad;\r\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\r\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\r\n\t}\r\n\r\n    // vigneting\t\r\n\tcolor *= sqrt(1.5-0.5*length(uv));\r\n\r\n\tfragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tuv.x *=  iResolution.x / iResolution.y;\r\n\r\n    // background\t \r\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\r\n\r\n    // bubbles\t\r\n\tfor( int i=0; i<40; i++ )\r\n\t{\r\n        // bubble seeds\r\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\r\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\r\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\r\n\r\n        // buble size, position and color\r\n\t\tfloat rad = 0.1 + 0.5*siz;\r\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\r\n\t\tfloat dis = length( uv - pos );\r\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\r\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\r\n\t\t\r\n        // render\r\n\t\tfloat f = length(uv-pos)/rad;\r\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\r\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\r\n\t}\r\n\r\n    // vigneting\t\r\n\tcolor *= sqrt(1.5-0.5*length(uv));\r\n\r\n\tfragColor = vec4(color,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Bubbles","id":"dfa31a54b7744220b2e60b7c18e337f1","date":null,"viewed":0,"name":"Bubbles","description":"Happy Bubbles ^_^\nhttps://www.shadertoy.com/view/4dl3zn","likes":0,"published":null,"tags":["2d"]},"ver":null,"info":{"Name":"Bubbles","id":"dfa31a54b7744220b2e60b7c18e337f1","date":null,"viewed":0,"name":"Bubbles","description":"Happy Bubbles ^_^\nhttps://www.shadertoy.com/view/4dl3zn","likes":0,"published":null,"tags":["2d"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tuv.x *=  iResolution.x / iResolution.y;\r\n\r\n    // background\t \r\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\r\n\r\n    // bubbles\t\r\n\tfor( int i=0; i<40; i++ )\r\n\t{\r\n        // bubble seeds\r\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\r\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\r\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\r\n\r\n        // buble size, position and color\r\n\t\tfloat rad = 0.1 + 0.5*siz;\r\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\r\n\t\tfloat dis = length( uv - pos );\r\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\r\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\r\n\t\t\r\n        // render\r\n\t\tfloat f = length(uv-pos)/rad;\r\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\r\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\r\n\t}\r\n\r\n    // vigneting\t\r\n\tcolor *= sqrt(1.5-0.5*length(uv));\r\n\r\n\tfragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\r\n\tuv.x *=  iResolution.x / iResolution.y;\r\n\r\n    // background\t \r\n\tvec3 color = vec3(0.8 + 0.2*uv.y);\r\n\r\n    // bubbles\t\r\n\tfor( int i=0; i<40; i++ )\r\n\t{\r\n        // bubble seeds\r\n\t\tfloat pha =      sin(float(i)*546.13+1.0)*0.5 + 0.5;\r\n\t\tfloat siz = pow( sin(float(i)*651.74+5.0)*0.5 + 0.5, 4.0 );\r\n\t\tfloat pox =      sin(float(i)*321.55+4.1) * iResolution.x / iResolution.y;\r\n\r\n        // buble size, position and color\r\n\t\tfloat rad = 0.1 + 0.5*siz;\r\n\t\tvec2  pos = vec2( pox, -1.0-rad + (2.0+2.0*rad)*mod(pha+0.1*iTime*(0.2+0.8*siz),1.0));\r\n\t\tfloat dis = length( uv - pos );\r\n\t\tvec3  col = mix( vec3(0.94,0.3,0.0), vec3(0.1,0.4,0.8), 0.5+0.5*sin(float(i)*1.2+1.9));\r\n\t\t//    col+= 8.0*smoothstep( rad*0.95, rad, dis );\r\n\t\t\r\n        // render\r\n\t\tfloat f = length(uv-pos)/rad;\r\n\t\tf = sqrt(clamp(1.0-f*f,0.0,1.0));\r\n\t\tcolor -= col.zyx *(1.0-smoothstep( rad*0.95, rad, dis )) * f;\r\n\t}\r\n\r\n    // vigneting\t\r\n\tcolor *= sqrt(1.5-0.5*length(uv));\r\n\r\n\tfragColor = vec4(color,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Bump Mapping","id":"3l3GWS","date":"1577616030","viewed":34,"name":"Bump Mapping","description":"\u51F9\u51F8\u8D34\u56FE","likes":2,"published":"Public","tags":["noise","bump"]},"ver":"0.1","info":{"Name":"Bump Mapping","id":"3l3GWS","date":"1577616030","viewed":34,"name":"Bump Mapping","description":"\u51F9\u51F8\u8D34\u56FE","likes":2,"published":"Public","tags":["noise","bump"]},"renderpass":[{"Code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0.0,0.0,0.0)\n#define SphereRadius 2.0\n\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nfloat getBumpMap(in vec2 uv){\n    uv *= 0.01;\n    return fractal_noise(uv)*25.23;\n}\n\nvec2 getPerturbationVector(in vec2 uv)\n{\n    vec2 size = vec2(.00001,0.0);\n    float  perturbationU = (getBumpMap(uv+size.xy) - getBumpMap(uv-size.xy))/(2.0*size.x);\n    float  perturbationV = (getBumpMap(uv+size.yx) - getBumpMap(uv-size.yx))/(2.0*size.x);\n    return vec2(perturbationU,perturbationV);\n}\n\nvec3 getSphereNormal(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    \n    vec3 nW = normalize(posLocal);\n    vec3 uW = normalize(vec3(-nW.z,0.0,nW.x));\n    vec3 vW = normalize(cross(nW,uW));\n    \n    vec2 uv = getSphereUV(pos);\n    vec2 perturbation = getPerturbationVector(uv);\n    vec3 n = nW + uW*perturbation.x + vW*perturbation.y;\n    n = normalize(n);\n    //n =  normalize(vec3(dot(n,uW),dot(n,vW),dot(n,nW)));\n    return n;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\nconst vec3 LightPos = vec3(5,5,5);\nconst vec3 LightColor = vec3(1,1,1);\nconst vec3 Ambient = vec3(0.4,0.4,0.4);\n\nvec3 lambert(in vec3 objColor, in vec3 pos, in vec3 normal, in vec3 view)\n{\n    float ka = 0.01;\n    float kd = 0.5;\n    float ks = 0.3;\n    float shininess = 7.0;\n    vec3 l = normalize(LightPos - pos);\n    vec3 ref = reflect(-l, normal);\n    vec3 a = ka * Ambient * objColor;\n    vec3 d = kd * LightColor * clamp(dot(normal, l),0.0,1.0) * objColor;\n    vec3 s = ks * LightColor * pow(clamp(dot(ref, view),0.0,1.0), shininess) * objColor;\n    return a + d+ s;\n}   \n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec3 n = getSphereNormal(pos);\n        col = lambert(vec3(0.6,0.99,0.7), pos, n, -rd);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3((3.0 + -3.0*mousePos.y) * cos(time + 6.0*mousePos.x), 2.0 , (3.0 + -3.0*mousePos.y) * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Catmull-Rom Spline Demo","id":"3tt3zS","date":"1576731439","viewed":48,"name":"Catmull-Rom Spline Demo","description":"Catmull-Rom\u6837\u6761\u7EBF\u63D2\u503C\u793A\u4F8B","likes":1,"published":"Public","tags":["spline","catmullrom","interpolating"]},"ver":"0.1","info":{"Name":"Catmull-Rom Spline Demo","id":"3tt3zS","date":"1576731439","viewed":48,"name":"Catmull-Rom Spline Demo","description":"Catmull-Rom\u6837\u6761\u7EBF\u63D2\u503C\u793A\u4F8B","likes":1,"published":"Public","tags":["spline","catmullrom","interpolating"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define _spline(x,nKnots,_knots) float _x = x;int _nKnots = nKnots;_x= clamp(_x,0.0,1.0);int _nspan = _nKnots - 3;_x = _x*float(_nspan);int _span = int(floor(_x));if(_span>=_nspan){_span = _nspan - 1;}_x -= float(_span);int _p0 = _span;int _p1 = _span+1;int _p2 = _span+2;int _p3 = _span+3;float _c3 = CR00*_knots[_p0] + CR01*_knots[_p1] + CR02*_knots[_p2] + CR03*_knots[_p3];float _c2 = CR10*_knots[_p0] + CR11*_knots[_p1] + CR12*_knots[_p2] + CR13*_knots[_p3];float _c1 = CR20*_knots[_p0] + CR21*_knots[_p1] + CR22*_knots[_p2] + CR23*_knots[_p3];float _c0 = CR30*_knots[_p0] + CR31*_knots[_p1] + CR32*_knots[_p2] + CR33*_knots[_p3]; v = ((_c3*_x+_c2)*_x+_c1)*_x+_c0;\n\nfloat spline(float x,int nKnots,float[6] knots){  \n    x = clamp(x,0.0,1.0);\n    int nspan = nKnots - 3;\n    \n    x = x*float(nspan);\n    int span = int(floor(x));\n    if(span>=nspan){\n        span = nspan - 1;\n    }\n    x -= float(span);\n    int p0 = span;\n    int p1 = span+1;\n    int p2 = span+2;\n    int p3 = span+3;\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.0 - 0.5;\n    \n    int nKnots = 6;\n    float knots[6];\n    knots[0]=1.2;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=-0.1;\n   \n    float v = 0.0;\n    if(uv.x > 0.0 && uv.x < 1.0) {\n        _spline(uv.x,nKnots,knots)\n        //v = spline(uv.x,nKnots,knots);\n        v *= 0.9;\n    }\n    \n    vec3 col = vec3(uv.y<v?1.0:0.0);\n    \n    int nspan = nKnots - 3;\n    for(int i = 0; i < nspan - 1; i++){\n         col *= smoothstep(0.0,0.005,abs(uv.x-1.0/float(nspan)*(float(i)+1.0)));\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\r\n/*\r\nvoid mainImage( out vec4 O, in vec2 U )    // compact version by FabriceNeyret2 (having problems with it on windows)\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         i = ceil(p);\r\n    O -= O - C(i-p) * D(i-p, .5 + .4 * sin( iDate.w*SPEED + (i.x+i.y)*FREQUENCY + vec2(1.6,0) ));\r\n}*/\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         f = fract(p);\r\n    p=floor(p);\r\n    float t=(p.x+p.y)*FREQUENCY\r\n           +iTime*SPEED;\r\n    vec2 o=vec2(cos(t),sin(t))*.4+.5;\r\n    O.xyz = vec3(C(f)*D(f,o));\r\n}","inputs":[],"outputs":[],"code":"#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\r\n/*\r\nvoid mainImage( out vec4 O, in vec2 U )    // compact version by FabriceNeyret2 (having problems with it on windows)\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         i = ceil(p);\r\n    O -= O - C(i-p) * D(i-p, .5 + .4 * sin( iDate.w*SPEED + (i.x+i.y)*FREQUENCY + vec2(1.6,0) ));\r\n}*/\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         f = fract(p);\r\n    p=floor(p);\r\n    float t=(p.x+p.y)*FREQUENCY\r\n           +iTime*SPEED;\r\n    vec2 o=vec2(cos(t),sin(t))*.4+.5;\r\n    O.xyz = vec3(C(f)*D(f,o));\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"CircleWave","id":"c904d7f2bbbc41099884298668c704b6","date":null,"viewed":0,"name":"CircleWave","description":"wave effect","likes":0,"published":null,"tags":["wavecircle2d"]},"ver":null,"info":{"Name":"CircleWave","id":"c904d7f2bbbc41099884298668c704b6","date":null,"viewed":0,"name":"CircleWave","description":"wave effect","likes":0,"published":null,"tags":["wavecircle2d"]},"renderpass":[{"Code":"#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\r\n/*\r\nvoid mainImage( out vec4 O, in vec2 U )    // compact version by FabriceNeyret2 (having problems with it on windows)\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         i = ceil(p);\r\n    O -= O - C(i-p) * D(i-p, .5 + .4 * sin( iDate.w*SPEED + (i.x+i.y)*FREQUENCY + vec2(1.6,0) ));\r\n}*/\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         f = fract(p);\r\n    p=floor(p);\r\n    float t=(p.x+p.y)*FREQUENCY\r\n           +iTime*SPEED;\r\n    vec2 o=vec2(cos(t),sin(t))*.4+.5;\r\n    O.xyz = vec3(C(f)*D(f,o));\r\n}","inputs":[],"outputs":[],"code":"#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\r\n/*\r\nvoid mainImage( out vec4 O, in vec2 U )    // compact version by FabriceNeyret2 (having problems with it on windows)\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         i = ceil(p);\r\n    O -= O - C(i-p) * D(i-p, .5 + .4 * sin( iDate.w*SPEED + (i.x+i.y)*FREQUENCY + vec2(1.6,0) ));\r\n}*/\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         f = fract(p);\r\n    p=floor(p);\r\n    float t=(p.x+p.y)*FREQUENCY\r\n           +iTime*SPEED;\r\n    vec2 o=vec2(cos(t),sin(t))*.4+.5;\r\n    O.xyz = vec3(C(f)*D(f,o));\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// inspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\n\r\n#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? 1.-d : 0. )\r\n//#define P(i)    if (i.y<10.) O.gb += D(i-p, .5 + r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0) ));\r\n#define P(i)    R = r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0)); if ((p-R).y<10.1) O.b++, O.g+= D(i-p,.5+R);\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    O -= O;\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         I = vec2(.5,0);\r\n  //float r = 1.*U.y/R.y;\r\n    float r = .5*exp(-4.*(.5-U.y/R.y));\r\n\r\n    P( ceil(p))\r\n    P((ceil(p+.5)-.5))\r\n    P((ceil(p+I)-I))\r\n\r\n}","inputs":[],"outputs":[],"code":"// inspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\n\r\n#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? 1.-d : 0. )\r\n//#define P(i)    if (i.y<10.) O.gb += D(i-p, .5 + r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0) ));\r\n#define P(i)    R = r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0)); if ((p-R).y<10.1) O.b++, O.g+= D(i-p,.5+R);\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    O -= O;\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         I = vec2(.5,0);\r\n  //float r = 1.*U.y/R.y;\r\n    float r = .5*exp(-4.*(.5-U.y/R.y));\r\n\r\n    P( ceil(p))\r\n    P((ceil(p+.5)-.5))\r\n    P((ceil(p+I)-I))\r\n\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"CircleWave2 ","id":"055a4349f6a2432f9100cc087ff82aef","date":null,"viewed":0,"name":"CircleWave2 ","description":"trochoid waves caused by dephased rotations of water.\r\ninspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\nhttps://www.shadertoy.com/view/Xd33DH","likes":0,"published":null,"tags":["waves"," trochoid"," incompressible"," gerstner"]},"ver":null,"info":{"Name":"CircleWave2 ","id":"055a4349f6a2432f9100cc087ff82aef","date":null,"viewed":0,"name":"CircleWave2 ","description":"trochoid waves caused by dephased rotations of water.\r\ninspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\nhttps://www.shadertoy.com/view/Xd33DH","likes":0,"published":null,"tags":["waves"," trochoid"," incompressible"," gerstner"]},"renderpass":[{"Code":"// inspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\n\r\n#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? 1.-d : 0. )\r\n//#define P(i)    if (i.y<10.) O.gb += D(i-p, .5 + r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0) ));\r\n#define P(i)    R = r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0)); if ((p-R).y<10.1) O.b++, O.g+= D(i-p,.5+R);\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    O -= O;\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         I = vec2(.5,0);\r\n  //float r = 1.*U.y/R.y;\r\n    float r = .5*exp(-4.*(.5-U.y/R.y));\r\n\r\n    P( ceil(p))\r\n    P((ceil(p+.5)-.5))\r\n    P((ceil(p+I)-I))\r\n\r\n}","inputs":[],"outputs":[],"code":"// inspired by RenoM's  https://www.shadertoy.com/view/4dc3D8\r\n\r\n#define SCALE 20.\r\n#define SPEED 9.\r\n#define FREQUENCY .3\r\n\r\nfloat d;\r\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? 1.-d : 0. )\r\n//#define P(i)    if (i.y<10.) O.gb += D(i-p, .5 + r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0) ));\r\n#define P(i)    R = r * sin( iDate.w*SPEED + i.x*FREQUENCY + vec2(1.6,0)); if ((p-R).y<10.1) O.b++, O.g+= D(i-p,.5+R);\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    O -= O;\r\n    vec2 R = iResolution.xy, \r\n         p = SCALE*(U+U/R)/R.y,\r\n         I = vec2(.5,0);\r\n  //float r = 1.*U.y/R.y;\r\n    float r = .5*exp(-4.*(.5-U.y/R.y));\r\n\r\n    P( ceil(p))\r\n    P((ceil(p+.5)-.5))\r\n    P((ceil(p+I)-I))\r\n\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\r\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\r\n\r\nvec2 sphere1Pos = vec2(0.,0.);\r\nfloat sphere1Rad = .7;         // sphere radius\r\n\r\nfloat planePos = .1;\r\n\r\nvec2 sphere2Pos = vec2(1.,0.);\r\nfloat sphere2Rad = .2;         \r\n\r\n// cloud appearance (superseeded by mouse tuning)\r\n\r\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\r\nfloat sharp = 0.3;            // cloud sharness (0= ultra sharp ).\r\n\r\n\r\n\r\n#define ANIM 1         // 1/0\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n    return fract(sin(n-765.36334)*43758.5453);\r\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE==1\r\n\treturn res;\r\n#elif NOISE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n\r\n// smooth distance to sphere = [-1,1] around radius +- thickness H\r\n\r\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\r\n{\r\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\r\n\tfloat d = (1.-length(p))/H;  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\t\r\n// smooth distance to plane = [-1,1] around plane +- thickness H\r\n\r\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\r\n{\r\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\r\n\tfloat d = -p.x/(H*planeRad);  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\r\n// smooth intersect operator\r\n\r\nfloat inter(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*d0*d1 -1.;\r\n}\r\n\r\n// smooth union operator\r\n\r\nfloat add(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*(d0+d1-d0*d1) -1.;\r\n}\r\n\r\n// jitter the distance around 0  and smoothclamp\r\n\r\nfloat perturb(vec2 p, float d, float H) {\r\n#if ANIM\r\n   float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\r\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\r\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\r\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\r\n\t\r\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\r\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\r\n}\r\n\r\n// convert [-1,1] distances into densities\r\n\r\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\r\n\treturn smoothstep(-sharp,sharp,d);\r\n}\r\n\r\n\r\n// user-define shape\r\n\t\r\nfloat shape(vec2 uv,float n) {\r\n\t\r\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\r\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\r\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\r\n\tfloat v;\r\n\r\n#define globalNoise false\r\n\t\r\n\tif (globalNoise || (n==0.)) {\r\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\r\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\r\n\t}\r\n\telse {\r\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\r\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\r\n\t}\r\n\t\r\n\treturn v;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = 2.* (fragCoord.xy / iResolution.y - vec2(.8,.5) );\r\n\tif (iMouse.z>0.) {       \t\t\t\t   // mouse tuning\r\n\t\tvec2 m = iMouse.xy / iResolution.xy;\r\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \r\n\t}\r\n\r\n\tfloat v = dist2dens( shape(uv,1.) ); \r\n\tvec3 col = vec3(v);\r\n\t\r\n\tif (uv.y<0.) {                   \t // bottom half scren: display bounds\r\n\t\t\r\n\t\tsharp = 1e-5; // no noise for bounds\r\n\t\tfloat d = shape(uv,0.), dv = fwidth(d);\r\n\t\t\r\n\t\tv = dist2dens(d-0.99+dv)-dist2dens(d-0.99); // inner bound : draw on top\r\n\t\tcol = mix(col, vec3(v,0.,0.),v);\t\r\n\t\t\r\n\t\tv = dist2dens(d+.5*dv)-dist2dens(d-.5*dv);  // mid-bound: draw on top\r\n\t\tcol = mix(col, vec3(0.,v,0.),v);\r\n\t\t\r\n\t\tv = dist2dens(d+.99)-dist2dens(d+0.99-dv);  // exterior bound : draw below\r\n\t\tfloat alpha = max(col.r,col.g);\r\n\t\tcol = mix(vec3(0.,0.,v),col, alpha);\t\r\n\t\talpha = max(col.b,alpha);\r\n\t\t\r\n\t\tv = dist2dens(sphere(uv, sphere1Pos, sphere1Rad)+.99); // sphere without plane clipping\r\n\t\tcol = mix(v*vec3(0.,0.,.3),col, alpha);\t\r\n\t}\r\n\t\r\n    fragColor = vec4(col,0.); \r\n}\r\n","inputs":[],"outputs":[],"code":"#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\r\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\r\n\r\nvec2 sphere1Pos = vec2(0.,0.);\r\nfloat sphere1Rad = .7;         // sphere radius\r\n\r\nfloat planePos = .1;\r\n\r\nvec2 sphere2Pos = vec2(1.,0.);\r\nfloat sphere2Rad = .2;         \r\n\r\n// cloud appearance (superseeded by mouse tuning)\r\n\r\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\r\nfloat sharp = 0.3;            // cloud sharness (0= ultra sharp ).\r\n\r\n\r\n\r\n#define ANIM 1         // 1/0\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n    return fract(sin(n-765.36334)*43758.5453);\r\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE==1\r\n\treturn res;\r\n#elif NOISE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n\r\n// smooth distance to sphere = [-1,1] around radius +- thickness H\r\n\r\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\r\n{\r\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\r\n\tfloat d = (1.-length(p))/H;  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\t\r\n// smooth distance to plane = [-1,1] around plane +- thickness H\r\n\r\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\r\n{\r\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\r\n\tfloat d = -p.x/(H*planeRad);  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\r\n// smooth intersect operator\r\n\r\nfloat inter(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*d0*d1 -1.;\r\n}\r\n\r\n// smooth union operator\r\n\r\nfloat add(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*(d0+d1-d0*d1) -1.;\r\n}\r\n\r\n// jitter the distance around 0  and smoothclamp\r\n\r\nfloat perturb(vec2 p, float d, float H) {\r\n#if ANIM\r\n   float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\r\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\r\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\r\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\r\n\t\r\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\r\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\r\n}\r\n\r\n// convert [-1,1] distances into densities\r\n\r\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\r\n\treturn smoothstep(-sharp,sharp,d);\r\n}\r\n\r\n\r\n// user-define shape\r\n\t\r\nfloat shape(vec2 uv,float n) {\r\n\t\r\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\r\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\r\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\r\n\tfloat v;\r\n\r\n#define globalNoise false\r\n\t\r\n\tif (globalNoise || (n==0.)) {\r\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\r\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\r\n\t}\r\n\telse {\r\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\r\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\r\n\t}\r\n\t\r\n\treturn v;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = 2.* (fragCoord.xy / iResolution.y - vec2(.8,.5) );\r\n\tif (iMouse.z>0.) {       \t\t\t\t   // mouse tuning\r\n\t\tvec2 m = iMouse.xy / iResolution.xy;\r\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \r\n\t}\r\n\r\n\tfloat v = dist2dens( shape(uv,1.) ); \r\n\tvec3 col = vec3(v);\r\n\t\r\n\tif (uv.y<0.) {                   \t // bottom half scren: display bounds\r\n\t\t\r\n\t\tsharp = 1e-5; // no noise for bounds\r\n\t\tfloat d = shape(uv,0.), dv = fwidth(d);\r\n\t\t\r\n\t\tv = dist2dens(d-0.99+dv)-dist2dens(d-0.99); // inner bound : draw on top\r\n\t\tcol = mix(col, vec3(v,0.,0.),v);\t\r\n\t\t\r\n\t\tv = dist2dens(d+.5*dv)-dist2dens(d-.5*dv);  // mid-bound: draw on top\r\n\t\tcol = mix(col, vec3(0.,v,0.),v);\r\n\t\t\r\n\t\tv = dist2dens(d+.99)-dist2dens(d+0.99-dv);  // exterior bound : draw below\r\n\t\tfloat alpha = max(col.r,col.g);\r\n\t\tcol = mix(vec3(0.,0.,v),col, alpha);\t\r\n\t\talpha = max(col.b,alpha);\r\n\t\t\r\n\t\tv = dist2dens(sphere(uv, sphere1Pos, sphere1Rad)+.99); // sphere without plane clipping\r\n\t\tcol = mix(v*vec3(0.,0.,.3),col, alpha);\t\r\n\t}\r\n\t\r\n    fragColor = vec4(col,0.); \r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"clipped disc hypertexture 1","id":"41ff66540f354e74b84c58880788dd2d","date":null,"viewed":0,"name":"clipped disc hypertexture 1","description":"hypertexture (here, sphere clipped by plane) with well controlled thickness, i.e., noise saturating the \"skin\" range.\nmouse.x tune noise layer thickness\nmouse.y tune noise bluriness\nSee #define for more tunings\nhttps://www.shadertoy.com/view/lssSRn","likes":0,"published":null,"tags":["procedural"]},"ver":null,"info":{"Name":"clipped disc hypertexture 1","id":"41ff66540f354e74b84c58880788dd2d","date":null,"viewed":0,"name":"clipped disc hypertexture 1","description":"hypertexture (here, sphere clipped by plane) with well controlled thickness, i.e., noise saturating the \"skin\" range.\nmouse.x tune noise layer thickness\nmouse.y tune noise bluriness\nSee #define for more tunings\nhttps://www.shadertoy.com/view/lssSRn","likes":0,"published":null,"tags":["procedural"]},"renderpass":[{"Code":"#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\r\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\r\n\r\nvec2 sphere1Pos = vec2(0.,0.);\r\nfloat sphere1Rad = .7;         // sphere radius\r\n\r\nfloat planePos = .1;\r\n\r\nvec2 sphere2Pos = vec2(1.,0.);\r\nfloat sphere2Rad = .2;         \r\n\r\n// cloud appearance (superseeded by mouse tuning)\r\n\r\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\r\nfloat sharp = 0.3;            // cloud sharness (0= ultra sharp ).\r\n\r\n\r\n\r\n#define ANIM 1         // 1/0\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n    return fract(sin(n-765.36334)*43758.5453);\r\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE==1\r\n\treturn res;\r\n#elif NOISE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n\r\n// smooth distance to sphere = [-1,1] around radius +- thickness H\r\n\r\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\r\n{\r\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\r\n\tfloat d = (1.-length(p))/H;  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\t\r\n// smooth distance to plane = [-1,1] around plane +- thickness H\r\n\r\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\r\n{\r\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\r\n\tfloat d = -p.x/(H*planeRad);  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\r\n// smooth intersect operator\r\n\r\nfloat inter(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*d0*d1 -1.;\r\n}\r\n\r\n// smooth union operator\r\n\r\nfloat add(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*(d0+d1-d0*d1) -1.;\r\n}\r\n\r\n// jitter the distance around 0  and smoothclamp\r\n\r\nfloat perturb(vec2 p, float d, float H) {\r\n#if ANIM\r\n   float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\r\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\r\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\r\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\r\n\t\r\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\r\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\r\n}\r\n\r\n// convert [-1,1] distances into densities\r\n\r\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\r\n\treturn smoothstep(-sharp,sharp,d);\r\n}\r\n\r\n\r\n// user-define shape\r\n\t\r\nfloat shape(vec2 uv,float n) {\r\n\t\r\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\r\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\r\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\r\n\tfloat v;\r\n\r\n#define globalNoise false\r\n\t\r\n\tif (globalNoise || (n==0.)) {\r\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\r\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\r\n\t}\r\n\telse {\r\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\r\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\r\n\t}\r\n\t\r\n\treturn v;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = 2.* (fragCoord.xy / iResolution.y - vec2(.8,.5) );\r\n\tif (iMouse.z>0.) {       \t\t\t\t   // mouse tuning\r\n\t\tvec2 m = iMouse.xy / iResolution.xy;\r\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \r\n\t}\r\n\r\n\tfloat v = dist2dens( shape(uv,1.) ); \r\n\tvec3 col = vec3(v);\r\n\t\r\n\tif (uv.y<0.) {                   \t // bottom half scren: display bounds\r\n\t\t\r\n\t\tsharp = 1e-5; // no noise for bounds\r\n\t\tfloat d = shape(uv,0.), dv = fwidth(d);\r\n\t\t\r\n\t\tv = dist2dens(d-0.99+dv)-dist2dens(d-0.99); // inner bound : draw on top\r\n\t\tcol = mix(col, vec3(v,0.,0.),v);\t\r\n\t\t\r\n\t\tv = dist2dens(d+.5*dv)-dist2dens(d-.5*dv);  // mid-bound: draw on top\r\n\t\tcol = mix(col, vec3(0.,v,0.),v);\r\n\t\t\r\n\t\tv = dist2dens(d+.99)-dist2dens(d+0.99-dv);  // exterior bound : draw below\r\n\t\tfloat alpha = max(col.r,col.g);\r\n\t\tcol = mix(vec3(0.,0.,v),col, alpha);\t\r\n\t\talpha = max(col.b,alpha);\r\n\t\t\r\n\t\tv = dist2dens(sphere(uv, sphere1Pos, sphere1Rad)+.99); // sphere without plane clipping\r\n\t\tcol = mix(v*vec3(0.,0.,.3),col, alpha);\t\r\n\t}\r\n\t\r\n    fragColor = vec4(col,0.); \r\n}\r\n","inputs":[],"outputs":[],"code":"#define GAIN 1.6 // >1 is unsafe, but up to 2 still looks ok (noise don t sature dynamics)\r\n#define NOISE 1 // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n// --- scene    ( screen = [-1.8, 1.8] x [-1, 1] )\r\n\r\nvec2 sphere1Pos = vec2(0.,0.);\r\nfloat sphere1Rad = .7;         // sphere radius\r\n\r\nfloat planePos = .1;\r\n\r\nvec2 sphere2Pos = vec2(1.,0.);\r\nfloat sphere2Rad = .2;         \r\n\r\n// cloud appearance (superseeded by mouse tuning)\r\n\r\nfloat H = .2;                 // skin layer thickness ( % of normalized sphere)\r\nfloat sharp = 0.3;            // cloud sharness (0= ultra sharp ).\r\n\r\n\r\n\r\n#define ANIM 1         // 1/0\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n    return fract(sin(n-765.36334)*43758.5453);\r\n    //return -1.+2.*fract(sin(n-765.36334)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE==1\r\n\treturn res;\r\n#elif NOISE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n\r\n// smooth distance to sphere = [-1,1] around radius +- thickness H\r\n\r\nfloat sphere(vec2 uv, vec2 spherePos, float sphereRad)\r\n{\r\n\tvec2 p = (uv-spherePos)/sphereRad; // pos in sphere normalized coordinates\r\n\tfloat d = (1.-length(p))/H;  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\t\r\n// smooth distance to plane = [-1,1] around plane +- thickness H\r\n\r\nfloat plane(vec2 uv, float planePos, float planeRad) // planeRad to share normalization with spheres\r\n{\r\n\tvec2 p = uv-vec2(planePos,0.); // pos in sphere normalized coordinates\r\n\tfloat d = -p.x/(H*planeRad);  \r\n\treturn clamp(d,-1.,1.);\r\n}\r\n\t\r\n// smooth intersect operator\r\n\r\nfloat inter(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;    \t //   [-1,1] -> [0,1], mul,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*d0*d1 -1.;\r\n}\r\n\r\n// smooth union operator\r\n\r\nfloat add(float d0, float d1) {\r\n\td0 = (1.+d0)/2.;     \t//   [-1,1] -> [0,1], add,  [0,1] -> [-1,1]\r\n\td1 = (1.+d1)/2.;\r\n\treturn 2.*(d0+d1-d0*d1) -1.;\r\n}\r\n\r\n// jitter the distance around 0  and smoothclamp\r\n\r\nfloat perturb(vec2 p, float d, float H) {\r\n#if ANIM\r\n   float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\r\n    //float fillfactor=0.; d = (d+1.)*fillfactor-1.;\r\n\tif (d<=-1.) return -1.;  \t\t\t// exterior\r\n\tif (d>= 1.) return 1.;   \t\t\t// interior (1 when H% inside radius )\r\n\t\r\n\tfloat n = 2.*fbm(vec3(p/H,t)) -1.;  // perturbation in [-1,1]\r\n\treturn  2.*(d + GAIN*n);   \t\t\t// still in [-1,1] :-)\r\n}\r\n\r\n// convert [-1,1] distances into densities\r\n\r\nfloat dist2dens(float d) {  \t// transition around zero. Tunable sharpness\r\n\treturn smoothstep(-sharp,sharp,d);\r\n}\r\n\r\n\r\n// user-define shape\r\n\t\r\nfloat shape(vec2 uv,float n) {\r\n\t\r\n\tfloat v1 = sphere(uv, sphere1Pos, sphere1Rad),\r\n\t\t  v2 = plane (uv, planePos,   sphere1Rad), // share normalization radius\r\n\t\t  v3 = sphere(uv, sphere2Pos, sphere2Rad);\r\n\tfloat v;\r\n\r\n#define globalNoise false\r\n\t\r\n\tif (globalNoise || (n==0.)) {\r\n\t\tv = add( inter(v1,v2), v3 );               // we combine smooth distances *then* perturbate\r\n\t\tif (n>0.) v = perturb(uv, v,H*sphere1Rad);\r\n\t}\r\n\telse {\r\n\t\tv = perturb(uv, inter(v1,v2), H*sphere1Rad); // we perturbate (with different coefs) *then* combine\r\n\t\tv = add( v, perturb(uv, v3 , H*sphere2Rad));\r\n\t}\r\n\t\r\n\treturn v;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = 2.* (fragCoord.xy / iResolution.y - vec2(.8,.5) );\r\n\tif (iMouse.z>0.) {       \t\t\t\t   // mouse tuning\r\n\t\tvec2 m = iMouse.xy / iResolution.xy;\r\n\t\tH = m.x+1e-5 ; sharp = m.y+1e-5; \r\n\t}\r\n\r\n\tfloat v = dist2dens( shape(uv,1.) ); \r\n\tvec3 col = vec3(v);\r\n\t\r\n\tif (uv.y<0.) {                   \t // bottom half scren: display bounds\r\n\t\t\r\n\t\tsharp = 1e-5; // no noise for bounds\r\n\t\tfloat d = shape(uv,0.), dv = fwidth(d);\r\n\t\t\r\n\t\tv = dist2dens(d-0.99+dv)-dist2dens(d-0.99); // inner bound : draw on top\r\n\t\tcol = mix(col, vec3(v,0.,0.),v);\t\r\n\t\t\r\n\t\tv = dist2dens(d+.5*dv)-dist2dens(d-.5*dv);  // mid-bound: draw on top\r\n\t\tcol = mix(col, vec3(0.,v,0.),v);\r\n\t\t\r\n\t\tv = dist2dens(d+.99)-dist2dens(d+0.99-dv);  // exterior bound : draw below\r\n\t\tfloat alpha = max(col.r,col.g);\r\n\t\tcol = mix(vec3(0.,0.,v),col, alpha);\t\r\n\t\talpha = max(col.b,alpha);\r\n\t\t\r\n\t\tv = dist2dens(sphere(uv, sphere1Pos, sphere1Rad)+.99); // sphere without plane clipping\r\n\t\tcol = mix(v*vec3(0.,0.,.3),col, alpha);\t\r\n\t}\r\n\t\r\n    fragColor = vec4(col,0.); \r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Naive texture fetching of atan() based UVs can create some\r\n// discontinuities in the derivatives (see a line of weird pixels\r\n// on the left side of the sccren if you enable NAIVE_IMPLEMENTATION\r\n// and if the viewport resolution is an odd number).\r\n//\r\n// This shader shows one way to fix it, in lines 41 and 42. More info:\r\n//\r\n// http://www.iquilezles.org/www/articles/tunnel/tunnel.htm\r\n\r\n\r\n#define NAIVE_IMPLEMENTATION\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\r\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fbm(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\r\n\r\nvec3 randomColorMap(in vec2 p){\r\n    return vec3(fbm(p),fbm(p+0.01),fbm(p+1.11));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized coordinates (-1 to 1 vertically)\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n\r\n    // angle of each pixel to the center of the screen\r\n    float a = atan(p.y,p.x);\r\n\r\n    #if 0\r\n    // cylindrical tunnel\r\n    float r = length(p);\r\n    #else\r\n    // squareish tunnel\r\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\r\n    #endif\r\n    \r\n    // index texture by (animated inverse) radious and angle\r\n    vec2 uv = vec2( 0.3/r + 0.2*iTime, a/3.1415927 );\r\n\r\n    #ifdef NAIVE_IMPLEMENTATION\r\n        // naive fecth color\r\n        vec3 col =  randomColorMap(uv);// texture( iChannel0, uv ).xyz;\r\n\t#else\r\n        // fetch color with correct texture gradients, to prevent discontinutity\r\n        vec2 uv2 = vec2( uv.x, atan(p.y,abs(p.x))/3.1415927 );\r\n        vec3 col = textureGrad( iChannel0, uv, dFdx(uv2), dFdy(uv2) ).xyz;\r\n\t#endif\r\n    \r\n    // darken at the center    \r\n    col = col*r;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Naive texture fetching of atan() based UVs can create some\r\n// discontinuities in the derivatives (see a line of weird pixels\r\n// on the left side of the sccren if you enable NAIVE_IMPLEMENTATION\r\n// and if the viewport resolution is an odd number).\r\n//\r\n// This shader shows one way to fix it, in lines 41 and 42. More info:\r\n//\r\n// http://www.iquilezles.org/www/articles/tunnel/tunnel.htm\r\n\r\n\r\n#define NAIVE_IMPLEMENTATION\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\r\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fbm(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\r\n\r\nvec3 randomColorMap(in vec2 p){\r\n    return vec3(fbm(p),fbm(p+0.01),fbm(p+1.11));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized coordinates (-1 to 1 vertically)\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n\r\n    // angle of each pixel to the center of the screen\r\n    float a = atan(p.y,p.x);\r\n\r\n    #if 0\r\n    // cylindrical tunnel\r\n    float r = length(p);\r\n    #else\r\n    // squareish tunnel\r\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\r\n    #endif\r\n    \r\n    // index texture by (animated inverse) radious and angle\r\n    vec2 uv = vec2( 0.3/r + 0.2*iTime, a/3.1415927 );\r\n\r\n    #ifdef NAIVE_IMPLEMENTATION\r\n        // naive fecth color\r\n        vec3 col =  randomColorMap(uv);// texture( iChannel0, uv ).xyz;\r\n\t#else\r\n        // fetch color with correct texture gradients, to prevent discontinutity\r\n        vec2 uv2 = vec2( uv.x, atan(p.y,abs(p.x))/3.1415927 );\r\n        vec3 col = textureGrad( iChannel0, uv, dFdx(uv2), dFdy(uv2) ).xyz;\r\n\t#endif\r\n    \r\n    // darken at the center    \r\n    col = col*r;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Deform - square tunnel","id":"af0d0884f7564ee3b2692b28a83d8b2c","date":null,"viewed":0,"name":"Deform - square tunnel","description":"A 2D square tunnel. If done naively, the tunnel will have a discontinuity in the left side of the screen where the atan() function branches. Taking derivatives on the right where there's no branch and applying them on the left side fixes the problem.\nhttps://www.shadertoy.com/view/Ms2SWW","likes":0,"published":null,"tags":["2d"," planedeformation"," deform"," distance"," metric"]},"ver":null,"info":{"Name":"Deform - square tunnel","id":"af0d0884f7564ee3b2692b28a83d8b2c","date":null,"viewed":0,"name":"Deform - square tunnel","description":"A 2D square tunnel. If done naively, the tunnel will have a discontinuity in the left side of the screen where the atan() function branches. Taking derivatives on the right where there's no branch and applying them on the left side fixes the problem.\nhttps://www.shadertoy.com/view/Ms2SWW","likes":0,"published":null,"tags":["2d"," planedeformation"," deform"," distance"," metric"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Naive texture fetching of atan() based UVs can create some\r\n// discontinuities in the derivatives (see a line of weird pixels\r\n// on the left side of the sccren if you enable NAIVE_IMPLEMENTATION\r\n// and if the viewport resolution is an odd number).\r\n//\r\n// This shader shows one way to fix it, in lines 41 and 42. More info:\r\n//\r\n// http://www.iquilezles.org/www/articles/tunnel/tunnel.htm\r\n\r\n\r\n#define NAIVE_IMPLEMENTATION\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\r\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fbm(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\r\n\r\nvec3 randomColorMap(in vec2 p){\r\n    return vec3(fbm(p),fbm(p+0.01),fbm(p+1.11));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized coordinates (-1 to 1 vertically)\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n\r\n    // angle of each pixel to the center of the screen\r\n    float a = atan(p.y,p.x);\r\n\r\n    #if 0\r\n    // cylindrical tunnel\r\n    float r = length(p);\r\n    #else\r\n    // squareish tunnel\r\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\r\n    #endif\r\n    \r\n    // index texture by (animated inverse) radious and angle\r\n    vec2 uv = vec2( 0.3/r + 0.2*iTime, a/3.1415927 );\r\n\r\n    #ifdef NAIVE_IMPLEMENTATION\r\n        // naive fecth color\r\n        vec3 col =  randomColorMap(uv);// texture( iChannel0, uv ).xyz;\r\n\t#else\r\n        // fetch color with correct texture gradients, to prevent discontinutity\r\n        vec2 uv2 = vec2( uv.x, atan(p.y,abs(p.x))/3.1415927 );\r\n        vec3 col = textureGrad( iChannel0, uv, dFdx(uv2), dFdy(uv2) ).xyz;\r\n\t#endif\r\n    \r\n    // darken at the center    \r\n    col = col*r;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Naive texture fetching of atan() based UVs can create some\r\n// discontinuities in the derivatives (see a line of weird pixels\r\n// on the left side of the sccren if you enable NAIVE_IMPLEMENTATION\r\n// and if the viewport resolution is an odd number).\r\n//\r\n// This shader shows one way to fix it, in lines 41 and 42. More info:\r\n//\r\n// http://www.iquilezles.org/www/articles/tunnel/tunnel.htm\r\n\r\n\r\n#define NAIVE_IMPLEMENTATION\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\r\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fbm(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\r\n\r\nvec3 randomColorMap(in vec2 p){\r\n    return vec3(fbm(p),fbm(p+0.01),fbm(p+1.11));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // normalized coordinates (-1 to 1 vertically)\r\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n\r\n    // angle of each pixel to the center of the screen\r\n    float a = atan(p.y,p.x);\r\n\r\n    #if 0\r\n    // cylindrical tunnel\r\n    float r = length(p);\r\n    #else\r\n    // squareish tunnel\r\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\r\n    #endif\r\n    \r\n    // index texture by (animated inverse) radious and angle\r\n    vec2 uv = vec2( 0.3/r + 0.2*iTime, a/3.1415927 );\r\n\r\n    #ifdef NAIVE_IMPLEMENTATION\r\n        // naive fecth color\r\n        vec3 col =  randomColorMap(uv);// texture( iChannel0, uv ).xyz;\r\n\t#else\r\n        // fetch color with correct texture gradients, to prevent discontinutity\r\n        vec2 uv2 = vec2( uv.x, atan(p.y,abs(p.x))/3.1415927 );\r\n        vec3 col = textureGrad( iChannel0, uv, dFdx(uv2), dFdy(uv2) ).xyz;\r\n\t#endif\r\n    \r\n    // darken at the center    \r\n    col = col*r;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// efficient distance to spline relying on the iterative construction of splines.\r\n\r\n#define POINTS 8  \t\t // number of control points\r\n\r\nconst int   SUBDIV=5;    // subdivision depth for the analytic method\r\nconst float sampl=120.; // number of samples per spline for the costly method\r\nfloat t;\r\n\r\nbool SHOW_MESH, SHOW_LINE, SHOW_GRAD, SHOW_ISO, SHOW_COSTLY;\r\n\r\n// --- GUI utils\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat cross2(vec2 v0, vec2 v1) {\treturn v0.x*v1.y - v0.y*v1.x; }\r\nfloat amin(float a, float b) { return (abs(a)<abs(b)) ? a : b ; }\r\nfloat amax(float a, float b) { return (abs(a)>abs(b)) ? a : b ; }\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n// --- dist pos to seg P0P1\r\n\r\nbool SIGNED_DIST = true; // if signed, positive distance is at left of oriented segment\r\nbool FLIP=false;         // for normalized turn direction (we want dist negative inside shape)\r\n\r\nfloat dist2seg(vec2 pos, vec2 P0, vec2 P1) {\r\n\tif (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }\r\n\tvec2 P0P1 = P1-P0, P0Pos = pos-P0;\r\n\tfloat d, l2_01=dist2(P0,P1);\r\n\r\n\t// --- if projection out of segment bounds, dist to extremity\r\n\t// Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)\r\n\tfloat l = dot(P0Pos, P0P1)/l2_01;\r\n\tif      (l <= 0.) return distance(pos,P0);\r\n\telse if (l >= 1.) return distance(pos,P1);\r\n\r\n\t// --- dist to seg = dist to line\r\n\telse if (SIGNED_DIST) \r\n\t    { float D = cross2(P0P1,P0Pos); return D/sqrt(l2_01); }\r\n\telse return distance(pos, P0+l*P0P1);\r\n}\r\n\r\n// --- min/max dist to quadrilateral P0P1P2P3 (possibly non-convex)\r\n\r\nvec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\r\n\r\n\tvec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;\r\n\r\n\t// makes the quadri convex if not: the 4 turns must have same sign.\r\n\t//    Note that alternate signs cannot happen (wouldn't loop), so possibility are:\r\n\t// all same, 1 different ('>'), 2 + then 2 - ('X').\r\n\t// for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.\r\n\r\n\t// measure turns direction\r\n#define ssign(v) (((v)>=0.) ? 1 : -1)\r\n\tint t0 = ssign(cross2(P30,P01)), t1 = ssign(cross2(P01,P12)),\t\r\n\t\tt2 = ssign(cross2(P12,P23)), t3 = ssign(cross2(P23,P30));\r\n\tif (SIGNED_DIST &&(t0>0)) // if direct, makes it indirect: we want negative inside\r\n\t\t{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } \r\n\telse  FLIP = false;\r\n\tint t = t0+t1+t2+t3; // sum of turn sign = +- 4, +-2 or 0.\r\n\t\r\n\tfloat d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), \r\n\t\t  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);\r\n\t// take care: dji != -dij at extremities since must be always positive outside\r\n\tfloat d0, d1;\r\n\t\r\n\tif ((t==4)||(t==-4)) // --- all same sign: P0P1P2P3 convex-> paths 0123, 30\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; } \r\n\r\n\telse {\r\n\t  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);\r\n\t  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;\r\n\r\n\t  if (t==0)         // --- 'X' shape\r\n\t\tif(t0==t1)  // swap 2 & 3 : P0P1P3P2 -> paths 013, 320\r\n\t\t    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }\r\n\t\t\t  d0 = amin(d01,d13);\t\t\t\t\td1 = amin(d02,d23); }\r\n\t    else \t    // swap 1 & 2 : P0P2P1P3-> paths 0213, 30\r\n\t\t\t{ d0 = amin( amin( d02, d21 ), d13);\td1 = d30; }\t\t\r\n\r\n\t  else  // t == +-2   //  --- '>' shape : one sign different -> bounding triangle\r\n\t\tif (t1*t<0)       // it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30\r\n\t\t\t{ d0 = amin( d02, d23);\t\t\t\t\td1 = d30; }\r\n\t\telse if (t2*t<0)  // it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30\r\n\t\t\t{ d0 = amin( d01, d13);\t\t\t\t\td1 = d30; }\r\n\t\telse              // it's P0 or P3: in facts, that's fine.\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; }\r\n\t  }\r\n\r\n\treturn vec2( amin(d0,d1), amax(d0,d1) );\r\n}\r\n\r\n\r\n// --- dist to spline - costly (for pixels where smart method failed )\r\n\r\n// TODO: - recursive subdivision\r\n//       - Newton iterations to  min dist\r\n//       - adaptive stepping (especially when used on small spline section)\r\n//       - sampling = diameter*pi*resolution\r\n// (anyway this function has negligible cost since rarely used).\r\nvec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tif (SHOW_COSTLY) return vec2(8.);\r\n\tfloat d = 1e5;\r\n\tfor (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),\r\n\t\t\t P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),\r\n\t\t\t P0123 = mix(P012,P123,x); // is on the spline\r\n\t\tvec2 D = P0123-pos;\r\n\t\td = min(d, dot(D,D));\r\n\t}\r\n\td = sqrt(d);\r\n\treturn vec2(d);\r\n}\r\n\r\n// --- dist to spline - iterative\r\n\r\nvec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tvec2 d0mM, d3mM;\r\n\tfor (int i=0; i<SUBDIV; i++) { // iterative subdivision\r\n\t\tif (i >= n) continue;\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),\r\n\t\t\t P012  = .5*(P01+P12),  P123 = .5*(P12+P23),\r\n\t\t\t P0123 = .5*(P012+P123); // is on the spline\r\n\r\n\t\t\r\n\t\td0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1\r\n\t\td3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2\r\n\t\t\r\n\t\tbool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);\r\n\t\td0mM = abs(d0mM); d3mM=  abs(d3mM);\r\n\t\t\t\r\n\t\tif (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )\r\n\t\t\treturn vec2(0.,float(i));    // draw skeleton\r\n\t\tfloat s;\r\n\r\n\r\n\t\t// inside one of the sub quadri\r\n\t\tif      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;\r\n\t\telse \r\n#if 1\r\n\t\tif (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer\r\n\t\telse if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer\r\n\t\t\telse // ambiguous\r\n\t\t\t  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method\r\n#else\r\n\t\t\tif (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)\r\n#endif\r\n\t\t\r\n\t\tif (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1\r\n\t\telse      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2\r\n   \t}\r\n\t\r\n\tif (n<0) // ambiguity found: switch to costly method\r\n\t\treturn dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); \r\n\t\r\n  \treturn dist2quadri(pos, P0,P1,P2,P3);\r\n}\r\n\r\n\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of control points and tangents.\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tt = iTime;\r\n    fragColor = vec4(0.);\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tvec2 Pc, Tc;\r\n\t\r\n\t// --- tuning \r\n\t\r\n\tvec2 mouse = 2.*(iMouse.xy  / iResolution.y - vec2(.8,.5));\r\n\tSIGNED_DIST = !keyToggle(64+19); \r\n\tfragColor.b += showFlag(vec2(-1.5,.9),uv,(mod(10.*t,2.)<1.))\r\n\t\t\t\t\t+ showFlag(vec2(-1.4,.9),uv,SIGNED_DIST);\r\n\t\r\n\tif (iMouse.z<=0.) {\r\n\t\tfloat fm = mod(.2*t,8.); int m=int(fm);\r\n\t\tSHOW_MESH   =  (mod(fm,2.)>=1.);\r\n\t\tSHOW_LINE   =  (m==2)||(m==3);\r\n\t\tSHOW_GRAD   =  (m==4)||(m==5);\r\n\t\tSHOW_ISO    =  (m==6)||(m==7);\r\n\t\tSHOW_COSTLY =  false;\r\n\t\tPc = P(0.); Tc = P(0.5);\r\n\t} else {\r\n\t\tSHOW_MESH   = keyToggle(64+13); // 'M'\r\n\t\tSHOW_LINE   = keyToggle(64+12); // 'L'\r\n\t\tSHOW_GRAD   = !keyToggle(64+7); // 'G'\r\n\t\tSHOW_ISO    = keyToggle(64+9);  // 'I'\t\r\n\t\tSHOW_COSTLY = keyToggle(64+3);  // 'C'\t\r\n\t\tPc = mouse; Tc = vec2(1.);\r\n\t}\r\n\t\r\n\t\r\n\t// --- dist to spline \r\n\t// TODO:\r\n\t//    - first select possible splines\r\n\t//    - parallel descent in the vector of splines\r\n\t\r\n\tvec2 dmMi[POINTS];\r\n\tvec2 dmM = vec2(1e5);\r\n\tvec2 P0, T0, P3=Pc, T3=Tc;\r\n#if 0\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\t\tfloat d0=dist2(uv,P0), d1=dist2(uv,P0+T0), d2=dist2(uv,P3-T3), d3=dist2(uv,P3);\r\n\t\tfloat dmi = min(min(d0,d1),min(d2,d3)), dMi = max(max(d0,d1),max(d2,d3));\r\n\t\tdmMi[int(i)] = vec2(dmi, dMi);\r\n\t}\r\n#endif\r\n\t\r\n\tdmM = vec2(1e5);\r\n\tP3=Pc, T3=Tc;\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\r\n\t\tvec2 dmMi = abs(dist2spline(uv, P0,P0+T0,P3-T3,P3, SUBDIV)); // draw spline i\r\n\r\n\t\tif (dmMi.x==0.) // display mesh\r\n\t\t\t{ fragColor=mix(vec4(1),vec4(0.,0.,1.,0.),dmMi.y/3.); return; } \r\n\t\tif (dmMi.x==8.) // display ambiguous parts\r\n\t\t\t{ fragColor=vec4(.15,0.,0.,0.); return; } \r\n\t\tdmM = min (dmM, dmMi);\r\n\t}\r\n\t\r\n\t\r\n\t// --- display\r\n\t\r\n\tvec3 col = 1.-abs(vec3(dmM,.5*(dmM.x+dmM.y))); \r\n\tif (SHOW_LINE) col = pow(col, vec3(16.));\r\n\tif (SHOW_ISO ) col = sin(100.*col);\r\n\tif (SHOW_GRAD) col.xy = .5+.5*normalize(vec2(dFdx(col.z),dFdy(col.z)));\r\n\t\r\n\tfragColor += vec4(col.xy, 0.,1.);\r\n}","inputs":[],"outputs":[],"code":"// efficient distance to spline relying on the iterative construction of splines.\r\n\r\n#define POINTS 8  \t\t // number of control points\r\n\r\nconst int   SUBDIV=5;    // subdivision depth for the analytic method\r\nconst float sampl=120.; // number of samples per spline for the costly method\r\nfloat t;\r\n\r\nbool SHOW_MESH, SHOW_LINE, SHOW_GRAD, SHOW_ISO, SHOW_COSTLY;\r\n\r\n// --- GUI utils\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat cross2(vec2 v0, vec2 v1) {\treturn v0.x*v1.y - v0.y*v1.x; }\r\nfloat amin(float a, float b) { return (abs(a)<abs(b)) ? a : b ; }\r\nfloat amax(float a, float b) { return (abs(a)>abs(b)) ? a : b ; }\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n// --- dist pos to seg P0P1\r\n\r\nbool SIGNED_DIST = true; // if signed, positive distance is at left of oriented segment\r\nbool FLIP=false;         // for normalized turn direction (we want dist negative inside shape)\r\n\r\nfloat dist2seg(vec2 pos, vec2 P0, vec2 P1) {\r\n\tif (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }\r\n\tvec2 P0P1 = P1-P0, P0Pos = pos-P0;\r\n\tfloat d, l2_01=dist2(P0,P1);\r\n\r\n\t// --- if projection out of segment bounds, dist to extremity\r\n\t// Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)\r\n\tfloat l = dot(P0Pos, P0P1)/l2_01;\r\n\tif      (l <= 0.) return distance(pos,P0);\r\n\telse if (l >= 1.) return distance(pos,P1);\r\n\r\n\t// --- dist to seg = dist to line\r\n\telse if (SIGNED_DIST) \r\n\t    { float D = cross2(P0P1,P0Pos); return D/sqrt(l2_01); }\r\n\telse return distance(pos, P0+l*P0P1);\r\n}\r\n\r\n// --- min/max dist to quadrilateral P0P1P2P3 (possibly non-convex)\r\n\r\nvec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\r\n\r\n\tvec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;\r\n\r\n\t// makes the quadri convex if not: the 4 turns must have same sign.\r\n\t//    Note that alternate signs cannot happen (wouldn't loop), so possibility are:\r\n\t// all same, 1 different ('>'), 2 + then 2 - ('X').\r\n\t// for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.\r\n\r\n\t// measure turns direction\r\n#define ssign(v) (((v)>=0.) ? 1 : -1)\r\n\tint t0 = ssign(cross2(P30,P01)), t1 = ssign(cross2(P01,P12)),\t\r\n\t\tt2 = ssign(cross2(P12,P23)), t3 = ssign(cross2(P23,P30));\r\n\tif (SIGNED_DIST &&(t0>0)) // if direct, makes it indirect: we want negative inside\r\n\t\t{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } \r\n\telse  FLIP = false;\r\n\tint t = t0+t1+t2+t3; // sum of turn sign = +- 4, +-2 or 0.\r\n\t\r\n\tfloat d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), \r\n\t\t  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);\r\n\t// take care: dji != -dij at extremities since must be always positive outside\r\n\tfloat d0, d1;\r\n\t\r\n\tif ((t==4)||(t==-4)) // --- all same sign: P0P1P2P3 convex-> paths 0123, 30\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; } \r\n\r\n\telse {\r\n\t  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);\r\n\t  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;\r\n\r\n\t  if (t==0)         // --- 'X' shape\r\n\t\tif(t0==t1)  // swap 2 & 3 : P0P1P3P2 -> paths 013, 320\r\n\t\t    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }\r\n\t\t\t  d0 = amin(d01,d13);\t\t\t\t\td1 = amin(d02,d23); }\r\n\t    else \t    // swap 1 & 2 : P0P2P1P3-> paths 0213, 30\r\n\t\t\t{ d0 = amin( amin( d02, d21 ), d13);\td1 = d30; }\t\t\r\n\r\n\t  else  // t == +-2   //  --- '>' shape : one sign different -> bounding triangle\r\n\t\tif (t1*t<0)       // it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30\r\n\t\t\t{ d0 = amin( d02, d23);\t\t\t\t\td1 = d30; }\r\n\t\telse if (t2*t<0)  // it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30\r\n\t\t\t{ d0 = amin( d01, d13);\t\t\t\t\td1 = d30; }\r\n\t\telse              // it's P0 or P3: in facts, that's fine.\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; }\r\n\t  }\r\n\r\n\treturn vec2( amin(d0,d1), amax(d0,d1) );\r\n}\r\n\r\n\r\n// --- dist to spline - costly (for pixels where smart method failed )\r\n\r\n// TODO: - recursive subdivision\r\n//       - Newton iterations to  min dist\r\n//       - adaptive stepping (especially when used on small spline section)\r\n//       - sampling = diameter*pi*resolution\r\n// (anyway this function has negligible cost since rarely used).\r\nvec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tif (SHOW_COSTLY) return vec2(8.);\r\n\tfloat d = 1e5;\r\n\tfor (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),\r\n\t\t\t P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),\r\n\t\t\t P0123 = mix(P012,P123,x); // is on the spline\r\n\t\tvec2 D = P0123-pos;\r\n\t\td = min(d, dot(D,D));\r\n\t}\r\n\td = sqrt(d);\r\n\treturn vec2(d);\r\n}\r\n\r\n// --- dist to spline - iterative\r\n\r\nvec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tvec2 d0mM, d3mM;\r\n\tfor (int i=0; i<SUBDIV; i++) { // iterative subdivision\r\n\t\tif (i >= n) continue;\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),\r\n\t\t\t P012  = .5*(P01+P12),  P123 = .5*(P12+P23),\r\n\t\t\t P0123 = .5*(P012+P123); // is on the spline\r\n\r\n\t\t\r\n\t\td0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1\r\n\t\td3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2\r\n\t\t\r\n\t\tbool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);\r\n\t\td0mM = abs(d0mM); d3mM=  abs(d3mM);\r\n\t\t\t\r\n\t\tif (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )\r\n\t\t\treturn vec2(0.,float(i));    // draw skeleton\r\n\t\tfloat s;\r\n\r\n\r\n\t\t// inside one of the sub quadri\r\n\t\tif      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;\r\n\t\telse \r\n#if 1\r\n\t\tif (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer\r\n\t\telse if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer\r\n\t\t\telse // ambiguous\r\n\t\t\t  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method\r\n#else\r\n\t\t\tif (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)\r\n#endif\r\n\t\t\r\n\t\tif (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1\r\n\t\telse      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2\r\n   \t}\r\n\t\r\n\tif (n<0) // ambiguity found: switch to costly method\r\n\t\treturn dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); \r\n\t\r\n  \treturn dist2quadri(pos, P0,P1,P2,P3);\r\n}\r\n\r\n\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of control points and tangents.\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tt = iTime;\r\n    fragColor = vec4(0.);\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tvec2 Pc, Tc;\r\n\t\r\n\t// --- tuning \r\n\t\r\n\tvec2 mouse = 2.*(iMouse.xy  / iResolution.y - vec2(.8,.5));\r\n\tSIGNED_DIST = !keyToggle(64+19); \r\n\tfragColor.b += showFlag(vec2(-1.5,.9),uv,(mod(10.*t,2.)<1.))\r\n\t\t\t\t\t+ showFlag(vec2(-1.4,.9),uv,SIGNED_DIST);\r\n\t\r\n\tif (iMouse.z<=0.) {\r\n\t\tfloat fm = mod(.2*t,8.); int m=int(fm);\r\n\t\tSHOW_MESH   =  (mod(fm,2.)>=1.);\r\n\t\tSHOW_LINE   =  (m==2)||(m==3);\r\n\t\tSHOW_GRAD   =  (m==4)||(m==5);\r\n\t\tSHOW_ISO    =  (m==6)||(m==7);\r\n\t\tSHOW_COSTLY =  false;\r\n\t\tPc = P(0.); Tc = P(0.5);\r\n\t} else {\r\n\t\tSHOW_MESH   = keyToggle(64+13); // 'M'\r\n\t\tSHOW_LINE   = keyToggle(64+12); // 'L'\r\n\t\tSHOW_GRAD   = !keyToggle(64+7); // 'G'\r\n\t\tSHOW_ISO    = keyToggle(64+9);  // 'I'\t\r\n\t\tSHOW_COSTLY = keyToggle(64+3);  // 'C'\t\r\n\t\tPc = mouse; Tc = vec2(1.);\r\n\t}\r\n\t\r\n\t\r\n\t// --- dist to spline \r\n\t// TODO:\r\n\t//    - first select possible splines\r\n\t//    - parallel descent in the vector of splines\r\n\t\r\n\tvec2 dmMi[POINTS];\r\n\tvec2 dmM = vec2(1e5);\r\n\tvec2 P0, T0, P3=Pc, T3=Tc;\r\n#if 0\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\t\tfloat d0=dist2(uv,P0), d1=dist2(uv,P0+T0), d2=dist2(uv,P3-T3), d3=dist2(uv,P3);\r\n\t\tfloat dmi = min(min(d0,d1),min(d2,d3)), dMi = max(max(d0,d1),max(d2,d3));\r\n\t\tdmMi[int(i)] = vec2(dmi, dMi);\r\n\t}\r\n#endif\r\n\t\r\n\tdmM = vec2(1e5);\r\n\tP3=Pc, T3=Tc;\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\r\n\t\tvec2 dmMi = abs(dist2spline(uv, P0,P0+T0,P3-T3,P3, SUBDIV)); // draw spline i\r\n\r\n\t\tif (dmMi.x==0.) // display mesh\r\n\t\t\t{ fragColor=mix(vec4(1),vec4(0.,0.,1.,0.),dmMi.y/3.); return; } \r\n\t\tif (dmMi.x==8.) // display ambiguous parts\r\n\t\t\t{ fragColor=vec4(.15,0.,0.,0.); return; } \r\n\t\tdmM = min (dmM, dmMi);\r\n\t}\r\n\t\r\n\t\r\n\t// --- display\r\n\t\r\n\tvec3 col = 1.-abs(vec3(dmM,.5*(dmM.x+dmM.y))); \r\n\tif (SHOW_LINE) col = pow(col, vec3(16.));\r\n\tif (SHOW_ISO ) col = sin(100.*col);\r\n\tif (SHOW_GRAD) col.xy = .5+.5*normalize(vec2(dFdx(col.z),dFdy(col.z)));\r\n\t\r\n\tfragColor += vec4(col.xy, 0.,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"dist 2 spline #3","id":"4df813e55f664882847b2110f1d2e851","date":null,"viewed":0,"name":"dist 2 spline #3","description":"M: toggles construction mesh     L: toggles distance field / thin line\nG: show gradient                        I: show isolines\nC: shows parts drawn with the costly algo","likes":0,"published":null,"tags":[" spline"]},"ver":null,"info":{"Name":"dist 2 spline #3","id":"4df813e55f664882847b2110f1d2e851","date":null,"viewed":0,"name":"dist 2 spline #3","description":"M: toggles construction mesh     L: toggles distance field / thin line\nG: show gradient                        I: show isolines\nC: shows parts drawn with the costly algo","likes":0,"published":null,"tags":[" spline"]},"renderpass":[{"Code":"// efficient distance to spline relying on the iterative construction of splines.\r\n\r\n#define POINTS 8  \t\t // number of control points\r\n\r\nconst int   SUBDIV=5;    // subdivision depth for the analytic method\r\nconst float sampl=120.; // number of samples per spline for the costly method\r\nfloat t;\r\n\r\nbool SHOW_MESH, SHOW_LINE, SHOW_GRAD, SHOW_ISO, SHOW_COSTLY;\r\n\r\n// --- GUI utils\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat cross2(vec2 v0, vec2 v1) {\treturn v0.x*v1.y - v0.y*v1.x; }\r\nfloat amin(float a, float b) { return (abs(a)<abs(b)) ? a : b ; }\r\nfloat amax(float a, float b) { return (abs(a)>abs(b)) ? a : b ; }\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n// --- dist pos to seg P0P1\r\n\r\nbool SIGNED_DIST = true; // if signed, positive distance is at left of oriented segment\r\nbool FLIP=false;         // for normalized turn direction (we want dist negative inside shape)\r\n\r\nfloat dist2seg(vec2 pos, vec2 P0, vec2 P1) {\r\n\tif (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }\r\n\tvec2 P0P1 = P1-P0, P0Pos = pos-P0;\r\n\tfloat d, l2_01=dist2(P0,P1);\r\n\r\n\t// --- if projection out of segment bounds, dist to extremity\r\n\t// Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)\r\n\tfloat l = dot(P0Pos, P0P1)/l2_01;\r\n\tif      (l <= 0.) return distance(pos,P0);\r\n\telse if (l >= 1.) return distance(pos,P1);\r\n\r\n\t// --- dist to seg = dist to line\r\n\telse if (SIGNED_DIST) \r\n\t    { float D = cross2(P0P1,P0Pos); return D/sqrt(l2_01); }\r\n\telse return distance(pos, P0+l*P0P1);\r\n}\r\n\r\n// --- min/max dist to quadrilateral P0P1P2P3 (possibly non-convex)\r\n\r\nvec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\r\n\r\n\tvec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;\r\n\r\n\t// makes the quadri convex if not: the 4 turns must have same sign.\r\n\t//    Note that alternate signs cannot happen (wouldn't loop), so possibility are:\r\n\t// all same, 1 different ('>'), 2 + then 2 - ('X').\r\n\t// for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.\r\n\r\n\t// measure turns direction\r\n#define ssign(v) (((v)>=0.) ? 1 : -1)\r\n\tint t0 = ssign(cross2(P30,P01)), t1 = ssign(cross2(P01,P12)),\t\r\n\t\tt2 = ssign(cross2(P12,P23)), t3 = ssign(cross2(P23,P30));\r\n\tif (SIGNED_DIST &&(t0>0)) // if direct, makes it indirect: we want negative inside\r\n\t\t{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } \r\n\telse  FLIP = false;\r\n\tint t = t0+t1+t2+t3; // sum of turn sign = +- 4, +-2 or 0.\r\n\t\r\n\tfloat d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), \r\n\t\t  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);\r\n\t// take care: dji != -dij at extremities since must be always positive outside\r\n\tfloat d0, d1;\r\n\t\r\n\tif ((t==4)||(t==-4)) // --- all same sign: P0P1P2P3 convex-> paths 0123, 30\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; } \r\n\r\n\telse {\r\n\t  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);\r\n\t  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;\r\n\r\n\t  if (t==0)         // --- 'X' shape\r\n\t\tif(t0==t1)  // swap 2 & 3 : P0P1P3P2 -> paths 013, 320\r\n\t\t    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }\r\n\t\t\t  d0 = amin(d01,d13);\t\t\t\t\td1 = amin(d02,d23); }\r\n\t    else \t    // swap 1 & 2 : P0P2P1P3-> paths 0213, 30\r\n\t\t\t{ d0 = amin( amin( d02, d21 ), d13);\td1 = d30; }\t\t\r\n\r\n\t  else  // t == +-2   //  --- '>' shape : one sign different -> bounding triangle\r\n\t\tif (t1*t<0)       // it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30\r\n\t\t\t{ d0 = amin( d02, d23);\t\t\t\t\td1 = d30; }\r\n\t\telse if (t2*t<0)  // it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30\r\n\t\t\t{ d0 = amin( d01, d13);\t\t\t\t\td1 = d30; }\r\n\t\telse              // it's P0 or P3: in facts, that's fine.\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; }\r\n\t  }\r\n\r\n\treturn vec2( amin(d0,d1), amax(d0,d1) );\r\n}\r\n\r\n\r\n// --- dist to spline - costly (for pixels where smart method failed )\r\n\r\n// TODO: - recursive subdivision\r\n//       - Newton iterations to  min dist\r\n//       - adaptive stepping (especially when used on small spline section)\r\n//       - sampling = diameter*pi*resolution\r\n// (anyway this function has negligible cost since rarely used).\r\nvec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tif (SHOW_COSTLY) return vec2(8.);\r\n\tfloat d = 1e5;\r\n\tfor (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),\r\n\t\t\t P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),\r\n\t\t\t P0123 = mix(P012,P123,x); // is on the spline\r\n\t\tvec2 D = P0123-pos;\r\n\t\td = min(d, dot(D,D));\r\n\t}\r\n\td = sqrt(d);\r\n\treturn vec2(d);\r\n}\r\n\r\n// --- dist to spline - iterative\r\n\r\nvec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tvec2 d0mM, d3mM;\r\n\tfor (int i=0; i<SUBDIV; i++) { // iterative subdivision\r\n\t\tif (i >= n) continue;\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),\r\n\t\t\t P012  = .5*(P01+P12),  P123 = .5*(P12+P23),\r\n\t\t\t P0123 = .5*(P012+P123); // is on the spline\r\n\r\n\t\t\r\n\t\td0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1\r\n\t\td3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2\r\n\t\t\r\n\t\tbool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);\r\n\t\td0mM = abs(d0mM); d3mM=  abs(d3mM);\r\n\t\t\t\r\n\t\tif (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )\r\n\t\t\treturn vec2(0.,float(i));    // draw skeleton\r\n\t\tfloat s;\r\n\r\n\r\n\t\t// inside one of the sub quadri\r\n\t\tif      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;\r\n\t\telse \r\n#if 1\r\n\t\tif (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer\r\n\t\telse if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer\r\n\t\t\telse // ambiguous\r\n\t\t\t  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method\r\n#else\r\n\t\t\tif (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)\r\n#endif\r\n\t\t\r\n\t\tif (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1\r\n\t\telse      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2\r\n   \t}\r\n\t\r\n\tif (n<0) // ambiguity found: switch to costly method\r\n\t\treturn dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); \r\n\t\r\n  \treturn dist2quadri(pos, P0,P1,P2,P3);\r\n}\r\n\r\n\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of control points and tangents.\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tt = iTime;\r\n    fragColor = vec4(0.);\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tvec2 Pc, Tc;\r\n\t\r\n\t// --- tuning \r\n\t\r\n\tvec2 mouse = 2.*(iMouse.xy  / iResolution.y - vec2(.8,.5));\r\n\tSIGNED_DIST = !keyToggle(64+19); \r\n\tfragColor.b += showFlag(vec2(-1.5,.9),uv,(mod(10.*t,2.)<1.))\r\n\t\t\t\t\t+ showFlag(vec2(-1.4,.9),uv,SIGNED_DIST);\r\n\t\r\n\tif (iMouse.z<=0.) {\r\n\t\tfloat fm = mod(.2*t,8.); int m=int(fm);\r\n\t\tSHOW_MESH   =  (mod(fm,2.)>=1.);\r\n\t\tSHOW_LINE   =  (m==2)||(m==3);\r\n\t\tSHOW_GRAD   =  (m==4)||(m==5);\r\n\t\tSHOW_ISO    =  (m==6)||(m==7);\r\n\t\tSHOW_COSTLY =  false;\r\n\t\tPc = P(0.); Tc = P(0.5);\r\n\t} else {\r\n\t\tSHOW_MESH   = keyToggle(64+13); // 'M'\r\n\t\tSHOW_LINE   = keyToggle(64+12); // 'L'\r\n\t\tSHOW_GRAD   = !keyToggle(64+7); // 'G'\r\n\t\tSHOW_ISO    = keyToggle(64+9);  // 'I'\t\r\n\t\tSHOW_COSTLY = keyToggle(64+3);  // 'C'\t\r\n\t\tPc = mouse; Tc = vec2(1.);\r\n\t}\r\n\t\r\n\t\r\n\t// --- dist to spline \r\n\t// TODO:\r\n\t//    - first select possible splines\r\n\t//    - parallel descent in the vector of splines\r\n\t\r\n\tvec2 dmMi[POINTS];\r\n\tvec2 dmM = vec2(1e5);\r\n\tvec2 P0, T0, P3=Pc, T3=Tc;\r\n#if 0\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\t\tfloat d0=dist2(uv,P0), d1=dist2(uv,P0+T0), d2=dist2(uv,P3-T3), d3=dist2(uv,P3);\r\n\t\tfloat dmi = min(min(d0,d1),min(d2,d3)), dMi = max(max(d0,d1),max(d2,d3));\r\n\t\tdmMi[int(i)] = vec2(dmi, dMi);\r\n\t}\r\n#endif\r\n\t\r\n\tdmM = vec2(1e5);\r\n\tP3=Pc, T3=Tc;\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\r\n\t\tvec2 dmMi = abs(dist2spline(uv, P0,P0+T0,P3-T3,P3, SUBDIV)); // draw spline i\r\n\r\n\t\tif (dmMi.x==0.) // display mesh\r\n\t\t\t{ fragColor=mix(vec4(1),vec4(0.,0.,1.,0.),dmMi.y/3.); return; } \r\n\t\tif (dmMi.x==8.) // display ambiguous parts\r\n\t\t\t{ fragColor=vec4(.15,0.,0.,0.); return; } \r\n\t\tdmM = min (dmM, dmMi);\r\n\t}\r\n\t\r\n\t\r\n\t// --- display\r\n\t\r\n\tvec3 col = 1.-abs(vec3(dmM,.5*(dmM.x+dmM.y))); \r\n\tif (SHOW_LINE) col = pow(col, vec3(16.));\r\n\tif (SHOW_ISO ) col = sin(100.*col);\r\n\tif (SHOW_GRAD) col.xy = .5+.5*normalize(vec2(dFdx(col.z),dFdy(col.z)));\r\n\t\r\n\tfragColor += vec4(col.xy, 0.,1.);\r\n}","inputs":[],"outputs":[],"code":"// efficient distance to spline relying on the iterative construction of splines.\r\n\r\n#define POINTS 8  \t\t // number of control points\r\n\r\nconst int   SUBDIV=5;    // subdivision depth for the analytic method\r\nconst float sampl=120.; // number of samples per spline for the costly method\r\nfloat t;\r\n\r\nbool SHOW_MESH, SHOW_LINE, SHOW_GRAD, SHOW_ISO, SHOW_COSTLY;\r\n\r\n// --- GUI utils\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat cross2(vec2 v0, vec2 v1) {\treturn v0.x*v1.y - v0.y*v1.x; }\r\nfloat amin(float a, float b) { return (abs(a)<abs(b)) ? a : b ; }\r\nfloat amax(float a, float b) { return (abs(a)>abs(b)) ? a : b ; }\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n// --- dist pos to seg P0P1\r\n\r\nbool SIGNED_DIST = true; // if signed, positive distance is at left of oriented segment\r\nbool FLIP=false;         // for normalized turn direction (we want dist negative inside shape)\r\n\r\nfloat dist2seg(vec2 pos, vec2 P0, vec2 P1) {\r\n\tif (FLIP) { vec2 tmp=P0; P0=P1; P1=tmp; }\r\n\tvec2 P0P1 = P1-P0, P0Pos = pos-P0;\r\n\tfloat d, l2_01=dist2(P0,P1);\r\n\r\n\t// --- if projection out of segment bounds, dist to extremity\r\n\t// Note that sign is set to '+' at extremity (should'nt be reached from inside cvx shape)\r\n\tfloat l = dot(P0Pos, P0P1)/l2_01;\r\n\tif      (l <= 0.) return distance(pos,P0);\r\n\telse if (l >= 1.) return distance(pos,P1);\r\n\r\n\t// --- dist to seg = dist to line\r\n\telse if (SIGNED_DIST) \r\n\t    { float D = cross2(P0P1,P0Pos); return D/sqrt(l2_01); }\r\n\telse return distance(pos, P0+l*P0P1);\r\n}\r\n\r\n// --- min/max dist to quadrilateral P0P1P2P3 (possibly non-convex)\r\n\r\nvec2 dist2quadri(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\r\n\r\n\tvec2 P01 = P1-P0, P12 = P2-P1, P23 = P3-P2, P30 = P0-P3;\r\n\r\n\t// makes the quadri convex if not: the 4 turns must have same sign.\r\n\t//    Note that alternate signs cannot happen (wouldn't loop), so possibility are:\r\n\t// all same, 1 different ('>'), 2 + then 2 - ('X').\r\n\t// for '>' shape, indeed it's no problem if it's in 0 or 3. otherwise bounding triangle.\r\n\r\n\t// measure turns direction\r\n#define ssign(v) (((v)>=0.) ? 1 : -1)\r\n\tint t0 = ssign(cross2(P30,P01)), t1 = ssign(cross2(P01,P12)),\t\r\n\t\tt2 = ssign(cross2(P12,P23)), t3 = ssign(cross2(P23,P30));\r\n\tif (SIGNED_DIST &&(t0>0)) // if direct, makes it indirect: we want negative inside\r\n\t\t{ FLIP = true; t0=-t0; t1=-t1; t2=-t2; t3=-t3; } \r\n\telse  FLIP = false;\r\n\tint t = t0+t1+t2+t3; // sum of turn sign = +- 4, +-2 or 0.\r\n\t\r\n\tfloat d01 = dist2seg(pos,P0,P1), d12 = dist2seg(pos,P1,P2), \r\n\t\t  d23 = dist2seg(pos,P2,P3), d30 = dist2seg(pos,P3,P0);\r\n\t// take care: dji != -dij at extremities since must be always positive outside\r\n\tfloat d0, d1;\r\n\t\r\n\tif ((t==4)||(t==-4)) // --- all same sign: P0P1P2P3 convex-> paths 0123, 30\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; } \r\n\r\n\telse {\r\n\t  float d13 = dist2seg(pos,P1,P3), d02 = dist2seg(pos,P0,P2);\r\n\t  float d21 = (SIGNED_DIST) ?  dist2seg(pos,P2,P1) : d12;\r\n\r\n\t  if (t==0)         // --- 'X' shape\r\n\t\tif(t0==t1)  // swap 2 & 3 : P0P1P3P2 -> paths 013, 320\r\n\t\t    { if (SIGNED_DIST) { d02 = dist2seg(pos,P2,P0); d23 = dist2seg(pos,P3,P2); }\r\n\t\t\t  d0 = amin(d01,d13);\t\t\t\t\td1 = amin(d02,d23); }\r\n\t    else \t    // swap 1 & 2 : P0P2P1P3-> paths 0213, 30\r\n\t\t\t{ d0 = amin( amin( d02, d21 ), d13);\td1 = d30; }\t\t\r\n\r\n\t  else  // t == +-2   //  --- '>' shape : one sign different -> bounding triangle\r\n\t\tif (t1*t<0)       // it's P1 : del it.  -> P0P2P2P3 -> paths 023, 30\r\n\t\t\t{ d0 = amin( d02, d23);\t\t\t\t\td1 = d30; }\r\n\t\telse if (t2*t<0)  // it's P2 : del it.  -> P0P1P1P3 -> paths 013, 30\r\n\t\t\t{ d0 = amin( d01, d13);\t\t\t\t\td1 = d30; }\r\n\t\telse              // it's P0 or P3: in facts, that's fine.\r\n\t\t\t{ d0 = amin( amin( d01, d12 ), d23);\td1 = d30; }\r\n\t  }\r\n\r\n\treturn vec2( amin(d0,d1), amax(d0,d1) );\r\n}\r\n\r\n\r\n// --- dist to spline - costly (for pixels where smart method failed )\r\n\r\n// TODO: - recursive subdivision\r\n//       - Newton iterations to  min dist\r\n//       - adaptive stepping (especially when used on small spline section)\r\n//       - sampling = diameter*pi*resolution\r\n// (anyway this function has negligible cost since rarely used).\r\nvec2 dist2spline2(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tif (SHOW_COSTLY) return vec2(8.);\r\n\tfloat d = 1e5;\r\n\tfor (float x=0.; x<1.; x+= 1./sampl) { // iterative subdivision\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = mix(P0,P1,x),     P12 = mix(P1,P2,x),    P23 = mix(P2,P3,x),\r\n\t\t\t P012  = mix(P01,P12,x),  P123 = mix(P12,P23,x),\r\n\t\t\t P0123 = mix(P012,P123,x); // is on the spline\r\n\t\tvec2 D = P0123-pos;\r\n\t\td = min(d, dot(D,D));\r\n\t}\r\n\td = sqrt(d);\r\n\treturn vec2(d);\r\n}\r\n\r\n// --- dist to spline - iterative\r\n\r\nvec2 dist2spline(vec2 pos, vec2 P0, vec2 P1, vec2 P2, vec2 P3, int n) {\r\n\tvec2 d0mM, d3mM;\r\n\tfor (int i=0; i<SUBDIV; i++) { // iterative subdivision\r\n\t\tif (i >= n) continue;\r\n\t\t\r\n\t\t// construct the 2 sub- control polygons\r\n\t\tvec2 P01   = .5*(P0+P1),     P12 = .5*(P1+P2),    P23 = .5*(P2+P3),\r\n\t\t\t P012  = .5*(P01+P12),  P123 = .5*(P12+P23),\r\n\t\t\t P0123 = .5*(P012+P123); // is on the spline\r\n\r\n\t\t\r\n\t\td0mM = dist2quadri(pos, P0,P01,P012,P0123), // sub quadri 1\r\n\t\td3mM = dist2quadri(pos, P0123,P123,P23,P3); // sub quadri 2\r\n\t\t\r\n\t\tbool in0 = (d0mM.x<0.) && (d0mM.y<0.), in3 = (d3mM.x<0.) && (d3mM.y<0.);\r\n\t\td0mM = abs(d0mM); d3mM=  abs(d3mM);\r\n\t\t\t\r\n\t\tif (SHOW_MESH && ( (d0mM.x<3e-3)||(d3mM.x<3e-3) ) )\r\n\t\t\treturn vec2(0.,float(i));    // draw skeleton\r\n\t\tfloat s;\r\n\r\n\r\n\t\t// inside one of the sub quadri\r\n\t\tif      (in0 && ! in3) s = -1.; else if (in3 && ! in0) s = 1.;\r\n\t\telse \r\n#if 1\r\n\t\tif (d0mM.y <= d3mM.x) s = -1.;       // sub-quadri 1 totally closer\r\n\t\telse if (d3mM.y <= d0mM.x) s = 1.;   // sub-quadri 2 totally closer\r\n\t\t\telse // ambiguous\r\n\t\t\t  { n =-n; d0mM.x = float(n-i); continue; } // switch to costly method\r\n#else\r\n\t\t\tif (d0mM.x <= d3mM.x) s = -1.; else s = 1.; // closest box (very approx)\r\n#endif\r\n\t\t\r\n\t\tif (s<0.) { P1 = P01;   P2 = P012; P3 = P0123; } // continue on sub quadri 1\r\n\t\telse      { P0 = P0123; P1 = P123; P2 = P23;   } // continue on sub quadri 2\r\n   \t}\r\n\t\r\n\tif (n<0) // ambiguity found: switch to costly method\r\n\t\treturn dist2spline2(pos, P0,P1,P2,P3, int(d0mM.x+.5)); \r\n\t\r\n  \treturn dist2quadri(pos, P0,P1,P2,P3);\r\n}\r\n\r\n\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of control points and tangents.\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tt = iTime;\r\n    fragColor = vec4(0.);\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tvec2 Pc, Tc;\r\n\t\r\n\t// --- tuning \r\n\t\r\n\tvec2 mouse = 2.*(iMouse.xy  / iResolution.y - vec2(.8,.5));\r\n\tSIGNED_DIST = !keyToggle(64+19); \r\n\tfragColor.b += showFlag(vec2(-1.5,.9),uv,(mod(10.*t,2.)<1.))\r\n\t\t\t\t\t+ showFlag(vec2(-1.4,.9),uv,SIGNED_DIST);\r\n\t\r\n\tif (iMouse.z<=0.) {\r\n\t\tfloat fm = mod(.2*t,8.); int m=int(fm);\r\n\t\tSHOW_MESH   =  (mod(fm,2.)>=1.);\r\n\t\tSHOW_LINE   =  (m==2)||(m==3);\r\n\t\tSHOW_GRAD   =  (m==4)||(m==5);\r\n\t\tSHOW_ISO    =  (m==6)||(m==7);\r\n\t\tSHOW_COSTLY =  false;\r\n\t\tPc = P(0.); Tc = P(0.5);\r\n\t} else {\r\n\t\tSHOW_MESH   = keyToggle(64+13); // 'M'\r\n\t\tSHOW_LINE   = keyToggle(64+12); // 'L'\r\n\t\tSHOW_GRAD   = !keyToggle(64+7); // 'G'\r\n\t\tSHOW_ISO    = keyToggle(64+9);  // 'I'\t\r\n\t\tSHOW_COSTLY = keyToggle(64+3);  // 'C'\t\r\n\t\tPc = mouse; Tc = vec2(1.);\r\n\t}\r\n\t\r\n\t\r\n\t// --- dist to spline \r\n\t// TODO:\r\n\t//    - first select possible splines\r\n\t//    - parallel descent in the vector of splines\r\n\t\r\n\tvec2 dmMi[POINTS];\r\n\tvec2 dmM = vec2(1e5);\r\n\tvec2 P0, T0, P3=Pc, T3=Tc;\r\n#if 0\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\t\tfloat d0=dist2(uv,P0), d1=dist2(uv,P0+T0), d2=dist2(uv,P3-T3), d3=dist2(uv,P3);\r\n\t\tfloat dmi = min(min(d0,d1),min(d2,d3)), dMi = max(max(d0,d1),max(d2,d3));\r\n\t\tdmMi[int(i)] = vec2(dmi, dMi);\r\n\t}\r\n#endif\r\n\t\r\n\tdmM = vec2(1e5);\r\n\tP3=Pc, T3=Tc;\r\n\tfor (float i=1.; i<float(POINTS); i++) \r\n\t{\r\n\t\tP0 = P3; T0 = T3; P3 = P(i); T3 = P(i+.5);\r\n\r\n\t\tvec2 dmMi = abs(dist2spline(uv, P0,P0+T0,P3-T3,P3, SUBDIV)); // draw spline i\r\n\r\n\t\tif (dmMi.x==0.) // display mesh\r\n\t\t\t{ fragColor=mix(vec4(1),vec4(0.,0.,1.,0.),dmMi.y/3.); return; } \r\n\t\tif (dmMi.x==8.) // display ambiguous parts\r\n\t\t\t{ fragColor=vec4(.15,0.,0.,0.); return; } \r\n\t\tdmM = min (dmM, dmMi);\r\n\t}\r\n\t\r\n\t\r\n\t// --- display\r\n\t\r\n\tvec3 col = 1.-abs(vec3(dmM,.5*(dmM.x+dmM.y))); \r\n\tif (SHOW_LINE) col = pow(col, vec3(16.));\r\n\tif (SHOW_ISO ) col = sin(100.*col);\r\n\tif (SHOW_GRAD) col.xy = .5+.5*normalize(vec2(dFdx(col.z),dFdy(col.z)));\r\n\t\r\n\tfragColor += vec4(col.xy, 0.,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define Wmin 50.    // spectrum shape of exciter \r\n#define Wmax 200.\r\n#define Wsamples 150.\r\n#define AMP(w) (1./(w))\r\n\r\n#define COL 0\t\t// water reflects\r\n#define CAM 1\t\t// perspective camera\r\n#define PULSE 1     // time shape of exciter  1: square 2: smooth\r\n// SPACE to toggle spreaded source\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- rand\r\nfloat hash(float x) { return fract(sin(3234.*x)*6563.234); }\r\n\r\n// --- solve degree 3 equation\r\nfloat solveP3(float a, float c, float d) {\r\n\tc /= a; d /= a;\r\n\tfloat C = -d/2.*(1.+sqrt(1.+(c*c*c)/(d*d)*4./27.));  \r\n\tC = sign(C)*pow(abs(C),1./3.);\r\n    return C-c/(3.*C);\r\n}\r\n\r\n// --- Pierson-Moskowitz oceanographic spectrum   V = wind at 20m height\r\nfloat PM(float w,float V) { return 8.1E-3*9.81*9.81/pow(w,5.)*exp(-0.74*pow(9.81/(V*w),4.)); }\r\n\r\n// --- drop exciter\r\nfloat pulse(float t) {\r\n#if   PULSE==1\r\n\treturn (mod(t,1.)<.1) ? 1.: 0.;      // square signal\r\n#elif PULSE==2\r\n\treturn pow(.5+.5*cos(6.283*t),20.);  // smoothed signal\r\n#endif\r\n}\r\n\r\n// === main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat t = .3*iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\r\n\tvec2 m  =      2.*( iMouse.xy / iResolution.y - vec2(.9,.5));\r\n\tif (length(iMouse.zw)==0.) m = vec2(1e-5);\r\n\t\r\n#if CAM\r\n\t// set view conditions and get water plane position viewed in the pixel\r\n\tfloat b = 3.14*length(m), a = atan(m.y,m.x);\r\n\tvec3 eye = vec3(sin(b)*cos(a),sin(b)*sin(a),cos(b)); // vec3(2.*m,2.);\r\n\tmat3 M; \t\t\t\t\t// view matrix\r\n\tM[0] = normalize(-eye);\r\n\tM[2] = normalize(vec3(0.,0.,1.)-M[0].z*M[0]);\r\n\tM[1] = cross(M[0],M[2]);\r\n\tvec3 ray = normalize(M*vec3(1.,uv));\r\n\tif (abs(ray.z)>1e-3) {\r\n\t\tfloat l = -eye.z/ray.z; vec3 P = eye + l*ray; // point on water plane\r\n\t\tuv = P.xy;\r\n\t}\r\n#endif\r\n\t\r\n\tvec2 dir = normalize(uv);\r\n\tfloat d = 10.*length(uv);\r\n\tfloat x = 0., y = 0.; vec4 col = vec4(0.);\r\n\t\r\n\t// k = 2Pi/L , w = 2Pi/T\r\n\t// complete waves dispertion equation: w^2 = (gk + sigma/rho k^3) tanh(kh)\r\n\t// here, ignore tan(kh) ( = deep water case )\r\n\t\r\n\t// sum on wave spectrum // < 85: gravity waves  > 85: capillary waves\r\n\tfor (float w = Wmin; w < Wmax; w += (Wmax-Wmin)/Wsamples) \r\n\t{  \r\n\t    float k = solveP3(9.81, 0.074/1000.,-w*w);  // k(w)\r\n\t\tif (keyToggle(32)) d = 10.*length(uv+.03*(2.*vec2(hash(1./w),1.+hash(1./w))-1.));\r\n\t\tfloat phi =k*d-w*t ,\t\t\t\t\t\t// wave phase\r\n\t\t\t  phi0 = 6.283*hash(w);   \t\t\t\t// random phasing(w)\r\n\t\tfloat A = 2.*AMP(w) * pulse(-phi/w);\t\t// amplitude\r\n#if !COL\r\n\t\ty += A*sin(phi+phi0);\r\n\t\t// x += A*cos(phi+phi0);\r\n#else\r\n\t\tA *= 1.;\r\n\t\t// normal to the surface, and ray reflection in the cubemap.\r\n\t\tvec3 N = normalize(vec3( A*k*cos(phi+phi0)*dir,-(1.-A*k*sin(phi+phi0)))),\r\n\t\t\t V = reflect(ray,N);\r\n\t\tcol += texture(iChannel0, V.xzy );\r\n#endif\r\n\t}\r\n\t\r\n#if COL\r\n\tfragColor = vec4(col/Wsamples); \r\n#else\r\n\tfragColor = vec4(.5+y); fragColor.b += .1;\r\n#endif\r\n}","inputs":[],"outputs":[],"code":"#define Wmin 50.    // spectrum shape of exciter \r\n#define Wmax 200.\r\n#define Wsamples 150.\r\n#define AMP(w) (1./(w))\r\n\r\n#define COL 0\t\t// water reflects\r\n#define CAM 1\t\t// perspective camera\r\n#define PULSE 1     // time shape of exciter  1: square 2: smooth\r\n// SPACE to toggle spreaded source\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- rand\r\nfloat hash(float x) { return fract(sin(3234.*x)*6563.234); }\r\n\r\n// --- solve degree 3 equation\r\nfloat solveP3(float a, float c, float d) {\r\n\tc /= a; d /= a;\r\n\tfloat C = -d/2.*(1.+sqrt(1.+(c*c*c)/(d*d)*4./27.));  \r\n\tC = sign(C)*pow(abs(C),1./3.);\r\n    return C-c/(3.*C);\r\n}\r\n\r\n// --- Pierson-Moskowitz oceanographic spectrum   V = wind at 20m height\r\nfloat PM(float w,float V) { return 8.1E-3*9.81*9.81/pow(w,5.)*exp(-0.74*pow(9.81/(V*w),4.)); }\r\n\r\n// --- drop exciter\r\nfloat pulse(float t) {\r\n#if   PULSE==1\r\n\treturn (mod(t,1.)<.1) ? 1.: 0.;      // square signal\r\n#elif PULSE==2\r\n\treturn pow(.5+.5*cos(6.283*t),20.);  // smoothed signal\r\n#endif\r\n}\r\n\r\n// === main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat t = .3*iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\r\n\tvec2 m  =      2.*( iMouse.xy / iResolution.y - vec2(.9,.5));\r\n\tif (length(iMouse.zw)==0.) m = vec2(1e-5);\r\n\t\r\n#if CAM\r\n\t// set view conditions and get water plane position viewed in the pixel\r\n\tfloat b = 3.14*length(m), a = atan(m.y,m.x);\r\n\tvec3 eye = vec3(sin(b)*cos(a),sin(b)*sin(a),cos(b)); // vec3(2.*m,2.);\r\n\tmat3 M; \t\t\t\t\t// view matrix\r\n\tM[0] = normalize(-eye);\r\n\tM[2] = normalize(vec3(0.,0.,1.)-M[0].z*M[0]);\r\n\tM[1] = cross(M[0],M[2]);\r\n\tvec3 ray = normalize(M*vec3(1.,uv));\r\n\tif (abs(ray.z)>1e-3) {\r\n\t\tfloat l = -eye.z/ray.z; vec3 P = eye + l*ray; // point on water plane\r\n\t\tuv = P.xy;\r\n\t}\r\n#endif\r\n\t\r\n\tvec2 dir = normalize(uv);\r\n\tfloat d = 10.*length(uv);\r\n\tfloat x = 0., y = 0.; vec4 col = vec4(0.);\r\n\t\r\n\t// k = 2Pi/L , w = 2Pi/T\r\n\t// complete waves dispertion equation: w^2 = (gk + sigma/rho k^3) tanh(kh)\r\n\t// here, ignore tan(kh) ( = deep water case )\r\n\t\r\n\t// sum on wave spectrum // < 85: gravity waves  > 85: capillary waves\r\n\tfor (float w = Wmin; w < Wmax; w += (Wmax-Wmin)/Wsamples) \r\n\t{  \r\n\t    float k = solveP3(9.81, 0.074/1000.,-w*w);  // k(w)\r\n\t\tif (keyToggle(32)) d = 10.*length(uv+.03*(2.*vec2(hash(1./w),1.+hash(1./w))-1.));\r\n\t\tfloat phi =k*d-w*t ,\t\t\t\t\t\t// wave phase\r\n\t\t\t  phi0 = 6.283*hash(w);   \t\t\t\t// random phasing(w)\r\n\t\tfloat A = 2.*AMP(w) * pulse(-phi/w);\t\t// amplitude\r\n#if !COL\r\n\t\ty += A*sin(phi+phi0);\r\n\t\t// x += A*cos(phi+phi0);\r\n#else\r\n\t\tA *= 1.;\r\n\t\t// normal to the surface, and ray reflection in the cubemap.\r\n\t\tvec3 N = normalize(vec3( A*k*cos(phi+phi0)*dir,-(1.-A*k*sin(phi+phi0)))),\r\n\t\t\t V = reflect(ray,N);\r\n\t\tcol += texture(iChannel0, V.xzy );\r\n#endif\r\n\t}\r\n\t\r\n#if COL\r\n\tfragColor = vec4(col/Wsamples); \r\n#else\r\n\tfragColor = vec4(.5+y); fragColor.b += .1;\r\n#endif\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"drop splash","id":"3a7e47f2ef5a4d27b72c07e31121f1ac","date":null,"viewed":0,"name":"drop splash","description":"Real drop splashes are *not* sin(k(d-ct)) !\r\n- wave speed depends on wavelenght (dispertion). slowest=.4 cm; faster for larger (gravity) and smaller (capillary)\r\n- vertical displ = A.sin, horiz displ = A.cos -> trochoids, not sinusoids (not drawn here).\r\nhttps://www.shadertoy.com/view/ldlXDN","likes":0,"published":null,"tags":["waves"]},"ver":null,"info":{"Name":"drop splash","id":"3a7e47f2ef5a4d27b72c07e31121f1ac","date":null,"viewed":0,"name":"drop splash","description":"Real drop splashes are *not* sin(k(d-ct)) !\r\n- wave speed depends on wavelenght (dispertion). slowest=.4 cm; faster for larger (gravity) and smaller (capillary)\r\n- vertical displ = A.sin, horiz displ = A.cos -> trochoids, not sinusoids (not drawn here).\r\nhttps://www.shadertoy.com/view/ldlXDN","likes":0,"published":null,"tags":["waves"]},"renderpass":[{"Code":"#define Wmin 50.    // spectrum shape of exciter \r\n#define Wmax 200.\r\n#define Wsamples 150.\r\n#define AMP(w) (1./(w))\r\n\r\n#define COL 0\t\t// water reflects\r\n#define CAM 1\t\t// perspective camera\r\n#define PULSE 1     // time shape of exciter  1: square 2: smooth\r\n// SPACE to toggle spreaded source\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- rand\r\nfloat hash(float x) { return fract(sin(3234.*x)*6563.234); }\r\n\r\n// --- solve degree 3 equation\r\nfloat solveP3(float a, float c, float d) {\r\n\tc /= a; d /= a;\r\n\tfloat C = -d/2.*(1.+sqrt(1.+(c*c*c)/(d*d)*4./27.));  \r\n\tC = sign(C)*pow(abs(C),1./3.);\r\n    return C-c/(3.*C);\r\n}\r\n\r\n// --- Pierson-Moskowitz oceanographic spectrum   V = wind at 20m height\r\nfloat PM(float w,float V) { return 8.1E-3*9.81*9.81/pow(w,5.)*exp(-0.74*pow(9.81/(V*w),4.)); }\r\n\r\n// --- drop exciter\r\nfloat pulse(float t) {\r\n#if   PULSE==1\r\n\treturn (mod(t,1.)<.1) ? 1.: 0.;      // square signal\r\n#elif PULSE==2\r\n\treturn pow(.5+.5*cos(6.283*t),20.);  // smoothed signal\r\n#endif\r\n}\r\n\r\n// === main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat t = .3*iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\r\n\tvec2 m  =      2.*( iMouse.xy / iResolution.y - vec2(.9,.5));\r\n\tif (length(iMouse.zw)==0.) m = vec2(1e-5);\r\n\t\r\n#if CAM\r\n\t// set view conditions and get water plane position viewed in the pixel\r\n\tfloat b = 3.14*length(m), a = atan(m.y,m.x);\r\n\tvec3 eye = vec3(sin(b)*cos(a),sin(b)*sin(a),cos(b)); // vec3(2.*m,2.);\r\n\tmat3 M; \t\t\t\t\t// view matrix\r\n\tM[0] = normalize(-eye);\r\n\tM[2] = normalize(vec3(0.,0.,1.)-M[0].z*M[0]);\r\n\tM[1] = cross(M[0],M[2]);\r\n\tvec3 ray = normalize(M*vec3(1.,uv));\r\n\tif (abs(ray.z)>1e-3) {\r\n\t\tfloat l = -eye.z/ray.z; vec3 P = eye + l*ray; // point on water plane\r\n\t\tuv = P.xy;\r\n\t}\r\n#endif\r\n\t\r\n\tvec2 dir = normalize(uv);\r\n\tfloat d = 10.*length(uv);\r\n\tfloat x = 0., y = 0.; vec4 col = vec4(0.);\r\n\t\r\n\t// k = 2Pi/L , w = 2Pi/T\r\n\t// complete waves dispertion equation: w^2 = (gk + sigma/rho k^3) tanh(kh)\r\n\t// here, ignore tan(kh) ( = deep water case )\r\n\t\r\n\t// sum on wave spectrum // < 85: gravity waves  > 85: capillary waves\r\n\tfor (float w = Wmin; w < Wmax; w += (Wmax-Wmin)/Wsamples) \r\n\t{  \r\n\t    float k = solveP3(9.81, 0.074/1000.,-w*w);  // k(w)\r\n\t\tif (keyToggle(32)) d = 10.*length(uv+.03*(2.*vec2(hash(1./w),1.+hash(1./w))-1.));\r\n\t\tfloat phi =k*d-w*t ,\t\t\t\t\t\t// wave phase\r\n\t\t\t  phi0 = 6.283*hash(w);   \t\t\t\t// random phasing(w)\r\n\t\tfloat A = 2.*AMP(w) * pulse(-phi/w);\t\t// amplitude\r\n#if !COL\r\n\t\ty += A*sin(phi+phi0);\r\n\t\t// x += A*cos(phi+phi0);\r\n#else\r\n\t\tA *= 1.;\r\n\t\t// normal to the surface, and ray reflection in the cubemap.\r\n\t\tvec3 N = normalize(vec3( A*k*cos(phi+phi0)*dir,-(1.-A*k*sin(phi+phi0)))),\r\n\t\t\t V = reflect(ray,N);\r\n\t\tcol += texture(iChannel0, V.xzy );\r\n#endif\r\n\t}\r\n\t\r\n#if COL\r\n\tfragColor = vec4(col/Wsamples); \r\n#else\r\n\tfragColor = vec4(.5+y); fragColor.b += .1;\r\n#endif\r\n}","inputs":[],"outputs":[],"code":"#define Wmin 50.    // spectrum shape of exciter \r\n#define Wmax 200.\r\n#define Wsamples 150.\r\n#define AMP(w) (1./(w))\r\n\r\n#define COL 0\t\t// water reflects\r\n#define CAM 1\t\t// perspective camera\r\n#define PULSE 1     // time shape of exciter  1: square 2: smooth\r\n// SPACE to toggle spreaded source\r\n\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- rand\r\nfloat hash(float x) { return fract(sin(3234.*x)*6563.234); }\r\n\r\n// --- solve degree 3 equation\r\nfloat solveP3(float a, float c, float d) {\r\n\tc /= a; d /= a;\r\n\tfloat C = -d/2.*(1.+sqrt(1.+(c*c*c)/(d*d)*4./27.));  \r\n\tC = sign(C)*pow(abs(C),1./3.);\r\n    return C-c/(3.*C);\r\n}\r\n\r\n// --- Pierson-Moskowitz oceanographic spectrum   V = wind at 20m height\r\nfloat PM(float w,float V) { return 8.1E-3*9.81*9.81/pow(w,5.)*exp(-0.74*pow(9.81/(V*w),4.)); }\r\n\r\n// --- drop exciter\r\nfloat pulse(float t) {\r\n#if   PULSE==1\r\n\treturn (mod(t,1.)<.1) ? 1.: 0.;      // square signal\r\n#elif PULSE==2\r\n\treturn pow(.5+.5*cos(6.283*t),20.);  // smoothed signal\r\n#endif\r\n}\r\n\r\n// === main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat t = .3*iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\r\n\tvec2 m  =      2.*( iMouse.xy / iResolution.y - vec2(.9,.5));\r\n\tif (length(iMouse.zw)==0.) m = vec2(1e-5);\r\n\t\r\n#if CAM\r\n\t// set view conditions and get water plane position viewed in the pixel\r\n\tfloat b = 3.14*length(m), a = atan(m.y,m.x);\r\n\tvec3 eye = vec3(sin(b)*cos(a),sin(b)*sin(a),cos(b)); // vec3(2.*m,2.);\r\n\tmat3 M; \t\t\t\t\t// view matrix\r\n\tM[0] = normalize(-eye);\r\n\tM[2] = normalize(vec3(0.,0.,1.)-M[0].z*M[0]);\r\n\tM[1] = cross(M[0],M[2]);\r\n\tvec3 ray = normalize(M*vec3(1.,uv));\r\n\tif (abs(ray.z)>1e-3) {\r\n\t\tfloat l = -eye.z/ray.z; vec3 P = eye + l*ray; // point on water plane\r\n\t\tuv = P.xy;\r\n\t}\r\n#endif\r\n\t\r\n\tvec2 dir = normalize(uv);\r\n\tfloat d = 10.*length(uv);\r\n\tfloat x = 0., y = 0.; vec4 col = vec4(0.);\r\n\t\r\n\t// k = 2Pi/L , w = 2Pi/T\r\n\t// complete waves dispertion equation: w^2 = (gk + sigma/rho k^3) tanh(kh)\r\n\t// here, ignore tan(kh) ( = deep water case )\r\n\t\r\n\t// sum on wave spectrum // < 85: gravity waves  > 85: capillary waves\r\n\tfor (float w = Wmin; w < Wmax; w += (Wmax-Wmin)/Wsamples) \r\n\t{  \r\n\t    float k = solveP3(9.81, 0.074/1000.,-w*w);  // k(w)\r\n\t\tif (keyToggle(32)) d = 10.*length(uv+.03*(2.*vec2(hash(1./w),1.+hash(1./w))-1.));\r\n\t\tfloat phi =k*d-w*t ,\t\t\t\t\t\t// wave phase\r\n\t\t\t  phi0 = 6.283*hash(w);   \t\t\t\t// random phasing(w)\r\n\t\tfloat A = 2.*AMP(w) * pulse(-phi/w);\t\t// amplitude\r\n#if !COL\r\n\t\ty += A*sin(phi+phi0);\r\n\t\t// x += A*cos(phi+phi0);\r\n#else\r\n\t\tA *= 1.;\r\n\t\t// normal to the surface, and ray reflection in the cubemap.\r\n\t\tvec3 N = normalize(vec3( A*k*cos(phi+phi0)*dir,-(1.-A*k*sin(phi+phi0)))),\r\n\t\t\t V = reflect(ray,N);\r\n\t\tcol += texture(iChannel0, V.xzy );\r\n#endif\r\n\t}\r\n\t\r\n#if COL\r\n\tfragColor = vec4(col/Wsamples); \r\n#else\r\n\tfragColor = vec4(.5+y); fragColor.b += .1;\r\n#endif\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define LINEAR_DENSITY 1  // 0: constant\r\n#define DENS 2.           // tau.rho\r\n#define rad .3            // sphere radius\r\n#define H   .05           // skin layer thickness (for linear density)\r\n#define ANIM true         // true/false\r\n#define PI 3.14159\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,1.0);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","inputs":[],"outputs":[],"code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define LINEAR_DENSITY 1  // 0: constant\r\n#define DENS 2.           // tau.rho\r\n#define rad .3            // sphere radius\r\n#define H   .05           // skin layer thickness (for linear density)\r\n#define ANIM true         // true/false\r\n#define PI 3.14159\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,1.0);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"enlightened dark cloud","id":"14549e70635646ff90ecf0179c63748c","date":null,"viewed":0,"name":"enlightened dark cloud","description":"Mouse moves the light direction.\nThis is a test of analytical estimation of light scattering within a thin layer. \nDefaut: gradient density within a \"skin\"; no account of curvature.\nhttps://www.shadertoy.com/view/4slGWM","likes":0,"published":null,"tags":["procedural"," noise"," cloud"," scattering"," smoke"," subsurface"," diffusion"]},"ver":null,"info":{"Name":"enlightened dark cloud","id":"14549e70635646ff90ecf0179c63748c","date":null,"viewed":0,"name":"enlightened dark cloud","description":"Mouse moves the light direction.\nThis is a test of analytical estimation of light scattering within a thin layer. \nDefaut: gradient density within a \"skin\"; no account of curvature.\nhttps://www.shadertoy.com/view/4slGWM","likes":0,"published":null,"tags":["procedural"," noise"," cloud"," scattering"," smoke"," subsurface"," diffusion"]},"renderpass":[{"Code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define LINEAR_DENSITY 1  // 0: constant\r\n#define DENS 2.           // tau.rho\r\n#define rad .3            // sphere radius\r\n#define H   .05           // skin layer thickness (for linear density)\r\n#define ANIM true         // true/false\r\n#define PI 3.14159\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,1.0);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","inputs":[],"outputs":[],"code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define LINEAR_DENSITY 1  // 0: constant\r\n#define DENS 2.           // tau.rho\r\n#define rad .3            // sphere radius\r\n#define H   .05           // skin layer thickness (for linear density)\r\n#define ANIM true         // true/false\r\n#define PI 3.14159\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,1.0);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\r\n// and animate the scene. The rays are reflected off a displaced\r\n// plane  into the trees.\r\n\r\n// polynomial smooth min (k = 0.1);\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\nfloat sminCubic( float a, float b, float k )\r\n{\r\n    float h = max( k-abs(a-b), 0.0 )/k;\r\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\r\n}\r\n\r\n// the wave for each droplet is based on a simple cosine wave\r\n// the wave in attenuated by the sqared distace to the center\r\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\r\n// both the cosine wave and the rings are animated by offsets\r\n// time is looped in 25 second intervals\r\n// about the time for the rings to leave the field of view\r\nfloat waveDisplacement( vec3 p )\r\n{\r\n    // drop one\r\n    float dist = length(p.xz - vec2(-0.5, 6.0));\r\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\r\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop two\r\n    dist = length(p.xz - vec2(0.5, 5.5));\r\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop three\r\n    dist = length(p.xz - vec2(-0.0, 5.0));\r\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    return waves;\r\n}\r\n\r\n// plane with waves\r\nfloat sdPlane( vec3 p )\r\n{\r\n    float dist = p.y;\r\n    \r\n    // apply costly displacement only when close\r\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\r\n    \r\n    return dist;\r\n}\r\n\r\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\r\n{\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\n// like capsule, but with different radii at each end\r\n// https://www.shadertoy.com/view/3lsSzf\r\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\r\n{\r\n    vec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\r\n}\r\n\r\nfloat sdTree( vec3 p )\r\n{\r\n    // trunk\r\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\r\n    \r\n    // mirror x-axis\r\n    p.x = abs( p.x );\r\n    \r\n    // big branches\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\r\n    \r\n    // mirror z-axis\r\n    p.z = abs( p.z );\r\n    \r\n    // small branches\r\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\r\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\r\n    \r\n    // lang thin branches\r\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\r\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\r\n    \r\n    return dist;\r\n}\r\n\r\n// combined SDF for scene\r\n// water is handled seperately for optimization\r\nfloat map( vec3 p ) {\r\n   \t\r\n    // slight distortion of the space\r\n    // makes the trees look more organic\r\n    // this makes a big difference\r\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\r\n    \r\n    vec3 p1 = p;\r\n    \r\n\t// rotation matrix based on pythagorean tripel\r\n    p1 *= mat3( 4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, 4.0) / 5.0;\r\n    \r\n    float tree1 = sdTree(p1);\r\n    \r\n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\r\n   \t\r\n    // rotation matrix based on pythagorean tripel\r\n    p2 *= mat3(-4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, -4.0) / 5.0;\r\n    \r\n    float tree2 = sdTree(p2);\r\n    \r\n    return min(tree1, tree2);\r\n}\r\n\r\n// optimized normal for water\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcWaterNormal( in vec3 pos)\r\n{\r\n    \r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\r\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \r\n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \r\n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \r\n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=0; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*sdPlane(pos+0.001*e);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n\r\n// get distance to the water surface\r\n// the water is close, only a few iterations are needed\r\n// this helps because the displacement is costly\r\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 10; i++) {\r\n        float d = sdPlane( eye + dist * ray_dir );\r\n        if ( d < 0.001) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 10.0 ) {\r\n            break;\r\n        }    \r\n    }\r\n    return dist;\r\n}\r\n\r\n// get distance to the trees\r\n// farplane is close to speed things up\r\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 70; i++) {\r\n        float d = map( eye + dist * ray_dir );\r\n        if ( d < 0.001 * dist) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 18.0 ) {\r\n            break;\r\n        }\r\n        \r\n    }\r\n    return dist;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get uv between -1 and 1 and fix aspect ratio\r\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n    \r\n    // camera setup\r\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\r\n    \r\n    vec3 eye = vec3(3.0*sin(angle),\r\n                    1.6 + 0.2*(sin(iTime*0.23)),\r\n                    3.0*cos(angle));\r\n    \r\n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\r\n    \r\n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\r\n    vec3 view_dir = normalize( look_at - eye );\r\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\r\n    vec3 up = cross( view_dir, right );\r\n    float focal_dist = 5.0;\r\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\r\n    \r\n    // background color\r\n    vec3 col = vec3(0.5);\r\n    \r\n    // reflect ray at water surface\r\n    float dist = ray_march_water( eye, ray_dir );\r\n    vec3 p = eye + dist*ray_dir;\r\n    vec3 normal = calcWaterNormal( p );\r\n    ray_dir = reflect( ray_dir, normal );\r\n    \r\n    // raymarch the trees\r\n\tdist = ray_march( p + normal * 0.01, ray_dir );\r\n \r\n    // color trees black\r\n    if (dist < 18.0) col = vec3(0);\r\n    \r\n    // color moon white\r\n    // moon is at infinity\r\n    // render based on angle of the reflected ray\r\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\r\n\r\n\tfragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\r\n// and animate the scene. The rays are reflected off a displaced\r\n// plane  into the trees.\r\n\r\n// polynomial smooth min (k = 0.1);\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\nfloat sminCubic( float a, float b, float k )\r\n{\r\n    float h = max( k-abs(a-b), 0.0 )/k;\r\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\r\n}\r\n\r\n// the wave for each droplet is based on a simple cosine wave\r\n// the wave in attenuated by the sqared distace to the center\r\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\r\n// both the cosine wave and the rings are animated by offsets\r\n// time is looped in 25 second intervals\r\n// about the time for the rings to leave the field of view\r\nfloat waveDisplacement( vec3 p )\r\n{\r\n    // drop one\r\n    float dist = length(p.xz - vec2(-0.5, 6.0));\r\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\r\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop two\r\n    dist = length(p.xz - vec2(0.5, 5.5));\r\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop three\r\n    dist = length(p.xz - vec2(-0.0, 5.0));\r\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    return waves;\r\n}\r\n\r\n// plane with waves\r\nfloat sdPlane( vec3 p )\r\n{\r\n    float dist = p.y;\r\n    \r\n    // apply costly displacement only when close\r\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\r\n    \r\n    return dist;\r\n}\r\n\r\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\r\n{\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\n// like capsule, but with different radii at each end\r\n// https://www.shadertoy.com/view/3lsSzf\r\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\r\n{\r\n    vec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\r\n}\r\n\r\nfloat sdTree( vec3 p )\r\n{\r\n    // trunk\r\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\r\n    \r\n    // mirror x-axis\r\n    p.x = abs( p.x );\r\n    \r\n    // big branches\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\r\n    \r\n    // mirror z-axis\r\n    p.z = abs( p.z );\r\n    \r\n    // small branches\r\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\r\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\r\n    \r\n    // lang thin branches\r\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\r\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\r\n    \r\n    return dist;\r\n}\r\n\r\n// combined SDF for scene\r\n// water is handled seperately for optimization\r\nfloat map( vec3 p ) {\r\n   \t\r\n    // slight distortion of the space\r\n    // makes the trees look more organic\r\n    // this makes a big difference\r\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\r\n    \r\n    vec3 p1 = p;\r\n    \r\n\t// rotation matrix based on pythagorean tripel\r\n    p1 *= mat3( 4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, 4.0) / 5.0;\r\n    \r\n    float tree1 = sdTree(p1);\r\n    \r\n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\r\n   \t\r\n    // rotation matrix based on pythagorean tripel\r\n    p2 *= mat3(-4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, -4.0) / 5.0;\r\n    \r\n    float tree2 = sdTree(p2);\r\n    \r\n    return min(tree1, tree2);\r\n}\r\n\r\n// optimized normal for water\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcWaterNormal( in vec3 pos)\r\n{\r\n    \r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\r\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \r\n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \r\n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \r\n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=0; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*sdPlane(pos+0.001*e);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n\r\n// get distance to the water surface\r\n// the water is close, only a few iterations are needed\r\n// this helps because the displacement is costly\r\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 10; i++) {\r\n        float d = sdPlane( eye + dist * ray_dir );\r\n        if ( d < 0.001) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 10.0 ) {\r\n            break;\r\n        }    \r\n    }\r\n    return dist;\r\n}\r\n\r\n// get distance to the trees\r\n// farplane is close to speed things up\r\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 70; i++) {\r\n        float d = map( eye + dist * ray_dir );\r\n        if ( d < 0.001 * dist) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 18.0 ) {\r\n            break;\r\n        }\r\n        \r\n    }\r\n    return dist;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get uv between -1 and 1 and fix aspect ratio\r\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n    \r\n    // camera setup\r\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\r\n    \r\n    vec3 eye = vec3(3.0*sin(angle),\r\n                    1.6 + 0.2*(sin(iTime*0.23)),\r\n                    3.0*cos(angle));\r\n    \r\n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\r\n    \r\n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\r\n    vec3 view_dir = normalize( look_at - eye );\r\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\r\n    vec3 up = cross( view_dir, right );\r\n    float focal_dist = 5.0;\r\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\r\n    \r\n    // background color\r\n    vec3 col = vec3(0.5);\r\n    \r\n    // reflect ray at water surface\r\n    float dist = ray_march_water( eye, ray_dir );\r\n    vec3 p = eye + dist*ray_dir;\r\n    vec3 normal = calcWaterNormal( p );\r\n    ray_dir = reflect( ray_dir, normal );\r\n    \r\n    // raymarch the trees\r\n\tdist = ray_march( p + normal * 0.01, ray_dir );\r\n \r\n    // color trees black\r\n    if (dist < 18.0) col = vec3(0);\r\n    \r\n    // color moon white\r\n    // moon is at infinity\r\n    // render based on angle of the reflected ray\r\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\r\n\r\n\tfragColor = vec4(col, 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Escher Puddle","id":"48d0b6c517c9477ea10c38a4d67d9d57","date":null,"viewed":0,"name":"Escher Puddle","description":"This is my attempt to recreate and animate M.C. Eschers 'Rippled Surface'\r\nhttps://www.shadertoy.com/view/3tVGDh","likes":0,"published":null,"tags":["raymarching"," reflection"," waves"," escher"," reproduction"]},"ver":null,"info":{"Name":"Escher Puddle","id":"48d0b6c517c9477ea10c38a4d67d9d57","date":null,"viewed":0,"name":"Escher Puddle","description":"This is my attempt to recreate and animate M.C. Eschers 'Rippled Surface'\r\nhttps://www.shadertoy.com/view/3tVGDh","likes":0,"published":null,"tags":["raymarching"," reflection"," waves"," escher"," reproduction"]},"renderpass":[{"Code":"// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\r\n// and animate the scene. The rays are reflected off a displaced\r\n// plane  into the trees.\r\n\r\n// polynomial smooth min (k = 0.1);\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\nfloat sminCubic( float a, float b, float k )\r\n{\r\n    float h = max( k-abs(a-b), 0.0 )/k;\r\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\r\n}\r\n\r\n// the wave for each droplet is based on a simple cosine wave\r\n// the wave in attenuated by the sqared distace to the center\r\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\r\n// both the cosine wave and the rings are animated by offsets\r\n// time is looped in 25 second intervals\r\n// about the time for the rings to leave the field of view\r\nfloat waveDisplacement( vec3 p )\r\n{\r\n    // drop one\r\n    float dist = length(p.xz - vec2(-0.5, 6.0));\r\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\r\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop two\r\n    dist = length(p.xz - vec2(0.5, 5.5));\r\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop three\r\n    dist = length(p.xz - vec2(-0.0, 5.0));\r\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    return waves;\r\n}\r\n\r\n// plane with waves\r\nfloat sdPlane( vec3 p )\r\n{\r\n    float dist = p.y;\r\n    \r\n    // apply costly displacement only when close\r\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\r\n    \r\n    return dist;\r\n}\r\n\r\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\r\n{\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\n// like capsule, but with different radii at each end\r\n// https://www.shadertoy.com/view/3lsSzf\r\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\r\n{\r\n    vec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\r\n}\r\n\r\nfloat sdTree( vec3 p )\r\n{\r\n    // trunk\r\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\r\n    \r\n    // mirror x-axis\r\n    p.x = abs( p.x );\r\n    \r\n    // big branches\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\r\n    \r\n    // mirror z-axis\r\n    p.z = abs( p.z );\r\n    \r\n    // small branches\r\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\r\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\r\n    \r\n    // lang thin branches\r\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\r\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\r\n    \r\n    return dist;\r\n}\r\n\r\n// combined SDF for scene\r\n// water is handled seperately for optimization\r\nfloat map( vec3 p ) {\r\n   \t\r\n    // slight distortion of the space\r\n    // makes the trees look more organic\r\n    // this makes a big difference\r\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\r\n    \r\n    vec3 p1 = p;\r\n    \r\n\t// rotation matrix based on pythagorean tripel\r\n    p1 *= mat3( 4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, 4.0) / 5.0;\r\n    \r\n    float tree1 = sdTree(p1);\r\n    \r\n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\r\n   \t\r\n    // rotation matrix based on pythagorean tripel\r\n    p2 *= mat3(-4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, -4.0) / 5.0;\r\n    \r\n    float tree2 = sdTree(p2);\r\n    \r\n    return min(tree1, tree2);\r\n}\r\n\r\n// optimized normal for water\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcWaterNormal( in vec3 pos)\r\n{\r\n    \r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\r\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \r\n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \r\n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \r\n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=0; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*sdPlane(pos+0.001*e);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n\r\n// get distance to the water surface\r\n// the water is close, only a few iterations are needed\r\n// this helps because the displacement is costly\r\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 10; i++) {\r\n        float d = sdPlane( eye + dist * ray_dir );\r\n        if ( d < 0.001) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 10.0 ) {\r\n            break;\r\n        }    \r\n    }\r\n    return dist;\r\n}\r\n\r\n// get distance to the trees\r\n// farplane is close to speed things up\r\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 70; i++) {\r\n        float d = map( eye + dist * ray_dir );\r\n        if ( d < 0.001 * dist) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 18.0 ) {\r\n            break;\r\n        }\r\n        \r\n    }\r\n    return dist;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get uv between -1 and 1 and fix aspect ratio\r\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n    \r\n    // camera setup\r\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\r\n    \r\n    vec3 eye = vec3(3.0*sin(angle),\r\n                    1.6 + 0.2*(sin(iTime*0.23)),\r\n                    3.0*cos(angle));\r\n    \r\n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\r\n    \r\n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\r\n    vec3 view_dir = normalize( look_at - eye );\r\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\r\n    vec3 up = cross( view_dir, right );\r\n    float focal_dist = 5.0;\r\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\r\n    \r\n    // background color\r\n    vec3 col = vec3(0.5);\r\n    \r\n    // reflect ray at water surface\r\n    float dist = ray_march_water( eye, ray_dir );\r\n    vec3 p = eye + dist*ray_dir;\r\n    vec3 normal = calcWaterNormal( p );\r\n    ray_dir = reflect( ray_dir, normal );\r\n    \r\n    // raymarch the trees\r\n\tdist = ray_march( p + normal * 0.01, ray_dir );\r\n \r\n    // color trees black\r\n    if (dist < 18.0) col = vec3(0);\r\n    \r\n    // color moon white\r\n    // moon is at infinity\r\n    // render based on angle of the reflected ray\r\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\r\n\r\n\tfragColor = vec4(col, 1.0);\r\n}","inputs":[],"outputs":[],"code":"// I have tried to recreate the effect of M.C. Eschers 'Rippled Surface'\r\n// and animate the scene. The rays are reflected off a displaced\r\n// plane  into the trees.\r\n\r\n// polynomial smooth min (k = 0.1);\r\n// http://iquilezles.org/www/articles/smin/smin.htm\r\nfloat sminCubic( float a, float b, float k )\r\n{\r\n    float h = max( k-abs(a-b), 0.0 )/k;\r\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\r\n}\r\n\r\n// the wave for each droplet is based on a simple cosine wave\r\n// the wave in attenuated by the sqared distace to the center\r\n// for the ring the wave is multiplied by e^(-x^2) to get the rings\r\n// both the cosine wave and the rings are animated by offsets\r\n// time is looped in 25 second intervals\r\n// about the time for the rings to leave the field of view\r\nfloat waveDisplacement( vec3 p )\r\n{\r\n    // drop one\r\n    float dist = length(p.xz - vec2(-0.5, 6.0));\r\n    float ring = 10.0*dist - mod(iTime - 8.0, 25.0) + 4.0;\r\n    float waves = cos(60.0*dist - 10.0*mod(iTime + 2.0, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop two\r\n    dist = length(p.xz - vec2(0.5, 5.5));\r\n    ring = 10.0*dist - mod(iTime, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    // drop three\r\n    dist = length(p.xz - vec2(-0.0, 5.0));\r\n    ring = 10.0*dist - mod(iTime - 16.0, 25.0) + 4.0;\r\n    waves += cos(60.0*dist - 10.0*mod(iTime, 25.0))*exp(-0.2*ring*ring)/(1.0 + 15.0*dist*dist);\r\n    \r\n    return waves;\r\n}\r\n\r\n// plane with waves\r\nfloat sdPlane( vec3 p )\r\n{\r\n    float dist = p.y;\r\n    \r\n    // apply costly displacement only when close\r\n    if (p.y < 0.1) dist -= 0.0008*waveDisplacement(p);\r\n    \r\n    return dist;\r\n}\r\n\r\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\r\n{\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\n\r\n// like capsule, but with different radii at each end\r\n// https://www.shadertoy.com/view/3lsSzf\r\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\r\n{\r\n    vec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\r\n}\r\n\r\nfloat sdTree( vec3 p )\r\n{\r\n    // trunk\r\n    float dist = sdCapsule( p, vec3(0), vec3(0.0, 2.5, 0.0), 0.3 );\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.0, 2.5, 0.0), vec3(0.0, 6.5, 0.0), 0.2), 0.1);\r\n    \r\n    // mirror x-axis\r\n    p.x = abs( p.x );\r\n    \r\n    // big branches\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 1.5, 0.0), vec3(1.4, 3.0, 0.0), 0.11), 0.1);\r\n    dist = sminCubic( dist, sdCapsule( p , vec3(0.15, 2.5, 0.0), vec3(0.7, 3.5, 0.0), 0.10), 0.1);\r\n    \r\n    // mirror z-axis\r\n    p.z = abs( p.z );\r\n    \r\n    // small branches\r\n    dist = sminCubic( dist, sdStick( p , vec3(1.4, 3.0, 0.1), vec3(3.2, 6.5, 3.0), 0.07, 0.02), 0.1);\r\n    dist = sminCubic( dist, sdStick( p , vec3(0.7, 3.5, 0.08), vec3(2.8, 7.5, 1.0), 0.05, 0.02), 0.1);\r\n    \r\n    // lang thin branches\r\n    dist = min( dist, sdStick( p , vec3(0.7, 0.0, 0.1), vec3(5.8, 10.5, 2.0), 0.05, 0.01));\r\n    dist = min( dist, sdStick( p , vec3(1.3, 0.0, 2.5), vec3(.3, 3.5, 2.0), 0.02, 0.01));\r\n    \r\n    return dist;\r\n}\r\n\r\n// combined SDF for scene\r\n// water is handled seperately for optimization\r\nfloat map( vec3 p ) {\r\n   \t\r\n    // slight distortion of the space\r\n    // makes the trees look more organic\r\n    // this makes a big difference\r\n    p += vec3(0.3*cos(1.2*p.x), 0.2*sin(1.2*p.y), 0.1*sin(p.z));\r\n    \r\n    vec3 p1 = p;\r\n    \r\n\t// rotation matrix based on pythagorean tripel\r\n    p1 *= mat3( 4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, 4.0) / 5.0;\r\n    \r\n    float tree1 = sdTree(p1);\r\n    \r\n    vec3 p2 = p + vec3(3.0, 0.0, 0.0);\r\n   \t\r\n    // rotation matrix based on pythagorean tripel\r\n    p2 *= mat3(-4.0, 0.0, 3.0,\r\n                0.0, 5.0, 0.0,\r\n               -3.0, 0.0, -4.0) / 5.0;\r\n    \r\n    float tree2 = sdTree(p2);\r\n    \r\n    return min(tree1, tree2);\r\n}\r\n\r\n// optimized normal for water\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcWaterNormal( in vec3 pos)\r\n{\r\n    \r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\r\n    return normalize( e.xyy*sdPlane( pos + e.xyy) + \r\n\t\t\t\t\t  e.yyx*sdPlane( pos + e.yyx) + \r\n\t\t\t\t\t  e.yxy*sdPlane( pos + e.yxy) + \r\n\t\t\t\t\t  e.xxx*sdPlane( pos + e.xxx) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=0; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*sdPlane(pos+0.001*e);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n\r\n// get distance to the water surface\r\n// the water is close, only a few iterations are needed\r\n// this helps because the displacement is costly\r\nfloat ray_march_water( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 10; i++) {\r\n        float d = sdPlane( eye + dist * ray_dir );\r\n        if ( d < 0.001) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 10.0 ) {\r\n            break;\r\n        }    \r\n    }\r\n    return dist;\r\n}\r\n\r\n// get distance to the trees\r\n// farplane is close to speed things up\r\nfloat ray_march( vec3 eye, vec3 ray_dir ) {\r\n    float dist = 0.0;\r\n    for (int i = 0; i < 70; i++) {\r\n        float d = map( eye + dist * ray_dir );\r\n        if ( d < 0.001 * dist) {\r\n      \t\tbreak;\r\n        }\r\n        dist += d;\r\n        if ( dist > 18.0 ) {\r\n            break;\r\n        }\r\n        \r\n    }\r\n    return dist;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get uv between -1 and 1 and fix aspect ratio\r\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n    \r\n    // camera setup\r\n    float angle = 0.05*(cos(iTime*0.2)) + 0.25;\r\n    \r\n    vec3 eye = vec3(3.0*sin(angle),\r\n                    1.6 + 0.2*(sin(iTime*0.23)),\r\n                    3.0*cos(angle));\r\n    \r\n    eye += vec3(0.3*sin(iTime*0.32), 0.0, 6.0);\r\n    \r\n    vec3 look_at = vec3( 0.0, 0.0, 6.0 );\r\n    vec3 view_dir = normalize( look_at - eye );\r\n    vec3 right = cross( vec3( 0.0, 1.0, 0.0 ), view_dir );\r\n    vec3 up = cross( view_dir, right );\r\n    float focal_dist = 5.0;\r\n    vec3 ray_dir = normalize( focal_dist*view_dir + uv.x*right + uv.y*up );\r\n    \r\n    // background color\r\n    vec3 col = vec3(0.5);\r\n    \r\n    // reflect ray at water surface\r\n    float dist = ray_march_water( eye, ray_dir );\r\n    vec3 p = eye + dist*ray_dir;\r\n    vec3 normal = calcWaterNormal( p );\r\n    ray_dir = reflect( ray_dir, normal );\r\n    \r\n    // raymarch the trees\r\n\tdist = ray_march( p + normal * 0.01, ray_dir );\r\n \r\n    // color trees black\r\n    if (dist < 18.0) col = vec3(0);\r\n    \r\n    // color moon white\r\n    // moon is at infinity\r\n    // render based on angle of the reflected ray\r\n\telse if ( dot( ray_dir, normalize(vec3(-0.35, 0.6, -1.0))) > 0.997) col = vec3(1);\r\n\r\n\tfragColor = vec4(col, 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Example of 3D Noise","id":"Wtc3W7","date":"0","viewed":0,"name":"Example of 3D Noise","description":"3d\u566A\u58F0\u793A\u4F8B","likes":0,"published":"Private","tags":["3d","noise"]},"ver":"0.1","info":{"Name":"Example of 3D Noise","id":"Wtc3W7","date":"0","viewed":0,"name":"Example of 3D Noise","description":"3d\u566A\u58F0\u793A\u4F8B","likes":0,"published":"Private","tags":["3d","noise"]},"renderpass":[{"Code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    \n    res = opU(res, vec2(sdPlane(pos),0));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n         col = vec3(noise(pos*16.0));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(4.0 * cos(time + 6.0*mousePos.x), 2.5 + 2.0*mousePos.y, 4.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Examples Of 2D Noise","id":"llKyDc","date":"1576221630","viewed":61,"name":"Examples Of 2D Noise","description":"2d\u566A\u58F0\u793A\u4F8B","likes":6,"published":"Public","tags":["2d","noise"]},"ver":"0.1","info":{"Name":"Examples Of 2D Noise","id":"llKyDc","date":"1576221630","viewed":61,"name":"Examples Of 2D Noise","description":"2d\u566A\u58F0\u793A\u4F8B","likes":6,"published":"Public","tags":["2d","noise"]},"renderpass":[{"Code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n \n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\n\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u68AF\u5EA6\u566A\u58F0\n// \u7B97\u6CD5\u89E3\u6790\uFF1A\u521B\u5EFA\u4E00\u4E2A\u7531\u82E5\u5E72\u865A\u62DF\u6676\u683C\u7EC4\u6210\u7684\u5E73\u9762\uFF0C\u63A5\u7740\u7ED9\u6BCF\u4E2A\u6676\u683C\u7684\u9876\u70B9\u8D4B\u4E88\u4E00\u4E2A\u968F\u673A\u7684\u5411\u91CF\uFF08\u901A\u8FC7hash\u51FD\u6570\u751F\u6210\uFF09\uFF0C\n// \u7136\u540E\u901A\u8FC7fract\u51FD\u6570\u5C06\u8BE5\u70B9\u5E73\u79FB\u5230\u3010x:0-1, y:0-1\u3011\u7684\u7A7A\u95F4\u4E2D\uFF0C\u518D\u8BA1\u7B97\u5230\u5404\u4E2A\u6676\u683C\u9876\u70B9\u7684\u8DDD\u79BB\u5411\u91CF\uFF0C\n// \u7136\u540E\u5C06\u8FD9\u4E24\u4E2A\u5411\u91CF\u8FDB\u884Cdot\uFF0C\u6700\u540Edot\u7684\u7ED3\u679C\u5229\u7528ease curves\uFF08\u5373u\uFF09\u8FDB\u884C\u53CC\u7EBF\u6027\u63D2\u503C\u3002\nfloat gradient_noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n \n//simplex\u566A\u58F0 \nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t// \u53D8\u6362\u5230\u65B0\u7F51\u683C\u7684(0, 0)\u70B9\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\t// i - (i.x+i.y)*K2\u6362\u7B97\u5230\u65E7\u7F51\u683C\u70B9\n    // a:\u53D8\u5F62\u524D\u8F93\u5165\u70B9p\u5230\u8BE5\u7F51\u683C\u70B9\u7684\u8DDD\u79BB\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    // \u65B0\u7F51\u683C(1.0, 0.0)\u6216(0.0, 1.0)\n    // b = p - (i+o - (i.x + i.y + 1.0)*K2);\n    vec2 b = a - o + K2;\n    // \u65B0\u7F51\u683C(1.0, 1.0)\n    // c = p - (i+vec2(1.0, 1.0) - (i.x+1.0 + i.y+1.0)*K2);\n    vec2 c = a - 1.0 + 2.0 * K2;\n\t// \u8BA1\u7B97\u6BCF\u4E2A\u9876\u70B9\u7684\u6743\u91CD\u5411\u91CF\uFF0Cr^2 = 0.5\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    // \u6BCF\u4E2A\u9876\u70B9\u7684\u68AF\u5EA6\u5411\u91CF\u548C\u8DDD\u79BB\u5411\u91CF\u7684\u70B9\u4E58\uFF0C\u7136\u540E\u518D\u4E58\u4E0A\u6743\u91CD\u5411\u91CF\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\t\n    // \u4E4B\u6240\u4EE5\u4E58\u4E0A70\uFF0C\u662F\u5728\u8BA1\u7B97\u4E86n\u6BCF\u4E2A\u5206\u91CF\u7684\u548C\u7684\u6700\u5927\u503C\u4EE5\u540E\u5F97\u51FA\u7684\uFF0C\u8FD9\u6837\u624D\u80FD\u4FDD\u8BC1\u5C06n\u5404\u4E2A\u5206\u91CF\u76F8\u52A0\u4EE5\u540E\u7684\u7ED3\u679C\u5728[-1, 1]\u4E4B\u95F4\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n//\u57FA\u4E8E\u503C\u566A\u58F0\u7684\u5206\u5F62\u566A\u58F0\nfloat fractal_noise(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise(p); p = m*p;\n\tf += 0.2500*value_noise(p); p = m*p;\n\tf += 0.1250*value_noise(p); p = m*p;\n\tf += 0.0625*value_noise(p); p = m*p;\n    \n    return f;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n\tvec2 uv = p * vec2(iResolution.x/iResolution.y,1.0);\n\t\n\tfloat f = 0.0;\n\t\n    // 1: white noise\t\n\tif( p.x<0.2 )\n\t{\n\t\tf = white_noise(uv);\n\t}\n    // 2: value noise\n    else if(p.x>=0.2 && p.x<0.4)\t\n\t{\n        f = value_noise(uv*56.0);\n\t}\n    // 3. gradient noise\n    else if(p.x>=0.4 && p.x<0.6)\n    {\n    \tf = gradient_noise(uv*32.0);\n    }\n    // 4: simplex noise\n    else if(p.x>=0.6 && p.x<0.8)\n    {\n    \tf = simplex_noise(uv*32.0);\n    }\n    // 5: fractal noise\n    else\n    {\n    \tf = fractal_noise(8.0*uv);\n    }\n \n\tf = 0.5 + 0.5*f;\n\t\n    // \u5206\u5272\u7EBF\uFF1A\u6CE8\u610F\u5982\u679C\u7B2C\u4E09\u4E2A\u53C2\u6570\u8D85\u8FC7\u4E86\u9650\u5B9A\u8303\u56F4\u5C31\u4E0D\u8FDB\u884C\u63D2\u503C\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.2));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.4));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.6));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.8));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Eye-2D","id":"3dyXDt","date":"0","viewed":0,"name":"Eye-2D","description":"Eye-2D","likes":0,"published":"Private","tags":["2dmodel"]},"ver":"0.1","info":{"Name":"Eye-2D","id":"3dyXDt","date":"0","viewed":0,"name":"Eye-2D","description":"Eye-2D","likes":0,"published":"Private","tags":["2dmodel"]},"renderpass":[{"Code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n \n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n \n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);   \n}\n\nvec3 eye(vec2 p,float b)\n{\n    //b:abs(p.y)\u4E0E\u773C\u775B\u8F6E\u5ED3\u66F2\u7EBF\u7684\u5DEE\n    p -= vec2(0.6,0.05);//\u5706\u5FC3\n    float a = atan(p.y,p.x);\n    float d = length(p);//\u5230\u5706\u5FC3\u7684\u8DDD\u79BB\n    float e = smoothstep(0.20,0.21,d);//\u8679\u819C\u534A\u5F84\n    vec3 fue = vec3(1.0,1.0,1.0);//\u773C\u767D\u989C\u8272\n    float ven = noise(vec2(24.0*p.x,24.0*p.y));//\u8840\u4E1D\n    ven = smoothstep(-0.1,0.0,ven)-smoothstep(0.0,0.1,ven);\n    float x = p.x+0.6;\n    ven += x + x*x*x*x*x*x*7.0;\n    fue.x += 0.04 - 0.01*ven;\n    fue.y += 0.04 - 0.05*ven;\n    fue.z += 0.04 - 0.05*ven;\n    //vec3 den = vec3(0.3,0.7,0.4+d*1.5);//\u8679\u819C\u989C\u8272\n    vec3 den = vec3(160.0/255.0+d*0.2,82.0/255.0+d*0.5,45.0/255.0);//\u8679\u819C\u989C\u8272\n    float noi = 0.8 + 0.2*noise(vec2(d*12.0,24.0*a/3.1415926));//\u8679\u819C\u4E2D\u5F84\u5411\u5206\u5E03\u7684\u9ED1\u8272\u7D20\n    den *= noi;\n    float f = smoothstep(0.055,0.065,d);//\u77B3\u5B54\u534A\u5F84\n    den *= f;\n    vec3 col = mix(den,fue,e);\n    float ring = smoothstep(0.18,0.20,d)-smoothstep(0.20,0.22,d);//\u8679\u819C\u7684\u5916\u73AF\n    ring = 1.0 - 0.35*ring;\n    col *= ring;\n    //\u53CD\u5C04\n    float r = sqrt(d*d*d);\n    float re = noise(vec2(1.2+32.0*r*cos(a),32.0*r*sin(a)));\n    re = 0.5*smoothstep(0.1f,0.5f,re);\n    col.x += (1.0-col.x)*re;col.y +=(1.0-col.y)*re;col.z += (1.0-col.z)*re;\n    //\u9634\u5F71\n    col*=0.8+0.2*smoothstep(0.0,0.1,-b);\n    return col;\n}\n\nvec3 skin(vec2 p)\n{\n    return vec3(0.0,0.0,0.0);\n}\n\nvec3 draw(vec2 p){\n    p.x = (p.x+1.0)*0.5;\n    p.y = p.y * iResolution.y/(iResolution.x*1.0);   \n    float h = sqrt(p.x*p.x*p.x)*(1.0-p.x);//\u773C\u955C\u7684\u8F6E\u5ED3\u66F2\u7EBF\n    float e = abs(p.y)-h;\n    float f = smoothstep(0.0,0.01,e);\n    vec3 eye = eye(p,e);\n    vec3 skin = skin(p);\n    vec3 col = mix(eye,skin,f);\n    float ring = smoothstep(-0.01,0.0,e)-smoothstep(0.0,0.01,e);\n    col *= 1.0-ring*0.8;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.x;\n    \n    vec3 col = draw(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"fbm test1","id":"wsyXDV","date":"0","viewed":0,"name":"fbm test1","description":"math fbm noise","likes":0,"published":"Private","tags":["mathfbmnoise"]},"ver":"0.1","info":{"Name":"fbm test1","id":"wsyXDV","date":"0","viewed":0,"name":"fbm test1","description":"math fbm noise","likes":0,"published":"Private","tags":["mathfbmnoise"]},"renderpass":[{"Code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Shows the anisotropic self-similarity of Brownian Motion \n// on the left and the isotropic self-similarity of Fractional\n// Brownian Motion if gain=0.5.\n//\n// On the left, a clasical Brownian Motion is generated, which\n// is a process with Hurst Exponet H=1/2 (uncorrelated deltas,\n// no memory). Such curve has a fractal dimension of 1.5 and\n// needs a vertical scaling factor of sqrt(x) when it's scaled\n// by x horizontally. It's power spectrum decays as f^-2\n//\n// On the right, a Fractional Brownian Motion with H=1\n// which means a gain G of 0.5. It's a long memory curve\n// with possitively correlated increments, has a fractal\n// of 1, and is naturally istropicaly self-similar (non-\n// distorted zoom). Because of that, it's what we use to\n// mimic mountains. It's power spectrum decays as f^-3\n//\n// More info: http://iquilezles.org/www/articles/fbm/fbm.htm\n\n// integer hash copied from Hugo Elias\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\n// gradient noise\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\n\nfloat fbmPurest(in float x, in float H )\n{    \n    float t = 0.0;\n    int numOctaves = 16;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*gnoise(f*x);\n    }\n    return t;\n}\n\nfloat fbmEquivalent( in float x, in float H )\n{    \n    float G = exp2(-H);\n    int numOctaves = 16;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*gnoise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// fbm\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nvec3 anim( in vec2 p, float time )\n{\n    vec3 col = vec3(0.0);\n    \n    //float ani = fract(time/4.0);\n    float ani = smoothstep(0.0,1.0,fract(time/4.0));\n\n    float zoom = pow( 2.0, 6.0*ani );\n    \n\n    if( p.x<0.0 )\n    {\n        vec2 q = vec2(p.x*0.5 + 0.5,p.y);\n        float G = 0.707107;\n\n        float comp = zoom;\n        float comp2 = sqrt(comp);\n\n        if( q.y<0.0 )\n        {\n        float y = -0.5+0.5*comp2*(fbm(0.8*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5).zyx, 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.5*fbm(0.8*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0).zyx, (1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y)));\n        }\n    }\n    else\n    {\n        vec2 q = vec2(p.x*0.5 - 0.5,p.y);\n        float G = 0.5;\n        float comp = zoom;\n        float comp2 = comp;\n        if( p.y<0.0 )\n        {\n        float y = -0.5+0.9*comp2*(fbm(1.0*q.x/comp, G ));\n        y += zoom*0.004;\n        col = mix( col, vec3(1.0,1.0,0.5), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        else\n        {\n        float y = 0.5+0.9*fbm(1.0*q.x, G );\n        col = mix( col, vec3(1.0,0.5,0.0), 1.0-smoothstep( 0.0, 12.0/iResolution.x,q.y-y));\n        }\n        \n    }\n       \n    col  *= smoothstep(0.01,0.02,abs(p.x) );\n    col  *= smoothstep(0.01,0.02,abs(p.y) );\n\n    return col;\n}\n\n\n#define AA 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(m,n)/float(AA);\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        col += anim(p,iTime);\n    }\n    col /= float(AA*AA);\n    \n    fragColor = vec4( col, 1.0 );\n    \n}\n","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// from star shader https://www.shadertoy.com/view/Xty3zc\r\n\r\n\r\n#define rnd(x)  fract( 4356.17 * sin( 1e4*x ) )\r\n#define srnd(x) ( 2.* rnd(x) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n    float r, t = iTime,t1,v;\r\n    vec2 R = iResolution.xy, P;\r\n    U =  (2.*U-R) / R.y;\r\n\r\n    O -= O;\r\n    \r\n  if (abs(U.x)<1.25*cos(1.2*(.5+.5*U.y))) // clamp out of the flame profile\r\n    for(float i=0.; i<3.*256.; i++) {\r\n       t1 = t + 6.28*rnd(i);\r\n        v = 2.+srnd(i+.7);\r\n        r = cos(1.4*fract(t1)) * (.2+rnd(i+.1));    \r\n        P = vec2(   cos(t1*v)*r ,          // particle location\r\n                 .2*sin (t1*v)*r + 2.*pow(fract(t1),1.5)-1.   ), \r\n        r = length(P-U),\r\n\t    O += U.x<0. \r\n             ? 1e-4 / pow(r,3.)            // pix = clamp ( Emit/dist^2 * Bessel )\r\n             : smoothstep(1.,.8, r*20.);   // pix = disk ( R/dist )\r\n    }\r\n    \r\n    O *= vec4(1,.5,.2,1);                  // color  \r\n    \r\n  //O += .3*texture(iChannel0,vec3(-U,-1));\r\n}","inputs":[],"outputs":[],"code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// from star shader https://www.shadertoy.com/view/Xty3zc\r\n\r\n\r\n#define rnd(x)  fract( 4356.17 * sin( 1e4*x ) )\r\n#define srnd(x) ( 2.* rnd(x) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n    float r, t = iTime,t1,v;\r\n    vec2 R = iResolution.xy, P;\r\n    U =  (2.*U-R) / R.y;\r\n\r\n    O -= O;\r\n    \r\n  if (abs(U.x)<1.25*cos(1.2*(.5+.5*U.y))) // clamp out of the flame profile\r\n    for(float i=0.; i<3.*256.; i++) {\r\n       t1 = t + 6.28*rnd(i);\r\n        v = 2.+srnd(i+.7);\r\n        r = cos(1.4*fract(t1)) * (.2+rnd(i+.1));    \r\n        P = vec2(   cos(t1*v)*r ,          // particle location\r\n                 .2*sin (t1*v)*r + 2.*pow(fract(t1),1.5)-1.   ), \r\n        r = length(P-U),\r\n\t    O += U.x<0. \r\n             ? 1e-4 / pow(r,3.)            // pix = clamp ( Emit/dist^2 * Bessel )\r\n             : smoothstep(1.,.8, r*20.);   // pix = disk ( R/dist )\r\n    }\r\n    \r\n    O *= vec4(1,.5,.2,1);                  // color  \r\n    \r\n  //O += .3*texture(iChannel0,vec3(-U,-1));\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"fire particles - PSF+saturation","id":"ffbf1ee3a163422982f3e5ff093660f1","date":null,"viewed":0,"name":"fire particles - PSF+saturation","description":"Accounting for blooming+saturation effect\r\nhttps://www.shadertoy.com/view/MlG3R3","likes":0,"published":null,"tags":["psf"," sensor"]},"ver":null,"info":{"Name":"fire particles - PSF+saturation","id":"ffbf1ee3a163422982f3e5ff093660f1","date":null,"viewed":0,"name":"fire particles - PSF+saturation","description":"Accounting for blooming+saturation effect\r\nhttps://www.shadertoy.com/view/MlG3R3","likes":0,"published":null,"tags":["psf"," sensor"]},"renderpass":[{"Code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// from star shader https://www.shadertoy.com/view/Xty3zc\r\n\r\n\r\n#define rnd(x)  fract( 4356.17 * sin( 1e4*x ) )\r\n#define srnd(x) ( 2.* rnd(x) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n    float r, t = iTime,t1,v;\r\n    vec2 R = iResolution.xy, P;\r\n    U =  (2.*U-R) / R.y;\r\n\r\n    O -= O;\r\n    \r\n  if (abs(U.x)<1.25*cos(1.2*(.5+.5*U.y))) // clamp out of the flame profile\r\n    for(float i=0.; i<3.*256.; i++) {\r\n       t1 = t + 6.28*rnd(i);\r\n        v = 2.+srnd(i+.7);\r\n        r = cos(1.4*fract(t1)) * (.2+rnd(i+.1));    \r\n        P = vec2(   cos(t1*v)*r ,          // particle location\r\n                 .2*sin (t1*v)*r + 2.*pow(fract(t1),1.5)-1.   ), \r\n        r = length(P-U),\r\n\t    O += U.x<0. \r\n             ? 1e-4 / pow(r,3.)            // pix = clamp ( Emit/dist^2 * Bessel )\r\n             : smoothstep(1.,.8, r*20.);   // pix = disk ( R/dist )\r\n    }\r\n    \r\n    O *= vec4(1,.5,.2,1);                  // color  \r\n    \r\n  //O += .3*texture(iChannel0,vec3(-U,-1));\r\n}","inputs":[],"outputs":[],"code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// from star shader https://www.shadertoy.com/view/Xty3zc\r\n\r\n\r\n#define rnd(x)  fract( 4356.17 * sin( 1e4*x ) )\r\n#define srnd(x) ( 2.* rnd(x) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n    float r, t = iTime,t1,v;\r\n    vec2 R = iResolution.xy, P;\r\n    U =  (2.*U-R) / R.y;\r\n\r\n    O -= O;\r\n    \r\n  if (abs(U.x)<1.25*cos(1.2*(.5+.5*U.y))) // clamp out of the flame profile\r\n    for(float i=0.; i<3.*256.; i++) {\r\n       t1 = t + 6.28*rnd(i);\r\n        v = 2.+srnd(i+.7);\r\n        r = cos(1.4*fract(t1)) * (.2+rnd(i+.1));    \r\n        P = vec2(   cos(t1*v)*r ,          // particle location\r\n                 .2*sin (t1*v)*r + 2.*pow(fract(t1),1.5)-1.   ), \r\n        r = length(P-U),\r\n\t    O += U.x<0. \r\n             ? 1e-4 / pow(r,3.)            // pix = clamp ( Emit/dist^2 * Bessel )\r\n             : smoothstep(1.,.8, r*20.);   // pix = disk ( R/dist )\r\n    }\r\n    \r\n    O *= vec4(1,.5,.2,1);                  // color  \r\n    \r\n  //O += .3*texture(iChannel0,vec3(-U,-1));\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// see \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\r\n\r\n// noise-based variant: https://www.shadertoy.com/view/Xl3Gzj\r\n\r\n#define r 1.5 // test distance      for efficiency, as small as it keep covering influencials river sides \r\n#define c 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\r\n\r\n#define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\r\n    \r\nfloat f(float d) { // interpolation function\r\n    float t = 1.-d/r;\r\n    return t<0. ? 0. :pow(d,-c)*(6.*t*t-15.*t+10.)*t*t*t;\r\n}\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.y;\r\n    \r\n    // --- interpolate stream function : add(distance to border, stream at border)\r\n    float t = iTime,wf=0.,wT=0., w; \r\n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\r\n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\r\n    add( length( U-vec2(.0+.2*sin(t) , .8)    ) -.3, 0.);   // rock1 stream=0.\r\n    add( length( U-vec2(.3+.2*sin(t) , .5)    ) -.3, 0.);\r\n    add( length( U-vec2(1.3, .8+.2*cos(2.*t)) ) -.5, .5);   // rock2 stream=.5\r\n    add( length( U-vec2(.8+.2*cos(.5*t), -.2) ) -.4, 1.);   // rock3 stream=1.\r\n    add( length( U-vec2(1.7, .15)             ) -.1,  .75); // rock4 stream=.75\r\n    w = wf / wT;                               // stream field\r\n    vec2 V = vec2(-dFdy(w), dFdx(w));          // velocity field\r\n    \r\n    // --- display\r\n    if (w!=w) { O =  vec4(.5,0,0,0); return; } // in rocks   ( w!=w = NaN )\r\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\r\n\r\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\r\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\r\n}","inputs":[],"outputs":[],"code":"// see \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\r\n\r\n// noise-based variant: https://www.shadertoy.com/view/Xl3Gzj\r\n\r\n#define r 1.5 // test distance      for efficiency, as small as it keep covering influencials river sides \r\n#define c 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\r\n\r\n#define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\r\n    \r\nfloat f(float d) { // interpolation function\r\n    float t = 1.-d/r;\r\n    return t<0. ? 0. :pow(d,-c)*(6.*t*t-15.*t+10.)*t*t*t;\r\n}\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.y;\r\n    \r\n    // --- interpolate stream function : add(distance to border, stream at border)\r\n    float t = iTime,wf=0.,wT=0., w; \r\n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\r\n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\r\n    add( length( U-vec2(.0+.2*sin(t) , .8)    ) -.3, 0.);   // rock1 stream=0.\r\n    add( length( U-vec2(.3+.2*sin(t) , .5)    ) -.3, 0.);\r\n    add( length( U-vec2(1.3, .8+.2*cos(2.*t)) ) -.5, .5);   // rock2 stream=.5\r\n    add( length( U-vec2(.8+.2*cos(.5*t), -.2) ) -.4, 1.);   // rock3 stream=1.\r\n    add( length( U-vec2(1.7, .15)             ) -.1,  .75); // rock4 stream=.75\r\n    w = wf / wT;                               // stream field\r\n    vec2 V = vec2(-dFdy(w), dFdx(w));          // velocity field\r\n    \r\n    // --- display\r\n    if (w!=w) { O =  vec4(.5,0,0,0); return; } // in rocks   ( w!=w = NaN )\r\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\r\n\r\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\r\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"flow by stream function ","id":"b21e193b17d741298a17d8b740377dc3","date":null,"viewed":0,"name":"flow by stream function ","description":"flow by stream function. see https://hal.inria.fr/inria-00345903/\nhttps://www.shadertoy.com/view/ldtSzn","likes":0,"published":null,"tags":["fluid"," flow"," short"," stream"]},"ver":null,"info":{"Name":"flow by stream function ","id":"b21e193b17d741298a17d8b740377dc3","date":null,"viewed":0,"name":"flow by stream function ","description":"flow by stream function. see https://hal.inria.fr/inria-00345903/\nhttps://www.shadertoy.com/view/ldtSzn","likes":0,"published":null,"tags":["fluid"," flow"," short"," stream"]},"renderpass":[{"Code":"// see \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\r\n\r\n// noise-based variant: https://www.shadertoy.com/view/Xl3Gzj\r\n\r\n#define r 1.5 // test distance      for efficiency, as small as it keep covering influencials river sides \r\n#define c 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\r\n\r\n#define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\r\n    \r\nfloat f(float d) { // interpolation function\r\n    float t = 1.-d/r;\r\n    return t<0. ? 0. :pow(d,-c)*(6.*t*t-15.*t+10.)*t*t*t;\r\n}\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.y;\r\n    \r\n    // --- interpolate stream function : add(distance to border, stream at border)\r\n    float t = iTime,wf=0.,wT=0., w; \r\n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\r\n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\r\n    add( length( U-vec2(.0+.2*sin(t) , .8)    ) -.3, 0.);   // rock1 stream=0.\r\n    add( length( U-vec2(.3+.2*sin(t) , .5)    ) -.3, 0.);\r\n    add( length( U-vec2(1.3, .8+.2*cos(2.*t)) ) -.5, .5);   // rock2 stream=.5\r\n    add( length( U-vec2(.8+.2*cos(.5*t), -.2) ) -.4, 1.);   // rock3 stream=1.\r\n    add( length( U-vec2(1.7, .15)             ) -.1,  .75); // rock4 stream=.75\r\n    w = wf / wT;                               // stream field\r\n    vec2 V = vec2(-dFdy(w), dFdx(w));          // velocity field\r\n    \r\n    // --- display\r\n    if (w!=w) { O =  vec4(.5,0,0,0); return; } // in rocks   ( w!=w = NaN )\r\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\r\n\r\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\r\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\r\n}","inputs":[],"outputs":[],"code":"// see \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\r\n\r\n// noise-based variant: https://www.shadertoy.com/view/Xl3Gzj\r\n\r\n#define r 1.5 // test distance      for efficiency, as small as it keep covering influencials river sides \r\n#define c 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\r\n\r\n#define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\r\n    \r\nfloat f(float d) { // interpolation function\r\n    float t = 1.-d/r;\r\n    return t<0. ? 0. :pow(d,-c)*(6.*t*t-15.*t+10.)*t*t*t;\r\n}\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.y;\r\n    \r\n    // --- interpolate stream function : add(distance to border, stream at border)\r\n    float t = iTime,wf=0.,wT=0., w; \r\n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\r\n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\r\n    add( length( U-vec2(.0+.2*sin(t) , .8)    ) -.3, 0.);   // rock1 stream=0.\r\n    add( length( U-vec2(.3+.2*sin(t) , .5)    ) -.3, 0.);\r\n    add( length( U-vec2(1.3, .8+.2*cos(2.*t)) ) -.5, .5);   // rock2 stream=.5\r\n    add( length( U-vec2(.8+.2*cos(.5*t), -.2) ) -.4, 1.);   // rock3 stream=1.\r\n    add( length( U-vec2(1.7, .15)             ) -.1,  .75); // rock4 stream=.75\r\n    w = wf / wT;                               // stream field\r\n    vec2 V = vec2(-dFdy(w), dFdx(w));          // velocity field\r\n    \r\n    // --- display\r\n    if (w!=w) { O =  vec4(.5,0,0,0); return; } // in rocks   ( w!=w = NaN )\r\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\r\n\r\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\r\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"float M = 10.;\r\n\r\nfloat rnd(vec2 uv, float n) {\r\n#if 1\r\n\tuv -= .5*n;\r\n\treturn mod(sin(34556.456*uv.x-457523.345*uv.y)*345674.54,1.);\r\n#else\r\n\tuv *= 4.*iResolution.y/256.;\r\n\treturn (n==0.) ? texture(iChannel0,uv).r : texture(iChannel0,uv).g;\r\n#endif\r\n}\r\n\r\nfloat gauss(float m, float s, vec2 uv) {\r\n\tfloat x = rnd(uv,0.), y=rnd(uv,1.);\r\n\treturn m + s* sqrt(-2.*log(x+1e-6))*cos(2.*3.14159*y); // http://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\r\n}\r\n\r\nfloat poisson(float m, vec2 uv) { // good approx for m >= 10 \r\n\treturn gauss(m-.5,sqrt(m),uv);  // http://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\r\n}\r\n\r\n#define SCALES 8.\r\nfloat poisson_rec(float m, vec2 uv) {\r\n\tfloat s = pow(4.,SCALES);\r\n\tm *= s;\r\n\tfor (float i=0.; i<SCALES; i++) {\r\n\t\tm = poisson(m/4.,(uv+i)/s);  // +i)/s for decorrelation\r\n\t\ts /= 4.;\r\n\t}\r\n\t\r\n\treturn m;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat c;\r\n\tvec2 uv = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy/iResolution.xy;\r\n\tif (iMouse.x+iMouse.y>0.)\r\n\t\tM = pow(2., 20.* (mouse.y-.5));\r\n\t\r\n\tif (abs(uv.x-.5*iResolution.x/iResolution.y)<2e-3) {\r\n\t\tfragColor = vec4(1.,0.,0.,0.);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t//uv *= 2.*mouse.x;\r\n\tif (uv.x<0.)\r\n\t\tc = poisson(M,uv)/(2.*M);\r\n\telse\r\n\t\tc = poisson_rec(M,uv)/(2.*M);\r\n\t\r\n\tfragColor = vec4(c);\r\n}","inputs":[],"outputs":[],"code":"float M = 10.;\r\n\r\nfloat rnd(vec2 uv, float n) {\r\n#if 1\r\n\tuv -= .5*n;\r\n\treturn mod(sin(34556.456*uv.x-457523.345*uv.y)*345674.54,1.);\r\n#else\r\n\tuv *= 4.*iResolution.y/256.;\r\n\treturn (n==0.) ? texture(iChannel0,uv).r : texture(iChannel0,uv).g;\r\n#endif\r\n}\r\n\r\nfloat gauss(float m, float s, vec2 uv) {\r\n\tfloat x = rnd(uv,0.), y=rnd(uv,1.);\r\n\treturn m + s* sqrt(-2.*log(x+1e-6))*cos(2.*3.14159*y); // http://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\r\n}\r\n\r\nfloat poisson(float m, vec2 uv) { // good approx for m >= 10 \r\n\treturn gauss(m-.5,sqrt(m),uv);  // http://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\r\n}\r\n\r\n#define SCALES 8.\r\nfloat poisson_rec(float m, vec2 uv) {\r\n\tfloat s = pow(4.,SCALES);\r\n\tm *= s;\r\n\tfor (float i=0.; i<SCALES; i++) {\r\n\t\tm = poisson(m/4.,(uv+i)/s);  // +i)/s for decorrelation\r\n\t\ts /= 4.;\r\n\t}\r\n\t\r\n\treturn m;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat c;\r\n\tvec2 uv = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy/iResolution.xy;\r\n\tif (iMouse.x+iMouse.y>0.)\r\n\t\tM = pow(2., 20.* (mouse.y-.5));\r\n\t\r\n\tif (abs(uv.x-.5*iResolution.x/iResolution.y)<2e-3) {\r\n\t\tfragColor = vec4(1.,0.,0.,0.);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t//uv *= 2.*mouse.x;\r\n\tif (uv.x<0.)\r\n\t\tc = poisson(M,uv)/(2.*M);\r\n\telse\r\n\t\tc = poisson_rec(M,uv)/(2.*M);\r\n\t\r\n\tfragColor = vec4(c);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"gauss / poisson process","id":"05a777fdac004d6bb55bbf73349f0513","date":null,"viewed":0,"name":"gauss / poisson process","description":"Poisson process = uniform points distribution (e.g, stars) with average M per pixel.\npixel-average law = Poisson(M) ~ gauss(M-.5,sqrt(M))\ndensity = 2^(10*Mouse.y) , mouse in -1..1\nLeft: pixel-based Poisson.   Right: recursive Poisson.  \nhttps://www.shadertoy.com/view/4dsSR2","likes":0,"published":null,"tags":["random"," stars"]},"ver":null,"info":{"Name":"gauss / poisson process","id":"05a777fdac004d6bb55bbf73349f0513","date":null,"viewed":0,"name":"gauss / poisson process","description":"Poisson process = uniform points distribution (e.g, stars) with average M per pixel.\npixel-average law = Poisson(M) ~ gauss(M-.5,sqrt(M))\ndensity = 2^(10*Mouse.y) , mouse in -1..1\nLeft: pixel-based Poisson.   Right: recursive Poisson.  \nhttps://www.shadertoy.com/view/4dsSR2","likes":0,"published":null,"tags":["random"," stars"]},"renderpass":[{"Code":"float M = 10.;\r\n\r\nfloat rnd(vec2 uv, float n) {\r\n#if 1\r\n\tuv -= .5*n;\r\n\treturn mod(sin(34556.456*uv.x-457523.345*uv.y)*345674.54,1.);\r\n#else\r\n\tuv *= 4.*iResolution.y/256.;\r\n\treturn (n==0.) ? texture(iChannel0,uv).r : texture(iChannel0,uv).g;\r\n#endif\r\n}\r\n\r\nfloat gauss(float m, float s, vec2 uv) {\r\n\tfloat x = rnd(uv,0.), y=rnd(uv,1.);\r\n\treturn m + s* sqrt(-2.*log(x+1e-6))*cos(2.*3.14159*y); // http://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\r\n}\r\n\r\nfloat poisson(float m, vec2 uv) { // good approx for m >= 10 \r\n\treturn gauss(m-.5,sqrt(m),uv);  // http://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\r\n}\r\n\r\n#define SCALES 8.\r\nfloat poisson_rec(float m, vec2 uv) {\r\n\tfloat s = pow(4.,SCALES);\r\n\tm *= s;\r\n\tfor (float i=0.; i<SCALES; i++) {\r\n\t\tm = poisson(m/4.,(uv+i)/s);  // +i)/s for decorrelation\r\n\t\ts /= 4.;\r\n\t}\r\n\t\r\n\treturn m;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat c;\r\n\tvec2 uv = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy/iResolution.xy;\r\n\tif (iMouse.x+iMouse.y>0.)\r\n\t\tM = pow(2., 20.* (mouse.y-.5));\r\n\t\r\n\tif (abs(uv.x-.5*iResolution.x/iResolution.y)<2e-3) {\r\n\t\tfragColor = vec4(1.,0.,0.,0.);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t//uv *= 2.*mouse.x;\r\n\tif (uv.x<0.)\r\n\t\tc = poisson(M,uv)/(2.*M);\r\n\telse\r\n\t\tc = poisson_rec(M,uv)/(2.*M);\r\n\t\r\n\tfragColor = vec4(c);\r\n}","inputs":[],"outputs":[],"code":"float M = 10.;\r\n\r\nfloat rnd(vec2 uv, float n) {\r\n#if 1\r\n\tuv -= .5*n;\r\n\treturn mod(sin(34556.456*uv.x-457523.345*uv.y)*345674.54,1.);\r\n#else\r\n\tuv *= 4.*iResolution.y/256.;\r\n\treturn (n==0.) ? texture(iChannel0,uv).r : texture(iChannel0,uv).g;\r\n#endif\r\n}\r\n\r\nfloat gauss(float m, float s, vec2 uv) {\r\n\tfloat x = rnd(uv,0.), y=rnd(uv,1.);\r\n\treturn m + s* sqrt(-2.*log(x+1e-6))*cos(2.*3.14159*y); // http://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\r\n}\r\n\r\nfloat poisson(float m, vec2 uv) { // good approx for m >= 10 \r\n\treturn gauss(m-.5,sqrt(m),uv);  // http://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\r\n}\r\n\r\n#define SCALES 8.\r\nfloat poisson_rec(float m, vec2 uv) {\r\n\tfloat s = pow(4.,SCALES);\r\n\tm *= s;\r\n\tfor (float i=0.; i<SCALES; i++) {\r\n\t\tm = poisson(m/4.,(uv+i)/s);  // +i)/s for decorrelation\r\n\t\ts /= 4.;\r\n\t}\r\n\t\r\n\treturn m;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat c;\r\n\tvec2 uv = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy/iResolution.xy;\r\n\tif (iMouse.x+iMouse.y>0.)\r\n\t\tM = pow(2., 20.* (mouse.y-.5));\r\n\t\r\n\tif (abs(uv.x-.5*iResolution.x/iResolution.y)<2e-3) {\r\n\t\tfragColor = vec4(1.,0.,0.,0.);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t//uv *= 2.*mouse.x;\r\n\tif (uv.x<0.)\r\n\t\tc = poisson(M,uv)/(2.*M);\r\n\telse\r\n\t\tc = poisson_rec(M,uv)/(2.*M);\r\n\t\r\n\tfragColor = vec4(c);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by evilryu\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\r\n\r\n#define GRASS_ENV 0.2\r\n#define FREQ 340.\r\n#define PI 3.1415926535\r\n\r\nfloat hash11(float p)\r\n{\r\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\r\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\r\n    return fract(p2.x * p2.y * 95.4337)*0.5+0.5;\r\n}\r\n\r\nvec3 hash33(float n) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\r\nvec3 noise(float x)\r\n{\r\n    float p=floor(x);\r\n    float f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    return mix(hash33(p+0.0), hash33(p+1.0), f);\r\n}\r\n\r\nfloat noise(vec2 x)\r\n{\r\n    vec2 p=floor(x);\r\n    vec2 f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    float n=p.x + p.y*57.0;\r\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\r\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n    float f=0.0;\r\n    f+=.5*noise(p); p=p*2.01;\r\n    f+=.25*noise(p); p=p*2.1;\r\n    f+=.125*noise(p); p=p*2.03;\r\n    return f;\r\n}\r\n\r\nfloat terrain(vec2 p) \r\n{\r\n    float w=0.;\r\n    float s=1.;\r\n    p.x*=20.;\r\n    w+=sin(p.x*.3521)*4.;\r\n    for (int i=0; i<5; i++) \r\n    {\r\n        p.x*=1.53562;\r\n        p.x+=7.56248;\r\n        w+=sin(p.x)*s;      \r\n        s*=.5;\r\n    }\r\n    w=w*.5+.5;\r\n    return smoothstep(0.,0.05,p.y-w*.01-0.02);\r\n}\r\n\r\nvec3 renderTerrian(vec3 ro, vec3 rd, vec3 col)\r\n{\r\n    col=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.-terrain(rd.xy));\r\n\t\r\n    return col;\r\n}\r\n\r\nfloat mapTerrian(vec3 p)\r\n{\r\n    vec2 q=p.xz*1.1-vec2(2.3,0.);\r\n    float f=0.0;\r\n    f+=.56*noise(q); q=q*2.01;\r\n    f+=.25*noise(q); q=q*2.1;\r\n    //f+=.125*noise(q); q=q*2.03;\r\n    return f-0.3;\r\n}\r\n\r\nfloat traceTerrian(vec3 ro, vec3 rd)\r\n{\r\n    float t=0.01,d,h;\r\n    float tPrev=t;\r\n    vec3 p;\r\n    float grassMint=100.;\r\n    for(int i=0;i<200;++i)\r\n    {\r\n        p=ro+t*rd;\r\n        h=mapTerrian(p);    \r\n        d=p.y-h;\r\n        \r\n        if(p.y-h-GRASS_ENV < 0.001 && grassMint>99.)\r\n        {\r\n\t\t\tgrassMint=tPrev;   \r\n            break;\r\n        }\r\n       \r\n        if(t>=100.0) { break;}\r\n        \r\n        tPrev=t;\r\n        t+=d;\r\n    }\r\n \r\n    return grassMint;\r\n}\r\n\r\nfloat blades[8];\r\n    \r\nvoid rotate(float v)\r\n{\r\n    blades[7]=blades[6]; blades[6]=blades[5]; blades[5]=blades[4];\r\n    blades[4]=blades[3]; blades[3]=blades[2]; blades[2]=blades[1];\r\n    blades[1]=blades[0]; blades[0]=v;\r\n}\r\n\r\nbool useAA=false;\r\nfloat oldD=0.;\r\n\r\nfloat shear(vec3 p, float t)\r\n{\r\n    return sin(t+p.x*3.+p.z*(2.))*.3*(p.y)*(1.-smoothstep(-1.5, 2., p.z));\r\n}\r\n\r\nfloat grassNoise(vec2 p)\r\n{\r\n    vec2 l=floor(p);\r\n    vec2 f=fract(p);\r\n    f=f*f*(3.-2.*f);\r\n    float n=l.x+l.y*57.;\r\n    float d=mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n    return d;\r\n}\r\n\r\nfloat mapGrass(vec3 p)\r\n{\r\n    vec3 q=p;\r\n    // Shear\r\n    p.xy=vec2(p.x+shear(p,0.)+.02*shear(p,iTime*2.), p.y);\r\n    float d=grassNoise(p.xz*FREQ);\r\n    d*=mix(1.,grassNoise(p.xz*30.),0.6);\r\n    \r\n    #if 1\r\n    if(useAA)\r\n    {\r\n        rotate(d);\r\n        d = (blades[0]+blades[1]+blades[2]+blades[3]\r\n            +blades[4]+blades[5]+blades[6]+blades[7])*0.125;\r\n    }\r\n    #else\r\n    if(useAA&&oldD>0.)\r\n    {\r\n        d=(oldD+d)*.5;\r\n    }\r\n    oldD=d;\r\n    #endif\r\n    \r\n    d*=GRASS_ENV;\r\n    return d;\r\n}\r\n\r\nfloat occlusion(vec3 p)\r\n{\r\n    // 1 cell backwards\r\n \tfloat w=1./FREQ;\r\n    // check the difference of height\r\n    float d=p.y-mapGrass(p-vec3(0,0,w))-mapTerrian(p);\r\n    // normalize\r\n    return clamp(d/GRASS_ENV, 0.0, 1.0);\r\n}\r\n\r\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\r\n{\r\n    float mid=0.;\r\n    vec3 p=ro+near*rd;\r\n    float sgn=sign(p.y-mapGrass(p)-mapTerrian(p));\r\n    for (int i=0; i<6; i++)\r\n    { \r\n        mid=(near+far)*.5;\r\n        p=ro+mid*rd;\r\n        float d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if(abs(d)<0.001)break;\r\n        if(d*sgn<0.)  far=mid; else near=mid;\r\n    }\r\n    return (near+far)*.5;\r\n}\r\n\r\nvec4 renderGrass(vec3 ro, vec3 rd, float mint)\r\n{\r\n\tfloat t=mint;//((ro.y-GRASS_ENV)/abs(rd.y));\r\n\r\n    vec3 p=ro+t*rd;\r\n    float d=p.y-mapGrass(p)-mapTerrian(p);\r\n\tfloat sgn=sign(d);\r\n    float told=0.;\r\n\tbool doBisect=false;\r\n\r\n    useAA=true;\r\n    \r\n    for(int i=0;i<500;++i)\r\n    {\r\n        d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if (sign(d)!=sgn)\r\n        {\r\n            doBisect=true;\r\n            break;\r\n        }\r\n        \r\n        if(d<0.003||t>=50.0)\r\n        {\r\n            break;\r\n        }\r\n        \r\n        told=t;\r\n        \r\n\t    d=max(1e-4, 0.04*d*exp(t*.2));\r\n        p+=d*rd;\r\n        t+=d;\r\n    }\r\n    if (doBisect)t=bisect(ro,rd,told,t);\r\n    \r\n    useAA=false;\r\n    vec3 col=vec3(0.1,0.5,1.)*3.5;\r\n    col=renderTerrian(ro,rd,col);\r\n\r\n    if(t<50.)\r\n    {\r\n        vec3 ld0=normalize(vec3(5., 5.0, 0.));\r\n        col=vec3(0.1,0.2,0.05)*10.;\r\n        col=mix(col,vec3(0.12,0.1,0.05)*10.,fbm(p.xz*2.));       \r\n        col*=smoothstep(GRASS_ENV*0.45,GRASS_ENV*2.,p.y-mapTerrian(p));\r\n        col*=pow(smoothstep(0.,1.,fbm(p.xz)),2.);\r\n \r\n        col*=.7*smoothstep(0.3,0.5,p.y)+.3;\r\n \r\n        col*=.8*occlusion(p)+.2;\r\n        \r\n        col*=20.;\r\n    \tcol=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.0-exp(-0.01*t*t));\r\n    }\r\n    \r\n    return vec4(col,t);\r\n}\r\n\r\nvec3 tonemap(vec3 x) \r\n{\r\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\r\n    return (x*(a*x+b))/(x*(c*x+d)+e);\r\n}\r\n\r\nvec3 firecolor(float f)\r\n{\r\n\tf=f*f*(3.-2.*f);\r\n    return min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n\tif(abs(p.y)-0.85>0.) { fragColor.xyz=vec3(0); return; }\r\n    \r\n    vec3 lookat=vec3(0.0, 0., 0.0);\r\n\tvec3 ro=vec3(0., .8,-2.5);\r\n    ro.xy+=vec2(0.04,0.01)*noise(iTime*0.5).xy;\r\n    \r\n    vec3 forward=normalize(lookat-ro);\r\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\r\n    vec3 up=normalize(cross(right, forward));\r\n    \r\n    vec3 rd=normalize(p.x*right + p.y*up + 1.6*forward);\r\n    \r\n    vec3 col=vec3(0.1,0.5,1.)*0.1;\r\n\t\r\n    float grassMint=traceTerrian(ro,rd);\r\n\tvec4 res=renderGrass(ro,rd,grassMint);\r\n    col=res.xyz;\r\n    col+=firecolor(0.5)*pow(clamp(dot(normalize(vec3(.0, 1., 2.)),rd), 0.0, 1.0),10.);\r\n    col=tonemap(col);\r\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\r\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\r\n    //col=pow(col,vec3(0.85,0.9,1.));\r\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\r\n    fragColor.xyz=col;\r\n}","inputs":[],"outputs":[],"code":"// Created by evilryu\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\r\n\r\n#define GRASS_ENV 0.2\r\n#define FREQ 340.\r\n#define PI 3.1415926535\r\n\r\nfloat hash11(float p)\r\n{\r\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\r\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\r\n    return fract(p2.x * p2.y * 95.4337)*0.5+0.5;\r\n}\r\n\r\nvec3 hash33(float n) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\r\nvec3 noise(float x)\r\n{\r\n    float p=floor(x);\r\n    float f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    return mix(hash33(p+0.0), hash33(p+1.0), f);\r\n}\r\n\r\nfloat noise(vec2 x)\r\n{\r\n    vec2 p=floor(x);\r\n    vec2 f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    float n=p.x + p.y*57.0;\r\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\r\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n    float f=0.0;\r\n    f+=.5*noise(p); p=p*2.01;\r\n    f+=.25*noise(p); p=p*2.1;\r\n    f+=.125*noise(p); p=p*2.03;\r\n    return f;\r\n}\r\n\r\nfloat terrain(vec2 p) \r\n{\r\n    float w=0.;\r\n    float s=1.;\r\n    p.x*=20.;\r\n    w+=sin(p.x*.3521)*4.;\r\n    for (int i=0; i<5; i++) \r\n    {\r\n        p.x*=1.53562;\r\n        p.x+=7.56248;\r\n        w+=sin(p.x)*s;      \r\n        s*=.5;\r\n    }\r\n    w=w*.5+.5;\r\n    return smoothstep(0.,0.05,p.y-w*.01-0.02);\r\n}\r\n\r\nvec3 renderTerrian(vec3 ro, vec3 rd, vec3 col)\r\n{\r\n    col=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.-terrain(rd.xy));\r\n\t\r\n    return col;\r\n}\r\n\r\nfloat mapTerrian(vec3 p)\r\n{\r\n    vec2 q=p.xz*1.1-vec2(2.3,0.);\r\n    float f=0.0;\r\n    f+=.56*noise(q); q=q*2.01;\r\n    f+=.25*noise(q); q=q*2.1;\r\n    //f+=.125*noise(q); q=q*2.03;\r\n    return f-0.3;\r\n}\r\n\r\nfloat traceTerrian(vec3 ro, vec3 rd)\r\n{\r\n    float t=0.01,d,h;\r\n    float tPrev=t;\r\n    vec3 p;\r\n    float grassMint=100.;\r\n    for(int i=0;i<200;++i)\r\n    {\r\n        p=ro+t*rd;\r\n        h=mapTerrian(p);    \r\n        d=p.y-h;\r\n        \r\n        if(p.y-h-GRASS_ENV < 0.001 && grassMint>99.)\r\n        {\r\n\t\t\tgrassMint=tPrev;   \r\n            break;\r\n        }\r\n       \r\n        if(t>=100.0) { break;}\r\n        \r\n        tPrev=t;\r\n        t+=d;\r\n    }\r\n \r\n    return grassMint;\r\n}\r\n\r\nfloat blades[8];\r\n    \r\nvoid rotate(float v)\r\n{\r\n    blades[7]=blades[6]; blades[6]=blades[5]; blades[5]=blades[4];\r\n    blades[4]=blades[3]; blades[3]=blades[2]; blades[2]=blades[1];\r\n    blades[1]=blades[0]; blades[0]=v;\r\n}\r\n\r\nbool useAA=false;\r\nfloat oldD=0.;\r\n\r\nfloat shear(vec3 p, float t)\r\n{\r\n    return sin(t+p.x*3.+p.z*(2.))*.3*(p.y)*(1.-smoothstep(-1.5, 2., p.z));\r\n}\r\n\r\nfloat grassNoise(vec2 p)\r\n{\r\n    vec2 l=floor(p);\r\n    vec2 f=fract(p);\r\n    f=f*f*(3.-2.*f);\r\n    float n=l.x+l.y*57.;\r\n    float d=mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n    return d;\r\n}\r\n\r\nfloat mapGrass(vec3 p)\r\n{\r\n    vec3 q=p;\r\n    // Shear\r\n    p.xy=vec2(p.x+shear(p,0.)+.02*shear(p,iTime*2.), p.y);\r\n    float d=grassNoise(p.xz*FREQ);\r\n    d*=mix(1.,grassNoise(p.xz*30.),0.6);\r\n    \r\n    #if 1\r\n    if(useAA)\r\n    {\r\n        rotate(d);\r\n        d = (blades[0]+blades[1]+blades[2]+blades[3]\r\n            +blades[4]+blades[5]+blades[6]+blades[7])*0.125;\r\n    }\r\n    #else\r\n    if(useAA&&oldD>0.)\r\n    {\r\n        d=(oldD+d)*.5;\r\n    }\r\n    oldD=d;\r\n    #endif\r\n    \r\n    d*=GRASS_ENV;\r\n    return d;\r\n}\r\n\r\nfloat occlusion(vec3 p)\r\n{\r\n    // 1 cell backwards\r\n \tfloat w=1./FREQ;\r\n    // check the difference of height\r\n    float d=p.y-mapGrass(p-vec3(0,0,w))-mapTerrian(p);\r\n    // normalize\r\n    return clamp(d/GRASS_ENV, 0.0, 1.0);\r\n}\r\n\r\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\r\n{\r\n    float mid=0.;\r\n    vec3 p=ro+near*rd;\r\n    float sgn=sign(p.y-mapGrass(p)-mapTerrian(p));\r\n    for (int i=0; i<6; i++)\r\n    { \r\n        mid=(near+far)*.5;\r\n        p=ro+mid*rd;\r\n        float d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if(abs(d)<0.001)break;\r\n        if(d*sgn<0.)  far=mid; else near=mid;\r\n    }\r\n    return (near+far)*.5;\r\n}\r\n\r\nvec4 renderGrass(vec3 ro, vec3 rd, float mint)\r\n{\r\n\tfloat t=mint;//((ro.y-GRASS_ENV)/abs(rd.y));\r\n\r\n    vec3 p=ro+t*rd;\r\n    float d=p.y-mapGrass(p)-mapTerrian(p);\r\n\tfloat sgn=sign(d);\r\n    float told=0.;\r\n\tbool doBisect=false;\r\n\r\n    useAA=true;\r\n    \r\n    for(int i=0;i<500;++i)\r\n    {\r\n        d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if (sign(d)!=sgn)\r\n        {\r\n            doBisect=true;\r\n            break;\r\n        }\r\n        \r\n        if(d<0.003||t>=50.0)\r\n        {\r\n            break;\r\n        }\r\n        \r\n        told=t;\r\n        \r\n\t    d=max(1e-4, 0.04*d*exp(t*.2));\r\n        p+=d*rd;\r\n        t+=d;\r\n    }\r\n    if (doBisect)t=bisect(ro,rd,told,t);\r\n    \r\n    useAA=false;\r\n    vec3 col=vec3(0.1,0.5,1.)*3.5;\r\n    col=renderTerrian(ro,rd,col);\r\n\r\n    if(t<50.)\r\n    {\r\n        vec3 ld0=normalize(vec3(5., 5.0, 0.));\r\n        col=vec3(0.1,0.2,0.05)*10.;\r\n        col=mix(col,vec3(0.12,0.1,0.05)*10.,fbm(p.xz*2.));       \r\n        col*=smoothstep(GRASS_ENV*0.45,GRASS_ENV*2.,p.y-mapTerrian(p));\r\n        col*=pow(smoothstep(0.,1.,fbm(p.xz)),2.);\r\n \r\n        col*=.7*smoothstep(0.3,0.5,p.y)+.3;\r\n \r\n        col*=.8*occlusion(p)+.2;\r\n        \r\n        col*=20.;\r\n    \tcol=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.0-exp(-0.01*t*t));\r\n    }\r\n    \r\n    return vec4(col,t);\r\n}\r\n\r\nvec3 tonemap(vec3 x) \r\n{\r\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\r\n    return (x*(a*x+b))/(x*(c*x+d)+e);\r\n}\r\n\r\nvec3 firecolor(float f)\r\n{\r\n\tf=f*f*(3.-2.*f);\r\n    return min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n\tif(abs(p.y)-0.85>0.) { fragColor.xyz=vec3(0); return; }\r\n    \r\n    vec3 lookat=vec3(0.0, 0., 0.0);\r\n\tvec3 ro=vec3(0., .8,-2.5);\r\n    ro.xy+=vec2(0.04,0.01)*noise(iTime*0.5).xy;\r\n    \r\n    vec3 forward=normalize(lookat-ro);\r\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\r\n    vec3 up=normalize(cross(right, forward));\r\n    \r\n    vec3 rd=normalize(p.x*right + p.y*up + 1.6*forward);\r\n    \r\n    vec3 col=vec3(0.1,0.5,1.)*0.1;\r\n\t\r\n    float grassMint=traceTerrian(ro,rd);\r\n\tvec4 res=renderGrass(ro,rd,grassMint);\r\n    col=res.xyz;\r\n    col+=firecolor(0.5)*pow(clamp(dot(normalize(vec3(.0, 1., 2.)),rd), 0.0, 1.0),10.);\r\n    col=tonemap(col);\r\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\r\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\r\n    //col=pow(col,vec3(0.85,0.9,1.));\r\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\r\n    fragColor.xyz=col;\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"GrassTest","id":"e8e4be3d603c4bc694921a00eb75e6f7","date":null,"viewed":0,"name":"GrassTest","description":"Grass test, fullscreen doesn't look good.","likes":0,"published":null,"tags":["noise"," fbm"," grass"," terrian"]},"ver":null,"info":{"Name":"GrassTest","id":"e8e4be3d603c4bc694921a00eb75e6f7","date":null,"viewed":0,"name":"GrassTest","description":"Grass test, fullscreen doesn't look good.","likes":0,"published":null,"tags":["noise"," fbm"," grass"," terrian"]},"renderpass":[{"Code":"// Created by evilryu\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\r\n\r\n#define GRASS_ENV 0.2\r\n#define FREQ 340.\r\n#define PI 3.1415926535\r\n\r\nfloat hash11(float p)\r\n{\r\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\r\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\r\n    return fract(p2.x * p2.y * 95.4337)*0.5+0.5;\r\n}\r\n\r\nvec3 hash33(float n) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\r\nvec3 noise(float x)\r\n{\r\n    float p=floor(x);\r\n    float f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    return mix(hash33(p+0.0), hash33(p+1.0), f);\r\n}\r\n\r\nfloat noise(vec2 x)\r\n{\r\n    vec2 p=floor(x);\r\n    vec2 f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    float n=p.x + p.y*57.0;\r\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\r\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n    float f=0.0;\r\n    f+=.5*noise(p); p=p*2.01;\r\n    f+=.25*noise(p); p=p*2.1;\r\n    f+=.125*noise(p); p=p*2.03;\r\n    return f;\r\n}\r\n\r\nfloat terrain(vec2 p) \r\n{\r\n    float w=0.;\r\n    float s=1.;\r\n    p.x*=20.;\r\n    w+=sin(p.x*.3521)*4.;\r\n    for (int i=0; i<5; i++) \r\n    {\r\n        p.x*=1.53562;\r\n        p.x+=7.56248;\r\n        w+=sin(p.x)*s;      \r\n        s*=.5;\r\n    }\r\n    w=w*.5+.5;\r\n    return smoothstep(0.,0.05,p.y-w*.01-0.02);\r\n}\r\n\r\nvec3 renderTerrian(vec3 ro, vec3 rd, vec3 col)\r\n{\r\n    col=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.-terrain(rd.xy));\r\n\t\r\n    return col;\r\n}\r\n\r\nfloat mapTerrian(vec3 p)\r\n{\r\n    vec2 q=p.xz*1.1-vec2(2.3,0.);\r\n    float f=0.0;\r\n    f+=.56*noise(q); q=q*2.01;\r\n    f+=.25*noise(q); q=q*2.1;\r\n    //f+=.125*noise(q); q=q*2.03;\r\n    return f-0.3;\r\n}\r\n\r\nfloat traceTerrian(vec3 ro, vec3 rd)\r\n{\r\n    float t=0.01,d,h;\r\n    float tPrev=t;\r\n    vec3 p;\r\n    float grassMint=100.;\r\n    for(int i=0;i<200;++i)\r\n    {\r\n        p=ro+t*rd;\r\n        h=mapTerrian(p);    \r\n        d=p.y-h;\r\n        \r\n        if(p.y-h-GRASS_ENV < 0.001 && grassMint>99.)\r\n        {\r\n\t\t\tgrassMint=tPrev;   \r\n            break;\r\n        }\r\n       \r\n        if(t>=100.0) { break;}\r\n        \r\n        tPrev=t;\r\n        t+=d;\r\n    }\r\n \r\n    return grassMint;\r\n}\r\n\r\nfloat blades[8];\r\n    \r\nvoid rotate(float v)\r\n{\r\n    blades[7]=blades[6]; blades[6]=blades[5]; blades[5]=blades[4];\r\n    blades[4]=blades[3]; blades[3]=blades[2]; blades[2]=blades[1];\r\n    blades[1]=blades[0]; blades[0]=v;\r\n}\r\n\r\nbool useAA=false;\r\nfloat oldD=0.;\r\n\r\nfloat shear(vec3 p, float t)\r\n{\r\n    return sin(t+p.x*3.+p.z*(2.))*.3*(p.y)*(1.-smoothstep(-1.5, 2., p.z));\r\n}\r\n\r\nfloat grassNoise(vec2 p)\r\n{\r\n    vec2 l=floor(p);\r\n    vec2 f=fract(p);\r\n    f=f*f*(3.-2.*f);\r\n    float n=l.x+l.y*57.;\r\n    float d=mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n    return d;\r\n}\r\n\r\nfloat mapGrass(vec3 p)\r\n{\r\n    vec3 q=p;\r\n    // Shear\r\n    p.xy=vec2(p.x+shear(p,0.)+.02*shear(p,iTime*2.), p.y);\r\n    float d=grassNoise(p.xz*FREQ);\r\n    d*=mix(1.,grassNoise(p.xz*30.),0.6);\r\n    \r\n    #if 1\r\n    if(useAA)\r\n    {\r\n        rotate(d);\r\n        d = (blades[0]+blades[1]+blades[2]+blades[3]\r\n            +blades[4]+blades[5]+blades[6]+blades[7])*0.125;\r\n    }\r\n    #else\r\n    if(useAA&&oldD>0.)\r\n    {\r\n        d=(oldD+d)*.5;\r\n    }\r\n    oldD=d;\r\n    #endif\r\n    \r\n    d*=GRASS_ENV;\r\n    return d;\r\n}\r\n\r\nfloat occlusion(vec3 p)\r\n{\r\n    // 1 cell backwards\r\n \tfloat w=1./FREQ;\r\n    // check the difference of height\r\n    float d=p.y-mapGrass(p-vec3(0,0,w))-mapTerrian(p);\r\n    // normalize\r\n    return clamp(d/GRASS_ENV, 0.0, 1.0);\r\n}\r\n\r\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\r\n{\r\n    float mid=0.;\r\n    vec3 p=ro+near*rd;\r\n    float sgn=sign(p.y-mapGrass(p)-mapTerrian(p));\r\n    for (int i=0; i<6; i++)\r\n    { \r\n        mid=(near+far)*.5;\r\n        p=ro+mid*rd;\r\n        float d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if(abs(d)<0.001)break;\r\n        if(d*sgn<0.)  far=mid; else near=mid;\r\n    }\r\n    return (near+far)*.5;\r\n}\r\n\r\nvec4 renderGrass(vec3 ro, vec3 rd, float mint)\r\n{\r\n\tfloat t=mint;//((ro.y-GRASS_ENV)/abs(rd.y));\r\n\r\n    vec3 p=ro+t*rd;\r\n    float d=p.y-mapGrass(p)-mapTerrian(p);\r\n\tfloat sgn=sign(d);\r\n    float told=0.;\r\n\tbool doBisect=false;\r\n\r\n    useAA=true;\r\n    \r\n    for(int i=0;i<500;++i)\r\n    {\r\n        d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if (sign(d)!=sgn)\r\n        {\r\n            doBisect=true;\r\n            break;\r\n        }\r\n        \r\n        if(d<0.003||t>=50.0)\r\n        {\r\n            break;\r\n        }\r\n        \r\n        told=t;\r\n        \r\n\t    d=max(1e-4, 0.04*d*exp(t*.2));\r\n        p+=d*rd;\r\n        t+=d;\r\n    }\r\n    if (doBisect)t=bisect(ro,rd,told,t);\r\n    \r\n    useAA=false;\r\n    vec3 col=vec3(0.1,0.5,1.)*3.5;\r\n    col=renderTerrian(ro,rd,col);\r\n\r\n    if(t<50.)\r\n    {\r\n        vec3 ld0=normalize(vec3(5., 5.0, 0.));\r\n        col=vec3(0.1,0.2,0.05)*10.;\r\n        col=mix(col,vec3(0.12,0.1,0.05)*10.,fbm(p.xz*2.));       \r\n        col*=smoothstep(GRASS_ENV*0.45,GRASS_ENV*2.,p.y-mapTerrian(p));\r\n        col*=pow(smoothstep(0.,1.,fbm(p.xz)),2.);\r\n \r\n        col*=.7*smoothstep(0.3,0.5,p.y)+.3;\r\n \r\n        col*=.8*occlusion(p)+.2;\r\n        \r\n        col*=20.;\r\n    \tcol=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.0-exp(-0.01*t*t));\r\n    }\r\n    \r\n    return vec4(col,t);\r\n}\r\n\r\nvec3 tonemap(vec3 x) \r\n{\r\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\r\n    return (x*(a*x+b))/(x*(c*x+d)+e);\r\n}\r\n\r\nvec3 firecolor(float f)\r\n{\r\n\tf=f*f*(3.-2.*f);\r\n    return min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n\tif(abs(p.y)-0.85>0.) { fragColor.xyz=vec3(0); return; }\r\n    \r\n    vec3 lookat=vec3(0.0, 0., 0.0);\r\n\tvec3 ro=vec3(0., .8,-2.5);\r\n    ro.xy+=vec2(0.04,0.01)*noise(iTime*0.5).xy;\r\n    \r\n    vec3 forward=normalize(lookat-ro);\r\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\r\n    vec3 up=normalize(cross(right, forward));\r\n    \r\n    vec3 rd=normalize(p.x*right + p.y*up + 1.6*forward);\r\n    \r\n    vec3 col=vec3(0.1,0.5,1.)*0.1;\r\n\t\r\n    float grassMint=traceTerrian(ro,rd);\r\n\tvec4 res=renderGrass(ro,rd,grassMint);\r\n    col=res.xyz;\r\n    col+=firecolor(0.5)*pow(clamp(dot(normalize(vec3(.0, 1., 2.)),rd), 0.0, 1.0),10.);\r\n    col=tonemap(col);\r\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\r\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\r\n    //col=pow(col,vec3(0.85,0.9,1.));\r\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\r\n    fragColor.xyz=col;\r\n}","inputs":[],"outputs":[],"code":"// Created by evilryu\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Based on kuvkar's Windyplains: https://www.shadertoy.com/view/ltXXRM\r\n\r\n#define GRASS_ENV 0.2\r\n#define FREQ 340.\r\n#define PI 3.1415926535\r\n\r\nfloat hash11(float p)\r\n{\r\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\r\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\r\n    return fract(p2.x * p2.y * 95.4337)*0.5+0.5;\r\n}\r\n\r\nvec3 hash33(float n) { return fract(sin(vec3(n,n+7.3,n+13.7))*1313.54531); }\r\nvec3 noise(float x)\r\n{\r\n    float p=floor(x);\r\n    float f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    return mix(hash33(p+0.0), hash33(p+1.0), f);\r\n}\r\n\r\nfloat noise(vec2 x)\r\n{\r\n    vec2 p=floor(x);\r\n    vec2 f=fract(x);\r\n    f=f*f*(3.0-2.0*f);\r\n    float n=p.x + p.y*57.0;\r\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\r\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n    float f=0.0;\r\n    f+=.5*noise(p); p=p*2.01;\r\n    f+=.25*noise(p); p=p*2.1;\r\n    f+=.125*noise(p); p=p*2.03;\r\n    return f;\r\n}\r\n\r\nfloat terrain(vec2 p) \r\n{\r\n    float w=0.;\r\n    float s=1.;\r\n    p.x*=20.;\r\n    w+=sin(p.x*.3521)*4.;\r\n    for (int i=0; i<5; i++) \r\n    {\r\n        p.x*=1.53562;\r\n        p.x+=7.56248;\r\n        w+=sin(p.x)*s;      \r\n        s*=.5;\r\n    }\r\n    w=w*.5+.5;\r\n    return smoothstep(0.,0.05,p.y-w*.01-0.02);\r\n}\r\n\r\nvec3 renderTerrian(vec3 ro, vec3 rd, vec3 col)\r\n{\r\n    col=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.-terrain(rd.xy));\r\n\t\r\n    return col;\r\n}\r\n\r\nfloat mapTerrian(vec3 p)\r\n{\r\n    vec2 q=p.xz*1.1-vec2(2.3,0.);\r\n    float f=0.0;\r\n    f+=.56*noise(q); q=q*2.01;\r\n    f+=.25*noise(q); q=q*2.1;\r\n    //f+=.125*noise(q); q=q*2.03;\r\n    return f-0.3;\r\n}\r\n\r\nfloat traceTerrian(vec3 ro, vec3 rd)\r\n{\r\n    float t=0.01,d,h;\r\n    float tPrev=t;\r\n    vec3 p;\r\n    float grassMint=100.;\r\n    for(int i=0;i<200;++i)\r\n    {\r\n        p=ro+t*rd;\r\n        h=mapTerrian(p);    \r\n        d=p.y-h;\r\n        \r\n        if(p.y-h-GRASS_ENV < 0.001 && grassMint>99.)\r\n        {\r\n\t\t\tgrassMint=tPrev;   \r\n            break;\r\n        }\r\n       \r\n        if(t>=100.0) { break;}\r\n        \r\n        tPrev=t;\r\n        t+=d;\r\n    }\r\n \r\n    return grassMint;\r\n}\r\n\r\nfloat blades[8];\r\n    \r\nvoid rotate(float v)\r\n{\r\n    blades[7]=blades[6]; blades[6]=blades[5]; blades[5]=blades[4];\r\n    blades[4]=blades[3]; blades[3]=blades[2]; blades[2]=blades[1];\r\n    blades[1]=blades[0]; blades[0]=v;\r\n}\r\n\r\nbool useAA=false;\r\nfloat oldD=0.;\r\n\r\nfloat shear(vec3 p, float t)\r\n{\r\n    return sin(t+p.x*3.+p.z*(2.))*.3*(p.y)*(1.-smoothstep(-1.5, 2., p.z));\r\n}\r\n\r\nfloat grassNoise(vec2 p)\r\n{\r\n    vec2 l=floor(p);\r\n    vec2 f=fract(p);\r\n    f=f*f*(3.-2.*f);\r\n    float n=l.x+l.y*57.;\r\n    float d=mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\r\n    return d;\r\n}\r\n\r\nfloat mapGrass(vec3 p)\r\n{\r\n    vec3 q=p;\r\n    // Shear\r\n    p.xy=vec2(p.x+shear(p,0.)+.02*shear(p,iTime*2.), p.y);\r\n    float d=grassNoise(p.xz*FREQ);\r\n    d*=mix(1.,grassNoise(p.xz*30.),0.6);\r\n    \r\n    #if 1\r\n    if(useAA)\r\n    {\r\n        rotate(d);\r\n        d = (blades[0]+blades[1]+blades[2]+blades[3]\r\n            +blades[4]+blades[5]+blades[6]+blades[7])*0.125;\r\n    }\r\n    #else\r\n    if(useAA&&oldD>0.)\r\n    {\r\n        d=(oldD+d)*.5;\r\n    }\r\n    oldD=d;\r\n    #endif\r\n    \r\n    d*=GRASS_ENV;\r\n    return d;\r\n}\r\n\r\nfloat occlusion(vec3 p)\r\n{\r\n    // 1 cell backwards\r\n \tfloat w=1./FREQ;\r\n    // check the difference of height\r\n    float d=p.y-mapGrass(p-vec3(0,0,w))-mapTerrian(p);\r\n    // normalize\r\n    return clamp(d/GRASS_ENV, 0.0, 1.0);\r\n}\r\n\r\nfloat bisect(vec3 ro, vec3 rd, float near, float far)\r\n{\r\n    float mid=0.;\r\n    vec3 p=ro+near*rd;\r\n    float sgn=sign(p.y-mapGrass(p)-mapTerrian(p));\r\n    for (int i=0; i<6; i++)\r\n    { \r\n        mid=(near+far)*.5;\r\n        p=ro+mid*rd;\r\n        float d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if(abs(d)<0.001)break;\r\n        if(d*sgn<0.)  far=mid; else near=mid;\r\n    }\r\n    return (near+far)*.5;\r\n}\r\n\r\nvec4 renderGrass(vec3 ro, vec3 rd, float mint)\r\n{\r\n\tfloat t=mint;//((ro.y-GRASS_ENV)/abs(rd.y));\r\n\r\n    vec3 p=ro+t*rd;\r\n    float d=p.y-mapGrass(p)-mapTerrian(p);\r\n\tfloat sgn=sign(d);\r\n    float told=0.;\r\n\tbool doBisect=false;\r\n\r\n    useAA=true;\r\n    \r\n    for(int i=0;i<500;++i)\r\n    {\r\n        d=p.y-mapGrass(p)-mapTerrian(p);\r\n        if (sign(d)!=sgn)\r\n        {\r\n            doBisect=true;\r\n            break;\r\n        }\r\n        \r\n        if(d<0.003||t>=50.0)\r\n        {\r\n            break;\r\n        }\r\n        \r\n        told=t;\r\n        \r\n\t    d=max(1e-4, 0.04*d*exp(t*.2));\r\n        p+=d*rd;\r\n        t+=d;\r\n    }\r\n    if (doBisect)t=bisect(ro,rd,told,t);\r\n    \r\n    useAA=false;\r\n    vec3 col=vec3(0.1,0.5,1.)*3.5;\r\n    col=renderTerrian(ro,rd,col);\r\n\r\n    if(t<50.)\r\n    {\r\n        vec3 ld0=normalize(vec3(5., 5.0, 0.));\r\n        col=vec3(0.1,0.2,0.05)*10.;\r\n        col=mix(col,vec3(0.12,0.1,0.05)*10.,fbm(p.xz*2.));       \r\n        col*=smoothstep(GRASS_ENV*0.45,GRASS_ENV*2.,p.y-mapTerrian(p));\r\n        col*=pow(smoothstep(0.,1.,fbm(p.xz)),2.);\r\n \r\n        col*=.7*smoothstep(0.3,0.5,p.y)+.3;\r\n \r\n        col*=.8*occlusion(p)+.2;\r\n        \r\n        col*=20.;\r\n    \tcol=mix(col,vec3(0.05,0.1,0.2)*2.7, 1.0-exp(-0.01*t*t));\r\n    }\r\n    \r\n    return vec4(col,t);\r\n}\r\n\r\nvec3 tonemap(vec3 x) \r\n{\r\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\r\n    return (x*(a*x+b))/(x*(c*x+d)+e);\r\n}\r\n\r\nvec3 firecolor(float f)\r\n{\r\n\tf=f*f*(3.-2.*f);\r\n    return min(vec3(f+.8, f*f*1.4+.1, f*f*f*.7)*f, 1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n\tif(abs(p.y)-0.85>0.) { fragColor.xyz=vec3(0); return; }\r\n    \r\n    vec3 lookat=vec3(0.0, 0., 0.0);\r\n\tvec3 ro=vec3(0., .8,-2.5);\r\n    ro.xy+=vec2(0.04,0.01)*noise(iTime*0.5).xy;\r\n    \r\n    vec3 forward=normalize(lookat-ro);\r\n    vec3 right=normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\r\n    vec3 up=normalize(cross(right, forward));\r\n    \r\n    vec3 rd=normalize(p.x*right + p.y*up + 1.6*forward);\r\n    \r\n    vec3 col=vec3(0.1,0.5,1.)*0.1;\r\n\t\r\n    float grassMint=traceTerrian(ro,rd);\r\n\tvec4 res=renderGrass(ro,rd,grassMint);\r\n    col=res.xyz;\r\n    col+=firecolor(0.5)*pow(clamp(dot(normalize(vec3(.0, 1., 2.)),rd), 0.0, 1.0),10.);\r\n    col=tonemap(col);\r\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\r\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\r\n    //col=pow(col,vec3(0.85,0.9,1.));\r\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2);\r\n    fragColor.xyz=col;\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define POINTS 100  \t\t // number of stars\r\n\r\n// --- GUI utils\r\n\r\nfloat t;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- flag and values buton display ---\r\n\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\n\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of stars\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    t = iTime;\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : 4.*iMouse.x/iResolution.x;\r\n\tint MODE = int(mod(m,4.)); \r\n\tfloat fMODE = (1.-cos(6.283*m))/2.;\r\n\r\n\t\r\n\tfloat v=0.; vec2 V=vec2(0.);\r\n\tfor (int i=1; i<POINTS; i++) { // sum stars\r\n\t\tvec2 p = P(float(i));\r\n\t\tfor (int y=-1; y<=1; y++)  // ghost echos in cycling universe\r\n\t\t\tfor (int x=-1; x<=1; x++) {\r\n\t\t\t\tvec2 d = p+vec2(float(x),float(y)) -uv; // pixel to star\r\n\t\t\t\tif      (MODE==0) v +=  1./length(d);\r\n\t\t\t\telse if (MODE==1) v +=  1./dot(d,d);\r\n\t\t\t    else if (MODE==2) V +=  d /dot(d,d);\r\n\t\t\t\telse\t\t\t  V +=  d /pow(length(d),3.);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\tif (MODE>1) v = length(V);\r\n\tv *= 1./(9.*float(POINTS));\r\n\t\r\n\tv *= 10.*fMODE;\r\n\tfragColor = vec4(sin(v),sin(v/2.),sin(v/4.),1.);\r\n\t\r\n\tv =   showFlag(vec2(-1.5+.1*float(MODE),.9),uv,fMODE)\r\n\t\t+ showFlag(vec2(-1.5,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.4,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.3,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.2,.9),uv,false);\r\n\tfragColor = mix(fragColor,vec4(0,0,1,0),v);\r\n\r\n}","inputs":[],"outputs":[],"code":"#define POINTS 100  \t\t // number of stars\r\n\r\n// --- GUI utils\r\n\r\nfloat t;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- flag and values buton display ---\r\n\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\n\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of stars\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    t = iTime;\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : 4.*iMouse.x/iResolution.x;\r\n\tint MODE = int(mod(m,4.)); \r\n\tfloat fMODE = (1.-cos(6.283*m))/2.;\r\n\r\n\t\r\n\tfloat v=0.; vec2 V=vec2(0.);\r\n\tfor (int i=1; i<POINTS; i++) { // sum stars\r\n\t\tvec2 p = P(float(i));\r\n\t\tfor (int y=-1; y<=1; y++)  // ghost echos in cycling universe\r\n\t\t\tfor (int x=-1; x<=1; x++) {\r\n\t\t\t\tvec2 d = p+vec2(float(x),float(y)) -uv; // pixel to star\r\n\t\t\t\tif      (MODE==0) v +=  1./length(d);\r\n\t\t\t\telse if (MODE==1) v +=  1./dot(d,d);\r\n\t\t\t    else if (MODE==2) V +=  d /dot(d,d);\r\n\t\t\t\telse\t\t\t  V +=  d /pow(length(d),3.);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\tif (MODE>1) v = length(V);\r\n\tv *= 1./(9.*float(POINTS));\r\n\t\r\n\tv *= 10.*fMODE;\r\n\tfragColor = vec4(sin(v),sin(v/2.),sin(v/4.),1.);\r\n\t\r\n\tv =   showFlag(vec2(-1.5+.1*float(MODE),.9),uv,fMODE)\r\n\t\t+ showFlag(vec2(-1.5,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.4,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.3,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.2,.9),uv,false);\r\n\tfragColor = mix(fragColor,vec4(0,0,1,0),v);\r\n\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"gravity field","id":"8631eb555eb84d3c8785663602e11498","date":null,"viewed":0,"name":"gravity field","description":"gravity field generated by a schoolfish of stars\r\nCycles between sum(pot2D), sum(pot3D), sum(gravity2D), sum(gravity3D)\r\nMouse.x to force cycling.\r\nhttps://www.shadertoy.com/view/XdlXW4","likes":0,"published":null,"tags":["gravity"]},"ver":null,"info":{"Name":"gravity field","id":"8631eb555eb84d3c8785663602e11498","date":null,"viewed":0,"name":"gravity field","description":"gravity field generated by a schoolfish of stars\r\nCycles between sum(pot2D), sum(pot3D), sum(gravity2D), sum(gravity3D)\r\nMouse.x to force cycling.\r\nhttps://www.shadertoy.com/view/XdlXW4","likes":0,"published":null,"tags":["gravity"]},"renderpass":[{"Code":"#define POINTS 100  \t\t // number of stars\r\n\r\n// --- GUI utils\r\n\r\nfloat t;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- flag and values buton display ---\r\n\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\n\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of stars\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    t = iTime;\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : 4.*iMouse.x/iResolution.x;\r\n\tint MODE = int(mod(m,4.)); \r\n\tfloat fMODE = (1.-cos(6.283*m))/2.;\r\n\r\n\t\r\n\tfloat v=0.; vec2 V=vec2(0.);\r\n\tfor (int i=1; i<POINTS; i++) { // sum stars\r\n\t\tvec2 p = P(float(i));\r\n\t\tfor (int y=-1; y<=1; y++)  // ghost echos in cycling universe\r\n\t\t\tfor (int x=-1; x<=1; x++) {\r\n\t\t\t\tvec2 d = p+vec2(float(x),float(y)) -uv; // pixel to star\r\n\t\t\t\tif      (MODE==0) v +=  1./length(d);\r\n\t\t\t\telse if (MODE==1) v +=  1./dot(d,d);\r\n\t\t\t    else if (MODE==2) V +=  d /dot(d,d);\r\n\t\t\t\telse\t\t\t  V +=  d /pow(length(d),3.);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\tif (MODE>1) v = length(V);\r\n\tv *= 1./(9.*float(POINTS));\r\n\t\r\n\tv *= 10.*fMODE;\r\n\tfragColor = vec4(sin(v),sin(v/2.),sin(v/4.),1.);\r\n\t\r\n\tv =   showFlag(vec2(-1.5+.1*float(MODE),.9),uv,fMODE)\r\n\t\t+ showFlag(vec2(-1.5,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.4,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.3,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.2,.9),uv,false);\r\n\tfragColor = mix(fragColor,vec4(0,0,1,0),v);\r\n\r\n}","inputs":[],"outputs":[],"code":"#define POINTS 100  \t\t // number of stars\r\n\r\n// --- GUI utils\r\n\r\nfloat t;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- flag and values buton display ---\r\n\r\nfloat showFlag(vec2 p, vec2 uv, float v) {\r\n\tfloat d = length(2.*(uv-p));\r\n\treturn \t1.-step(.06*v,d) + smoothstep(0.005,0.,abs(d-.06));\r\n}\r\n\r\nfloat showFlag(vec2 p, vec2 uv, bool flag) {\r\n\treturn showFlag(p, uv, (flag) ? 1.: 0.);\r\n}\r\n\r\n\r\n// --- math utils\r\n\r\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\r\n\r\nfloat hash (float i) { return 2.*fract(sin(i*7467.25)*1e5) - 1.; }\r\nvec2  hash2(float i) { return vec2(hash(i),hash(i-.1)); }\r\nvec4  hash4(float i) { return vec4(hash(i),hash(i-.1),hash(i-.3),hash(i+.1)); }\r\n\t\r\n\r\n\r\n// === main ===================\r\n\r\n// motion of stars\r\nvec2 P(float i) {\r\n\tvec4 c = hash4(i);\r\n\treturn vec2(   cos(t*c.x-c.z)+.5*cos(2.765*t*c.y+c.w),\r\n\t\t\t\t ( sin(t*c.y-c.w)+.5*sin(1.893*t*c.x+c.z) )/1.5\t );\r\n}\r\n\r\n// ---\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    t = iTime;\r\n\tvec2 uv    = 2.*(fragCoord.xy / iResolution.y - vec2(.8,.5));\r\n\tfloat m = (iMouse.z<=0.) ? .1*t/6.283 : 4.*iMouse.x/iResolution.x;\r\n\tint MODE = int(mod(m,4.)); \r\n\tfloat fMODE = (1.-cos(6.283*m))/2.;\r\n\r\n\t\r\n\tfloat v=0.; vec2 V=vec2(0.);\r\n\tfor (int i=1; i<POINTS; i++) { // sum stars\r\n\t\tvec2 p = P(float(i));\r\n\t\tfor (int y=-1; y<=1; y++)  // ghost echos in cycling universe\r\n\t\t\tfor (int x=-1; x<=1; x++) {\r\n\t\t\t\tvec2 d = p+vec2(float(x),float(y)) -uv; // pixel to star\r\n\t\t\t\tif      (MODE==0) v +=  1./length(d);\r\n\t\t\t\telse if (MODE==1) v +=  1./dot(d,d);\r\n\t\t\t    else if (MODE==2) V +=  d /dot(d,d);\r\n\t\t\t\telse\t\t\t  V +=  d /pow(length(d),3.);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\tif (MODE>1) v = length(V);\r\n\tv *= 1./(9.*float(POINTS));\r\n\t\r\n\tv *= 10.*fMODE;\r\n\tfragColor = vec4(sin(v),sin(v/2.),sin(v/4.),1.);\r\n\t\r\n\tv =   showFlag(vec2(-1.5+.1*float(MODE),.9),uv,fMODE)\r\n\t\t+ showFlag(vec2(-1.5,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.4,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.3,.9),uv,false) \r\n\t\t+ showFlag(vec2(-1.2,.9),uv,false);\r\n\tfragColor = mix(fragColor,vec4(0,0,1,0),v);\r\n\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/**\r\n This shader is basically an improvement upon a previous fireworks shader I did a while\r\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\r\n instead of the just following the same pattern in a loop, so the fireworks show can be\r\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\r\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\r\n\r\n I wish a very happy and a prosperous new year to everyone!\r\n*/\r\n\r\n#define PI  3.141592653589793\r\n#define TAU 6.283185307179586\r\n\r\n// Helper macros \r\n#define C(x) clamp(x, 0., 1.)\r\n#define S(a, b, x) smoothstep(a, b, x)\r\n#define F(x, f) (floor(x * f) / f)\r\n\r\n// Fireworks control variables\r\n#define FIREWORK_COUNT 8\r\n#define FIREWORK_DURATION 8.\r\n#define FIREWORK_LOW .75\r\n#define FIREWORK_HIGH 1.05\r\n#define ROCKET_PARTICES 32\r\n#define ROCKET_DURATION 1.5\r\n#define FLASH_DURATION ROCKET_DURATION + .2 \r\n#define THRUSTER_SPEED .25\r\n#define EXPLOSION_STRENGTH .03;\r\n#define EXPLOSION_PARTICLES 100\r\n\r\n// Hash functions by Dave_Hoskins\r\nvec2 hash21(float p)\r\n{\r\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n\tp3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n\r\n}\r\n\r\nvec3 hash31(float p)\r\n{\r\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\treturn vec3(n) * (1. / float(0xffffffffU));\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\r\n\tuint q = (n.x ^ n.y) * 1597334673U;\r\n\treturn float(q) * (1. / float(0xffffffffU));\r\n}\r\n\r\n// Function to remap a value from [a, b] to [c, d]\r\nfloat remap(float x, float a, float b, float c, float d)\r\n{\r\n    return (((x - a) / (b - a)) * (d - c)) + c;\r\n}\r\n\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// Tiny fbm\r\nfloat fbm (in vec3 p) {\r\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\r\n}\r\n\r\n// Building window lights from www.shadertoy.com/view/wtt3WB\r\nfloat windows (vec2 uv, float offset)\r\n{\r\n    vec2 grid = vec2(20., 1.);\r\n    uv.x += offset;\r\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\r\n    uv.x *= n1 * 6.;\r\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\r\n    float n = fbm(id.xxx);\r\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\r\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\r\n    vec2 lPos = fract(uv * lightGrid);\r\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\r\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\r\n    n2 = smoothstep(.225, .5, n2);\r\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\r\n}\r\n\r\n// Building skyline \r\nfloat buildings(vec2 st)\r\n{\r\n    // An fbm style amalgamation of various cos functions\r\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\r\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\r\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\r\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\r\n    return C((st.y + b - .1) * 100.);\r\n}\r\n\r\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\r\nfloat stars(vec2 st, vec2 fragCoord)\r\n{\r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\r\n    uv.y += .3;\r\n    uv.y = abs(uv.y);\r\n    float t = iTime * .1;\r\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\r\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\r\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\r\n    twinkle = twinkle * .5 + .5;\r\n    return h.x * h.y * twinkle * 1.5;\r\n}\r\n\r\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\r\nvec3 fireworks(vec2 st)\r\n{\r\n\tvec2 fireworkPos, particlePos;\r\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\r\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\r\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\r\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\r\n    {\r\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\r\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\r\n        // This hash changes after each firework cycle (rocket + explosion)\r\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\r\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\r\n        fireworkCol = fireworkHash * .5 + .5;\r\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\r\n        // Random firework x coordinate but confined to a certain column based on j\r\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\r\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\r\n        \r\n        // Duration of each firework with a random start time\r\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\r\n        if (time > ROCKET_DURATION)\r\n        {\r\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\r\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\r\n            {\r\n                // Unique hash that yeilds a separate spread pattern for each explosion\r\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \r\n\t\t\t\t\t* 1619.8196 + 469.7119);\r\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\r\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\r\n                // Radius expands exponentially over time, i.e. explosion effect\r\n                radius = radiusScale * time * time;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                particlePos.y -= 8. * pow(particlePos.x, 4.); // fake-ish gravity\r\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\r\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\r\n                // Shimmering effect for explosion particles\r\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \r\n                    * (sin((iTime + particleHash.y * TAU) * 18.)));\r\n                shimmerThreshold = FIREWORK_DURATION * .6;\r\n                // Fade after a certain time threshold\r\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\r\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\r\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\r\n                    * fade * fireworkCol;\r\n            }\r\n            \r\n            // Initial instant flash for the explosion\r\n            if(time < FLASH_DURATION)\r\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\r\n        }\r\n        else\r\n        {\r\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\r\n            // ease out sine\r\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\r\n            fireworkPos = vec2(fireworkHash.x, \r\n                    rocketPath * fireworkHash.y);\r\n            // Slight random wiggle for the rocket's path\r\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\r\n            \r\n            // Rockets flying before the explosion\r\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\r\n            {\r\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\r\n                // rocket trail size\r\n                float t = time * (2. - time);\r\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\r\n\t\t\t\t\t* particleHash.z * .1;\r\n                // Confine theta to a small value for a vertical thrust effect\r\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\r\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\r\n            }\r\n        }\r\n    }  \r\n    return finalCol;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\r\n    uv.y += .3; // shift the horizon a bit lower\r\n    float reflection = 0.;\r\n    \r\n    if (uv.y < 0.)\r\n    {\r\n        reflection = 1.;\r\n        // watery distortion in the lake (improved)\r\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\r\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\r\n    }\r\n\r\n    // Our special uv coord that gives us reflection effect for pratically free\r\n    vec2 st = vec2(uv.x, abs(uv.y));\r\n    vec3 col = vec3(0.);\r\n    \r\n    // Background mountain\r\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\r\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\r\n    mountain = C(S(-.005, .005, mountain));\r\n    \r\n    float building = buildings(st);\r\n    \r\n    // Finally blend everything together\r\n    \r\n    // Sky color\r\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\r\n    // Blend the mountain and the sky\r\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\r\n    // Occlude the mountain with the building skyline\r\n    col *= building;\r\n    \r\n    // Yellow-ish window color tint\r\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \r\n    \r\n    // Moon white circle\r\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\r\n    \r\n    //Twinkly stars, masked by the buildings, mountain, and the moon\r\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\r\n    \r\n    // Cut the main moon circle with an offset inverted one to make a crescent\r\n    moon *= smoothstep(.3, .4, length(st-vec2(.92, .88)));\r\n    \r\n    // Add the moon to the scene\r\n    col += moon * vec3(1.2, 1.18, 1.);\r\n    \r\n    // Fireworks launch from behind the buildings, but in front of the mountains\r\n    col += C(fireworks(st)) * (building + moon);\r\n    \r\n    // Slightly change of the reflections to watery blueish-green\r\n    col.r -= reflection * .05;\r\n    col.gb += reflection * .01;\r\n    \r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"/**\r\n This shader is basically an improvement upon a previous fireworks shader I did a while\r\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\r\n instead of the just following the same pattern in a loop, so the fireworks show can be\r\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\r\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\r\n\r\n I wish a very happy and a prosperous new year to everyone!\r\n*/\r\n\r\n#define PI  3.141592653589793\r\n#define TAU 6.283185307179586\r\n\r\n// Helper macros \r\n#define C(x) clamp(x, 0., 1.)\r\n#define S(a, b, x) smoothstep(a, b, x)\r\n#define F(x, f) (floor(x * f) / f)\r\n\r\n// Fireworks control variables\r\n#define FIREWORK_COUNT 8\r\n#define FIREWORK_DURATION 8.\r\n#define FIREWORK_LOW .75\r\n#define FIREWORK_HIGH 1.05\r\n#define ROCKET_PARTICES 32\r\n#define ROCKET_DURATION 1.5\r\n#define FLASH_DURATION ROCKET_DURATION + .2 \r\n#define THRUSTER_SPEED .25\r\n#define EXPLOSION_STRENGTH .03;\r\n#define EXPLOSION_PARTICLES 100\r\n\r\n// Hash functions by Dave_Hoskins\r\nvec2 hash21(float p)\r\n{\r\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n\tp3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n\r\n}\r\n\r\nvec3 hash31(float p)\r\n{\r\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\treturn vec3(n) * (1. / float(0xffffffffU));\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\r\n\tuint q = (n.x ^ n.y) * 1597334673U;\r\n\treturn float(q) * (1. / float(0xffffffffU));\r\n}\r\n\r\n// Function to remap a value from [a, b] to [c, d]\r\nfloat remap(float x, float a, float b, float c, float d)\r\n{\r\n    return (((x - a) / (b - a)) * (d - c)) + c;\r\n}\r\n\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// Tiny fbm\r\nfloat fbm (in vec3 p) {\r\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\r\n}\r\n\r\n// Building window lights from www.shadertoy.com/view/wtt3WB\r\nfloat windows (vec2 uv, float offset)\r\n{\r\n    vec2 grid = vec2(20., 1.);\r\n    uv.x += offset;\r\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\r\n    uv.x *= n1 * 6.;\r\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\r\n    float n = fbm(id.xxx);\r\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\r\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\r\n    vec2 lPos = fract(uv * lightGrid);\r\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\r\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\r\n    n2 = smoothstep(.225, .5, n2);\r\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\r\n}\r\n\r\n// Building skyline \r\nfloat buildings(vec2 st)\r\n{\r\n    // An fbm style amalgamation of various cos functions\r\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\r\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\r\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\r\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\r\n    return C((st.y + b - .1) * 100.);\r\n}\r\n\r\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\r\nfloat stars(vec2 st, vec2 fragCoord)\r\n{\r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\r\n    uv.y += .3;\r\n    uv.y = abs(uv.y);\r\n    float t = iTime * .1;\r\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\r\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\r\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\r\n    twinkle = twinkle * .5 + .5;\r\n    return h.x * h.y * twinkle * 1.5;\r\n}\r\n\r\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\r\nvec3 fireworks(vec2 st)\r\n{\r\n\tvec2 fireworkPos, particlePos;\r\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\r\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\r\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\r\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\r\n    {\r\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\r\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\r\n        // This hash changes after each firework cycle (rocket + explosion)\r\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\r\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\r\n        fireworkCol = fireworkHash * .5 + .5;\r\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\r\n        // Random firework x coordinate but confined to a certain column based on j\r\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\r\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\r\n        \r\n        // Duration of each firework with a random start time\r\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\r\n        if (time > ROCKET_DURATION)\r\n        {\r\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\r\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\r\n            {\r\n                // Unique hash that yeilds a separate spread pattern for each explosion\r\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \r\n\t\t\t\t\t* 1619.8196 + 469.7119);\r\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\r\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\r\n                // Radius expands exponentially over time, i.e. explosion effect\r\n                radius = radiusScale * time * time;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                particlePos.y -= 8. * pow(particlePos.x, 4.); // fake-ish gravity\r\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\r\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\r\n                // Shimmering effect for explosion particles\r\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \r\n                    * (sin((iTime + particleHash.y * TAU) * 18.)));\r\n                shimmerThreshold = FIREWORK_DURATION * .6;\r\n                // Fade after a certain time threshold\r\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\r\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\r\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\r\n                    * fade * fireworkCol;\r\n            }\r\n            \r\n            // Initial instant flash for the explosion\r\n            if(time < FLASH_DURATION)\r\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\r\n        }\r\n        else\r\n        {\r\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\r\n            // ease out sine\r\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\r\n            fireworkPos = vec2(fireworkHash.x, \r\n                    rocketPath * fireworkHash.y);\r\n            // Slight random wiggle for the rocket's path\r\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\r\n            \r\n            // Rockets flying before the explosion\r\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\r\n            {\r\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\r\n                // rocket trail size\r\n                float t = time * (2. - time);\r\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\r\n\t\t\t\t\t* particleHash.z * .1;\r\n                // Confine theta to a small value for a vertical thrust effect\r\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\r\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\r\n            }\r\n        }\r\n    }  \r\n    return finalCol;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\r\n    uv.y += .3; // shift the horizon a bit lower\r\n    float reflection = 0.;\r\n    \r\n    if (uv.y < 0.)\r\n    {\r\n        reflection = 1.;\r\n        // watery distortion in the lake (improved)\r\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\r\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\r\n    }\r\n\r\n    // Our special uv coord that gives us reflection effect for pratically free\r\n    vec2 st = vec2(uv.x, abs(uv.y));\r\n    vec3 col = vec3(0.);\r\n    \r\n    // Background mountain\r\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\r\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\r\n    mountain = C(S(-.005, .005, mountain));\r\n    \r\n    float building = buildings(st);\r\n    \r\n    // Finally blend everything together\r\n    \r\n    // Sky color\r\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\r\n    // Blend the mountain and the sky\r\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\r\n    // Occlude the mountain with the building skyline\r\n    col *= building;\r\n    \r\n    // Yellow-ish window color tint\r\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \r\n    \r\n    // Moon white circle\r\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\r\n    \r\n    //Twinkly stars, masked by the buildings, mountain, and the moon\r\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\r\n    \r\n    // Cut the main moon circle with an offset inverted one to make a crescent\r\n    moon *= smoothstep(.3, .4, length(st-vec2(.92, .88)));\r\n    \r\n    // Add the moon to the scene\r\n    col += moon * vec3(1.2, 1.18, 1.);\r\n    \r\n    // Fireworks launch from behind the buildings, but in front of the mountains\r\n    col += C(fireworks(st)) * (building + moon);\r\n    \r\n    // Slightly change of the reflections to watery blueish-green\r\n    col.r -= reflection * .05;\r\n    col.gb += reflection * .01;\r\n    \r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Happy 2020!","id":"0f147e1acfd44a91a25a4f581fcfe9b0","date":null,"viewed":0,"name":"Happy 2020!","description":"Happy new year everyone!\r\n\r\nv1.1 Added an initial bright flash at the starting of each explosion. (Thanks bigwings)\r\nv1.2 Improved water reflections.\r\nv1.3 Added a crescent moon.\r\nv1.4 Rockets slow down nearing apex.\r\nhttps://www.shadertoy.com/view/tt3GRN","likes":0,"published":null,"tags":["noise"," reflection"," fbm"," water"," particles"," city"," lights"," fireworks"]},"ver":null,"info":{"Name":"Happy 2020!","id":"0f147e1acfd44a91a25a4f581fcfe9b0","date":null,"viewed":0,"name":"Happy 2020!","description":"Happy new year everyone!\r\n\r\nv1.1 Added an initial bright flash at the starting of each explosion. (Thanks bigwings)\r\nv1.2 Improved water reflections.\r\nv1.3 Added a crescent moon.\r\nv1.4 Rockets slow down nearing apex.\r\nhttps://www.shadertoy.com/view/tt3GRN","likes":0,"published":null,"tags":["noise"," reflection"," fbm"," water"," particles"," city"," lights"," fireworks"]},"renderpass":[{"Code":"/**\r\n This shader is basically an improvement upon a previous fireworks shader I did a while\r\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\r\n instead of the just following the same pattern in a loop, so the fireworks show can be\r\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\r\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\r\n\r\n I wish a very happy and a prosperous new year to everyone!\r\n*/\r\n\r\n#define PI  3.141592653589793\r\n#define TAU 6.283185307179586\r\n\r\n// Helper macros \r\n#define C(x) clamp(x, 0., 1.)\r\n#define S(a, b, x) smoothstep(a, b, x)\r\n#define F(x, f) (floor(x * f) / f)\r\n\r\n// Fireworks control variables\r\n#define FIREWORK_COUNT 8\r\n#define FIREWORK_DURATION 8.\r\n#define FIREWORK_LOW .75\r\n#define FIREWORK_HIGH 1.05\r\n#define ROCKET_PARTICES 32\r\n#define ROCKET_DURATION 1.5\r\n#define FLASH_DURATION ROCKET_DURATION + .2 \r\n#define THRUSTER_SPEED .25\r\n#define EXPLOSION_STRENGTH .03;\r\n#define EXPLOSION_PARTICLES 100\r\n\r\n// Hash functions by Dave_Hoskins\r\nvec2 hash21(float p)\r\n{\r\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n\tp3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n\r\n}\r\n\r\nvec3 hash31(float p)\r\n{\r\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\treturn vec3(n) * (1. / float(0xffffffffU));\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\r\n\tuint q = (n.x ^ n.y) * 1597334673U;\r\n\treturn float(q) * (1. / float(0xffffffffU));\r\n}\r\n\r\n// Function to remap a value from [a, b] to [c, d]\r\nfloat remap(float x, float a, float b, float c, float d)\r\n{\r\n    return (((x - a) / (b - a)) * (d - c)) + c;\r\n}\r\n\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// Tiny fbm\r\nfloat fbm (in vec3 p) {\r\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\r\n}\r\n\r\n// Building window lights from www.shadertoy.com/view/wtt3WB\r\nfloat windows (vec2 uv, float offset)\r\n{\r\n    vec2 grid = vec2(20., 1.);\r\n    uv.x += offset;\r\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\r\n    uv.x *= n1 * 6.;\r\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\r\n    float n = fbm(id.xxx);\r\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\r\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\r\n    vec2 lPos = fract(uv * lightGrid);\r\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\r\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\r\n    n2 = smoothstep(.225, .5, n2);\r\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\r\n}\r\n\r\n// Building skyline \r\nfloat buildings(vec2 st)\r\n{\r\n    // An fbm style amalgamation of various cos functions\r\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\r\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\r\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\r\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\r\n    return C((st.y + b - .1) * 100.);\r\n}\r\n\r\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\r\nfloat stars(vec2 st, vec2 fragCoord)\r\n{\r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\r\n    uv.y += .3;\r\n    uv.y = abs(uv.y);\r\n    float t = iTime * .1;\r\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\r\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\r\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\r\n    twinkle = twinkle * .5 + .5;\r\n    return h.x * h.y * twinkle * 1.5;\r\n}\r\n\r\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\r\nvec3 fireworks(vec2 st)\r\n{\r\n\tvec2 fireworkPos, particlePos;\r\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\r\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\r\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\r\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\r\n    {\r\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\r\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\r\n        // This hash changes after each firework cycle (rocket + explosion)\r\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\r\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\r\n        fireworkCol = fireworkHash * .5 + .5;\r\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\r\n        // Random firework x coordinate but confined to a certain column based on j\r\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\r\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\r\n        \r\n        // Duration of each firework with a random start time\r\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\r\n        if (time > ROCKET_DURATION)\r\n        {\r\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\r\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\r\n            {\r\n                // Unique hash that yeilds a separate spread pattern for each explosion\r\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \r\n\t\t\t\t\t* 1619.8196 + 469.7119);\r\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\r\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\r\n                // Radius expands exponentially over time, i.e. explosion effect\r\n                radius = radiusScale * time * time;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                particlePos.y -= 8. * pow(particlePos.x, 4.); // fake-ish gravity\r\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\r\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\r\n                // Shimmering effect for explosion particles\r\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \r\n                    * (sin((iTime + particleHash.y * TAU) * 18.)));\r\n                shimmerThreshold = FIREWORK_DURATION * .6;\r\n                // Fade after a certain time threshold\r\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\r\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\r\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\r\n                    * fade * fireworkCol;\r\n            }\r\n            \r\n            // Initial instant flash for the explosion\r\n            if(time < FLASH_DURATION)\r\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\r\n        }\r\n        else\r\n        {\r\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\r\n            // ease out sine\r\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\r\n            fireworkPos = vec2(fireworkHash.x, \r\n                    rocketPath * fireworkHash.y);\r\n            // Slight random wiggle for the rocket's path\r\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\r\n            \r\n            // Rockets flying before the explosion\r\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\r\n            {\r\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\r\n                // rocket trail size\r\n                float t = time * (2. - time);\r\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\r\n\t\t\t\t\t* particleHash.z * .1;\r\n                // Confine theta to a small value for a vertical thrust effect\r\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\r\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\r\n            }\r\n        }\r\n    }  \r\n    return finalCol;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\r\n    uv.y += .3; // shift the horizon a bit lower\r\n    float reflection = 0.;\r\n    \r\n    if (uv.y < 0.)\r\n    {\r\n        reflection = 1.;\r\n        // watery distortion in the lake (improved)\r\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\r\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\r\n    }\r\n\r\n    // Our special uv coord that gives us reflection effect for pratically free\r\n    vec2 st = vec2(uv.x, abs(uv.y));\r\n    vec3 col = vec3(0.);\r\n    \r\n    // Background mountain\r\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\r\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\r\n    mountain = C(S(-.005, .005, mountain));\r\n    \r\n    float building = buildings(st);\r\n    \r\n    // Finally blend everything together\r\n    \r\n    // Sky color\r\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\r\n    // Blend the mountain and the sky\r\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\r\n    // Occlude the mountain with the building skyline\r\n    col *= building;\r\n    \r\n    // Yellow-ish window color tint\r\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \r\n    \r\n    // Moon white circle\r\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\r\n    \r\n    //Twinkly stars, masked by the buildings, mountain, and the moon\r\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\r\n    \r\n    // Cut the main moon circle with an offset inverted one to make a crescent\r\n    moon *= smoothstep(.3, .4, length(st-vec2(.92, .88)));\r\n    \r\n    // Add the moon to the scene\r\n    col += moon * vec3(1.2, 1.18, 1.);\r\n    \r\n    // Fireworks launch from behind the buildings, but in front of the mountains\r\n    col += C(fireworks(st)) * (building + moon);\r\n    \r\n    // Slightly change of the reflections to watery blueish-green\r\n    col.r -= reflection * .05;\r\n    col.gb += reflection * .01;\r\n    \r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"/**\r\n This shader is basically an improvement upon a previous fireworks shader I did a while\r\n ago (www.shadertoy.com/view/Ws3SRS). Here, each firework spawns at a random position\r\n instead of the just following the same pattern in a loop, so the fireworks show can be\r\n watched and enjoyed infinitely. The fireworks spawn from behind the buildings, but in\r\n front of the mountains. I hope everyone finds watching this relaxing and enjoyable!\r\n\r\n I wish a very happy and a prosperous new year to everyone!\r\n*/\r\n\r\n#define PI  3.141592653589793\r\n#define TAU 6.283185307179586\r\n\r\n// Helper macros \r\n#define C(x) clamp(x, 0., 1.)\r\n#define S(a, b, x) smoothstep(a, b, x)\r\n#define F(x, f) (floor(x * f) / f)\r\n\r\n// Fireworks control variables\r\n#define FIREWORK_COUNT 8\r\n#define FIREWORK_DURATION 8.\r\n#define FIREWORK_LOW .75\r\n#define FIREWORK_HIGH 1.05\r\n#define ROCKET_PARTICES 32\r\n#define ROCKET_DURATION 1.5\r\n#define FLASH_DURATION ROCKET_DURATION + .2 \r\n#define THRUSTER_SPEED .25\r\n#define EXPLOSION_STRENGTH .03;\r\n#define EXPLOSION_PARTICLES 100\r\n\r\n// Hash functions by Dave_Hoskins\r\nvec2 hash21(float p)\r\n{\r\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\r\n\tp3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.xx + p3.yz) * p3.zy);\r\n\r\n}\r\n\r\nvec3 hash31(float p)\r\n{\r\n\tuvec3 n = uint(int(p)) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\tn = (n.x ^ n.y ^ n.z) * uvec3(1597334673U, 3812015801U, 2798796415U);\r\n\treturn vec3(n) * (1. / float(0xffffffffU));\r\n}\r\n\r\nfloat hash11(float p)\r\n{\r\n\tuvec2 n = uint(int(p)) * uvec2(1597334673U, 3812015801U);\r\n\tuint q = (n.x ^ n.y) * 1597334673U;\r\n\treturn float(q) * (1. / float(0xffffffffU));\r\n}\r\n\r\n// Function to remap a value from [a, b] to [c, d]\r\nfloat remap(float x, float a, float b, float c, float d)\r\n{\r\n    return (((x - a) / (b - a)) * (d - c)) + c;\r\n}\r\n\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// Tiny fbm\r\nfloat fbm (in vec3 p) {\r\n\treturn noise (p) + noise (p * 2.) / 2. + noise (p * 4.) / 4.;\r\n}\r\n\r\n// Building window lights from www.shadertoy.com/view/wtt3WB\r\nfloat windows (vec2 uv, float offset)\r\n{\r\n    vec2 grid = vec2(20., 1.);\r\n    uv.x += offset;\r\n    float n1 = fbm((vec2(ivec2(uv * grid)) + .5).xxx);\r\n    uv.x *= n1 * 6.;\r\n    vec2 id = vec2(ivec2(uv * grid)) + .5;\r\n    float n = fbm(id.xxx);\r\n    vec2 lightGrid = vec2(79. * (n + .5), 250. * n);\r\n    float n2 = fbm((vec2(ivec2(uv * lightGrid + floor(iTime * .4) * .2)) + .5).xyx);\r\n    vec2 lPos = fract(uv * lightGrid);\r\n    n2 = (lPos.y < .2 || lPos.y > .7) ? 0. : n2;\r\n    n2 = (lPos.x < .5 || lPos.y > .7) ? 0. : n2;\r\n    n2 = smoothstep(.225, .5, n2);\r\n\treturn (uv.y < n - 0.01) ? n2 : 0.;\r\n}\r\n\r\n// Building skyline \r\nfloat buildings(vec2 st)\r\n{\r\n    // An fbm style amalgamation of various cos functions\r\n    float b = .1 * F(cos(st.x*4.0 + 1.7), 1.0);\r\n    b += (b + .3) * 0.3 * F(cos(st.x*4.-0.1), 2.0);\r\n    b += (b-.01) * 0.1 * F(cos(st.x*12.0), 4.);\r\n    b += (b-.05) * 0.3 * F(cos(st.x*24.0), 1.0);\r\n    return C((st.y + b - .1) * 100.);\r\n}\r\n\r\n// Twinkly stars, derived and modified from: www.shadertoy.com/view/4s33zf\r\nfloat stars(vec2 st, vec2 fragCoord)\r\n{\r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\r\n    uv.y += .3;\r\n    uv.y = abs(uv.y);\r\n    float t = iTime * .1;\r\n    vec2 h = pow(hash21(uv.x * iResolution.y + uv.y), vec2(50.));\r\n    float twinkle = sin((st.x + t + cos(st.y * 50. + t)) * 25.);\r\n    twinkle *= cos((st.y * .187 - t * 4.16 + sin(st.x * 11.8 + t * .347)) * 6.57);\r\n    twinkle = twinkle * .5 + .5;\r\n    return h.x * h.y * twinkle * 1.5;\r\n}\r\n\r\n// Fireworks improved upon my previous shader: https://www.shadertoy.com/view/Ws3SRS\r\nvec3 fireworks(vec2 st)\r\n{\r\n\tvec2 fireworkPos, particlePos;\r\n    float radius, theta, radiusScale, spark, sparkDistFromOrigin, shimmer,\r\n        shimmerThreshold, fade, timeHash, timeOffset, rocketPath;\r\n    vec3 particleHash, fireworkHash, fireworkCol, finalCol;\r\n    for (int j = 0; j < FIREWORK_COUNT; ++j)\r\n    {\r\n        timeHash = hash11(float(j + 1) * 9.6144 + 78.6118);\r\n        timeOffset = float(j + 1) + float(j + 1) * timeHash;\r\n        // This hash changes after each firework cycle (rocket + explosion)\r\n        fireworkHash = hash31(471.5277 * float(j) + 1226.9146\r\n\t\t\t+ float(int((iTime+timeOffset) / FIREWORK_DURATION))) * 2. - 1.;\r\n        fireworkCol = fireworkHash * .5 + .5;\r\n    \tfireworkHash.y = remap(fireworkHash.y, -1., 1., FIREWORK_LOW, FIREWORK_HIGH);\r\n        // Random firework x coordinate but confined to a certain column based on j\r\n        fireworkHash.x = ((float(j) + .5 + fireworkHash.x * .25)\r\n\t\t\t/ float(FIREWORK_COUNT)) * 2. - 1.;\r\n        \r\n        // Duration of each firework with a random start time\r\n        float time = mod(iTime + timeOffset, FIREWORK_DURATION);\r\n        if (time > ROCKET_DURATION)\r\n        {\r\n            fireworkPos = vec2(fireworkHash.x, fireworkHash.y);\r\n            for (int i = 0; i < EXPLOSION_PARTICLES; ++i)\r\n            {\r\n                // Unique hash that yeilds a separate spread pattern for each explosion\r\n                particleHash = hash31(float(j) * 1291.1978 + float(i) \r\n\t\t\t\t\t* 1619.8196 + 469.7119);\r\n                theta = remap(particleHash.x, 0., 1., 0., TAU); // [0, 2.*PI]\r\n                radiusScale = particleHash.y * EXPLOSION_STRENGTH;\r\n                // Radius expands exponentially over time, i.e. explosion effect\r\n                radius = radiusScale * time * time;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                particlePos.y -= 8. * pow(particlePos.x, 4.); // fake-ish gravity\r\n                spark = .0003 / pow(length(st - particlePos - fireworkPos), 1.7);\r\n                sparkDistFromOrigin = 2. * length(fireworkPos - particlePos);\r\n                // Shimmering effect for explosion particles\r\n                shimmer = max(0., sqrt(sparkDistFromOrigin) \r\n                    * (sin((iTime + particleHash.y * TAU) * 18.)));\r\n                shimmerThreshold = FIREWORK_DURATION * .6;\r\n                // Fade after a certain time threshold\r\n                fade = C((FIREWORK_DURATION * 2.) * radiusScale - radius);\r\n                finalCol += mix(spark, spark * shimmer, smoothstep(shimmerThreshold\r\n\t\t\t\t\t* radiusScale, (shimmerThreshold + 1.) * radiusScale , radius))\r\n                    * fade * fireworkCol;\r\n            }\r\n            \r\n            // Initial instant flash for the explosion\r\n            if(time < FLASH_DURATION)\r\n            \tfinalCol += spark / (.01 + mod(time, ROCKET_DURATION));\r\n        }\r\n        else\r\n        {\r\n            rocketPath = mod(time, ROCKET_DURATION) / ROCKET_DURATION;\r\n            // ease out sine\r\n            rocketPath = sin(rocketPath / (ROCKET_DURATION * .75) * PI * .5);\r\n            fireworkPos = vec2(fireworkHash.x, \r\n                    rocketPath * fireworkHash.y);\r\n            // Slight random wiggle for the rocket's path\r\n    \t\tfireworkPos.x += sin(st.y * 50. + time) * fireworkCol.z * .0035;\r\n            \r\n            // Rockets flying before the explosion\r\n            for (int i = 0; i < ROCKET_PARTICES; ++i)\r\n            {\r\n                particleHash = hash31((float(i) * 603.6837) + 1472.3486);\r\n                // rocket trail size\r\n                float t = time * (2. - time);\r\n                radius = mod(time + particleHash.y, THRUSTER_SPEED) / THRUSTER_SPEED\r\n\t\t\t\t\t* particleHash.z * .1;\r\n                // Confine theta to a small value for a vertical thrust effect\r\n                theta = remap(particleHash.x, 0., 1., 0., PI * .1) + PI * 1.45;\r\n                particlePos = vec2(radius * cos(theta), radius * sin(theta));\r\n                finalCol += 8e-5 / pow(length(st - particlePos - fireworkPos), 1.1)\r\n                    * mix(vec3(1.4, .7, .2), vec3(1.4), radius * 16.);\r\n            }\r\n        }\r\n    }  \r\n    return finalCol;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\r\n    uv.y += .3; // shift the horizon a bit lower\r\n    float reflection = 0.;\r\n    \r\n    if (uv.y < 0.)\r\n    {\r\n        reflection = 1.;\r\n        // watery distortion in the lake (improved)\r\n        uv.x += sin((uv.y * 64. + sin(iTime) * .2)\r\n\t\t\t* cos(uv.y * 128. - cos(iTime) * .1)) * .15;\r\n    }\r\n\r\n    // Our special uv coord that gives us reflection effect for pratically free\r\n    vec2 st = vec2(uv.x, abs(uv.y));\r\n    vec3 col = vec3(0.);\r\n    \r\n    // Background mountain\r\n    float mountain = sin(1.69 * st.x * 1.38 * cos(2.74 * st.x) + 4.87\r\n\t\t* sin(1.17 * st.x)) * .1 - .18 + st.y;\r\n    mountain = C(S(-.005, .005, mountain));\r\n    \r\n    float building = buildings(st);\r\n    \r\n    // Finally blend everything together\r\n    \r\n    // Sky color\r\n    col += vec3(.18 - st.y * .1, .18 - st.y * .1, .1 + st.y * .03);\r\n    // Blend the mountain and the sky\r\n    col = col * mountain + vec3(.1 - st.y * .1, .1 - st.y * .1, .08) * (1. - mountain);\r\n    // Occlude the mountain with the building skyline\r\n    col *= building;\r\n    \r\n    // Yellow-ish window color tint\r\n    col += windows(st * .8, 2.) * (1.-building) * vec3(1.2, 1., .8); \r\n    \r\n    // Moon white circle\r\n    float moon = smoothstep(.3, .29, length(st-vec2(1., .8)));\r\n    \r\n    //Twinkly stars, masked by the buildings, mountain, and the moon\r\n    col += stars(st, fragCoord) * mountain * building * (1. - moon);\r\n    \r\n    // Cut the main moon circle with an offset inverted one to make a crescent\r\n    moon *= smoothstep(.3, .4, length(st-vec2(.92, .88)));\r\n    \r\n    // Add the moon to the scene\r\n    col += moon * vec3(1.2, 1.18, 1.);\r\n    \r\n    // Fireworks launch from behind the buildings, but in front of the mountains\r\n    col += C(fireworks(st)) * (building + moon);\r\n    \r\n    // Slightly change of the reflections to watery blueish-green\r\n    col.r -= reflection * .05;\r\n    col.gb += reflection * .01;\r\n    \r\n    fragColor = vec4(col, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"vec4 h2rgb(float c) {  // classical hsv2rgb simplified\r\n    vec4 p = abs(fract(c + vec4(3,2,1,0)/3.) * 6. - 3.);\r\n    return clamp(p - 1., 0., 1.);\r\n}\r\n\r\nvec4 j2hue(float c) {\r\n    return .5+.5*cos(6.28*c+vec4(0,-2.1,2.1,0));\r\n}\r\n\r\nvec4 sin2hue(float c) {\r\n    vec4 C = .5+.5*cos(6.28*clamp(1.5*fract(c)-vec4(0,.5,1,1.5),-.5,.5));\r\n    return C+vec4(C.w,0,0,0);\r\n}\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.xy; U.y*=3.; U.x*=6.;\r\n\tO =   U.y>2. ? sin2hue(U.x) : U.y>1.99 ? O-O\r\n        : U.y>1. ? j2hue(U.x)   : U.y>0.99 ? O-O\r\n        :          h2rgb(U.x);\r\n    float v = O.r+O.g+O.b, \r\n          m = min(O.r,min(O.g,O.b)),\r\n        M = max(O.r,max(O.g,O.b));\r\n    \r\n    O =   U.x>5. ? sqrt((O-m)/(M-m)) : U.x>4.99 ? O-O\r\n        : U.x>4. ? sqrt(O/v)         : U.x>3.99 ? O-O\r\n        : U.x>3. ? sqrt(O)           : U.x>2.99 ? O-O+1.\r\n        : U.x>2. ? (O-m)/(M-m)       : U.x>1.99 ? O-O\r\n        : U.x>1. ? O/v               : U.x>0.99 ? O-O\r\n                 : O;\r\n\r\n}","inputs":[],"outputs":[],"code":"vec4 h2rgb(float c) {  // classical hsv2rgb simplified\r\n    vec4 p = abs(fract(c + vec4(3,2,1,0)/3.) * 6. - 3.);\r\n    return clamp(p - 1., 0., 1.);\r\n}\r\n\r\nvec4 j2hue(float c) {\r\n    return .5+.5*cos(6.28*c+vec4(0,-2.1,2.1,0));\r\n}\r\n\r\nvec4 sin2hue(float c) {\r\n    vec4 C = .5+.5*cos(6.28*clamp(1.5*fract(c)-vec4(0,.5,1,1.5),-.5,.5));\r\n    return C+vec4(C.w,0,0,0);\r\n}\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.xy; U.y*=3.; U.x*=6.;\r\n\tO =   U.y>2. ? sin2hue(U.x) : U.y>1.99 ? O-O\r\n        : U.y>1. ? j2hue(U.x)   : U.y>0.99 ? O-O\r\n        :          h2rgb(U.x);\r\n    float v = O.r+O.g+O.b, \r\n          m = min(O.r,min(O.g,O.b)),\r\n        M = max(O.r,max(O.g,O.b));\r\n    \r\n    O =   U.x>5. ? sqrt((O-m)/(M-m)) : U.x>4.99 ? O-O\r\n        : U.x>4. ? sqrt(O/v)         : U.x>3.99 ? O-O\r\n        : U.x>3. ? sqrt(O)           : U.x>2.99 ? O-O+1.\r\n        : U.x>2. ? (O-m)/(M-m)       : U.x>1.99 ? O-O\r\n        : U.x>1. ? O/v               : U.x>0.99 ? O-O\r\n                 : O;\r\n\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"hue / spectrum / rainbow ramps","id":"040c9f0945494d7e8f5d63ab4e79e3c3","date":null,"viewed":0,"name":"hue / spectrum / rainbow ramps","description":"Bottom to top:  h2rgb, 3-phased sines, 2-phased sines\r\nLeft to right:  brut, brut/lum, saturated,   then sames with gamma\r\ncf graphs: https://www.desmos.com/calculator/ccoc40kfhj\r\nhttps://www.shadertoy.com/view/ltyXRm","likes":0,"published":null,"tags":["spectrum"," color"," rainbow"," hue"]},"ver":null,"info":{"Name":"hue / spectrum / rainbow ramps","id":"040c9f0945494d7e8f5d63ab4e79e3c3","date":null,"viewed":0,"name":"hue / spectrum / rainbow ramps","description":"Bottom to top:  h2rgb, 3-phased sines, 2-phased sines\r\nLeft to right:  brut, brut/lum, saturated,   then sames with gamma\r\ncf graphs: https://www.desmos.com/calculator/ccoc40kfhj\r\nhttps://www.shadertoy.com/view/ltyXRm","likes":0,"published":null,"tags":["spectrum"," color"," rainbow"," hue"]},"renderpass":[{"Code":"vec4 h2rgb(float c) {  // classical hsv2rgb simplified\r\n    vec4 p = abs(fract(c + vec4(3,2,1,0)/3.) * 6. - 3.);\r\n    return clamp(p - 1., 0., 1.);\r\n}\r\n\r\nvec4 j2hue(float c) {\r\n    return .5+.5*cos(6.28*c+vec4(0,-2.1,2.1,0));\r\n}\r\n\r\nvec4 sin2hue(float c) {\r\n    vec4 C = .5+.5*cos(6.28*clamp(1.5*fract(c)-vec4(0,.5,1,1.5),-.5,.5));\r\n    return C+vec4(C.w,0,0,0);\r\n}\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.xy; U.y*=3.; U.x*=6.;\r\n\tO =   U.y>2. ? sin2hue(U.x) : U.y>1.99 ? O-O\r\n        : U.y>1. ? j2hue(U.x)   : U.y>0.99 ? O-O\r\n        :          h2rgb(U.x);\r\n    float v = O.r+O.g+O.b, \r\n          m = min(O.r,min(O.g,O.b)),\r\n        M = max(O.r,max(O.g,O.b));\r\n    \r\n    O =   U.x>5. ? sqrt((O-m)/(M-m)) : U.x>4.99 ? O-O\r\n        : U.x>4. ? sqrt(O/v)         : U.x>3.99 ? O-O\r\n        : U.x>3. ? sqrt(O)           : U.x>2.99 ? O-O+1.\r\n        : U.x>2. ? (O-m)/(M-m)       : U.x>1.99 ? O-O\r\n        : U.x>1. ? O/v               : U.x>0.99 ? O-O\r\n                 : O;\r\n\r\n}","inputs":[],"outputs":[],"code":"vec4 h2rgb(float c) {  // classical hsv2rgb simplified\r\n    vec4 p = abs(fract(c + vec4(3,2,1,0)/3.) * 6. - 3.);\r\n    return clamp(p - 1., 0., 1.);\r\n}\r\n\r\nvec4 j2hue(float c) {\r\n    return .5+.5*cos(6.28*c+vec4(0,-2.1,2.1,0));\r\n}\r\n\r\nvec4 sin2hue(float c) {\r\n    vec4 C = .5+.5*cos(6.28*clamp(1.5*fract(c)-vec4(0,.5,1,1.5),-.5,.5));\r\n    return C+vec4(C.w,0,0,0);\r\n}\r\n\r\nvoid mainImage( out vec4 O, vec2 U )\r\n{\r\n\tU /= iResolution.xy; U.y*=3.; U.x*=6.;\r\n\tO =   U.y>2. ? sin2hue(U.x) : U.y>1.99 ? O-O\r\n        : U.y>1. ? j2hue(U.x)   : U.y>0.99 ? O-O\r\n        :          h2rgb(U.x);\r\n    float v = O.r+O.g+O.b, \r\n          m = min(O.r,min(O.g,O.b)),\r\n        M = max(O.r,max(O.g,O.b));\r\n    \r\n    O =   U.x>5. ? sqrt((O-m)/(M-m)) : U.x>4.99 ? O-O\r\n        : U.x>4. ? sqrt(O/v)         : U.x>3.99 ? O-O\r\n        : U.x>3. ? sqrt(O)           : U.x>2.99 ? O-O+1.\r\n        : U.x>2. ? (O-m)/(M-m)       : U.x>1.99 ? O-O\r\n        : U.x>1. ? O/v               : U.x>0.99 ? O-O\r\n                 : O;\r\n\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define SHADED 1\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 1\r\n\r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"#define SHADED 1\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 1\r\n\r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"hypertexture - trabeculum","id":"a75398b2ccd44b78b15b0fbb135324e0","date":null,"viewed":0,"name":"hypertexture - trabeculum","description":"Trabeculum pattern. (camera follow mouse).\nYou can play with the defines for other patterns (NOISE) or larger trabelucum (VARIANT=0), and params in tweaknoise (thresh, scale).\nCheaper with SHADED=0 & FOG=1.\nhttps://www.shadertoy.com/view/ltj3Dc","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"ver":null,"info":{"Name":"hypertexture - trabeculum","id":"a75398b2ccd44b78b15b0fbb135324e0","date":null,"viewed":0,"name":"hypertexture - trabeculum","description":"Trabeculum pattern. (camera follow mouse).\nYou can play with the defines for other patterns (NOISE) or larger trabelucum (VARIANT=0), and params in tweaknoise (thresh, scale).\nCheaper with SHADED=0 & FOG=1.\nhttps://www.shadertoy.com/view/ltj3Dc","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"renderpass":[{"Code":"#define SHADED 1\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 1\r\n\r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"#define SHADED 1\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 1\r\n\r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// a variant from https://www.shadertoy.com/view/ltj3Dc\r\n\r\n#define SHADED 0\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n\r\nconst vec3 skyColor = 0.*vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.5+.5*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*iTime)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*iTime,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            float a = 2.*PI*float(i)/200.; vec3 c = .5+.5*cos(a+vec3(0.,2.*PI/3.,-2.*PI/3.)+iTime);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// a variant from https://www.shadertoy.com/view/ltj3Dc\r\n\r\n#define SHADED 0\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n\r\nconst vec3 skyColor = 0.*vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.5+.5*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*iTime)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*iTime,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            float a = 2.*PI*float(i)/200.; vec3 c = .5+.5*cos(a+vec3(0.,2.*PI/3.,-2.*PI/3.)+iTime);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"hypertexture - trabeculum 2","id":"b1233d6447ce4a64b876565cdd364622","date":null,"viewed":0,"name":"hypertexture - trabeculum 2","description":"Trabeculum pattern. (camera follow mouse).\n( a variant from https://www.shadertoy.com/view/ltj3Dc )\nhttps://www.shadertoy.com/view/MlB3Wt","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"ver":null,"info":{"Name":"hypertexture - trabeculum 2","id":"b1233d6447ce4a64b876565cdd364622","date":null,"viewed":0,"name":"hypertexture - trabeculum 2","description":"Trabeculum pattern. (camera follow mouse).\n( a variant from https://www.shadertoy.com/view/ltj3Dc )\nhttps://www.shadertoy.com/view/MlB3Wt","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"renderpass":[{"Code":"// a variant from https://www.shadertoy.com/view/ltj3Dc\r\n\r\n#define SHADED 0\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n\r\nconst vec3 skyColor = 0.*vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.5+.5*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*iTime)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*iTime,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            float a = 2.*PI*float(i)/200.; vec3 c = .5+.5*cos(a+vec3(0.,2.*PI/3.,-2.*PI/3.)+iTime);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// a variant from https://www.shadertoy.com/view/ltj3Dc\r\n\r\n#define SHADED 0\r\n#define FOG 0\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n\r\nconst vec3 skyColor = 0.*vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 10., thresh=.5+.5*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*iTime)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*iTime,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            float a = 2.*PI*float(i)/200.; vec3 c = .5+.5*cos(a+vec3(0.,2.*PI/3.,-2.*PI/3.)+iTime);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// mix of 3D trabeculum https://www.shadertoy.com/view/ltj3Dc\r\n// and even-border 2D-trabeculum https://www.shadertoy.com/view/MlGGDw\r\n\r\n#define SHADED 1\r\n#define FOG 1\r\n#define VARIANT 1\r\n#define ANIMATE 1 // 1: camera shake  2: evolving trabeculum\r\n    \r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n\r\nfloat hash( float n ) { // from https://www.shadertoy.com/view/XslGRr\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec3 dist(vec3 g, vec3 x) {\r\n    vec3 n = floor(x), f = fract(x),\r\n         o = hash33( n + g );\r\n\t#if ANIMATE==2\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 worley( vec3 x) {\r\n\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec3 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int k=-1; k<=1; k++ ) \r\n      for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec3  g = vec3(i,j,k), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    vec4 d = vec4(1e15);\r\n/**/\r\n    mg-=mg;\r\n    #define W 1   // shortcut. why does it work ?\r\n/**\r\n    #define W 2   // should be the correct way\r\n/**/\r\n    for( int k=-W; k<=W; k++ )\r\n      for( int j=-W; j<=W; j++ )\r\n        for( int i=-W; i<=W; i++ ) {\r\n            vec3 g = mg + vec3(i,j,k),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d0 = dot( .5*(mr+r), normalize(r-mr) );\r\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\r\n                else if (d0<d.z) {            d.z=d0; }   \r\n /*             if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   */\r\n            }\r\n        }\r\n    return d;           // distances to border P0-PN, N=1..4 closests (after P0)\r\n}\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5, // default value possibly overloaded below.\r\n    _dist=1.;\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p) {\r\n    // macroscopic shape pruning the noise\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1, v;\r\n\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    _dist = 1.;\r\n    if (d < .5) return 0.;\r\n    \r\n    // 3D noise\r\n    //grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    grad=.1, scale = 4., thresh=.9;\r\n    vec4 w = scale*worley(scale*p); \r\n#define TRAB 2 // variation for the magic trabeculum distance\r\n  #if TRAB==1\r\n    v = 1.-2./(0./w.x+1./w.y+1./w.z); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n  #elif TRAB==2\r\n    float n = 1.3; v= 1.-2.*pow(pow(w.y,-n)+pow(w.z,-n),-n);\r\n  #else\r\n    v= 1.-1.*w.y;\r\n  #endif\r\n    \r\n    _dist = 1.-v*d-thresh;\r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-tweaknoise(p-epsL*lightDir))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v*.5, 0.,1.); // Lambert shading  \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if ANIMATE==1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p); // density field\r\n        //epsC = .1*_dist;  // adaptive stepping\r\n        if (Aloc>0.01) {            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n          //vec3 c = ambient+diffuse*dot(N,lightDir); // if N already calculated\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// mix of 3D trabeculum https://www.shadertoy.com/view/ltj3Dc\r\n// and even-border 2D-trabeculum https://www.shadertoy.com/view/MlGGDw\r\n\r\n#define SHADED 1\r\n#define FOG 1\r\n#define VARIANT 1\r\n#define ANIMATE 1 // 1: camera shake  2: evolving trabeculum\r\n    \r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n\r\nfloat hash( float n ) { // from https://www.shadertoy.com/view/XslGRr\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec3 dist(vec3 g, vec3 x) {\r\n    vec3 n = floor(x), f = fract(x),\r\n         o = hash33( n + g );\r\n\t#if ANIMATE==2\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 worley( vec3 x) {\r\n\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec3 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int k=-1; k<=1; k++ ) \r\n      for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec3  g = vec3(i,j,k), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    vec4 d = vec4(1e15);\r\n/**/\r\n    mg-=mg;\r\n    #define W 1   // shortcut. why does it work ?\r\n/**\r\n    #define W 2   // should be the correct way\r\n/**/\r\n    for( int k=-W; k<=W; k++ )\r\n      for( int j=-W; j<=W; j++ )\r\n        for( int i=-W; i<=W; i++ ) {\r\n            vec3 g = mg + vec3(i,j,k),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d0 = dot( .5*(mr+r), normalize(r-mr) );\r\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\r\n                else if (d0<d.z) {            d.z=d0; }   \r\n /*             if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   */\r\n            }\r\n        }\r\n    return d;           // distances to border P0-PN, N=1..4 closests (after P0)\r\n}\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5, // default value possibly overloaded below.\r\n    _dist=1.;\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p) {\r\n    // macroscopic shape pruning the noise\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1, v;\r\n\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    _dist = 1.;\r\n    if (d < .5) return 0.;\r\n    \r\n    // 3D noise\r\n    //grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    grad=.1, scale = 4., thresh=.9;\r\n    vec4 w = scale*worley(scale*p); \r\n#define TRAB 2 // variation for the magic trabeculum distance\r\n  #if TRAB==1\r\n    v = 1.-2./(0./w.x+1./w.y+1./w.z); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n  #elif TRAB==2\r\n    float n = 1.3; v= 1.-2.*pow(pow(w.y,-n)+pow(w.z,-n),-n);\r\n  #else\r\n    v= 1.-1.*w.y;\r\n  #endif\r\n    \r\n    _dist = 1.-v*d-thresh;\r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-tweaknoise(p-epsL*lightDir))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v*.5, 0.,1.); // Lambert shading  \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if ANIMATE==1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p); // density field\r\n        //epsC = .1*_dist;  // adaptive stepping\r\n        if (Aloc>0.01) {            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n          //vec3 c = ambient+diffuse*dot(N,lightDir); // if N already calculated\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"hypertexture - trabeculum -2","id":"65b43cab3c5b43b0bac328cd5ebdcf79","date":null,"viewed":0,"name":"hypertexture - trabeculum -2","description":"3D Trabeculum pattern (camera follow mouse) - messy testbench.\nVoronoi with smooth corners and normalized thickness (see comments).\nhttps://www.shadertoy.com/view/ltyGRy","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"ver":null,"info":{"Name":"hypertexture - trabeculum -2","id":"65b43cab3c5b43b0bac328cd5ebdcf79","date":null,"viewed":0,"name":"hypertexture - trabeculum -2","description":"3D Trabeculum pattern (camera follow mouse) - messy testbench.\nVoronoi with smooth corners and normalized thickness (see comments).\nhttps://www.shadertoy.com/view/ltyGRy","likes":0,"published":null,"tags":["procedural"," noise"," perlin"," hypertexture"," trabeculum"]},"renderpass":[{"Code":"// mix of 3D trabeculum https://www.shadertoy.com/view/ltj3Dc\r\n// and even-border 2D-trabeculum https://www.shadertoy.com/view/MlGGDw\r\n\r\n#define SHADED 1\r\n#define FOG 1\r\n#define VARIANT 1\r\n#define ANIMATE 1 // 1: camera shake  2: evolving trabeculum\r\n    \r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n\r\nfloat hash( float n ) { // from https://www.shadertoy.com/view/XslGRr\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec3 dist(vec3 g, vec3 x) {\r\n    vec3 n = floor(x), f = fract(x),\r\n         o = hash33( n + g );\r\n\t#if ANIMATE==2\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 worley( vec3 x) {\r\n\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec3 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int k=-1; k<=1; k++ ) \r\n      for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec3  g = vec3(i,j,k), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    vec4 d = vec4(1e15);\r\n/**/\r\n    mg-=mg;\r\n    #define W 1   // shortcut. why does it work ?\r\n/**\r\n    #define W 2   // should be the correct way\r\n/**/\r\n    for( int k=-W; k<=W; k++ )\r\n      for( int j=-W; j<=W; j++ )\r\n        for( int i=-W; i<=W; i++ ) {\r\n            vec3 g = mg + vec3(i,j,k),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d0 = dot( .5*(mr+r), normalize(r-mr) );\r\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\r\n                else if (d0<d.z) {            d.z=d0; }   \r\n /*             if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   */\r\n            }\r\n        }\r\n    return d;           // distances to border P0-PN, N=1..4 closests (after P0)\r\n}\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5, // default value possibly overloaded below.\r\n    _dist=1.;\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p) {\r\n    // macroscopic shape pruning the noise\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1, v;\r\n\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    _dist = 1.;\r\n    if (d < .5) return 0.;\r\n    \r\n    // 3D noise\r\n    //grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    grad=.1, scale = 4., thresh=.9;\r\n    vec4 w = scale*worley(scale*p); \r\n#define TRAB 2 // variation for the magic trabeculum distance\r\n  #if TRAB==1\r\n    v = 1.-2./(0./w.x+1./w.y+1./w.z); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n  #elif TRAB==2\r\n    float n = 1.3; v= 1.-2.*pow(pow(w.y,-n)+pow(w.z,-n),-n);\r\n  #else\r\n    v= 1.-1.*w.y;\r\n  #endif\r\n    \r\n    _dist = 1.-v*d-thresh;\r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-tweaknoise(p-epsL*lightDir))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v*.5, 0.,1.); // Lambert shading  \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if ANIMATE==1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p); // density field\r\n        //epsC = .1*_dist;  // adaptive stepping\r\n        if (Aloc>0.01) {            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n          //vec3 c = ambient+diffuse*dot(N,lightDir); // if N already calculated\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// mix of 3D trabeculum https://www.shadertoy.com/view/ltj3Dc\r\n// and even-border 2D-trabeculum https://www.shadertoy.com/view/MlGGDw\r\n\r\n#define SHADED 1\r\n#define FOG 1\r\n#define VARIANT 1\r\n#define ANIMATE 1 // 1: camera shake  2: evolving trabeculum\r\n    \r\nconst vec3 skyColor = vec3(.7,.8,1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n\r\nfloat hash( float n ) { // from https://www.shadertoy.com/view/XslGRr\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n}\r\n\r\nvec3 dist(vec3 g, vec3 x) {\r\n    vec3 n = floor(x), f = fract(x),\r\n         o = hash33( n + g );\r\n\t#if ANIMATE==2\r\n    o = .5 + .5*sin( iTime + 6.2831*o );\r\n    #endif\t\r\n    return g + o - f;\r\n}\r\n\r\nvec4 worley( vec3 x) {\r\n\r\n    //----------------------------------\r\n    // first pass: regular voronoi\r\n    //----------------------------------\r\n\tvec3 mg, mr;\r\n\r\n    float md = 8., md2, md3;\r\n    for( int k=-1; k<=1; k++ ) \r\n      for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ ) {\r\n            vec3  g = vec3(i,j,k), \r\n                  r = dist(g, x);\r\n            float d = dot(r,r);\r\n\r\n            if( d < md ) { md = d; mr = r;  mg = g; } // memorize closest + state\r\n        }\r\n\r\n    //----------------------------------\r\n    // second pass: distance to borders\r\n    //----------------------------------\r\n    vec4 d = vec4(1e15);\r\n/**/\r\n    mg-=mg;\r\n    #define W 1   // shortcut. why does it work ?\r\n/**\r\n    #define W 2   // should be the correct way\r\n/**/\r\n    for( int k=-W; k<=W; k++ )\r\n      for( int j=-W; j<=W; j++ )\r\n        for( int i=-W; i<=W; i++ ) {\r\n            vec3 g = mg + vec3(i,j,k),       // around cell of closest\r\n                 r = dist(g, x);\r\n\r\n            if( dot(mr-r,mr-r) > 1e-5 ) {  // don't count self cell\r\n                float d0 = dot( .5*(mr+r), normalize(r-mr) );\r\n                if      (d0<d.x) { d.yz=d.xy; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.z =d.y ; d.y=d0; }\r\n                else if (d0<d.z) {            d.z=d0; }   \r\n /*             if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; } // we might store normals as well\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   */\r\n            }\r\n        }\r\n    return d;           // distances to border P0-PN, N=1..4 closests (after P0)\r\n}\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5, // default value possibly overloaded below.\r\n    _dist=1.;\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p) {\r\n    // macroscopic shape pruning the noise\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/2.,-grad/2.,abs(p.z)-.5),\r\n          d=d1, v;\r\n\r\n  #if !VARIANT\r\n    d = (1.-d1)*d2; \r\n  #endif\r\n    _dist = 1.;\r\n    if (d < .5) return 0.;\r\n    \r\n    // 3D noise\r\n    //grad=.8, scale = 10., thresh=.7+.3*(cos(.5*iTime)+.36*cos(.5*3.*iTime))/1.36;\r\n    grad=.1, scale = 4., thresh=.9;\r\n    vec4 w = scale*worley(scale*p); \r\n#define TRAB 2 // variation for the magic trabeculum distance\r\n  #if TRAB==1\r\n    v = 1.-2./(0./w.x+1./w.y+1./w.z); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n  #elif TRAB==2\r\n    float n = 1.3; v= 1.-2.*pow(pow(w.y,-n)+pow(w.z,-n),-n);\r\n  #else\r\n    v= 1.-1.*w.y;\r\n  #endif\r\n    \r\n    _dist = 1.-v*d-thresh;\r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-tweaknoise(p-epsL*lightDir))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v*.5, 0.,1.); // Lambert shading  \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    \r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if ANIMATE==1 // camera shake \r\n    float t=10.*iTime,B=.02; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord / iResolution.y -vec2(.9,.5));\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p); // density field\r\n        //epsC = .1*_dist;  // adaptive stepping\r\n        if (Aloc>0.01) {            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n          //vec3 c = ambient+diffuse*dot(N,lightDir); // if N already calculated\r\n#else\r\n            vec3 c = vec3(0.);\r\n#endif\r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// a variant from https://www.shadertoy.com/view/ltj3Dc and https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define SHADED 0\r\n#define FOG 1\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n#define SPIKES 1\r\n#define RANDtex 0 // 0: math rand 1: texture rand ( thanks Dave ! :-) )\r\nfloat time;\r\n\r\nconst vec3 skyColor = vec3(1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n#if !RANDtex\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n#else\r\nfloat noise( in vec3 f )\r\n{\r\n    vec3 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n#if !RANDtex\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n#else  // thanks Dave ! :-)\r\n    return texture( iChannel0, ((n.xy+vec2(37.0,17.0)*n.z+.5))/256.0, -100.0).xyz;\r\n#endif\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=1.; //d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 7., thresh=.7+.2*(cos(.5*time)+.36*cos(.5*3.*time))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*time)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#  if SPIKES    \r\n    v *= 1.-.9*(2.*fbm(10.*scale*p)-1.);\r\n#  endif\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    time = iTime*1.;\r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.4,.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*time,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    { float  t=.5*time, c=cos(t),s=sin(t); q *= mat2(c,-s,s,c); }\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n            //{ vec3 pp=smoothstep(0.,0.2,mod(p*scale,1.)); if (pp.x*pp.y*pp.z<.02) {col+=vec3(1.); break;}}\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.,.05,0.);\r\n#endif            \r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// a variant from https://www.shadertoy.com/view/ltj3Dc and https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define SHADED 0\r\n#define FOG 1\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n#define SPIKES 1\r\n#define RANDtex 0 // 0: math rand 1: texture rand ( thanks Dave ! :-) )\r\nfloat time;\r\n\r\nconst vec3 skyColor = vec3(1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n#if !RANDtex\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n#else\r\nfloat noise( in vec3 f )\r\n{\r\n    vec3 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n#if !RANDtex\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n#else  // thanks Dave ! :-)\r\n    return texture( iChannel0, ((n.xy+vec2(37.0,17.0)*n.z+.5))/256.0, -100.0).xyz;\r\n#endif\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=1.; //d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 7., thresh=.7+.2*(cos(.5*time)+.36*cos(.5*3.*time))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*time)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#  if SPIKES    \r\n    v *= 1.-.9*(2.*fbm(10.*scale*p)-1.);\r\n#  endif\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    time = iTime*1.;\r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.4,.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*time,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    { float  t=.5*time, c=cos(t),s=sin(t); q *= mat2(c,-s,s,c); }\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n            //{ vec3 pp=smoothstep(0.,0.2,mod(p*scale,1.)); if (pp.x*pp.y*pp.z<.02) {col+=vec3(1.); break;}}\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.,.05,0.);\r\n#endif            \r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"hypertexture - trabeculum 3","id":"bbc068a257e74c4290600dd3e4d647ac","date":null,"viewed":0,"name":"hypertexture - trabeculum 3","description":"Trabeculum pattern. (camera follow mouse).\n( a variant from https://www.shadertoy.com/view/MlB3Wt ).\nhttps://www.shadertoy.com/view/XtfXRn","likes":0,"published":null,"tags":["procedural"," raytracing"," noise"," perlin"," hypertexture"," trabeculum"]},"ver":null,"info":{"Name":"hypertexture - trabeculum 3","id":"bbc068a257e74c4290600dd3e4d647ac","date":null,"viewed":0,"name":"hypertexture - trabeculum 3","description":"Trabeculum pattern. (camera follow mouse).\n( a variant from https://www.shadertoy.com/view/MlB3Wt ).\nhttps://www.shadertoy.com/view/XtfXRn","likes":0,"published":null,"tags":["procedural"," raytracing"," noise"," perlin"," hypertexture"," trabeculum"]},"renderpass":[{"Code":"// a variant from https://www.shadertoy.com/view/ltj3Dc and https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define SHADED 0\r\n#define FOG 1\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n#define SPIKES 1\r\n#define RANDtex 0 // 0: math rand 1: texture rand ( thanks Dave ! :-) )\r\nfloat time;\r\n\r\nconst vec3 skyColor = vec3(1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n#if !RANDtex\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n#else\r\nfloat noise( in vec3 f )\r\n{\r\n    vec3 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n#if !RANDtex\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n#else  // thanks Dave ! :-)\r\n    return texture( iChannel0, ((n.xy+vec2(37.0,17.0)*n.z+.5))/256.0, -100.0).xyz;\r\n#endif\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=1.; //d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 7., thresh=.7+.2*(cos(.5*time)+.36*cos(.5*3.*time))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*time)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#  if SPIKES    \r\n    v *= 1.-.9*(2.*fbm(10.*scale*p)-1.);\r\n#  endif\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    time = iTime*1.;\r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.4,.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*time,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    { float  t=.5*time, c=cos(t),s=sin(t); q *= mat2(c,-s,s,c); }\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n            //{ vec3 pp=smoothstep(0.,0.2,mod(p*scale,1.)); if (pp.x*pp.y*pp.z<.02) {col+=vec3(1.); break;}}\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.,.05,0.);\r\n#endif            \r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","inputs":[],"outputs":[],"code":"// a variant from https://www.shadertoy.com/view/ltj3Dc and https://www.shadertoy.com/view/MlB3Wt\r\n\r\n#define SHADED 0\r\n#define FOG 1\r\n#define NOISE 3 // Perlin, Worley, Trabeculum\r\n#define VARIANT 2\r\n#define SPIKES 1\r\n#define RANDtex 0 // 0: math rand 1: texture rand ( thanks Dave ! :-) )\r\nfloat time;\r\n\r\nconst vec3 skyColor = vec3(1.); const float skyTrsp = .5;\r\nconst vec3 sunColor = vec3(1.,.7,.1)*10.;   \r\nconst vec3 lightDir = vec3(.94,.24,.24); // normalize(vec3(.8,.2,-.2));\r\nconst vec3 ambient  = vec3(.2,0.,0.), \r\n           diffuse  = vec3(.8);\r\n\r\n#define PI 3.14159\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\r\n           \t\t    -0.80,  0.36, -0.48,\r\n             \t\t-0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n ) {\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\n#if !RANDtex\r\nfloat noise( in vec3 x ) { // in [0,1]\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.-2.*f);\r\n\r\n    float n = p.x + p.y*57. + 113.*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\r\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\r\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\r\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n#else\r\nfloat noise( in vec3 f )\r\n{\r\n    vec3 p = floor(f);\r\n    f = fract(f);\r\n    f = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\nfloat fbm( vec3 p ) { // in [0,1]\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n// more 3D noise\r\nvec3 hash13( float n ) {\r\n    return fract(sin(n+vec3(0.,12.345,124))*43758.5453);\r\n}\r\nfloat hash31( vec3 n ) {\r\n    return hash(n.x+10.*n.y+100.*n.z);\r\n}\r\nvec3 hash33( vec3 n ) {\r\n#if !RANDtex\r\n    return hash13(n.x+10.*n.y+100.*n.z);\r\n#else  // thanks Dave ! :-)\r\n    return texture( iChannel0, ((n.xy+vec2(37.0,17.0)*n.z+.5))/256.0, -100.0).xyz;\r\n#endif\r\n}\r\n\r\nvec4 worley( vec3 p ) {\r\n    vec4 d = vec4(1e15);\r\n    vec3 ip = floor(p);\r\n    for (float i=-1.; i<2.; i++)\r\n   \t \tfor (float j=-1.; j<2.; j++)\r\n            for (float k=-1.; k<2.; k++) {\r\n                vec3 p0 = ip+vec3(i,j,k),\r\n                      c = hash33(p0)+p0-p;\r\n                float d0 = dot(c,c);\r\n                if      (d0<d.x) { d.yzw=d.xyz; d.x=d0; }\r\n                else if (d0<d.y) { d.zw =d.yz ; d.y=d0; }\r\n                else if (d0<d.z) { d.w  =d.z  ; d.z=d0; }\r\n                else if (d0<d.w) {              d.w=d0; }   \r\n            }\r\n    return sqrt(d);\r\n}\r\n\r\n\r\nfloat grad=.2/2., scale = 5., thresh=.5; // default value possibly overloaded below.\r\n\r\n// my noise\r\nfloat tweaknoise( vec3 p , bool step) {\r\n    float d1 = smoothstep(grad/2.,-grad/2.,length(p)-.5),\r\n          d2 = smoothstep(grad/1.,-grad/1.,abs(p.z)-.5),\r\n          d=d1;\r\n#if NOISE==1 // 3D Perlin noise\r\n    float v = fbm(scale*p);\r\n#elif NOISE==2 // Worley noise\r\n    float v = (.9-scale*worley(scale*p).x);\r\n#elif NOISE>=3 // trabeculum 3D\r\n  #if VARIANT==0\r\n    d = (1.-d1)*d2; \r\n  #elif VARIANT==2\r\n    d=1.; //d=d2;\r\n  #endif\r\n    if (d<0.5) return 0.;\r\n    grad=.8, scale = 7., thresh=.7+.2*(cos(.5*time)+.36*cos(.5*3.*time))/1.36;\r\n    vec4 w=scale*worley(scale*p-vec3(0.,0.,3.*time)); \r\n    float v=1.-1./(1./(w.z-w.x)+1./(w.a-w.x)); // formula (c) Fabrice NEYRET - BSD3:mention author.\r\n#  if SPIKES    \r\n    v *= 1.-.9*(2.*fbm(10.*scale*p)-1.);\r\n#  endif\r\n#endif\r\n    \r\n    return (true)? smoothstep(thresh-grad/2.,thresh+grad/2.,v*d) : v*d;\r\n}\r\n\r\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\r\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\r\nfloat shadedNormal( vec3 p, float v ) {\r\n    float epsL = 0.01;\r\n#if 1// centered directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-tweaknoise(p-epsL*lightDir,false))/(2.*epsL);\r\n#else // cheap directional derivative\r\n    float dx = (tweaknoise(p+epsL*lightDir,false)-v)/epsL;\r\n#endif\r\n    return clamp(-dx*grad/scale/v, 0.,1.); // Lambert shading\r\n    \r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // if (max(fragCoord.x,fragCoord.y)/iResolution.y<.05) \r\n    // { fragColor = vec4(ambient,1.); return; }\r\n    time = iTime*1.;\r\n    vec2 mouse=iMouse.xy/iResolution.xy;\r\n    if (mouse.x+mouse.y==0.) mouse.xy=vec2(0.4,.5);\r\n\r\n    //camera\r\n    float theta = (mouse.x*2. - 1.)*PI;\r\n    float phi = (mouse.y - .5)*PI;\r\n#if 1 // camera shake \r\n    float t=3.*time,B=.07; theta += B*cos(t); phi += B*sin(t);\r\n#endif\r\n    vec3 cameraPos =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));   \r\n    vec3 cameraTarget = vec3(0.);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = 2.*(fragCoord.xy / iResolution.y -vec2(.9,.5));\r\n    { float  t=.5*time, c=cos(t),s=sin(t); q *= mat2(c,-s,s,c); }\r\n    vec3 rayDir = normalize( q.x*uu + q.y*vv -1.5*ww );\r\n  \r\n    // ray-trace volume\r\n    vec3 col=vec3(0.);\r\n \tfloat transp=1., epsC=.01/2.;\r\n    float l = .5;\r\n    vec3 p=cameraPos+l*rayDir, p_=p;\r\n    \r\n    for (int i=0; i<200; i++) { \r\n        float Aloc = tweaknoise(p,true); // density field\r\n        if (Aloc>0.01) {\r\n            \r\n#if FOG \r\n\t      \tfloat fog = pow(skyTrsp,length(p_-p)); p_=p;\r\n            col += transp*skyColor*(1.-fog);\r\n    \t    transp *= fog; \r\n            if (transp<.001) break;\r\n#endif            \r\n\r\n            //{ vec3 pp=smoothstep(0.,0.2,mod(p*scale,1.)); if (pp.x*pp.y*pp.z<.02) {col+=vec3(1.); break;}}\r\n#if SHADED          \r\n            vec3 c = ambient+diffuse*shadedNormal(p,Aloc);\r\n#else\r\n            vec3 c = vec3(0.,.05,0.);\r\n#endif            \r\n \t        col += transp*c*Aloc;\r\n            //if (c.r>1.) { fragColor = vec4(0.,0.,1.,1.); return; }\r\n            col = clamp(col,0.,1.); // anomaly :-(\r\n    \t    transp *= 1.-Aloc;\r\n\t        if (transp<.001) break;\r\n        }\r\n \r\n        p += epsC*rayDir;\r\n    }\r\n    \r\n   fragColor = vec4(col+ transp*skyColor, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// These are 316 gaussian points (201 brushes by using local symmetry) forming the picture\r\n// of Audrey Hepburn. They pack down to 800 bytes (34 bits per point) before huffman/arithmetic\r\n// compression.\r\n//\r\n// The points were chosen by (very quickly) runing this \r\n//\r\n// http://www.iquilezles.org/www/articles/genetic/genetic.htm\r\n//\r\n// with some importance sampling for the eyes, nouse and mouth.\r\n\r\nfloat brush( float col, vec2 p, in vec4 b, float an )\r\n{\r\n\tp += an*cos( iTime + 100.0*b.yz );\r\n\t\t\t\t\r\n    vec2 dd = p - b.yz;\r\n    col = mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    if( abs(b.z-0.5)<0.251 )\r\n    {\r\n        dd.x = p.x - 1.0 + b.y;\r\n        col =  mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    }\r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.y;\r\n    uv.x -=  0.5*(iResolution.x / iResolution.y - 1.0);\r\n\r\n    float an = smoothstep( 0.0, 1.0, cos(iTime) );\r\n\r\n\tfloat col = 0.0;\r\n\r\n    col = brush( col, uv, vec4(1.000,0.371,0.379,11.770), an );\r\n    col = brush( col, uv, vec4(0.992,0.545,0.551,8.359), an );\r\n    col = brush( col, uv, vec4(0.749,0.623,0.990,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.510,0.395,11.315), an );\r\n    col = brush( col, uv, vec4(1.000,0.723,0.564,15.170), an );\r\n    col = brush( col, uv, vec4(0.953,0.729,0.750,14.629), an );\r\n    col = brush( col, uv, vec4(0.706,0.982,0.033,16.254), an );\r\n    col = brush( col, uv, vec4(1.000,0.855,0.652,26.256), an );\r\n    col = brush( col, uv, vec4(1.000,0.664,0.623,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.881,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.686,0.682,0.900,27.676), an );\r\n    col = brush( col, uv, vec4(1.000,0.189,0.684,18.618), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.422,0.195,44.522), an );\r\n    col = brush( col, uv, vec4(1.000,0.779,0.750,16.787), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.330,14.222), an );\r\n    col = brush( col, uv, vec4(1.000,0.197,0.648,22.505), an );\r\n    col = brush( col, uv, vec4(0.702,0.512,0.393,35.310), an );\r\n    col = brush( col, uv, vec4(1.000,0.744,0.621,14.949), an );\r\n    col = brush( col, uv, vec4(0.671,0.885,0.092,24.675), an );\r\n    col = brush( col, uv, vec4(0.000,0.344,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.760,0.465,40.960), an );\r\n    col = brush( col, uv, vec4(0.008,0.908,0.311,8.031), an );\r\n    col = brush( col, uv, vec4(0.016,0.959,0.750,10.039), an );\r\n    col = brush( col, uv, vec4(0.004,0.930,0.750,12.800), an );\r\n    col = brush( col, uv, vec4(1.000,0.555,0.250,19.883), an );\r\n    col = brush( col, uv, vec4(1.000,0.770,1.018,15.876), an );\r\n    col = brush( col, uv, vec4(0.000,0.828,0.756,36.571), an );\r\n    col = brush( col, uv, vec4(0.580,0.566,0.424,89.043), an );\r\n    col = brush( col, uv, vec4(0.988,0.162,0.691,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.314,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.947,0.125,32.000), an );\r\n    col = brush( col, uv, vec4(0.914,0.844,0.725,52.513), an );\r\n    col = brush( col, uv, vec4(1.000,0.313,0.762,42.667), an );\r\n    col = brush( col, uv, vec4(0.996,0.676,0.689,85.333), an );\r\n    col = brush( col, uv, vec4(0.980,0.346,0.559,24.675), an );\r\n    col = brush( col, uv, vec4(1.000,0.553,0.250,18.789), an );\r\n    col = brush( col, uv, vec4(0.004,0.258,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.420,0.742,30.567), an );\r\n    col = brush( col, uv, vec4(0.906,0.543,0.250,22.756), an );\r\n    col = brush( col, uv, vec4(0.863,0.674,0.322,20.078), an );\r\n    col = brush( col, uv, vec4(0.753,0.357,0.686,78.769), an );\r\n    col = brush( col, uv, vec4(0.906,0.795,0.705,37.236), an );\r\n    col = brush( col, uv, vec4(0.933,0.520,0.365,38.642), an );\r\n    col = brush( col, uv, vec4(0.996,0.318,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.337,0.486,0.281,81.920), an );\r\n    col = brush( col, uv, vec4(0.965,0.691,0.516,16.650), an );\r\n    col = brush( col, uv, vec4(0.808,0.582,0.973,52.513), an );\r\n    col = brush( col, uv, vec4(0.012,0.240,0.928,8.063), an );\r\n    col = brush( col, uv, vec4(1.000,0.496,0.217,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.658,0.953,34.133), an );\r\n    col = brush( col, uv, vec4(0.871,0.582,0.172,62.061), an );\r\n    col = brush( col, uv, vec4(0.855,0.346,0.342,17.504), an );\r\n    col = brush( col, uv, vec4(0.878,0.787,0.648,28.845), an );\r\n    col = brush( col, uv, vec4(0.000,0.984,0.111,35.310), an );\r\n    col = brush( col, uv, vec4(0.855,0.514,0.965,66.065), an );\r\n    col = brush( col, uv, vec4(0.561,0.613,0.350,81.920), an );\r\n    col = brush( col, uv, vec4(0.992,0.818,0.902,21.558), an );\r\n    col = brush( col, uv, vec4(0.914,0.746,0.615,40.157), an );\r\n    col = brush( col, uv, vec4(0.557,0.580,0.125,60.235), an );\r\n    col = brush( col, uv, vec4(0.475,0.547,0.414,70.621), an );\r\n    col = brush( col, uv, vec4(0.843,0.680,0.793,20.277), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.758,56.889), an );\r\n    col = brush( col, uv, vec4(1.000,0.299,0.691,68.267), an );\r\n    col = brush( col, uv, vec4(0.737,0.518,0.100,68.267), an );\r\n    col = brush( col, uv, vec4(0.996,0.227,0.514,41.796), an );\r\n    col = brush( col, uv, vec4(0.929,0.850,0.770,62.061), an );\r\n    col = brush( col, uv, vec4(0.682,0.834,0.111,30.118), an );\r\n    col = brush( col, uv, vec4(0.996,0.854,0.793,58.514), an );\r\n    col = brush( col, uv, vec4(0.490,0.736,0.889,19.321), an );\r\n    col = brush( col, uv, vec4(0.980,0.465,0.725,16.126), an );\r\n    col = brush( col, uv, vec4(0.992,0.484,1.010,23.273), an );\r\n    col = brush( col, uv, vec4(0.008,0.949,0.727,23.540), an );\r\n    col = brush( col, uv, vec4(0.012,0.086,0.086,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.121,0.750,44.522), an );\r\n    col = brush( col, uv, vec4(0.427,0.617,0.891,27.676), an );\r\n    col = brush( col, uv, vec4(0.804,0.693,0.633,78.769), an );\r\n    col = brush( col, uv, vec4(0.012,0.711,0.084,13.745), an );\r\n    col = brush( col, uv, vec4(0.082,0.584,0.338,107.789), an );\r\n    col = brush( col, uv, vec4(0.929,0.613,0.268,19.692), an );\r\n    col = brush( col, uv, vec4(0.200,0.549,0.420,128.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.402,0.717,26.947), an );\r\n    col = brush( col, uv, vec4(0.000,0.551,0.168,45.511), an );\r\n    col = brush( col, uv, vec4(0.992,0.627,0.621,56.889), an );\r\n    col = brush( col, uv, vec4(0.902,0.361,0.748,40.960), an );\r\n    col = brush( col, uv, vec4(0.984,0.344,0.754,38.642), an );\r\n    col = brush( col, uv, vec4(0.902,0.203,0.818,51.200), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.803,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.738,0.691,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.385,0.797,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.725,0.305,62.061), an );\r\n    col = brush( col, uv, vec4(0.000,0.150,0.750,45.511), an );\r\n    col = brush( col, uv, vec4(1.000,0.742,0.408,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.645,0.643,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.438,35.310), an );\r\n    col = brush( col, uv, vec4(0.510,0.564,0.789,18.450), an );\r\n    col = brush( col, uv, vec4(0.863,0.211,0.781,30.567), an );\r\n    col = brush( col, uv, vec4(0.106,0.508,0.328,89.043), an );\r\n    col = brush( col, uv, vec4(0.012,0.410,0.875,14.629), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.877,48.762), an );\r\n    col = brush( col, uv, vec4(1.000,0.258,0.779,37.926), an );\r\n    col = brush( col, uv, vec4(0.000,0.436,0.807,28.845), an );\r\n    col = brush( col, uv, vec4(0.918,0.861,0.836,49.951), an );\r\n    col = brush( col, uv, vec4(1.000,0.291,0.770,40.960), an );\r\n    col = brush( col, uv, vec4(0.000,0.750,0.283,27.676), an );\r\n    col = brush( col, uv, vec4(0.965,0.596,0.572,28.055), an );\r\n    col = brush( col, uv, vec4(0.902,0.803,0.953,24.976), an );\r\n    col = brush( col, uv, vec4(0.957,0.498,0.600,16.126), an );\r\n    col = brush( col, uv, vec4(0.914,0.322,0.432,15.634), an );\r\n    col = brush( col, uv, vec4(0.008,0.025,0.621,17.809), an );\r\n    col = brush( col, uv, vec4(0.000,0.916,0.713,56.889), an );\r\n    col = brush( col, uv, vec4(0.914,0.547,0.971,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.207,0.432,37.926), an );\r\n    col = brush( col, uv, vec4(0.875,0.176,0.793,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.646,0.668,41.796), an );\r\n    col = brush( col, uv, vec4(1.000,0.721,0.691,51.200), an );\r\n    col = brush( col, uv, vec4(0.451,0.559,0.754,49.951), an );\r\n    col = brush( col, uv, vec4(0.969,0.846,0.750,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.146,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.613,0.635,85.333), an );\r\n    col = brush( col, uv, vec4(0.596,0.807,0.150,58.514), an );\r\n    col = brush( col, uv, vec4(0.898,0.330,0.760,40.157), an );\r\n    col = brush( col, uv, vec4(0.694,0.594,0.012,51.200), an );\r\n    col = brush( col, uv, vec4(0.698,0.592,0.055,53.895), an );\r\n    col = brush( col, uv, vec4(0.902,0.268,0.773,39.385), an );\r\n    col = brush( col, uv, vec4(0.925,0.838,0.660,58.514), an );\r\n    col = brush( col, uv, vec4(0.843,0.670,0.242,28.444), an );\r\n    col = brush( col, uv, vec4(0.243,0.465,0.285,85.333), an );\r\n    col = brush( col, uv, vec4(0.816,0.588,0.674,44.522), an );\r\n    col = brush( col, uv, vec4(0.008,0.283,0.115,8.031), an );\r\n    col = brush( col, uv, vec4(0.247,0.414,0.691,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.104,0.781,60.235), an );\r\n    col = brush( col, uv, vec4(0.000,0.619,0.660,60.235), an );\r\n    col = brush( col, uv, vec4(0.584,0.650,0.994,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.219,0.393,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.307,0.645,97.524), an );\r\n    col = brush( col, uv, vec4(0.953,0.639,0.771,38.642), an );\r\n    col = brush( col, uv, vec4(0.000,0.238,0.357,34.712), an );\r\n    col = brush( col, uv, vec4(0.922,0.713,0.352,53.895), an );\r\n    col = brush( col, uv, vec4(0.965,0.387,0.748,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.898,0.633,41.796), an );\r\n    col = brush( col, uv, vec4(0.941,0.352,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.933,0.439,0.725,30.567), an );\r\n    col = brush( col, uv, vec4(0.310,0.541,0.906,47.628), an );\r\n    col = brush( col, uv, vec4(0.941,0.502,0.689,24.094), an );\r\n    col = brush( col, uv, vec4(0.094,0.527,0.330,85.333), an );\r\n    col = brush( col, uv, vec4(0.000,0.090,0.688,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.652,0.713,75.852), an );\r\n    col = brush( col, uv, vec4(0.949,0.320,0.623,107.789), an );\r\n    col = brush( col, uv, vec4(0.890,0.775,0.750,22.505), an );\r\n    col = brush( col, uv, vec4(0.012,0.918,0.490,14.322), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.967,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.324,0.676,64.000), an );\r\n    col = brush( col, uv, vec4(0.008,0.141,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.633,0.707,75.852), an );\r\n    col = brush( col, uv, vec4(0.910,0.385,0.207,44.522), an );\r\n    col = brush( col, uv, vec4(0.012,0.703,0.182,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.617,0.703,73.143), an );\r\n    col = brush( col, uv, vec4(0.890,0.352,0.225,45.511), an );\r\n    col = brush( col, uv, vec4(0.933,0.826,0.604,44.522), an );\r\n    col = brush( col, uv, vec4(0.914,0.777,0.574,25.924), an );\r\n    col = brush( col, uv, vec4(0.631,0.781,0.182,68.267), an );\r\n    col = brush( col, uv, vec4(1.000,0.873,0.916,48.762), an );\r\n    col = brush( col, uv, vec4(0.694,0.520,0.113,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.926,58.514), an );\r\n    col = brush( col, uv, vec4(0.184,0.598,0.344,146.286), an );\r\n    col = brush( col, uv, vec4(0.863,0.678,0.250,35.310), an );\r\n    col = brush( col, uv, vec4(0.090,0.566,0.332,78.769), an );\r\n    col = brush( col, uv, vec4(0.420,0.445,0.301,56.889), an );\r\n    col = brush( col, uv, vec4(0.973,0.617,0.516,18.124), an );\r\n    col = brush( col, uv, vec4(0.000,0.191,0.500,39.385), an );\r\n    col = brush( col, uv, vec4(0.000,0.240,0.326,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.264,0.322,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.604,0.699,70.621), an );\r\n    col = brush( col, uv, vec4(0.000,0.113,0.604,43.574), an );\r\n    col = brush( col, uv, vec4(0.894,0.760,0.697,49.951), an );\r\n    col = brush( col, uv, vec4(0.914,0.725,0.383,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.199,0.467,48.762), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.660,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.611,0.191,45.511), an );\r\n    col = brush( col, uv, vec4(0.059,0.789,0.869,30.118), an );\r\n    col = brush( col, uv, vec4(0.976,0.641,0.213,40.960), an );\r\n    col = brush( col, uv, vec4(0.918,0.402,0.742,47.628), an );\r\n    col = brush( col, uv, vec4(0.945,0.717,0.582,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.299,0.672,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.719,0.666,48.762), an );\r\n    col = brush( col, uv, vec4(0.882,0.697,0.271,58.514), an );\r\n    col = brush( col, uv, vec4(0.929,0.752,0.436,64.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.867,0.813,56.889), an );\r\n    col = brush( col, uv, vec4(0.643,0.588,0.090,64.000), an );\r\n    col = brush( col, uv, vec4(0.012,0.063,0.922,10.952), an );\r\n    col = brush( col, uv, vec4(0.878,0.186,0.750,31.508), an );\r\n    col = brush( col, uv, vec4(0.953,0.648,0.613,120.471), an );\r\n    col = brush( col, uv, vec4(0.973,0.180,0.576,45.511), an );\r\n    col = brush( col, uv, vec4(0.741,0.943,0.076,52.513), an );\r\n    col = brush( col, uv, vec4(0.059,0.545,0.332,89.043), an );\r\n    col = brush( col, uv, vec4(0.094,0.295,0.734,85.333), an );\r\n    col = brush( col, uv, vec4(0.008,0.676,0.721,85.333), an );\r\n    col = brush( col, uv, vec4(0.550,0.350,0.650,85.000), an );\r\n\r\n\tfragColor = vec4(col,col,col,1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// These are 316 gaussian points (201 brushes by using local symmetry) forming the picture\r\n// of Audrey Hepburn. They pack down to 800 bytes (34 bits per point) before huffman/arithmetic\r\n// compression.\r\n//\r\n// The points were chosen by (very quickly) runing this \r\n//\r\n// http://www.iquilezles.org/www/articles/genetic/genetic.htm\r\n//\r\n// with some importance sampling for the eyes, nouse and mouth.\r\n\r\nfloat brush( float col, vec2 p, in vec4 b, float an )\r\n{\r\n\tp += an*cos( iTime + 100.0*b.yz );\r\n\t\t\t\t\r\n    vec2 dd = p - b.yz;\r\n    col = mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    if( abs(b.z-0.5)<0.251 )\r\n    {\r\n        dd.x = p.x - 1.0 + b.y;\r\n        col =  mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    }\r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.y;\r\n    uv.x -=  0.5*(iResolution.x / iResolution.y - 1.0);\r\n\r\n    float an = smoothstep( 0.0, 1.0, cos(iTime) );\r\n\r\n\tfloat col = 0.0;\r\n\r\n    col = brush( col, uv, vec4(1.000,0.371,0.379,11.770), an );\r\n    col = brush( col, uv, vec4(0.992,0.545,0.551,8.359), an );\r\n    col = brush( col, uv, vec4(0.749,0.623,0.990,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.510,0.395,11.315), an );\r\n    col = brush( col, uv, vec4(1.000,0.723,0.564,15.170), an );\r\n    col = brush( col, uv, vec4(0.953,0.729,0.750,14.629), an );\r\n    col = brush( col, uv, vec4(0.706,0.982,0.033,16.254), an );\r\n    col = brush( col, uv, vec4(1.000,0.855,0.652,26.256), an );\r\n    col = brush( col, uv, vec4(1.000,0.664,0.623,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.881,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.686,0.682,0.900,27.676), an );\r\n    col = brush( col, uv, vec4(1.000,0.189,0.684,18.618), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.422,0.195,44.522), an );\r\n    col = brush( col, uv, vec4(1.000,0.779,0.750,16.787), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.330,14.222), an );\r\n    col = brush( col, uv, vec4(1.000,0.197,0.648,22.505), an );\r\n    col = brush( col, uv, vec4(0.702,0.512,0.393,35.310), an );\r\n    col = brush( col, uv, vec4(1.000,0.744,0.621,14.949), an );\r\n    col = brush( col, uv, vec4(0.671,0.885,0.092,24.675), an );\r\n    col = brush( col, uv, vec4(0.000,0.344,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.760,0.465,40.960), an );\r\n    col = brush( col, uv, vec4(0.008,0.908,0.311,8.031), an );\r\n    col = brush( col, uv, vec4(0.016,0.959,0.750,10.039), an );\r\n    col = brush( col, uv, vec4(0.004,0.930,0.750,12.800), an );\r\n    col = brush( col, uv, vec4(1.000,0.555,0.250,19.883), an );\r\n    col = brush( col, uv, vec4(1.000,0.770,1.018,15.876), an );\r\n    col = brush( col, uv, vec4(0.000,0.828,0.756,36.571), an );\r\n    col = brush( col, uv, vec4(0.580,0.566,0.424,89.043), an );\r\n    col = brush( col, uv, vec4(0.988,0.162,0.691,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.314,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.947,0.125,32.000), an );\r\n    col = brush( col, uv, vec4(0.914,0.844,0.725,52.513), an );\r\n    col = brush( col, uv, vec4(1.000,0.313,0.762,42.667), an );\r\n    col = brush( col, uv, vec4(0.996,0.676,0.689,85.333), an );\r\n    col = brush( col, uv, vec4(0.980,0.346,0.559,24.675), an );\r\n    col = brush( col, uv, vec4(1.000,0.553,0.250,18.789), an );\r\n    col = brush( col, uv, vec4(0.004,0.258,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.420,0.742,30.567), an );\r\n    col = brush( col, uv, vec4(0.906,0.543,0.250,22.756), an );\r\n    col = brush( col, uv, vec4(0.863,0.674,0.322,20.078), an );\r\n    col = brush( col, uv, vec4(0.753,0.357,0.686,78.769), an );\r\n    col = brush( col, uv, vec4(0.906,0.795,0.705,37.236), an );\r\n    col = brush( col, uv, vec4(0.933,0.520,0.365,38.642), an );\r\n    col = brush( col, uv, vec4(0.996,0.318,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.337,0.486,0.281,81.920), an );\r\n    col = brush( col, uv, vec4(0.965,0.691,0.516,16.650), an );\r\n    col = brush( col, uv, vec4(0.808,0.582,0.973,52.513), an );\r\n    col = brush( col, uv, vec4(0.012,0.240,0.928,8.063), an );\r\n    col = brush( col, uv, vec4(1.000,0.496,0.217,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.658,0.953,34.133), an );\r\n    col = brush( col, uv, vec4(0.871,0.582,0.172,62.061), an );\r\n    col = brush( col, uv, vec4(0.855,0.346,0.342,17.504), an );\r\n    col = brush( col, uv, vec4(0.878,0.787,0.648,28.845), an );\r\n    col = brush( col, uv, vec4(0.000,0.984,0.111,35.310), an );\r\n    col = brush( col, uv, vec4(0.855,0.514,0.965,66.065), an );\r\n    col = brush( col, uv, vec4(0.561,0.613,0.350,81.920), an );\r\n    col = brush( col, uv, vec4(0.992,0.818,0.902,21.558), an );\r\n    col = brush( col, uv, vec4(0.914,0.746,0.615,40.157), an );\r\n    col = brush( col, uv, vec4(0.557,0.580,0.125,60.235), an );\r\n    col = brush( col, uv, vec4(0.475,0.547,0.414,70.621), an );\r\n    col = brush( col, uv, vec4(0.843,0.680,0.793,20.277), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.758,56.889), an );\r\n    col = brush( col, uv, vec4(1.000,0.299,0.691,68.267), an );\r\n    col = brush( col, uv, vec4(0.737,0.518,0.100,68.267), an );\r\n    col = brush( col, uv, vec4(0.996,0.227,0.514,41.796), an );\r\n    col = brush( col, uv, vec4(0.929,0.850,0.770,62.061), an );\r\n    col = brush( col, uv, vec4(0.682,0.834,0.111,30.118), an );\r\n    col = brush( col, uv, vec4(0.996,0.854,0.793,58.514), an );\r\n    col = brush( col, uv, vec4(0.490,0.736,0.889,19.321), an );\r\n    col = brush( col, uv, vec4(0.980,0.465,0.725,16.126), an );\r\n    col = brush( col, uv, vec4(0.992,0.484,1.010,23.273), an );\r\n    col = brush( col, uv, vec4(0.008,0.949,0.727,23.540), an );\r\n    col = brush( col, uv, vec4(0.012,0.086,0.086,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.121,0.750,44.522), an );\r\n    col = brush( col, uv, vec4(0.427,0.617,0.891,27.676), an );\r\n    col = brush( col, uv, vec4(0.804,0.693,0.633,78.769), an );\r\n    col = brush( col, uv, vec4(0.012,0.711,0.084,13.745), an );\r\n    col = brush( col, uv, vec4(0.082,0.584,0.338,107.789), an );\r\n    col = brush( col, uv, vec4(0.929,0.613,0.268,19.692), an );\r\n    col = brush( col, uv, vec4(0.200,0.549,0.420,128.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.402,0.717,26.947), an );\r\n    col = brush( col, uv, vec4(0.000,0.551,0.168,45.511), an );\r\n    col = brush( col, uv, vec4(0.992,0.627,0.621,56.889), an );\r\n    col = brush( col, uv, vec4(0.902,0.361,0.748,40.960), an );\r\n    col = brush( col, uv, vec4(0.984,0.344,0.754,38.642), an );\r\n    col = brush( col, uv, vec4(0.902,0.203,0.818,51.200), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.803,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.738,0.691,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.385,0.797,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.725,0.305,62.061), an );\r\n    col = brush( col, uv, vec4(0.000,0.150,0.750,45.511), an );\r\n    col = brush( col, uv, vec4(1.000,0.742,0.408,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.645,0.643,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.438,35.310), an );\r\n    col = brush( col, uv, vec4(0.510,0.564,0.789,18.450), an );\r\n    col = brush( col, uv, vec4(0.863,0.211,0.781,30.567), an );\r\n    col = brush( col, uv, vec4(0.106,0.508,0.328,89.043), an );\r\n    col = brush( col, uv, vec4(0.012,0.410,0.875,14.629), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.877,48.762), an );\r\n    col = brush( col, uv, vec4(1.000,0.258,0.779,37.926), an );\r\n    col = brush( col, uv, vec4(0.000,0.436,0.807,28.845), an );\r\n    col = brush( col, uv, vec4(0.918,0.861,0.836,49.951), an );\r\n    col = brush( col, uv, vec4(1.000,0.291,0.770,40.960), an );\r\n    col = brush( col, uv, vec4(0.000,0.750,0.283,27.676), an );\r\n    col = brush( col, uv, vec4(0.965,0.596,0.572,28.055), an );\r\n    col = brush( col, uv, vec4(0.902,0.803,0.953,24.976), an );\r\n    col = brush( col, uv, vec4(0.957,0.498,0.600,16.126), an );\r\n    col = brush( col, uv, vec4(0.914,0.322,0.432,15.634), an );\r\n    col = brush( col, uv, vec4(0.008,0.025,0.621,17.809), an );\r\n    col = brush( col, uv, vec4(0.000,0.916,0.713,56.889), an );\r\n    col = brush( col, uv, vec4(0.914,0.547,0.971,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.207,0.432,37.926), an );\r\n    col = brush( col, uv, vec4(0.875,0.176,0.793,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.646,0.668,41.796), an );\r\n    col = brush( col, uv, vec4(1.000,0.721,0.691,51.200), an );\r\n    col = brush( col, uv, vec4(0.451,0.559,0.754,49.951), an );\r\n    col = brush( col, uv, vec4(0.969,0.846,0.750,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.146,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.613,0.635,85.333), an );\r\n    col = brush( col, uv, vec4(0.596,0.807,0.150,58.514), an );\r\n    col = brush( col, uv, vec4(0.898,0.330,0.760,40.157), an );\r\n    col = brush( col, uv, vec4(0.694,0.594,0.012,51.200), an );\r\n    col = brush( col, uv, vec4(0.698,0.592,0.055,53.895), an );\r\n    col = brush( col, uv, vec4(0.902,0.268,0.773,39.385), an );\r\n    col = brush( col, uv, vec4(0.925,0.838,0.660,58.514), an );\r\n    col = brush( col, uv, vec4(0.843,0.670,0.242,28.444), an );\r\n    col = brush( col, uv, vec4(0.243,0.465,0.285,85.333), an );\r\n    col = brush( col, uv, vec4(0.816,0.588,0.674,44.522), an );\r\n    col = brush( col, uv, vec4(0.008,0.283,0.115,8.031), an );\r\n    col = brush( col, uv, vec4(0.247,0.414,0.691,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.104,0.781,60.235), an );\r\n    col = brush( col, uv, vec4(0.000,0.619,0.660,60.235), an );\r\n    col = brush( col, uv, vec4(0.584,0.650,0.994,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.219,0.393,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.307,0.645,97.524), an );\r\n    col = brush( col, uv, vec4(0.953,0.639,0.771,38.642), an );\r\n    col = brush( col, uv, vec4(0.000,0.238,0.357,34.712), an );\r\n    col = brush( col, uv, vec4(0.922,0.713,0.352,53.895), an );\r\n    col = brush( col, uv, vec4(0.965,0.387,0.748,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.898,0.633,41.796), an );\r\n    col = brush( col, uv, vec4(0.941,0.352,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.933,0.439,0.725,30.567), an );\r\n    col = brush( col, uv, vec4(0.310,0.541,0.906,47.628), an );\r\n    col = brush( col, uv, vec4(0.941,0.502,0.689,24.094), an );\r\n    col = brush( col, uv, vec4(0.094,0.527,0.330,85.333), an );\r\n    col = brush( col, uv, vec4(0.000,0.090,0.688,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.652,0.713,75.852), an );\r\n    col = brush( col, uv, vec4(0.949,0.320,0.623,107.789), an );\r\n    col = brush( col, uv, vec4(0.890,0.775,0.750,22.505), an );\r\n    col = brush( col, uv, vec4(0.012,0.918,0.490,14.322), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.967,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.324,0.676,64.000), an );\r\n    col = brush( col, uv, vec4(0.008,0.141,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.633,0.707,75.852), an );\r\n    col = brush( col, uv, vec4(0.910,0.385,0.207,44.522), an );\r\n    col = brush( col, uv, vec4(0.012,0.703,0.182,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.617,0.703,73.143), an );\r\n    col = brush( col, uv, vec4(0.890,0.352,0.225,45.511), an );\r\n    col = brush( col, uv, vec4(0.933,0.826,0.604,44.522), an );\r\n    col = brush( col, uv, vec4(0.914,0.777,0.574,25.924), an );\r\n    col = brush( col, uv, vec4(0.631,0.781,0.182,68.267), an );\r\n    col = brush( col, uv, vec4(1.000,0.873,0.916,48.762), an );\r\n    col = brush( col, uv, vec4(0.694,0.520,0.113,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.926,58.514), an );\r\n    col = brush( col, uv, vec4(0.184,0.598,0.344,146.286), an );\r\n    col = brush( col, uv, vec4(0.863,0.678,0.250,35.310), an );\r\n    col = brush( col, uv, vec4(0.090,0.566,0.332,78.769), an );\r\n    col = brush( col, uv, vec4(0.420,0.445,0.301,56.889), an );\r\n    col = brush( col, uv, vec4(0.973,0.617,0.516,18.124), an );\r\n    col = brush( col, uv, vec4(0.000,0.191,0.500,39.385), an );\r\n    col = brush( col, uv, vec4(0.000,0.240,0.326,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.264,0.322,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.604,0.699,70.621), an );\r\n    col = brush( col, uv, vec4(0.000,0.113,0.604,43.574), an );\r\n    col = brush( col, uv, vec4(0.894,0.760,0.697,49.951), an );\r\n    col = brush( col, uv, vec4(0.914,0.725,0.383,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.199,0.467,48.762), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.660,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.611,0.191,45.511), an );\r\n    col = brush( col, uv, vec4(0.059,0.789,0.869,30.118), an );\r\n    col = brush( col, uv, vec4(0.976,0.641,0.213,40.960), an );\r\n    col = brush( col, uv, vec4(0.918,0.402,0.742,47.628), an );\r\n    col = brush( col, uv, vec4(0.945,0.717,0.582,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.299,0.672,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.719,0.666,48.762), an );\r\n    col = brush( col, uv, vec4(0.882,0.697,0.271,58.514), an );\r\n    col = brush( col, uv, vec4(0.929,0.752,0.436,64.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.867,0.813,56.889), an );\r\n    col = brush( col, uv, vec4(0.643,0.588,0.090,64.000), an );\r\n    col = brush( col, uv, vec4(0.012,0.063,0.922,10.952), an );\r\n    col = brush( col, uv, vec4(0.878,0.186,0.750,31.508), an );\r\n    col = brush( col, uv, vec4(0.953,0.648,0.613,120.471), an );\r\n    col = brush( col, uv, vec4(0.973,0.180,0.576,45.511), an );\r\n    col = brush( col, uv, vec4(0.741,0.943,0.076,52.513), an );\r\n    col = brush( col, uv, vec4(0.059,0.545,0.332,89.043), an );\r\n    col = brush( col, uv, vec4(0.094,0.295,0.734,85.333), an );\r\n    col = brush( col, uv, vec4(0.008,0.676,0.721,85.333), an );\r\n    col = brush( col, uv, vec4(0.550,0.350,0.650,85.000), an );\r\n\r\n\tfragColor = vec4(col,col,col,1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Image - Audrey","id":"62576e86697641c999341f0e36c0c26d","date":null,"viewed":0,"name":"Image - Audrey","description":"If you were entrusted to portray Audrey Hepburn (you've seen \"Breakfast at Tiffany's\") BUT asked to do it in no more than 316 brushstrokes you'd surely have to be very careful on your choice of strokes! (you'll only see 201 in the code thanks to symmetry)\nhttps://www.shadertoy.com/view/4df3D8","likes":0,"published":null,"tags":["2d"," compression"," genetic"," photo"," image"]},"ver":null,"info":{"Name":"Image - Audrey","id":"62576e86697641c999341f0e36c0c26d","date":null,"viewed":0,"name":"Image - Audrey","description":"If you were entrusted to portray Audrey Hepburn (you've seen \"Breakfast at Tiffany's\") BUT asked to do it in no more than 316 brushstrokes you'd surely have to be very careful on your choice of strokes! (you'll only see 201 in the code thanks to symmetry)\nhttps://www.shadertoy.com/view/4df3D8","likes":0,"published":null,"tags":["2d"," compression"," genetic"," photo"," image"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// These are 316 gaussian points (201 brushes by using local symmetry) forming the picture\r\n// of Audrey Hepburn. They pack down to 800 bytes (34 bits per point) before huffman/arithmetic\r\n// compression.\r\n//\r\n// The points were chosen by (very quickly) runing this \r\n//\r\n// http://www.iquilezles.org/www/articles/genetic/genetic.htm\r\n//\r\n// with some importance sampling for the eyes, nouse and mouth.\r\n\r\nfloat brush( float col, vec2 p, in vec4 b, float an )\r\n{\r\n\tp += an*cos( iTime + 100.0*b.yz );\r\n\t\t\t\t\r\n    vec2 dd = p - b.yz;\r\n    col = mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    if( abs(b.z-0.5)<0.251 )\r\n    {\r\n        dd.x = p.x - 1.0 + b.y;\r\n        col =  mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    }\r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.y;\r\n    uv.x -=  0.5*(iResolution.x / iResolution.y - 1.0);\r\n\r\n    float an = smoothstep( 0.0, 1.0, cos(iTime) );\r\n\r\n\tfloat col = 0.0;\r\n\r\n    col = brush( col, uv, vec4(1.000,0.371,0.379,11.770), an );\r\n    col = brush( col, uv, vec4(0.992,0.545,0.551,8.359), an );\r\n    col = brush( col, uv, vec4(0.749,0.623,0.990,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.510,0.395,11.315), an );\r\n    col = brush( col, uv, vec4(1.000,0.723,0.564,15.170), an );\r\n    col = brush( col, uv, vec4(0.953,0.729,0.750,14.629), an );\r\n    col = brush( col, uv, vec4(0.706,0.982,0.033,16.254), an );\r\n    col = brush( col, uv, vec4(1.000,0.855,0.652,26.256), an );\r\n    col = brush( col, uv, vec4(1.000,0.664,0.623,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.881,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.686,0.682,0.900,27.676), an );\r\n    col = brush( col, uv, vec4(1.000,0.189,0.684,18.618), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.422,0.195,44.522), an );\r\n    col = brush( col, uv, vec4(1.000,0.779,0.750,16.787), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.330,14.222), an );\r\n    col = brush( col, uv, vec4(1.000,0.197,0.648,22.505), an );\r\n    col = brush( col, uv, vec4(0.702,0.512,0.393,35.310), an );\r\n    col = brush( col, uv, vec4(1.000,0.744,0.621,14.949), an );\r\n    col = brush( col, uv, vec4(0.671,0.885,0.092,24.675), an );\r\n    col = brush( col, uv, vec4(0.000,0.344,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.760,0.465,40.960), an );\r\n    col = brush( col, uv, vec4(0.008,0.908,0.311,8.031), an );\r\n    col = brush( col, uv, vec4(0.016,0.959,0.750,10.039), an );\r\n    col = brush( col, uv, vec4(0.004,0.930,0.750,12.800), an );\r\n    col = brush( col, uv, vec4(1.000,0.555,0.250,19.883), an );\r\n    col = brush( col, uv, vec4(1.000,0.770,1.018,15.876), an );\r\n    col = brush( col, uv, vec4(0.000,0.828,0.756,36.571), an );\r\n    col = brush( col, uv, vec4(0.580,0.566,0.424,89.043), an );\r\n    col = brush( col, uv, vec4(0.988,0.162,0.691,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.314,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.947,0.125,32.000), an );\r\n    col = brush( col, uv, vec4(0.914,0.844,0.725,52.513), an );\r\n    col = brush( col, uv, vec4(1.000,0.313,0.762,42.667), an );\r\n    col = brush( col, uv, vec4(0.996,0.676,0.689,85.333), an );\r\n    col = brush( col, uv, vec4(0.980,0.346,0.559,24.675), an );\r\n    col = brush( col, uv, vec4(1.000,0.553,0.250,18.789), an );\r\n    col = brush( col, uv, vec4(0.004,0.258,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.420,0.742,30.567), an );\r\n    col = brush( col, uv, vec4(0.906,0.543,0.250,22.756), an );\r\n    col = brush( col, uv, vec4(0.863,0.674,0.322,20.078), an );\r\n    col = brush( col, uv, vec4(0.753,0.357,0.686,78.769), an );\r\n    col = brush( col, uv, vec4(0.906,0.795,0.705,37.236), an );\r\n    col = brush( col, uv, vec4(0.933,0.520,0.365,38.642), an );\r\n    col = brush( col, uv, vec4(0.996,0.318,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.337,0.486,0.281,81.920), an );\r\n    col = brush( col, uv, vec4(0.965,0.691,0.516,16.650), an );\r\n    col = brush( col, uv, vec4(0.808,0.582,0.973,52.513), an );\r\n    col = brush( col, uv, vec4(0.012,0.240,0.928,8.063), an );\r\n    col = brush( col, uv, vec4(1.000,0.496,0.217,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.658,0.953,34.133), an );\r\n    col = brush( col, uv, vec4(0.871,0.582,0.172,62.061), an );\r\n    col = brush( col, uv, vec4(0.855,0.346,0.342,17.504), an );\r\n    col = brush( col, uv, vec4(0.878,0.787,0.648,28.845), an );\r\n    col = brush( col, uv, vec4(0.000,0.984,0.111,35.310), an );\r\n    col = brush( col, uv, vec4(0.855,0.514,0.965,66.065), an );\r\n    col = brush( col, uv, vec4(0.561,0.613,0.350,81.920), an );\r\n    col = brush( col, uv, vec4(0.992,0.818,0.902,21.558), an );\r\n    col = brush( col, uv, vec4(0.914,0.746,0.615,40.157), an );\r\n    col = brush( col, uv, vec4(0.557,0.580,0.125,60.235), an );\r\n    col = brush( col, uv, vec4(0.475,0.547,0.414,70.621), an );\r\n    col = brush( col, uv, vec4(0.843,0.680,0.793,20.277), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.758,56.889), an );\r\n    col = brush( col, uv, vec4(1.000,0.299,0.691,68.267), an );\r\n    col = brush( col, uv, vec4(0.737,0.518,0.100,68.267), an );\r\n    col = brush( col, uv, vec4(0.996,0.227,0.514,41.796), an );\r\n    col = brush( col, uv, vec4(0.929,0.850,0.770,62.061), an );\r\n    col = brush( col, uv, vec4(0.682,0.834,0.111,30.118), an );\r\n    col = brush( col, uv, vec4(0.996,0.854,0.793,58.514), an );\r\n    col = brush( col, uv, vec4(0.490,0.736,0.889,19.321), an );\r\n    col = brush( col, uv, vec4(0.980,0.465,0.725,16.126), an );\r\n    col = brush( col, uv, vec4(0.992,0.484,1.010,23.273), an );\r\n    col = brush( col, uv, vec4(0.008,0.949,0.727,23.540), an );\r\n    col = brush( col, uv, vec4(0.012,0.086,0.086,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.121,0.750,44.522), an );\r\n    col = brush( col, uv, vec4(0.427,0.617,0.891,27.676), an );\r\n    col = brush( col, uv, vec4(0.804,0.693,0.633,78.769), an );\r\n    col = brush( col, uv, vec4(0.012,0.711,0.084,13.745), an );\r\n    col = brush( col, uv, vec4(0.082,0.584,0.338,107.789), an );\r\n    col = brush( col, uv, vec4(0.929,0.613,0.268,19.692), an );\r\n    col = brush( col, uv, vec4(0.200,0.549,0.420,128.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.402,0.717,26.947), an );\r\n    col = brush( col, uv, vec4(0.000,0.551,0.168,45.511), an );\r\n    col = brush( col, uv, vec4(0.992,0.627,0.621,56.889), an );\r\n    col = brush( col, uv, vec4(0.902,0.361,0.748,40.960), an );\r\n    col = brush( col, uv, vec4(0.984,0.344,0.754,38.642), an );\r\n    col = brush( col, uv, vec4(0.902,0.203,0.818,51.200), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.803,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.738,0.691,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.385,0.797,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.725,0.305,62.061), an );\r\n    col = brush( col, uv, vec4(0.000,0.150,0.750,45.511), an );\r\n    col = brush( col, uv, vec4(1.000,0.742,0.408,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.645,0.643,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.438,35.310), an );\r\n    col = brush( col, uv, vec4(0.510,0.564,0.789,18.450), an );\r\n    col = brush( col, uv, vec4(0.863,0.211,0.781,30.567), an );\r\n    col = brush( col, uv, vec4(0.106,0.508,0.328,89.043), an );\r\n    col = brush( col, uv, vec4(0.012,0.410,0.875,14.629), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.877,48.762), an );\r\n    col = brush( col, uv, vec4(1.000,0.258,0.779,37.926), an );\r\n    col = brush( col, uv, vec4(0.000,0.436,0.807,28.845), an );\r\n    col = brush( col, uv, vec4(0.918,0.861,0.836,49.951), an );\r\n    col = brush( col, uv, vec4(1.000,0.291,0.770,40.960), an );\r\n    col = brush( col, uv, vec4(0.000,0.750,0.283,27.676), an );\r\n    col = brush( col, uv, vec4(0.965,0.596,0.572,28.055), an );\r\n    col = brush( col, uv, vec4(0.902,0.803,0.953,24.976), an );\r\n    col = brush( col, uv, vec4(0.957,0.498,0.600,16.126), an );\r\n    col = brush( col, uv, vec4(0.914,0.322,0.432,15.634), an );\r\n    col = brush( col, uv, vec4(0.008,0.025,0.621,17.809), an );\r\n    col = brush( col, uv, vec4(0.000,0.916,0.713,56.889), an );\r\n    col = brush( col, uv, vec4(0.914,0.547,0.971,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.207,0.432,37.926), an );\r\n    col = brush( col, uv, vec4(0.875,0.176,0.793,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.646,0.668,41.796), an );\r\n    col = brush( col, uv, vec4(1.000,0.721,0.691,51.200), an );\r\n    col = brush( col, uv, vec4(0.451,0.559,0.754,49.951), an );\r\n    col = brush( col, uv, vec4(0.969,0.846,0.750,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.146,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.613,0.635,85.333), an );\r\n    col = brush( col, uv, vec4(0.596,0.807,0.150,58.514), an );\r\n    col = brush( col, uv, vec4(0.898,0.330,0.760,40.157), an );\r\n    col = brush( col, uv, vec4(0.694,0.594,0.012,51.200), an );\r\n    col = brush( col, uv, vec4(0.698,0.592,0.055,53.895), an );\r\n    col = brush( col, uv, vec4(0.902,0.268,0.773,39.385), an );\r\n    col = brush( col, uv, vec4(0.925,0.838,0.660,58.514), an );\r\n    col = brush( col, uv, vec4(0.843,0.670,0.242,28.444), an );\r\n    col = brush( col, uv, vec4(0.243,0.465,0.285,85.333), an );\r\n    col = brush( col, uv, vec4(0.816,0.588,0.674,44.522), an );\r\n    col = brush( col, uv, vec4(0.008,0.283,0.115,8.031), an );\r\n    col = brush( col, uv, vec4(0.247,0.414,0.691,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.104,0.781,60.235), an );\r\n    col = brush( col, uv, vec4(0.000,0.619,0.660,60.235), an );\r\n    col = brush( col, uv, vec4(0.584,0.650,0.994,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.219,0.393,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.307,0.645,97.524), an );\r\n    col = brush( col, uv, vec4(0.953,0.639,0.771,38.642), an );\r\n    col = brush( col, uv, vec4(0.000,0.238,0.357,34.712), an );\r\n    col = brush( col, uv, vec4(0.922,0.713,0.352,53.895), an );\r\n    col = brush( col, uv, vec4(0.965,0.387,0.748,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.898,0.633,41.796), an );\r\n    col = brush( col, uv, vec4(0.941,0.352,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.933,0.439,0.725,30.567), an );\r\n    col = brush( col, uv, vec4(0.310,0.541,0.906,47.628), an );\r\n    col = brush( col, uv, vec4(0.941,0.502,0.689,24.094), an );\r\n    col = brush( col, uv, vec4(0.094,0.527,0.330,85.333), an );\r\n    col = brush( col, uv, vec4(0.000,0.090,0.688,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.652,0.713,75.852), an );\r\n    col = brush( col, uv, vec4(0.949,0.320,0.623,107.789), an );\r\n    col = brush( col, uv, vec4(0.890,0.775,0.750,22.505), an );\r\n    col = brush( col, uv, vec4(0.012,0.918,0.490,14.322), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.967,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.324,0.676,64.000), an );\r\n    col = brush( col, uv, vec4(0.008,0.141,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.633,0.707,75.852), an );\r\n    col = brush( col, uv, vec4(0.910,0.385,0.207,44.522), an );\r\n    col = brush( col, uv, vec4(0.012,0.703,0.182,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.617,0.703,73.143), an );\r\n    col = brush( col, uv, vec4(0.890,0.352,0.225,45.511), an );\r\n    col = brush( col, uv, vec4(0.933,0.826,0.604,44.522), an );\r\n    col = brush( col, uv, vec4(0.914,0.777,0.574,25.924), an );\r\n    col = brush( col, uv, vec4(0.631,0.781,0.182,68.267), an );\r\n    col = brush( col, uv, vec4(1.000,0.873,0.916,48.762), an );\r\n    col = brush( col, uv, vec4(0.694,0.520,0.113,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.926,58.514), an );\r\n    col = brush( col, uv, vec4(0.184,0.598,0.344,146.286), an );\r\n    col = brush( col, uv, vec4(0.863,0.678,0.250,35.310), an );\r\n    col = brush( col, uv, vec4(0.090,0.566,0.332,78.769), an );\r\n    col = brush( col, uv, vec4(0.420,0.445,0.301,56.889), an );\r\n    col = brush( col, uv, vec4(0.973,0.617,0.516,18.124), an );\r\n    col = brush( col, uv, vec4(0.000,0.191,0.500,39.385), an );\r\n    col = brush( col, uv, vec4(0.000,0.240,0.326,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.264,0.322,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.604,0.699,70.621), an );\r\n    col = brush( col, uv, vec4(0.000,0.113,0.604,43.574), an );\r\n    col = brush( col, uv, vec4(0.894,0.760,0.697,49.951), an );\r\n    col = brush( col, uv, vec4(0.914,0.725,0.383,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.199,0.467,48.762), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.660,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.611,0.191,45.511), an );\r\n    col = brush( col, uv, vec4(0.059,0.789,0.869,30.118), an );\r\n    col = brush( col, uv, vec4(0.976,0.641,0.213,40.960), an );\r\n    col = brush( col, uv, vec4(0.918,0.402,0.742,47.628), an );\r\n    col = brush( col, uv, vec4(0.945,0.717,0.582,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.299,0.672,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.719,0.666,48.762), an );\r\n    col = brush( col, uv, vec4(0.882,0.697,0.271,58.514), an );\r\n    col = brush( col, uv, vec4(0.929,0.752,0.436,64.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.867,0.813,56.889), an );\r\n    col = brush( col, uv, vec4(0.643,0.588,0.090,64.000), an );\r\n    col = brush( col, uv, vec4(0.012,0.063,0.922,10.952), an );\r\n    col = brush( col, uv, vec4(0.878,0.186,0.750,31.508), an );\r\n    col = brush( col, uv, vec4(0.953,0.648,0.613,120.471), an );\r\n    col = brush( col, uv, vec4(0.973,0.180,0.576,45.511), an );\r\n    col = brush( col, uv, vec4(0.741,0.943,0.076,52.513), an );\r\n    col = brush( col, uv, vec4(0.059,0.545,0.332,89.043), an );\r\n    col = brush( col, uv, vec4(0.094,0.295,0.734,85.333), an );\r\n    col = brush( col, uv, vec4(0.008,0.676,0.721,85.333), an );\r\n    col = brush( col, uv, vec4(0.550,0.350,0.650,85.000), an );\r\n\r\n\tfragColor = vec4(col,col,col,1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// These are 316 gaussian points (201 brushes by using local symmetry) forming the picture\r\n// of Audrey Hepburn. They pack down to 800 bytes (34 bits per point) before huffman/arithmetic\r\n// compression.\r\n//\r\n// The points were chosen by (very quickly) runing this \r\n//\r\n// http://www.iquilezles.org/www/articles/genetic/genetic.htm\r\n//\r\n// with some importance sampling for the eyes, nouse and mouth.\r\n\r\nfloat brush( float col, vec2 p, in vec4 b, float an )\r\n{\r\n\tp += an*cos( iTime + 100.0*b.yz );\r\n\t\t\t\t\r\n    vec2 dd = p - b.yz;\r\n    col = mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    if( abs(b.z-0.5)<0.251 )\r\n    {\r\n        dd.x = p.x - 1.0 + b.y;\r\n        col =  mix( col, b.x, exp( -b.w*b.w*dot(dd,dd) ) );\r\n    }\r\n    return col;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.y;\r\n    uv.x -=  0.5*(iResolution.x / iResolution.y - 1.0);\r\n\r\n    float an = smoothstep( 0.0, 1.0, cos(iTime) );\r\n\r\n\tfloat col = 0.0;\r\n\r\n    col = brush( col, uv, vec4(1.000,0.371,0.379,11.770), an );\r\n    col = brush( col, uv, vec4(0.992,0.545,0.551,8.359), an );\r\n    col = brush( col, uv, vec4(0.749,0.623,0.990,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.510,0.395,11.315), an );\r\n    col = brush( col, uv, vec4(1.000,0.723,0.564,15.170), an );\r\n    col = brush( col, uv, vec4(0.953,0.729,0.750,14.629), an );\r\n    col = brush( col, uv, vec4(0.706,0.982,0.033,16.254), an );\r\n    col = brush( col, uv, vec4(1.000,0.855,0.652,26.256), an );\r\n    col = brush( col, uv, vec4(1.000,0.664,0.623,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.881,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.686,0.682,0.900,27.676), an );\r\n    col = brush( col, uv, vec4(1.000,0.189,0.684,18.618), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.422,0.195,44.522), an );\r\n    col = brush( col, uv, vec4(1.000,0.779,0.750,16.787), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.330,14.222), an );\r\n    col = brush( col, uv, vec4(1.000,0.197,0.648,22.505), an );\r\n    col = brush( col, uv, vec4(0.702,0.512,0.393,35.310), an );\r\n    col = brush( col, uv, vec4(1.000,0.744,0.621,14.949), an );\r\n    col = brush( col, uv, vec4(0.671,0.885,0.092,24.675), an );\r\n    col = brush( col, uv, vec4(0.000,0.344,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.760,0.465,40.960), an );\r\n    col = brush( col, uv, vec4(0.008,0.908,0.311,8.031), an );\r\n    col = brush( col, uv, vec4(0.016,0.959,0.750,10.039), an );\r\n    col = brush( col, uv, vec4(0.004,0.930,0.750,12.800), an );\r\n    col = brush( col, uv, vec4(1.000,0.555,0.250,19.883), an );\r\n    col = brush( col, uv, vec4(1.000,0.770,1.018,15.876), an );\r\n    col = brush( col, uv, vec4(0.000,0.828,0.756,36.571), an );\r\n    col = brush( col, uv, vec4(0.580,0.566,0.424,89.043), an );\r\n    col = brush( col, uv, vec4(0.988,0.162,0.691,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.314,0.750,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.947,0.125,32.000), an );\r\n    col = brush( col, uv, vec4(0.914,0.844,0.725,52.513), an );\r\n    col = brush( col, uv, vec4(1.000,0.313,0.762,42.667), an );\r\n    col = brush( col, uv, vec4(0.996,0.676,0.689,85.333), an );\r\n    col = brush( col, uv, vec4(0.980,0.346,0.559,24.675), an );\r\n    col = brush( col, uv, vec4(1.000,0.553,0.250,18.789), an );\r\n    col = brush( col, uv, vec4(0.004,0.258,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.420,0.742,30.567), an );\r\n    col = brush( col, uv, vec4(0.906,0.543,0.250,22.756), an );\r\n    col = brush( col, uv, vec4(0.863,0.674,0.322,20.078), an );\r\n    col = brush( col, uv, vec4(0.753,0.357,0.686,78.769), an );\r\n    col = brush( col, uv, vec4(0.906,0.795,0.705,37.236), an );\r\n    col = brush( col, uv, vec4(0.933,0.520,0.365,38.642), an );\r\n    col = brush( col, uv, vec4(0.996,0.318,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.337,0.486,0.281,81.920), an );\r\n    col = brush( col, uv, vec4(0.965,0.691,0.516,16.650), an );\r\n    col = brush( col, uv, vec4(0.808,0.582,0.973,52.513), an );\r\n    col = brush( col, uv, vec4(0.012,0.240,0.928,8.063), an );\r\n    col = brush( col, uv, vec4(1.000,0.496,0.217,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.658,0.953,34.133), an );\r\n    col = brush( col, uv, vec4(0.871,0.582,0.172,62.061), an );\r\n    col = brush( col, uv, vec4(0.855,0.346,0.342,17.504), an );\r\n    col = brush( col, uv, vec4(0.878,0.787,0.648,28.845), an );\r\n    col = brush( col, uv, vec4(0.000,0.984,0.111,35.310), an );\r\n    col = brush( col, uv, vec4(0.855,0.514,0.965,66.065), an );\r\n    col = brush( col, uv, vec4(0.561,0.613,0.350,81.920), an );\r\n    col = brush( col, uv, vec4(0.992,0.818,0.902,21.558), an );\r\n    col = brush( col, uv, vec4(0.914,0.746,0.615,40.157), an );\r\n    col = brush( col, uv, vec4(0.557,0.580,0.125,60.235), an );\r\n    col = brush( col, uv, vec4(0.475,0.547,0.414,70.621), an );\r\n    col = brush( col, uv, vec4(0.843,0.680,0.793,20.277), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.758,56.889), an );\r\n    col = brush( col, uv, vec4(1.000,0.299,0.691,68.267), an );\r\n    col = brush( col, uv, vec4(0.737,0.518,0.100,68.267), an );\r\n    col = brush( col, uv, vec4(0.996,0.227,0.514,41.796), an );\r\n    col = brush( col, uv, vec4(0.929,0.850,0.770,62.061), an );\r\n    col = brush( col, uv, vec4(0.682,0.834,0.111,30.118), an );\r\n    col = brush( col, uv, vec4(0.996,0.854,0.793,58.514), an );\r\n    col = brush( col, uv, vec4(0.490,0.736,0.889,19.321), an );\r\n    col = brush( col, uv, vec4(0.980,0.465,0.725,16.126), an );\r\n    col = brush( col, uv, vec4(0.992,0.484,1.010,23.273), an );\r\n    col = brush( col, uv, vec4(0.008,0.949,0.727,23.540), an );\r\n    col = brush( col, uv, vec4(0.012,0.086,0.086,8.031), an );\r\n    col = brush( col, uv, vec4(1.000,0.121,0.750,44.522), an );\r\n    col = brush( col, uv, vec4(0.427,0.617,0.891,27.676), an );\r\n    col = brush( col, uv, vec4(0.804,0.693,0.633,78.769), an );\r\n    col = brush( col, uv, vec4(0.012,0.711,0.084,13.745), an );\r\n    col = brush( col, uv, vec4(0.082,0.584,0.338,107.789), an );\r\n    col = brush( col, uv, vec4(0.929,0.613,0.268,19.692), an );\r\n    col = brush( col, uv, vec4(0.200,0.549,0.420,128.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.402,0.717,26.947), an );\r\n    col = brush( col, uv, vec4(0.000,0.551,0.168,45.511), an );\r\n    col = brush( col, uv, vec4(0.992,0.627,0.621,56.889), an );\r\n    col = brush( col, uv, vec4(0.902,0.361,0.748,40.960), an );\r\n    col = brush( col, uv, vec4(0.984,0.344,0.754,38.642), an );\r\n    col = brush( col, uv, vec4(0.902,0.203,0.818,51.200), an );\r\n    col = brush( col, uv, vec4(1.000,0.230,0.803,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.738,0.691,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.385,0.797,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.725,0.305,62.061), an );\r\n    col = brush( col, uv, vec4(0.000,0.150,0.750,45.511), an );\r\n    col = brush( col, uv, vec4(1.000,0.742,0.408,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.645,0.643,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.645,0.438,35.310), an );\r\n    col = brush( col, uv, vec4(0.510,0.564,0.789,18.450), an );\r\n    col = brush( col, uv, vec4(0.863,0.211,0.781,30.567), an );\r\n    col = brush( col, uv, vec4(0.106,0.508,0.328,89.043), an );\r\n    col = brush( col, uv, vec4(0.012,0.410,0.875,14.629), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.877,48.762), an );\r\n    col = brush( col, uv, vec4(1.000,0.258,0.779,37.926), an );\r\n    col = brush( col, uv, vec4(0.000,0.436,0.807,28.845), an );\r\n    col = brush( col, uv, vec4(0.918,0.861,0.836,49.951), an );\r\n    col = brush( col, uv, vec4(1.000,0.291,0.770,40.960), an );\r\n    col = brush( col, uv, vec4(0.000,0.750,0.283,27.676), an );\r\n    col = brush( col, uv, vec4(0.965,0.596,0.572,28.055), an );\r\n    col = brush( col, uv, vec4(0.902,0.803,0.953,24.976), an );\r\n    col = brush( col, uv, vec4(0.957,0.498,0.600,16.126), an );\r\n    col = brush( col, uv, vec4(0.914,0.322,0.432,15.634), an );\r\n    col = brush( col, uv, vec4(0.008,0.025,0.621,17.809), an );\r\n    col = brush( col, uv, vec4(0.000,0.916,0.713,56.889), an );\r\n    col = brush( col, uv, vec4(0.914,0.547,0.971,47.628), an );\r\n    col = brush( col, uv, vec4(0.000,0.207,0.432,37.926), an );\r\n    col = brush( col, uv, vec4(0.875,0.176,0.793,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.646,0.668,41.796), an );\r\n    col = brush( col, uv, vec4(1.000,0.721,0.691,51.200), an );\r\n    col = brush( col, uv, vec4(0.451,0.559,0.754,49.951), an );\r\n    col = brush( col, uv, vec4(0.969,0.846,0.750,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.146,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.613,0.635,85.333), an );\r\n    col = brush( col, uv, vec4(0.596,0.807,0.150,58.514), an );\r\n    col = brush( col, uv, vec4(0.898,0.330,0.760,40.157), an );\r\n    col = brush( col, uv, vec4(0.694,0.594,0.012,51.200), an );\r\n    col = brush( col, uv, vec4(0.698,0.592,0.055,53.895), an );\r\n    col = brush( col, uv, vec4(0.902,0.268,0.773,39.385), an );\r\n    col = brush( col, uv, vec4(0.925,0.838,0.660,58.514), an );\r\n    col = brush( col, uv, vec4(0.843,0.670,0.242,28.444), an );\r\n    col = brush( col, uv, vec4(0.243,0.465,0.285,85.333), an );\r\n    col = brush( col, uv, vec4(0.816,0.588,0.674,44.522), an );\r\n    col = brush( col, uv, vec4(0.008,0.283,0.115,8.031), an );\r\n    col = brush( col, uv, vec4(0.247,0.414,0.691,60.235), an );\r\n    col = brush( col, uv, vec4(1.000,0.104,0.781,60.235), an );\r\n    col = brush( col, uv, vec4(0.000,0.619,0.660,60.235), an );\r\n    col = brush( col, uv, vec4(0.584,0.650,0.994,46.545), an );\r\n    col = brush( col, uv, vec4(0.000,0.219,0.393,36.571), an );\r\n    col = brush( col, uv, vec4(1.000,0.307,0.645,97.524), an );\r\n    col = brush( col, uv, vec4(0.953,0.639,0.771,38.642), an );\r\n    col = brush( col, uv, vec4(0.000,0.238,0.357,34.712), an );\r\n    col = brush( col, uv, vec4(0.922,0.713,0.352,53.895), an );\r\n    col = brush( col, uv, vec4(0.965,0.387,0.748,43.574), an );\r\n    col = brush( col, uv, vec4(0.000,0.898,0.633,41.796), an );\r\n    col = brush( col, uv, vec4(0.941,0.352,0.488,14.734), an );\r\n    col = brush( col, uv, vec4(0.933,0.439,0.725,30.567), an );\r\n    col = brush( col, uv, vec4(0.310,0.541,0.906,47.628), an );\r\n    col = brush( col, uv, vec4(0.941,0.502,0.689,24.094), an );\r\n    col = brush( col, uv, vec4(0.094,0.527,0.330,85.333), an );\r\n    col = brush( col, uv, vec4(0.000,0.090,0.688,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.652,0.713,75.852), an );\r\n    col = brush( col, uv, vec4(0.949,0.320,0.623,107.789), an );\r\n    col = brush( col, uv, vec4(0.890,0.775,0.750,22.505), an );\r\n    col = brush( col, uv, vec4(0.012,0.918,0.490,14.322), an );\r\n    col = brush( col, uv, vec4(1.000,0.871,0.967,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.324,0.676,64.000), an );\r\n    col = brush( col, uv, vec4(0.008,0.141,0.248,8.031), an );\r\n    col = brush( col, uv, vec4(0.000,0.633,0.707,75.852), an );\r\n    col = brush( col, uv, vec4(0.910,0.385,0.207,44.522), an );\r\n    col = brush( col, uv, vec4(0.012,0.703,0.182,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.617,0.703,73.143), an );\r\n    col = brush( col, uv, vec4(0.890,0.352,0.225,45.511), an );\r\n    col = brush( col, uv, vec4(0.933,0.826,0.604,44.522), an );\r\n    col = brush( col, uv, vec4(0.914,0.777,0.574,25.924), an );\r\n    col = brush( col, uv, vec4(0.631,0.781,0.182,68.267), an );\r\n    col = brush( col, uv, vec4(1.000,0.873,0.916,48.762), an );\r\n    col = brush( col, uv, vec4(0.694,0.520,0.113,81.920), an );\r\n    col = brush( col, uv, vec4(0.000,0.900,0.926,58.514), an );\r\n    col = brush( col, uv, vec4(0.184,0.598,0.344,146.286), an );\r\n    col = brush( col, uv, vec4(0.863,0.678,0.250,35.310), an );\r\n    col = brush( col, uv, vec4(0.090,0.566,0.332,78.769), an );\r\n    col = brush( col, uv, vec4(0.420,0.445,0.301,56.889), an );\r\n    col = brush( col, uv, vec4(0.973,0.617,0.516,18.124), an );\r\n    col = brush( col, uv, vec4(0.000,0.191,0.500,39.385), an );\r\n    col = brush( col, uv, vec4(0.000,0.240,0.326,31.508), an );\r\n    col = brush( col, uv, vec4(0.000,0.264,0.322,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.604,0.699,70.621), an );\r\n    col = brush( col, uv, vec4(0.000,0.113,0.604,43.574), an );\r\n    col = brush( col, uv, vec4(0.894,0.760,0.697,49.951), an );\r\n    col = brush( col, uv, vec4(0.914,0.725,0.383,55.351), an );\r\n    col = brush( col, uv, vec4(0.000,0.199,0.467,48.762), an );\r\n    col = brush( col, uv, vec4(0.000,0.904,0.660,52.513), an );\r\n    col = brush( col, uv, vec4(0.922,0.611,0.191,45.511), an );\r\n    col = brush( col, uv, vec4(0.059,0.789,0.869,30.118), an );\r\n    col = brush( col, uv, vec4(0.976,0.641,0.213,40.960), an );\r\n    col = brush( col, uv, vec4(0.918,0.402,0.742,47.628), an );\r\n    col = brush( col, uv, vec4(0.945,0.717,0.582,40.157), an );\r\n    col = brush( col, uv, vec4(0.000,0.299,0.672,58.514), an );\r\n    col = brush( col, uv, vec4(0.000,0.719,0.666,48.762), an );\r\n    col = brush( col, uv, vec4(0.882,0.697,0.271,58.514), an );\r\n    col = brush( col, uv, vec4(0.929,0.752,0.436,64.000), an );\r\n    col = brush( col, uv, vec4(1.000,0.867,0.813,56.889), an );\r\n    col = brush( col, uv, vec4(0.643,0.588,0.090,64.000), an );\r\n    col = brush( col, uv, vec4(0.012,0.063,0.922,10.952), an );\r\n    col = brush( col, uv, vec4(0.878,0.186,0.750,31.508), an );\r\n    col = brush( col, uv, vec4(0.953,0.648,0.613,120.471), an );\r\n    col = brush( col, uv, vec4(0.973,0.180,0.576,45.511), an );\r\n    col = brush( col, uv, vec4(0.741,0.943,0.076,52.513), an );\r\n    col = brush( col, uv, vec4(0.059,0.545,0.332,89.043), an );\r\n    col = brush( col, uv, vec4(0.094,0.295,0.734,85.333), an );\r\n    col = brush( col, uv, vec4(0.008,0.676,0.721,85.333), an );\r\n    col = brush( col, uv, vec4(0.550,0.350,0.650,85.000), an );\r\n\r\n\tfragColor = vec4(col,col,col,1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Input - Time","id":"af7d383d414741edb4159353bc76c6ab","date":null,"viewed":0,"name":"Input - Time","description":"Simple realtime, real time, watch. The background changes with the time of day - dark grey at night, and blue during the day \nhttps://www.shadertoy.com/view/lsXGz8","likes":0,"published":null,"tags":["2d"," time"," clock"," watch"]},"ver":null,"info":{"Name":"Input - Time","id":"af7d383d414741edb4159353bc76c6ab","date":null,"viewed":0,"name":"Input - Time","description":"Simple realtime, real time, watch. The background changes with the time of day - dark grey at night, and blue during the day \nhttps://www.shadertoy.com/view/lsXGz8","likes":0,"published":null,"tags":["2d"," time"," clock"," watch"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n\r\n// See also:\r\n//\r\n// Input - Keyboard    : https://www.shadertoy.com/view/lsXGzf\r\n// Input - Microphone  : https://www.shadertoy.com/view/llSGDh\r\n// Input - Mouse       : https://www.shadertoy.com/view/Mss3zH\r\n// Input - Sound       : https://www.shadertoy.com/view/Xds3Rr\r\n// Input - SoundCloud  : https://www.shadertoy.com/view/MsdGzn\r\n// Input - Time        : https://www.shadertoy.com/view/lsXGz8\r\n// Input - TimeDelta   : https://www.shadertoy.com/view/lsKGWV\r\n// Inout - 3D Texture  : https://www.shadertoy.com/view/4llcR4\r\n\r\n\r\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\r\n{\r\n   float f = sdLine( p, a, b );\r\n   float g = fwidth(f)*w.y;\r\n   return mix( buf, col.xyz, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\r\n}\r\n\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // get time\r\n    float mils = fract(iDate.w);\r\n\tfloat secs = mod( floor(iDate.w),        60.0 );\r\n\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\r\n\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 );\r\n    \r\n    // enable this for subsecond resolution\r\n    //secs += mils;\r\n\r\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\r\n\r\n\tfloat r = length( uv );\r\n\tfloat a = atan( uv.y, uv.x )+3.1415926;\r\n    \r\n\t// background color\r\n\tvec3 nightColor = vec3( 0.2, 0.2, 0.2 ) + 0.1*uv.y;\r\n\tvec3 dayColor   = vec3( 0.5, 0.6, 0.7 ) + 0.2*uv.y;\r\n\tvec3 col = mix( nightColor, dayColor, smoothstep( 5.0, 7.0, hors ) - \r\n\t\t\t\t                          smoothstep(19.0,21.0, hors ) );\r\n\r\n    // inner watch body\t\r\n\tcol = mix( col, vec3(0.9-0.4*pow(r,4.0)), 1.0-smoothstep(0.94,0.95,r) );\r\n\r\n    // 5 minute marks\t\r\n\tfloat f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\r\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\r\n\tfloat w = fwidth(f);\r\n\tf = 1.0 - smoothstep( 0.1*g+0.05-w, 0.1*g+0.05+w, f );\r\n\tf *= smoothstep( 0.85, 0.86, r+0.05*g ) - smoothstep( 0.94, 0.95, r );\r\n\tcol = mix( col, vec3(0.0), f );\r\n\r\n\t// seconds hand\r\n\tvec2 dir;\r\n\tdir = vec2( sin(6.2831*secs/60.0), cos(6.2831*secs/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.9, uv+0.05, vec2(0.005,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.0, uv+0.05, vec2(0.055,4.0), vec4(0.0,0.0,0.0,0.2) ); \r\n    col = line( col, vec2(0.0), dir*0.9, uv,      vec2(0.005,1.0), vec4(0.5,0.0,0.0,1.0) );\r\n\r\n\t// minutes hand\r\n\tdir = vec2( sin(6.2831*mins/60.0), cos(6.2831*mins/60.0) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.7, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // hours hand\r\n\tdir = vec2( sin(6.2831*hors/12.0), cos(6.2831*hors/12.0) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv+0.05, vec2(0.015,4.0), vec4(0.0,0.0,0.0,0.2) );\r\n    col = line( col, vec2(0.0), dir*0.4, uv,      vec2(0.015,1.0), vec4(0.0,0.0,0.0,1.0) );\r\n\r\n    // center mini circle\t\r\n\tcol = mix( col, vec3(0.5), 1.0-smoothstep(0.050,0.055,r) );\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.005,0.01,abs(r-0.055)) );\r\n\r\n    // border of watch\r\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.02,abs(r-0.95)) );\r\n\r\n    // dithering    \r\n    col += (1.0/255.0)*hash3(uv.x+13.0*uv.y);\r\n\r\n\tfragColor = vec4( col,1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","inputs":[],"outputs":[],"code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Jupiter","id":"f42bd54a7b094bdfa426589faab377d5","date":null,"viewed":0,"name":"Jupiter","description":"Jupiter UV effect WIP\r\nTry increasing iteration, and enabling fullscreen to see less aliasing artifact. \r\n\r\nBased on --> https://www.shadertoy.com/view/ltc3Rj\r\nBlog post --> http://viclw17.github.io/2018/06/12/GLSL-Practice-With-Shadertoy/\r\nhttps://www.shadertoy.com/view/MdyfWw","likes":0,"published":null,"tags":["2d"," uv"]},"ver":null,"info":{"Name":"Jupiter","id":"f42bd54a7b094bdfa426589faab377d5","date":null,"viewed":0,"name":"Jupiter","description":"Jupiter UV effect WIP\r\nTry increasing iteration, and enabling fullscreen to see less aliasing artifact. \r\n\r\nBased on --> https://www.shadertoy.com/view/ltc3Rj\r\nBlog post --> http://viclw17.github.io/2018/06/12/GLSL-Practice-With-Shadertoy/\r\nhttps://www.shadertoy.com/view/MdyfWw","likes":0,"published":null,"tags":["2d"," uv"]},"renderpass":[{"Code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","inputs":[],"outputs":[],"code":"float iteration = 10.;\r\nfloat timeScale = 3.;\r\nvec2 zoom = vec2(25.,5.5);\r\nvec2 offset = vec2(0,2.);\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nvec2 scene( in vec3 pos )//reception d'une sphere\r\n{\r\n    vec3 dim = vec3(1, 1, 1);\r\n    \r\n    pos += vec3(0, 0., 0);\r\n    \r\n    float resSphere = sdSphere(pos, 1.3);\r\n    \r\n   \r\n    vec2 res = vec2(resSphere, 2.);\r\n    \r\n    \r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n    vec3 nor = vec3(\r\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\r\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\r\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\r\n    return normalize(nor);\r\n}\r\n\r\nvec2 getUV(vec3 pos)\r\n{\r\n    vec3 nor = calcNormal(pos);\r\n    float lon = atan(nor.x,nor.z)/3.14;\r\n    float lat = acos(nor.y)/3.14;\r\n    vec2 r = vec2(lat, lon);\r\n    \r\n    return r;\r\n}\r\n\r\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\r\n{\r\n    float dMin = 1.;\r\n    float dMax = 50.;\r\n    float precis = 0.002;\r\n    float traveledDistance = dMin;\r\n    float color = -1.;\r\n    \r\n    for( int i = 0 ; i < 50 ; i++ )\r\n    {\r\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\r\n        \r\n        if( res.x<precis || traveledDistance>dMax )\r\n        {\r\n            break;\r\n        }\r\n        \r\n        traveledDistance += res.x;\r\n        color = res.y;\r\n    }\r\n    \r\n    if( traveledDistance > dMax )\r\n    {\r\n        color = -1.0;\r\n    }\r\n    return vec2( traveledDistance, color );\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n    vec3 cw = normalize(ta-ro);//z (dir)\r\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\r\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\r\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalis\u00C3\u00A9)\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\n/*\r\nfloat makeCheker(vec2 p)\r\n{\r\n    vec2 checker = p*10.;\r\n    vec2 cells = floor(checker);\r\n    float chekerColor = 0.;\r\n    if(mod(cells.x+cells.y, 2.)== 0.)\r\n    {\r\n        chekerColor = 1.;\r\n    }\r\n    else\r\n    {\r\n     \tchekerColor = 0.;   \r\n    }\r\n    return chekerColor;\r\n}\r\n*/\r\n\r\nvec3 makeJupiter(vec2 uv)\r\n{\r\n\tfloat time = iTime;\r\n    vec2 point = uv * zoom + offset;\r\n    float p_x = float(point.x); \r\n    float p_y = float(point.y);\r\n    \r\n    float a_x = .2;\r\n    float a_y = .3;\r\n    \r\n    for(int i=1; i<int(iteration); i++){\r\n        float float_i = float(i); \r\n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\r\n        point.y+=a_y*cos(float_i*point.x);\r\n    }\r\n    \r\n    float r = sin(point.y)*.5+.4;\r\n    float g = cos(point.y)*.5+.7;\r\n    float b = cos(point.y)*.5+.8;\r\n    \r\n    r+=.3;\r\n    \r\n    r = cos(point.x+point.y+1.3)*.5+.5;\r\n    g = sin(point.x+point.y+2.)*.5+.5;\r\n    b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.))*.25+.5;\r\n      \r\n     \r\n    r = pow(r,.8);\r\n    g = pow(g,.8);\r\n    b = pow(b,1.);\r\n    \r\n    vec3 col = vec3(r,g,b);\r\n    col += vec3(.1);\r\n    \r\n    return col;\r\n}\r\n\r\nvec2 seeCoords(vec2 p)\r\n{\r\n    return p.xy;\r\n}\r\n\r\nvec2 arrangeCoords(vec2 p)\r\n{\r\n    vec2 q = p.xy/iResolution.xy;\r\n    vec2 r = -1.0+2.0*q;\r\n\tr.x *= iResolution.x/iResolution.y;\r\n    return r;\r\n}\r\n\r\n//->START\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    \r\n    vec2 p = arrangeCoords(fragCoord);\r\n     \r\n    vec3 lookAt = vec3(0.);\r\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\r\n    camPos = vec3(2,2.1,2.);\r\n    \r\n    mat3 camera = setCamera(camPos, lookAt, 0.);\r\n    \r\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\r\n    vec2 rayResult = rayMarching(camPos, rayDirection);     \r\n    \r\n    float rayDistance = rayResult.x;\r\n    float rayColor = rayResult.y;\r\n    vec3 hitPos = camPos + rayDirection*rayDistance;\r\n    vec2 chekerUv;\r\n    \r\n    vec3 color;\r\n    \r\n    vec3 sphereColor = vec3(0, 0, 0);  \r\n    \r\n    if(rayColor > 1.)\r\n    {\r\n        color = vec3(1. , 0.4 ,0.1 );\r\n     \r\n        if(rayDistance>1.)\r\n        {\r\n        \tchekerUv = getUV(hitPos);\r\n            //sphereColor = vec3(makeCheker(chekerUv));\r\n            sphereColor = vec3(makeJupiter(chekerUv));\r\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\r\n        }       \r\n    }\r\n    else\r\n    {\r\n        color = vec3(0., 0., 0.);\r\n    }\r\n   \r\n    vec3 pos = camPos + rayDistance * rayDirection;\r\n    vec3 nor = calcNormal( pos );\r\n    \r\n\r\n\t\r\n    fragColor = vec4(sphereColor, 1);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2017\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n\r\n#define MAT_MUSH_HEAD 1.0\r\n#define MAT_MUSH_NECK 2.0\r\n#define MAT_LADY_BODY 3.0\r\n#define MAT_LADY_HEAD 4.0\r\n#define MAT_LADY_LEGS 5.0\r\n#define MAT_GRASS     6.0\r\n#define MAT_GROUND    7.0\r\n#define MAT_MOSS      8.0\r\n#define MAT_CITA      9.0\r\n\r\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\r\n\r\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\r\n{\r\n#if 1\r\n    vec3 p = pos - cen;\r\n    float d = length(p/rad) - 1.0;   \r\n    return d * min(min(rad.x,rad.y),rad.z);\r\n#else\r\n    vec3 p = pos - cen;\r\n    float k0 = length(p/rad);\r\n    float k1 = length(p/(rad*rad));\r\n    return k0*(k0-1.0)/k1;\r\n#endif    \r\n}\r\n    \r\nvec2 sdLine( in vec3 pos, in vec3 a, in vec3 b )\r\n{\r\n    vec3 pa = pos - a;\r\n    vec3 ba = b - a;\r\n   \r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    \r\n    return vec2( length(pa-h*ba), h );\r\n}\r\n\r\nvec2 sdLineOri( in vec3 p, in vec3 b )\r\n{\r\n    float h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );\r\n    \r\n    return vec2( length(p-h*b), h );\r\n}\r\nvec2 sdLineOriY( in vec3 p, in float b )\r\n{\r\n    float h = clamp( p.y/b, 0.0, 1.0 );\r\n    \r\n    return vec2( length(vec3(p.x,p.y-b*h,p.z)), h );\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return min(a, b) - h*h*0.25/k;\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return max(a, b) + h*h*0.25/k;\r\n}\r\n\r\nfloat length2(in vec2 p ) { return dot(p,p); }\r\nfloat length2(in vec3 p ) { return dot(p,p); }\r\n\r\nvec3 rotateY( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateX( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\nvec3 rotateZ( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\n\r\n//==================================================\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n//==================================================\r\n\r\nvec3 mapLadyBug( vec3 p, float curmin )\r\n{\r\n    \r\n    float db = length(p-vec3(0.0,-0.35,0.05))-1.3;\r\n    if( db>curmin ) return vec3(10000.0,0.0,0.0);\r\n    \r\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\r\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\r\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\r\n\r\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\r\n\r\n    // --------\r\n    vec3 hc = vec3(0.0,0.1,0.8);\r\n    vec3 ph = rotateX(p-hc,0.5);\r\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\r\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\r\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\r\n\r\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\r\n    \r\n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq\r\n\r\n    // -------------\r\n    \r\n    vec3 k1 = vec3(0.42,-0.05,0.92);\r\n    vec3 k2 = vec3(0.49,-0.2,1.05);\r\n    float dLegs = 10.0;\r\n\r\n    float sx = sign(p.x);\r\n    p.x = abs(p.x);\r\n    for( int k=0; k<3; k++ )\r\n    {   \r\n        vec3 q = p;\r\n        q.y -= min(sx,0.0)*0.1;\r\n        if( k==0) q += vec3( 0.0,0.11,0.0);\r\n        if( k==1) q += vec3(-0.3,0.1,0.2);\r\n        if( k==2) q += vec3(-0.3,0.1,0.6);\r\n        \r\n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\r\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k1, k2 );\r\n        se.x -= 0.01 + 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\r\n        se.x -= 0.02 - 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n    }\r\n    \r\n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\r\n\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToMushrom( in vec3 pos )\r\n{\r\n    vec3 qos = pos;\r\n    qos.xy = (mat2(60,11,-11,60)/61.0) * qos.xy;\r\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\r\n    qos.y -= 0.4;\r\n    return qos;\r\n}\r\n\r\nvec3 mapMushroom( in vec3 pos, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n\r\n    vec3 qos = worldToMushrom(pos);\r\n    float db = length(qos-vec3(0.0,1.2,0.0)) - 1.3;\r\n    if( db<cur.x )\r\n    {\r\n\r\n        {\r\n\r\n            float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\r\n\r\n            d1 -= 0.025*textureLod( iChannel1, 0.05*qos.xz, 0.0 ).x - 0.02;\r\n\r\n            float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\r\n            float d = smax( d1, -d2, 0.1 );\r\n            d *= 0.8;\r\n            if( d<res.x )\r\n            {\r\n                res = vec3( d, MAT_MUSH_HEAD, 0.0 );\r\n            }\r\n        }\r\n\r\n\r\n        {\r\n            pos.x += 0.3*sin(pos.y) - 0.65;\r\n            float pa = sin( 20.0*atan(pos.z,pos.x) );\r\n            vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\r\n\r\n            float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\r\n\r\n            float d3 = se.x - tt;\r\n\r\n            d3 = smin( d3, sdEllipsoid( pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz),0.0), vec3(0.3,0.05,0.3) ), 0.05);\r\n            d3 += 0.003*pa;\r\n            d3 *= 0.7;\r\n            \r\n            if( d3<res.x )\r\n                res = vec3( d3, MAT_MUSH_NECK, 0.0 );\r\n        }\r\n    \r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n\r\nvec3 mapGrass( in vec3 pos, float h, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n    \r\n    float db = pos.y-2.6;\r\n    \r\n    if( db<cur.x && pos.z>-1.65 )\r\n    {\r\n        const float gf = 4.0;\r\n\r\n        vec3 qos = pos * gf;\r\n\r\n        vec2 n = floor( qos.xz );\r\n        vec2 f = fract( qos.xz );\r\n        for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n\r\n            vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\r\n\r\n            if( ra2.x<0.73 ) continue;\r\n\r\n            vec2  o = hash2( n + g );\r\n            vec2  r = g - f + o;\r\n            vec2 ra = hash2( n + g + vec2(11.0,37.0) );\r\n\r\n            float gh = 2.0*(0.3+0.7*ra.x);\r\n\r\n            float rosy = qos.y - h*gf;\r\n\r\n            r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\r\n            r.x -= 0.03*rosy*rosy;\r\n\r\n            r.x *= 4.0;\r\n\r\n            float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\r\n            vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\r\n\r\n            float gr = 0.3*sqrt(1.0-0.99*se.y);\r\n            float d = se.x - gr;\r\n            d /= 4.0;\r\n\r\n            d /= gf;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_GRASS;\r\n                res.z = r.y;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n    \r\n    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));\r\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\r\n    float dm = 1e10;\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 o = vec3(0.0,3.2,0.0);\r\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\r\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\r\n        float d = length2(pos - o);\r\n        dm = min(d,dm);\r\n    }\r\n    dm = sqrt(dm)-0.02;\r\n    \r\n    if( dm<res.x )\r\n        res = vec3( dm,MAT_CITA,0);\r\n    \r\n    return res;\r\n}\r\n\r\nvec3 mapMoss( in vec3 pos, float h, vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n\r\n    float db = pos.y-2.2;\r\n    if( db<res.x )\r\n    {\r\n    const float gf = 2.0;\r\n    \r\n    vec3 qos = pos * gf;\r\n    vec2 n = floor( qos.xz );\r\n    vec2 f = fract( qos.xz );\r\n\r\n    for( int k=ZERO; k<2; k++ )\r\n    {\r\n        for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\r\n            vec2  r = g - f + o;\r\n\r\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\r\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\r\n\r\n            float mh = 0.5 + 1.0*ra2.y;\r\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\r\n\r\n            vec3 rr = vec3(r.x,ros.y,r.y);\r\n\r\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\r\n\r\n            rr.xz += 0.5*(-1.0+2.0*ra2);\r\n            vec2 se  = sdLineOriY( rr, gf*mh );\r\n            float sey = se.y;\r\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\r\n\r\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\r\n\r\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );\r\n            float cc = cos(an);\r\n            float ss = sin(an);\r\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\r\n\r\n            pp.xz = abs(pp.xz);\r\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \r\n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\r\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\r\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\r\n\r\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\r\n            d = smin( d, d2, 0.05 );\r\n\r\n            d /= gf;\r\n            d *= 0.9;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_MOSS;\r\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\r\n                float e = clamp((pos.y - h)/1.0,0.0,1.0);\r\n                res.z *= 0.02 + 0.98*e*e;\r\n                \r\n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToLadyBug( in vec3 p )\r\n{\r\n    // TODO: combine all of the above in a single 4x4 matrix\r\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\r\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\r\n    p.y += 0.2;\r\n    return p;\r\n}\r\n\r\n\r\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\r\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\r\n\r\nfloat terrain( in vec2 pos )\r\n{\r\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\r\n}\r\n\r\nvec3 mapShadow( in vec3 pos )\r\n{\r\n    float h = terrain( pos.xz );\r\n    float d = pos.y - h;\r\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\r\n    \r\n    res = mapGrass(pos,h,res);\r\n    res = mapMoss(pos,h,res);\r\n\r\n    vec3 m1 =  pos - mushroomPos1;\r\n    vec3 m2 = (pos - mushroomPos2).zyx;\r\n    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\tres = mapMushroom(m1, res);\r\n\r\n\r\n    vec3 q = worldToLadyBug(pos);\r\n    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;\r\n    if( d3.x<res.x ) res = d3;\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 map( in vec3 pos )\r\n{\r\n    vec3 res = mapShadow(pos);\r\n        \r\n    res = mapCrapInTheAir(pos, res);\r\n\r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n#if 0    \r\n    vec2 e = vec2(0.002,0.0); \r\n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\r\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\r\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*0.002).x;\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n    \r\nfloat calcShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    float res = 1.0;\r\n    float t = 0.01;\r\n    for( int i=ZERO; i<100; i++ )\r\n    {\r\n        vec3 pos = ro + rd*t;\r\n        float h = mapShadow( pos ).x;\r\n        res = min( res, 16.0*max(h,0.0)/t );\r\n        if( h<0.0001 || pos.y>3.0 ) break;\r\n        \r\n        t += clamp(h,0.01,0.2);\r\n    }\r\n    \r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n    const float tmax = 12.0;\r\n    \r\n\tvec3 res = vec3(1.0,-1.0, 0.0);\r\n\r\n    for( int i=ZERO; i<256; i++ )\r\n    {\r\n        vec3 h = map( ro + rd*res.x );\r\n        if( h.x<(0.00015*res.x) || res.x>tmax )\r\n            break;\r\n        res.x += h.x;\r\n        res.y = h.y;\r\n        res.z = h.z;\r\n    }\r\n    \r\n    if( res.x>=tmax ) res.y = -1.0;\r\n    \r\n    return res;\r\n}\r\n\r\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\r\n                out vec3 matColor, out float matRough,\r\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\r\n{\r\n    matNor = nor;\r\n    matOcc = 1.0;\r\n    matSSS = 0.0;\r\n    matRough = 1.0;\r\n    matRefOcc = 1.0;\r\n    matGamma = vec3(1.0);\r\n    \r\n    if( matID<MAT_MUSH_HEAD+0.5 )\r\n    {\r\n        vec3 m1 =  pos - mushroomPos1;\r\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\r\n    \tif( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\r\n        vec3 qos = worldToMushrom( m1 );\r\n\r\n        matColor = vec3(0.26,0.21,0.15);\r\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\r\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\r\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\r\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\r\n        matColor *= 0.4*0.45;\r\n        matColor = max( matColor, 0.0 );\r\n        \r\n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\r\n        \r\n        matRough = 0.6;\r\n        matSSS = 1.0;\r\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.87,1.0);\r\n    }\r\n    else if( matID<MAT_MUSH_NECK+0.5 )\r\n    {\r\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0/3.14159) );\r\n\r\n        matColor = vec3(0.42,0.35,0.15);\r\n        \r\n        float pa = smoothstep(0.3,0.8,pos.y);\r\n\r\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\r\n        matColor = max(vec3(0.0),matColor);\r\n        \r\n        matColor *= 0.22;\r\n        matColor = clamp( matColor, 0.0, 1.0 );\r\n        \r\n        matRough = 0.7;\r\n        matSSS = 1.0;\r\n        \r\n        matOcc = clamp( (pos.y-0.5)/1.3,0.0,1.0);\r\n        matOcc = matOcc*matOcc;\r\n        matOcc *= clamp( 1.0-(pos.y-1.2)/1.2,0.0,1.0);\r\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.95,1.0);\r\n\r\n    }\r\n    else if( matID<MAT_LADY_BODY+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n            \r\n        // red\r\n        matColor = vec3(0.16,0.008,0.0);\r\n\r\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\r\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\r\n        \r\n        qos.x = abs(qos.x);\r\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\r\n\r\n        // white\r\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\r\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\r\n\r\n        // black\r\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\r\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\r\n        \r\n        \r\n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\r\n        matColor *= 1.0 - 0.5*f;\r\n        f = texture( iChannel1, 4.0*qos.xz ).x;\r\n        matColor *= 1.0 - 0.99*f*f;\r\n        \r\n        \r\n        matColor *= 1.3;\r\n        matRough = 0.15;\r\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\r\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\r\n    }\r\n    else if( matID<MAT_LADY_HEAD+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n\r\n        matColor = vec3(0.001);\r\n\r\n        qos.z += -0.22;\r\n        qos.y += -0.7;\r\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\r\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\r\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\r\n        matRough = 0.2;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_LADY_LEGS+.5 )\r\n    {\r\n        matColor = vec3(0.0,0.0,0.0);\r\n        matRough = 0.8;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_GRASS+0.5 )\r\n    {\r\n    \tmatColor = vec3(0.1,0.15,0.03);\r\n        \r\n        float h = terrain( pos.xz );\r\n        float e = clamp(pos.y-h,0.0,1.0);\r\n        matOcc = 0.01 + 0.99*e*e;\r\n        \r\n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\r\n        matColor += 0.04*sin(matID2*41.0);\r\n        \r\n        matSSS = 0.2;\r\n        matColor *= 0.75;\r\n        matRough = 0.5;\r\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        //matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.9,0.9,1.0);\r\n    }\r\n    else if( matID<MAT_GROUND+0.5 )\r\n    {\r\n        matColor = vec3(0.2,0.2,0.0);\r\n        matRough = 1.0;\r\n        matOcc = 0.02;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_MOSS+0.5 )\r\n    {\r\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\r\n        \r\n        float f = texture( iChannel1, pos.xy*8.0 ).x;\r\n        matColor *= 0.55 + f;\r\n            \r\n        matOcc = abs(matID2);\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRough = 0.25;\r\n        matSSS = 0.5;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.7,0.7,1.0);\r\n        \r\n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\r\n    }\r\n    else //if( matID<MAT_CITA+0.5 )\r\n    {\r\n        matColor = vec3(1.0);\r\n        matSSS = 1.0;\r\n        matRough = 1.0;\r\n        matGamma = vec3(0.5);\r\n    }\r\n}\r\n\r\n\r\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\r\n               in float occ,\r\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\r\n               in vec3 matGamma )\r\n{\r\n    vec3 col = vec3(0.0);\r\n\r\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\r\n    \r\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\r\n    \r\n    float pn = exp2( 10.0*(1.0-matRough) );\r\n    \r\n\r\n    // sun light\r\n    {\r\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\r\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\r\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\r\n        float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );\r\n        vec3 hal = normalize( sun - rd );\r\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\r\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\r\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\r\n    }\r\n\r\n    // sky light\r\n    {\r\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\r\n        float dif = 0.5 + 0.5*nor.y;\r\n        col += matColor * skyColor * dif * occ;\r\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\r\n    }\r\n\r\n    // bounce light\r\n    {\r\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\r\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\r\n        col += matColor * bouColor * dif * occ;\r\n    }\r\n\r\n    col += fre*matColor*occ*matSSS;\r\n    col = pow( max(col,0.0), matGamma );\r\n\r\n    return col;\r\n}\r\n\r\nvec3 background(in vec3 d)\r\n{\r\n    // cheap cubemap\r\n    vec3 n = abs(d);\r\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \r\n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\r\n                                     d.xy/d.z;\r\n    \r\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\r\n}\r\n\r\nmat3 calcCamera( in vec3 ro, in vec3 ta )\r\n{\r\n    vec3 w = normalize( ro-ta );\r\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\r\n    vec3 v =          ( cross( w, u ) );\r\n    \r\n    return mat3( u, v, w );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\r\n    \r\n    // camera\r\n    vec3 ro = vec3(0.0,2.7,-3.0);\r\n    vec3 ta = vec3(0.0,1.9,0.0);\r\n    ro.x += 0.3*sin(0.03*iTime);    \r\n    mat3 camRot = calcCamera( ro, ta );\r\n    \r\n    // ray\r\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\r\n    \r\n    // background\r\n    vec3 col = background(rd);\r\n \r\n    // scene\r\n    vec3 tm = intersect(ro,rd);\r\n    float t = tm.x;\r\n    float matID = tm.y;\r\n    if( matID>0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n    \tvec3 nor = calcNormal( pos ); \r\n        \r\n        vec3 matNormal, matColor, matGamma;\r\n        float matRough, matOcc, matSSS, matRefOcc;\r\n        \r\n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\r\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\r\n    }\r\n    else\r\n    {\r\n        t = 30.0;\r\n    }\r\n    \r\n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\r\n\tfragColor = pow(fragColor,vec4(1.0/2.2));\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2017\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n\r\n#define MAT_MUSH_HEAD 1.0\r\n#define MAT_MUSH_NECK 2.0\r\n#define MAT_LADY_BODY 3.0\r\n#define MAT_LADY_HEAD 4.0\r\n#define MAT_LADY_LEGS 5.0\r\n#define MAT_GRASS     6.0\r\n#define MAT_GROUND    7.0\r\n#define MAT_MOSS      8.0\r\n#define MAT_CITA      9.0\r\n\r\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\r\n\r\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\r\n{\r\n#if 1\r\n    vec3 p = pos - cen;\r\n    float d = length(p/rad) - 1.0;   \r\n    return d * min(min(rad.x,rad.y),rad.z);\r\n#else\r\n    vec3 p = pos - cen;\r\n    float k0 = length(p/rad);\r\n    float k1 = length(p/(rad*rad));\r\n    return k0*(k0-1.0)/k1;\r\n#endif    \r\n}\r\n    \r\nvec2 sdLine( in vec3 pos, in vec3 a, in vec3 b )\r\n{\r\n    vec3 pa = pos - a;\r\n    vec3 ba = b - a;\r\n   \r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    \r\n    return vec2( length(pa-h*ba), h );\r\n}\r\n\r\nvec2 sdLineOri( in vec3 p, in vec3 b )\r\n{\r\n    float h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );\r\n    \r\n    return vec2( length(p-h*b), h );\r\n}\r\nvec2 sdLineOriY( in vec3 p, in float b )\r\n{\r\n    float h = clamp( p.y/b, 0.0, 1.0 );\r\n    \r\n    return vec2( length(vec3(p.x,p.y-b*h,p.z)), h );\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return min(a, b) - h*h*0.25/k;\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return max(a, b) + h*h*0.25/k;\r\n}\r\n\r\nfloat length2(in vec2 p ) { return dot(p,p); }\r\nfloat length2(in vec3 p ) { return dot(p,p); }\r\n\r\nvec3 rotateY( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateX( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\nvec3 rotateZ( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\n\r\n//==================================================\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n//==================================================\r\n\r\nvec3 mapLadyBug( vec3 p, float curmin )\r\n{\r\n    \r\n    float db = length(p-vec3(0.0,-0.35,0.05))-1.3;\r\n    if( db>curmin ) return vec3(10000.0,0.0,0.0);\r\n    \r\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\r\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\r\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\r\n\r\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\r\n\r\n    // --------\r\n    vec3 hc = vec3(0.0,0.1,0.8);\r\n    vec3 ph = rotateX(p-hc,0.5);\r\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\r\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\r\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\r\n\r\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\r\n    \r\n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq\r\n\r\n    // -------------\r\n    \r\n    vec3 k1 = vec3(0.42,-0.05,0.92);\r\n    vec3 k2 = vec3(0.49,-0.2,1.05);\r\n    float dLegs = 10.0;\r\n\r\n    float sx = sign(p.x);\r\n    p.x = abs(p.x);\r\n    for( int k=0; k<3; k++ )\r\n    {   \r\n        vec3 q = p;\r\n        q.y -= min(sx,0.0)*0.1;\r\n        if( k==0) q += vec3( 0.0,0.11,0.0);\r\n        if( k==1) q += vec3(-0.3,0.1,0.2);\r\n        if( k==2) q += vec3(-0.3,0.1,0.6);\r\n        \r\n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\r\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k1, k2 );\r\n        se.x -= 0.01 + 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\r\n        se.x -= 0.02 - 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n    }\r\n    \r\n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\r\n\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToMushrom( in vec3 pos )\r\n{\r\n    vec3 qos = pos;\r\n    qos.xy = (mat2(60,11,-11,60)/61.0) * qos.xy;\r\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\r\n    qos.y -= 0.4;\r\n    return qos;\r\n}\r\n\r\nvec3 mapMushroom( in vec3 pos, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n\r\n    vec3 qos = worldToMushrom(pos);\r\n    float db = length(qos-vec3(0.0,1.2,0.0)) - 1.3;\r\n    if( db<cur.x )\r\n    {\r\n\r\n        {\r\n\r\n            float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\r\n\r\n            d1 -= 0.025*textureLod( iChannel1, 0.05*qos.xz, 0.0 ).x - 0.02;\r\n\r\n            float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\r\n            float d = smax( d1, -d2, 0.1 );\r\n            d *= 0.8;\r\n            if( d<res.x )\r\n            {\r\n                res = vec3( d, MAT_MUSH_HEAD, 0.0 );\r\n            }\r\n        }\r\n\r\n\r\n        {\r\n            pos.x += 0.3*sin(pos.y) - 0.65;\r\n            float pa = sin( 20.0*atan(pos.z,pos.x) );\r\n            vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\r\n\r\n            float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\r\n\r\n            float d3 = se.x - tt;\r\n\r\n            d3 = smin( d3, sdEllipsoid( pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz),0.0), vec3(0.3,0.05,0.3) ), 0.05);\r\n            d3 += 0.003*pa;\r\n            d3 *= 0.7;\r\n            \r\n            if( d3<res.x )\r\n                res = vec3( d3, MAT_MUSH_NECK, 0.0 );\r\n        }\r\n    \r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n\r\nvec3 mapGrass( in vec3 pos, float h, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n    \r\n    float db = pos.y-2.6;\r\n    \r\n    if( db<cur.x && pos.z>-1.65 )\r\n    {\r\n        const float gf = 4.0;\r\n\r\n        vec3 qos = pos * gf;\r\n\r\n        vec2 n = floor( qos.xz );\r\n        vec2 f = fract( qos.xz );\r\n        for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n\r\n            vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\r\n\r\n            if( ra2.x<0.73 ) continue;\r\n\r\n            vec2  o = hash2( n + g );\r\n            vec2  r = g - f + o;\r\n            vec2 ra = hash2( n + g + vec2(11.0,37.0) );\r\n\r\n            float gh = 2.0*(0.3+0.7*ra.x);\r\n\r\n            float rosy = qos.y - h*gf;\r\n\r\n            r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\r\n            r.x -= 0.03*rosy*rosy;\r\n\r\n            r.x *= 4.0;\r\n\r\n            float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\r\n            vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\r\n\r\n            float gr = 0.3*sqrt(1.0-0.99*se.y);\r\n            float d = se.x - gr;\r\n            d /= 4.0;\r\n\r\n            d /= gf;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_GRASS;\r\n                res.z = r.y;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n    \r\n    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));\r\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\r\n    float dm = 1e10;\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 o = vec3(0.0,3.2,0.0);\r\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\r\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\r\n        float d = length2(pos - o);\r\n        dm = min(d,dm);\r\n    }\r\n    dm = sqrt(dm)-0.02;\r\n    \r\n    if( dm<res.x )\r\n        res = vec3( dm,MAT_CITA,0);\r\n    \r\n    return res;\r\n}\r\n\r\nvec3 mapMoss( in vec3 pos, float h, vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n\r\n    float db = pos.y-2.2;\r\n    if( db<res.x )\r\n    {\r\n    const float gf = 2.0;\r\n    \r\n    vec3 qos = pos * gf;\r\n    vec2 n = floor( qos.xz );\r\n    vec2 f = fract( qos.xz );\r\n\r\n    for( int k=ZERO; k<2; k++ )\r\n    {\r\n        for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\r\n            vec2  r = g - f + o;\r\n\r\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\r\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\r\n\r\n            float mh = 0.5 + 1.0*ra2.y;\r\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\r\n\r\n            vec3 rr = vec3(r.x,ros.y,r.y);\r\n\r\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\r\n\r\n            rr.xz += 0.5*(-1.0+2.0*ra2);\r\n            vec2 se  = sdLineOriY( rr, gf*mh );\r\n            float sey = se.y;\r\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\r\n\r\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\r\n\r\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );\r\n            float cc = cos(an);\r\n            float ss = sin(an);\r\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\r\n\r\n            pp.xz = abs(pp.xz);\r\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \r\n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\r\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\r\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\r\n\r\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\r\n            d = smin( d, d2, 0.05 );\r\n\r\n            d /= gf;\r\n            d *= 0.9;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_MOSS;\r\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\r\n                float e = clamp((pos.y - h)/1.0,0.0,1.0);\r\n                res.z *= 0.02 + 0.98*e*e;\r\n                \r\n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToLadyBug( in vec3 p )\r\n{\r\n    // TODO: combine all of the above in a single 4x4 matrix\r\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\r\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\r\n    p.y += 0.2;\r\n    return p;\r\n}\r\n\r\n\r\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\r\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\r\n\r\nfloat terrain( in vec2 pos )\r\n{\r\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\r\n}\r\n\r\nvec3 mapShadow( in vec3 pos )\r\n{\r\n    float h = terrain( pos.xz );\r\n    float d = pos.y - h;\r\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\r\n    \r\n    res = mapGrass(pos,h,res);\r\n    res = mapMoss(pos,h,res);\r\n\r\n    vec3 m1 =  pos - mushroomPos1;\r\n    vec3 m2 = (pos - mushroomPos2).zyx;\r\n    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\tres = mapMushroom(m1, res);\r\n\r\n\r\n    vec3 q = worldToLadyBug(pos);\r\n    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;\r\n    if( d3.x<res.x ) res = d3;\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 map( in vec3 pos )\r\n{\r\n    vec3 res = mapShadow(pos);\r\n        \r\n    res = mapCrapInTheAir(pos, res);\r\n\r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n#if 0    \r\n    vec2 e = vec2(0.002,0.0); \r\n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\r\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\r\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*0.002).x;\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n    \r\nfloat calcShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    float res = 1.0;\r\n    float t = 0.01;\r\n    for( int i=ZERO; i<100; i++ )\r\n    {\r\n        vec3 pos = ro + rd*t;\r\n        float h = mapShadow( pos ).x;\r\n        res = min( res, 16.0*max(h,0.0)/t );\r\n        if( h<0.0001 || pos.y>3.0 ) break;\r\n        \r\n        t += clamp(h,0.01,0.2);\r\n    }\r\n    \r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n    const float tmax = 12.0;\r\n    \r\n\tvec3 res = vec3(1.0,-1.0, 0.0);\r\n\r\n    for( int i=ZERO; i<256; i++ )\r\n    {\r\n        vec3 h = map( ro + rd*res.x );\r\n        if( h.x<(0.00015*res.x) || res.x>tmax )\r\n            break;\r\n        res.x += h.x;\r\n        res.y = h.y;\r\n        res.z = h.z;\r\n    }\r\n    \r\n    if( res.x>=tmax ) res.y = -1.0;\r\n    \r\n    return res;\r\n}\r\n\r\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\r\n                out vec3 matColor, out float matRough,\r\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\r\n{\r\n    matNor = nor;\r\n    matOcc = 1.0;\r\n    matSSS = 0.0;\r\n    matRough = 1.0;\r\n    matRefOcc = 1.0;\r\n    matGamma = vec3(1.0);\r\n    \r\n    if( matID<MAT_MUSH_HEAD+0.5 )\r\n    {\r\n        vec3 m1 =  pos - mushroomPos1;\r\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\r\n    \tif( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\r\n        vec3 qos = worldToMushrom( m1 );\r\n\r\n        matColor = vec3(0.26,0.21,0.15);\r\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\r\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\r\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\r\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\r\n        matColor *= 0.4*0.45;\r\n        matColor = max( matColor, 0.0 );\r\n        \r\n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\r\n        \r\n        matRough = 0.6;\r\n        matSSS = 1.0;\r\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.87,1.0);\r\n    }\r\n    else if( matID<MAT_MUSH_NECK+0.5 )\r\n    {\r\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0/3.14159) );\r\n\r\n        matColor = vec3(0.42,0.35,0.15);\r\n        \r\n        float pa = smoothstep(0.3,0.8,pos.y);\r\n\r\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\r\n        matColor = max(vec3(0.0),matColor);\r\n        \r\n        matColor *= 0.22;\r\n        matColor = clamp( matColor, 0.0, 1.0 );\r\n        \r\n        matRough = 0.7;\r\n        matSSS = 1.0;\r\n        \r\n        matOcc = clamp( (pos.y-0.5)/1.3,0.0,1.0);\r\n        matOcc = matOcc*matOcc;\r\n        matOcc *= clamp( 1.0-(pos.y-1.2)/1.2,0.0,1.0);\r\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.95,1.0);\r\n\r\n    }\r\n    else if( matID<MAT_LADY_BODY+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n            \r\n        // red\r\n        matColor = vec3(0.16,0.008,0.0);\r\n\r\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\r\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\r\n        \r\n        qos.x = abs(qos.x);\r\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\r\n\r\n        // white\r\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\r\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\r\n\r\n        // black\r\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\r\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\r\n        \r\n        \r\n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\r\n        matColor *= 1.0 - 0.5*f;\r\n        f = texture( iChannel1, 4.0*qos.xz ).x;\r\n        matColor *= 1.0 - 0.99*f*f;\r\n        \r\n        \r\n        matColor *= 1.3;\r\n        matRough = 0.15;\r\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\r\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\r\n    }\r\n    else if( matID<MAT_LADY_HEAD+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n\r\n        matColor = vec3(0.001);\r\n\r\n        qos.z += -0.22;\r\n        qos.y += -0.7;\r\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\r\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\r\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\r\n        matRough = 0.2;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_LADY_LEGS+.5 )\r\n    {\r\n        matColor = vec3(0.0,0.0,0.0);\r\n        matRough = 0.8;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_GRASS+0.5 )\r\n    {\r\n    \tmatColor = vec3(0.1,0.15,0.03);\r\n        \r\n        float h = terrain( pos.xz );\r\n        float e = clamp(pos.y-h,0.0,1.0);\r\n        matOcc = 0.01 + 0.99*e*e;\r\n        \r\n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\r\n        matColor += 0.04*sin(matID2*41.0);\r\n        \r\n        matSSS = 0.2;\r\n        matColor *= 0.75;\r\n        matRough = 0.5;\r\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        //matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.9,0.9,1.0);\r\n    }\r\n    else if( matID<MAT_GROUND+0.5 )\r\n    {\r\n        matColor = vec3(0.2,0.2,0.0);\r\n        matRough = 1.0;\r\n        matOcc = 0.02;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_MOSS+0.5 )\r\n    {\r\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\r\n        \r\n        float f = texture( iChannel1, pos.xy*8.0 ).x;\r\n        matColor *= 0.55 + f;\r\n            \r\n        matOcc = abs(matID2);\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRough = 0.25;\r\n        matSSS = 0.5;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.7,0.7,1.0);\r\n        \r\n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\r\n    }\r\n    else //if( matID<MAT_CITA+0.5 )\r\n    {\r\n        matColor = vec3(1.0);\r\n        matSSS = 1.0;\r\n        matRough = 1.0;\r\n        matGamma = vec3(0.5);\r\n    }\r\n}\r\n\r\n\r\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\r\n               in float occ,\r\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\r\n               in vec3 matGamma )\r\n{\r\n    vec3 col = vec3(0.0);\r\n\r\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\r\n    \r\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\r\n    \r\n    float pn = exp2( 10.0*(1.0-matRough) );\r\n    \r\n\r\n    // sun light\r\n    {\r\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\r\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\r\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\r\n        float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );\r\n        vec3 hal = normalize( sun - rd );\r\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\r\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\r\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\r\n    }\r\n\r\n    // sky light\r\n    {\r\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\r\n        float dif = 0.5 + 0.5*nor.y;\r\n        col += matColor * skyColor * dif * occ;\r\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\r\n    }\r\n\r\n    // bounce light\r\n    {\r\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\r\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\r\n        col += matColor * bouColor * dif * occ;\r\n    }\r\n\r\n    col += fre*matColor*occ*matSSS;\r\n    col = pow( max(col,0.0), matGamma );\r\n\r\n    return col;\r\n}\r\n\r\nvec3 background(in vec3 d)\r\n{\r\n    // cheap cubemap\r\n    vec3 n = abs(d);\r\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \r\n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\r\n                                     d.xy/d.z;\r\n    \r\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\r\n}\r\n\r\nmat3 calcCamera( in vec3 ro, in vec3 ta )\r\n{\r\n    vec3 w = normalize( ro-ta );\r\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\r\n    vec3 v =          ( cross( w, u ) );\r\n    \r\n    return mat3( u, v, w );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\r\n    \r\n    // camera\r\n    vec3 ro = vec3(0.0,2.7,-3.0);\r\n    vec3 ta = vec3(0.0,1.9,0.0);\r\n    ro.x += 0.3*sin(0.03*iTime);    \r\n    mat3 camRot = calcCamera( ro, ta );\r\n    \r\n    // ray\r\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\r\n    \r\n    // background\r\n    vec3 col = background(rd);\r\n \r\n    // scene\r\n    vec3 tm = intersect(ro,rd);\r\n    float t = tm.x;\r\n    float matID = tm.y;\r\n    if( matID>0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n    \tvec3 nor = calcNormal( pos ); \r\n        \r\n        vec3 matNormal, matColor, matGamma;\r\n        float matRough, matOcc, matSSS, matRefOcc;\r\n        \r\n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\r\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\r\n    }\r\n    else\r\n    {\r\n        t = 30.0;\r\n    }\r\n    \r\n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\r\n\tfragColor = pow(fragColor,vec4(1.0/2.2));\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"ladybug","id":"3939cb89fe0a4270a2c8097e2b63a658","date":null,"viewed":0,"name":"ladybug","description":"A ladybug on a mushroom. It renders really slowly. Sorry for that, this is not meant to be rendered with raymarching really, but well, here we are. I'll get a pass later\r\nhttps://www.shadertoy.com/view/4tByz3","likes":0,"published":null,"tags":["procedural"," 3d"," raymarching"," distancefield"]},"ver":null,"info":{"Name":"ladybug","id":"3939cb89fe0a4270a2c8097e2b63a658","date":null,"viewed":0,"name":"ladybug","description":"A ladybug on a mushroom. It renders really slowly. Sorry for that, this is not meant to be rendered with raymarching really, but well, here we are. I'll get a pass later\r\nhttps://www.shadertoy.com/view/4tByz3","likes":0,"published":null,"tags":["procedural"," 3d"," raymarching"," distancefield"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2017\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n\r\n#define MAT_MUSH_HEAD 1.0\r\n#define MAT_MUSH_NECK 2.0\r\n#define MAT_LADY_BODY 3.0\r\n#define MAT_LADY_HEAD 4.0\r\n#define MAT_LADY_LEGS 5.0\r\n#define MAT_GRASS     6.0\r\n#define MAT_GROUND    7.0\r\n#define MAT_MOSS      8.0\r\n#define MAT_CITA      9.0\r\n\r\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\r\n\r\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\r\n{\r\n#if 1\r\n    vec3 p = pos - cen;\r\n    float d = length(p/rad) - 1.0;   \r\n    return d * min(min(rad.x,rad.y),rad.z);\r\n#else\r\n    vec3 p = pos - cen;\r\n    float k0 = length(p/rad);\r\n    float k1 = length(p/(rad*rad));\r\n    return k0*(k0-1.0)/k1;\r\n#endif    \r\n}\r\n    \r\nvec2 sdLine( in vec3 pos, in vec3 a, in vec3 b )\r\n{\r\n    vec3 pa = pos - a;\r\n    vec3 ba = b - a;\r\n   \r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    \r\n    return vec2( length(pa-h*ba), h );\r\n}\r\n\r\nvec2 sdLineOri( in vec3 p, in vec3 b )\r\n{\r\n    float h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );\r\n    \r\n    return vec2( length(p-h*b), h );\r\n}\r\nvec2 sdLineOriY( in vec3 p, in float b )\r\n{\r\n    float h = clamp( p.y/b, 0.0, 1.0 );\r\n    \r\n    return vec2( length(vec3(p.x,p.y-b*h,p.z)), h );\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return min(a, b) - h*h*0.25/k;\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return max(a, b) + h*h*0.25/k;\r\n}\r\n\r\nfloat length2(in vec2 p ) { return dot(p,p); }\r\nfloat length2(in vec3 p ) { return dot(p,p); }\r\n\r\nvec3 rotateY( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateX( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\nvec3 rotateZ( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\n\r\n//==================================================\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n//==================================================\r\n\r\nvec3 mapLadyBug( vec3 p, float curmin )\r\n{\r\n    \r\n    float db = length(p-vec3(0.0,-0.35,0.05))-1.3;\r\n    if( db>curmin ) return vec3(10000.0,0.0,0.0);\r\n    \r\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\r\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\r\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\r\n\r\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\r\n\r\n    // --------\r\n    vec3 hc = vec3(0.0,0.1,0.8);\r\n    vec3 ph = rotateX(p-hc,0.5);\r\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\r\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\r\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\r\n\r\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\r\n    \r\n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq\r\n\r\n    // -------------\r\n    \r\n    vec3 k1 = vec3(0.42,-0.05,0.92);\r\n    vec3 k2 = vec3(0.49,-0.2,1.05);\r\n    float dLegs = 10.0;\r\n\r\n    float sx = sign(p.x);\r\n    p.x = abs(p.x);\r\n    for( int k=0; k<3; k++ )\r\n    {   \r\n        vec3 q = p;\r\n        q.y -= min(sx,0.0)*0.1;\r\n        if( k==0) q += vec3( 0.0,0.11,0.0);\r\n        if( k==1) q += vec3(-0.3,0.1,0.2);\r\n        if( k==2) q += vec3(-0.3,0.1,0.6);\r\n        \r\n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\r\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k1, k2 );\r\n        se.x -= 0.01 + 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\r\n        se.x -= 0.02 - 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n    }\r\n    \r\n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\r\n\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToMushrom( in vec3 pos )\r\n{\r\n    vec3 qos = pos;\r\n    qos.xy = (mat2(60,11,-11,60)/61.0) * qos.xy;\r\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\r\n    qos.y -= 0.4;\r\n    return qos;\r\n}\r\n\r\nvec3 mapMushroom( in vec3 pos, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n\r\n    vec3 qos = worldToMushrom(pos);\r\n    float db = length(qos-vec3(0.0,1.2,0.0)) - 1.3;\r\n    if( db<cur.x )\r\n    {\r\n\r\n        {\r\n\r\n            float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\r\n\r\n            d1 -= 0.025*textureLod( iChannel1, 0.05*qos.xz, 0.0 ).x - 0.02;\r\n\r\n            float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\r\n            float d = smax( d1, -d2, 0.1 );\r\n            d *= 0.8;\r\n            if( d<res.x )\r\n            {\r\n                res = vec3( d, MAT_MUSH_HEAD, 0.0 );\r\n            }\r\n        }\r\n\r\n\r\n        {\r\n            pos.x += 0.3*sin(pos.y) - 0.65;\r\n            float pa = sin( 20.0*atan(pos.z,pos.x) );\r\n            vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\r\n\r\n            float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\r\n\r\n            float d3 = se.x - tt;\r\n\r\n            d3 = smin( d3, sdEllipsoid( pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz),0.0), vec3(0.3,0.05,0.3) ), 0.05);\r\n            d3 += 0.003*pa;\r\n            d3 *= 0.7;\r\n            \r\n            if( d3<res.x )\r\n                res = vec3( d3, MAT_MUSH_NECK, 0.0 );\r\n        }\r\n    \r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n\r\nvec3 mapGrass( in vec3 pos, float h, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n    \r\n    float db = pos.y-2.6;\r\n    \r\n    if( db<cur.x && pos.z>-1.65 )\r\n    {\r\n        const float gf = 4.0;\r\n\r\n        vec3 qos = pos * gf;\r\n\r\n        vec2 n = floor( qos.xz );\r\n        vec2 f = fract( qos.xz );\r\n        for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n\r\n            vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\r\n\r\n            if( ra2.x<0.73 ) continue;\r\n\r\n            vec2  o = hash2( n + g );\r\n            vec2  r = g - f + o;\r\n            vec2 ra = hash2( n + g + vec2(11.0,37.0) );\r\n\r\n            float gh = 2.0*(0.3+0.7*ra.x);\r\n\r\n            float rosy = qos.y - h*gf;\r\n\r\n            r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\r\n            r.x -= 0.03*rosy*rosy;\r\n\r\n            r.x *= 4.0;\r\n\r\n            float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\r\n            vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\r\n\r\n            float gr = 0.3*sqrt(1.0-0.99*se.y);\r\n            float d = se.x - gr;\r\n            d /= 4.0;\r\n\r\n            d /= gf;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_GRASS;\r\n                res.z = r.y;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n    \r\n    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));\r\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\r\n    float dm = 1e10;\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 o = vec3(0.0,3.2,0.0);\r\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\r\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\r\n        float d = length2(pos - o);\r\n        dm = min(d,dm);\r\n    }\r\n    dm = sqrt(dm)-0.02;\r\n    \r\n    if( dm<res.x )\r\n        res = vec3( dm,MAT_CITA,0);\r\n    \r\n    return res;\r\n}\r\n\r\nvec3 mapMoss( in vec3 pos, float h, vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n\r\n    float db = pos.y-2.2;\r\n    if( db<res.x )\r\n    {\r\n    const float gf = 2.0;\r\n    \r\n    vec3 qos = pos * gf;\r\n    vec2 n = floor( qos.xz );\r\n    vec2 f = fract( qos.xz );\r\n\r\n    for( int k=ZERO; k<2; k++ )\r\n    {\r\n        for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\r\n            vec2  r = g - f + o;\r\n\r\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\r\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\r\n\r\n            float mh = 0.5 + 1.0*ra2.y;\r\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\r\n\r\n            vec3 rr = vec3(r.x,ros.y,r.y);\r\n\r\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\r\n\r\n            rr.xz += 0.5*(-1.0+2.0*ra2);\r\n            vec2 se  = sdLineOriY( rr, gf*mh );\r\n            float sey = se.y;\r\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\r\n\r\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\r\n\r\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );\r\n            float cc = cos(an);\r\n            float ss = sin(an);\r\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\r\n\r\n            pp.xz = abs(pp.xz);\r\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \r\n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\r\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\r\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\r\n\r\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\r\n            d = smin( d, d2, 0.05 );\r\n\r\n            d /= gf;\r\n            d *= 0.9;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_MOSS;\r\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\r\n                float e = clamp((pos.y - h)/1.0,0.0,1.0);\r\n                res.z *= 0.02 + 0.98*e*e;\r\n                \r\n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToLadyBug( in vec3 p )\r\n{\r\n    // TODO: combine all of the above in a single 4x4 matrix\r\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\r\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\r\n    p.y += 0.2;\r\n    return p;\r\n}\r\n\r\n\r\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\r\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\r\n\r\nfloat terrain( in vec2 pos )\r\n{\r\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\r\n}\r\n\r\nvec3 mapShadow( in vec3 pos )\r\n{\r\n    float h = terrain( pos.xz );\r\n    float d = pos.y - h;\r\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\r\n    \r\n    res = mapGrass(pos,h,res);\r\n    res = mapMoss(pos,h,res);\r\n\r\n    vec3 m1 =  pos - mushroomPos1;\r\n    vec3 m2 = (pos - mushroomPos2).zyx;\r\n    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\tres = mapMushroom(m1, res);\r\n\r\n\r\n    vec3 q = worldToLadyBug(pos);\r\n    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;\r\n    if( d3.x<res.x ) res = d3;\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 map( in vec3 pos )\r\n{\r\n    vec3 res = mapShadow(pos);\r\n        \r\n    res = mapCrapInTheAir(pos, res);\r\n\r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n#if 0    \r\n    vec2 e = vec2(0.002,0.0); \r\n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\r\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\r\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*0.002).x;\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n    \r\nfloat calcShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    float res = 1.0;\r\n    float t = 0.01;\r\n    for( int i=ZERO; i<100; i++ )\r\n    {\r\n        vec3 pos = ro + rd*t;\r\n        float h = mapShadow( pos ).x;\r\n        res = min( res, 16.0*max(h,0.0)/t );\r\n        if( h<0.0001 || pos.y>3.0 ) break;\r\n        \r\n        t += clamp(h,0.01,0.2);\r\n    }\r\n    \r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n    const float tmax = 12.0;\r\n    \r\n\tvec3 res = vec3(1.0,-1.0, 0.0);\r\n\r\n    for( int i=ZERO; i<256; i++ )\r\n    {\r\n        vec3 h = map( ro + rd*res.x );\r\n        if( h.x<(0.00015*res.x) || res.x>tmax )\r\n            break;\r\n        res.x += h.x;\r\n        res.y = h.y;\r\n        res.z = h.z;\r\n    }\r\n    \r\n    if( res.x>=tmax ) res.y = -1.0;\r\n    \r\n    return res;\r\n}\r\n\r\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\r\n                out vec3 matColor, out float matRough,\r\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\r\n{\r\n    matNor = nor;\r\n    matOcc = 1.0;\r\n    matSSS = 0.0;\r\n    matRough = 1.0;\r\n    matRefOcc = 1.0;\r\n    matGamma = vec3(1.0);\r\n    \r\n    if( matID<MAT_MUSH_HEAD+0.5 )\r\n    {\r\n        vec3 m1 =  pos - mushroomPos1;\r\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\r\n    \tif( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\r\n        vec3 qos = worldToMushrom( m1 );\r\n\r\n        matColor = vec3(0.26,0.21,0.15);\r\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\r\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\r\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\r\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\r\n        matColor *= 0.4*0.45;\r\n        matColor = max( matColor, 0.0 );\r\n        \r\n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\r\n        \r\n        matRough = 0.6;\r\n        matSSS = 1.0;\r\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.87,1.0);\r\n    }\r\n    else if( matID<MAT_MUSH_NECK+0.5 )\r\n    {\r\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0/3.14159) );\r\n\r\n        matColor = vec3(0.42,0.35,0.15);\r\n        \r\n        float pa = smoothstep(0.3,0.8,pos.y);\r\n\r\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\r\n        matColor = max(vec3(0.0),matColor);\r\n        \r\n        matColor *= 0.22;\r\n        matColor = clamp( matColor, 0.0, 1.0 );\r\n        \r\n        matRough = 0.7;\r\n        matSSS = 1.0;\r\n        \r\n        matOcc = clamp( (pos.y-0.5)/1.3,0.0,1.0);\r\n        matOcc = matOcc*matOcc;\r\n        matOcc *= clamp( 1.0-(pos.y-1.2)/1.2,0.0,1.0);\r\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.95,1.0);\r\n\r\n    }\r\n    else if( matID<MAT_LADY_BODY+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n            \r\n        // red\r\n        matColor = vec3(0.16,0.008,0.0);\r\n\r\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\r\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\r\n        \r\n        qos.x = abs(qos.x);\r\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\r\n\r\n        // white\r\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\r\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\r\n\r\n        // black\r\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\r\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\r\n        \r\n        \r\n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\r\n        matColor *= 1.0 - 0.5*f;\r\n        f = texture( iChannel1, 4.0*qos.xz ).x;\r\n        matColor *= 1.0 - 0.99*f*f;\r\n        \r\n        \r\n        matColor *= 1.3;\r\n        matRough = 0.15;\r\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\r\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\r\n    }\r\n    else if( matID<MAT_LADY_HEAD+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n\r\n        matColor = vec3(0.001);\r\n\r\n        qos.z += -0.22;\r\n        qos.y += -0.7;\r\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\r\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\r\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\r\n        matRough = 0.2;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_LADY_LEGS+.5 )\r\n    {\r\n        matColor = vec3(0.0,0.0,0.0);\r\n        matRough = 0.8;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_GRASS+0.5 )\r\n    {\r\n    \tmatColor = vec3(0.1,0.15,0.03);\r\n        \r\n        float h = terrain( pos.xz );\r\n        float e = clamp(pos.y-h,0.0,1.0);\r\n        matOcc = 0.01 + 0.99*e*e;\r\n        \r\n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\r\n        matColor += 0.04*sin(matID2*41.0);\r\n        \r\n        matSSS = 0.2;\r\n        matColor *= 0.75;\r\n        matRough = 0.5;\r\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        //matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.9,0.9,1.0);\r\n    }\r\n    else if( matID<MAT_GROUND+0.5 )\r\n    {\r\n        matColor = vec3(0.2,0.2,0.0);\r\n        matRough = 1.0;\r\n        matOcc = 0.02;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_MOSS+0.5 )\r\n    {\r\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\r\n        \r\n        float f = texture( iChannel1, pos.xy*8.0 ).x;\r\n        matColor *= 0.55 + f;\r\n            \r\n        matOcc = abs(matID2);\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRough = 0.25;\r\n        matSSS = 0.5;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.7,0.7,1.0);\r\n        \r\n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\r\n    }\r\n    else //if( matID<MAT_CITA+0.5 )\r\n    {\r\n        matColor = vec3(1.0);\r\n        matSSS = 1.0;\r\n        matRough = 1.0;\r\n        matGamma = vec3(0.5);\r\n    }\r\n}\r\n\r\n\r\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\r\n               in float occ,\r\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\r\n               in vec3 matGamma )\r\n{\r\n    vec3 col = vec3(0.0);\r\n\r\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\r\n    \r\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\r\n    \r\n    float pn = exp2( 10.0*(1.0-matRough) );\r\n    \r\n\r\n    // sun light\r\n    {\r\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\r\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\r\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\r\n        float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );\r\n        vec3 hal = normalize( sun - rd );\r\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\r\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\r\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\r\n    }\r\n\r\n    // sky light\r\n    {\r\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\r\n        float dif = 0.5 + 0.5*nor.y;\r\n        col += matColor * skyColor * dif * occ;\r\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\r\n    }\r\n\r\n    // bounce light\r\n    {\r\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\r\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\r\n        col += matColor * bouColor * dif * occ;\r\n    }\r\n\r\n    col += fre*matColor*occ*matSSS;\r\n    col = pow( max(col,0.0), matGamma );\r\n\r\n    return col;\r\n}\r\n\r\nvec3 background(in vec3 d)\r\n{\r\n    // cheap cubemap\r\n    vec3 n = abs(d);\r\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \r\n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\r\n                                     d.xy/d.z;\r\n    \r\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\r\n}\r\n\r\nmat3 calcCamera( in vec3 ro, in vec3 ta )\r\n{\r\n    vec3 w = normalize( ro-ta );\r\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\r\n    vec3 v =          ( cross( w, u ) );\r\n    \r\n    return mat3( u, v, w );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\r\n    \r\n    // camera\r\n    vec3 ro = vec3(0.0,2.7,-3.0);\r\n    vec3 ta = vec3(0.0,1.9,0.0);\r\n    ro.x += 0.3*sin(0.03*iTime);    \r\n    mat3 camRot = calcCamera( ro, ta );\r\n    \r\n    // ray\r\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\r\n    \r\n    // background\r\n    vec3 col = background(rd);\r\n \r\n    // scene\r\n    vec3 tm = intersect(ro,rd);\r\n    float t = tm.x;\r\n    float matID = tm.y;\r\n    if( matID>0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n    \tvec3 nor = calcNormal( pos ); \r\n        \r\n        vec3 matNormal, matColor, matGamma;\r\n        float matRough, matOcc, matSSS, matRefOcc;\r\n        \r\n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\r\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\r\n    }\r\n    else\r\n    {\r\n        t = 30.0;\r\n    }\r\n    \r\n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\r\n\tfragColor = pow(fragColor,vec4(1.0/2.2));\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2017\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n\r\n#define MAT_MUSH_HEAD 1.0\r\n#define MAT_MUSH_NECK 2.0\r\n#define MAT_LADY_BODY 3.0\r\n#define MAT_LADY_HEAD 4.0\r\n#define MAT_LADY_LEGS 5.0\r\n#define MAT_GRASS     6.0\r\n#define MAT_GROUND    7.0\r\n#define MAT_MOSS      8.0\r\n#define MAT_CITA      9.0\r\n\r\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\r\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\r\n\r\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\r\n{\r\n#if 1\r\n    vec3 p = pos - cen;\r\n    float d = length(p/rad) - 1.0;   \r\n    return d * min(min(rad.x,rad.y),rad.z);\r\n#else\r\n    vec3 p = pos - cen;\r\n    float k0 = length(p/rad);\r\n    float k1 = length(p/(rad*rad));\r\n    return k0*(k0-1.0)/k1;\r\n#endif    \r\n}\r\n    \r\nvec2 sdLine( in vec3 pos, in vec3 a, in vec3 b )\r\n{\r\n    vec3 pa = pos - a;\r\n    vec3 ba = b - a;\r\n   \r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    \r\n    return vec2( length(pa-h*ba), h );\r\n}\r\n\r\nvec2 sdLineOri( in vec3 p, in vec3 b )\r\n{\r\n    float h = clamp( dot(p,b)/dot(b,b), 0.0, 1.0 );\r\n    \r\n    return vec2( length(p-h*b), h );\r\n}\r\nvec2 sdLineOriY( in vec3 p, in float b )\r\n{\r\n    float h = clamp( p.y/b, 0.0, 1.0 );\r\n    \r\n    return vec2( length(vec3(p.x,p.y-b*h,p.z)), h );\r\n}\r\n\r\nfloat smin( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return min(a, b) - h*h*0.25/k;\r\n}\r\n\r\nfloat smax( float a, float b, float k )\r\n{\r\n    float h = max(k-abs(a-b),0.0);\r\n    return max(a, b) + h*h*0.25/k;\r\n}\r\n\r\nfloat length2(in vec2 p ) { return dot(p,p); }\r\nfloat length2(in vec3 p ) { return dot(p,p); }\r\n\r\nvec3 rotateY( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xz = mat2(co,-si,si,co)*p.xz;\r\n    return p;\r\n}\r\n\r\nvec3 rotateX( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.yz = mat2(co,-si,si,co)*p.yz;\r\n    return p;\r\n}\r\nvec3 rotateZ( in vec3 p, float t )\r\n{\r\n    float co = cos(t);\r\n    float si = sin(t);\r\n    p.xy = mat2(co,-si,si,co)*p.xy;\r\n    return p;\r\n}\r\n\r\n\r\n//==================================================\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n//==================================================\r\n\r\nvec3 mapLadyBug( vec3 p, float curmin )\r\n{\r\n    \r\n    float db = length(p-vec3(0.0,-0.35,0.05))-1.3;\r\n    if( db>curmin ) return vec3(10000.0,0.0,0.0);\r\n    \r\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\r\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\r\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\r\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\r\n\r\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\r\n\r\n    // --------\r\n    vec3 hc = vec3(0.0,0.1,0.8);\r\n    vec3 ph = rotateX(p-hc,0.5);\r\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\r\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\r\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\r\n\r\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\r\n    \r\n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); // iqiq\r\n\r\n    // -------------\r\n    \r\n    vec3 k1 = vec3(0.42,-0.05,0.92);\r\n    vec3 k2 = vec3(0.49,-0.2,1.05);\r\n    float dLegs = 10.0;\r\n\r\n    float sx = sign(p.x);\r\n    p.x = abs(p.x);\r\n    for( int k=0; k<3; k++ )\r\n    {   \r\n        vec3 q = p;\r\n        q.y -= min(sx,0.0)*0.1;\r\n        if( k==0) q += vec3( 0.0,0.11,0.0);\r\n        if( k==1) q += vec3(-0.3,0.1,0.2);\r\n        if( k==2) q += vec3(-0.3,0.1,0.6);\r\n        \r\n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\r\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k1, k2 );\r\n        se.x -= 0.01 + 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n\r\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\r\n        se.x -= 0.02 - 0.01*se.y;\r\n        dLegs = min(dLegs,se.x);\r\n    }\r\n    \r\n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\r\n\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToMushrom( in vec3 pos )\r\n{\r\n    vec3 qos = pos;\r\n    qos.xy = (mat2(60,11,-11,60)/61.0) * qos.xy;\r\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\r\n    qos.y -= 0.4;\r\n    return qos;\r\n}\r\n\r\nvec3 mapMushroom( in vec3 pos, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n\r\n    vec3 qos = worldToMushrom(pos);\r\n    float db = length(qos-vec3(0.0,1.2,0.0)) - 1.3;\r\n    if( db<cur.x )\r\n    {\r\n\r\n        {\r\n\r\n            float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\r\n\r\n            d1 -= 0.025*textureLod( iChannel1, 0.05*qos.xz, 0.0 ).x - 0.02;\r\n\r\n            float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\r\n            float d = smax( d1, -d2, 0.1 );\r\n            d *= 0.8;\r\n            if( d<res.x )\r\n            {\r\n                res = vec3( d, MAT_MUSH_HEAD, 0.0 );\r\n            }\r\n        }\r\n\r\n\r\n        {\r\n            pos.x += 0.3*sin(pos.y) - 0.65;\r\n            float pa = sin( 20.0*atan(pos.z,pos.x) );\r\n            vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\r\n\r\n            float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\r\n\r\n            float d3 = se.x - tt;\r\n\r\n            d3 = smin( d3, sdEllipsoid( pos, vec3(0.0, 1.7 - 2.0*length2(pos.xz),0.0), vec3(0.3,0.05,0.3) ), 0.05);\r\n            d3 += 0.003*pa;\r\n            d3 *= 0.7;\r\n            \r\n            if( d3<res.x )\r\n                res = vec3( d3, MAT_MUSH_NECK, 0.0 );\r\n        }\r\n    \r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n\r\nvec3 mapGrass( in vec3 pos, float h, in vec3 cur )\r\n{\r\n    vec3 res = cur;\r\n    \r\n    float db = pos.y-2.6;\r\n    \r\n    if( db<cur.x && pos.z>-1.65 )\r\n    {\r\n        const float gf = 4.0;\r\n\r\n        vec3 qos = pos * gf;\r\n\r\n        vec2 n = floor( qos.xz );\r\n        vec2 f = fract( qos.xz );\r\n        for( int j=-2; j<=2; j++ )\r\n        for( int i=-2; i<=2; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n\r\n            vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\r\n\r\n            if( ra2.x<0.73 ) continue;\r\n\r\n            vec2  o = hash2( n + g );\r\n            vec2  r = g - f + o;\r\n            vec2 ra = hash2( n + g + vec2(11.0,37.0) );\r\n\r\n            float gh = 2.0*(0.3+0.7*ra.x);\r\n\r\n            float rosy = qos.y - h*gf;\r\n\r\n            r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\r\n            r.x -= 0.03*rosy*rosy;\r\n\r\n            r.x *= 4.0;\r\n\r\n            float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\r\n            vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\r\n\r\n            float gr = 0.3*sqrt(1.0-0.99*se.y);\r\n            float d = se.x - gr;\r\n            d /= 4.0;\r\n\r\n            d /= gf;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_GRASS;\r\n                res.z = r.y;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 mapCrapInTheAir( in vec3 pos, in vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n    \r\n    ivec2 id = ivec2(floor((pos.xz+2.0)/4.0));\r\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\r\n    float dm = 1e10;\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 o = vec3(0.0,3.2,0.0);\r\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\r\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\r\n        float d = length2(pos - o);\r\n        dm = min(d,dm);\r\n    }\r\n    dm = sqrt(dm)-0.02;\r\n    \r\n    if( dm<res.x )\r\n        res = vec3( dm,MAT_CITA,0);\r\n    \r\n    return res;\r\n}\r\n\r\nvec3 mapMoss( in vec3 pos, float h, vec3 cur)\r\n{\r\n    vec3 res = cur;\r\n\r\n    float db = pos.y-2.2;\r\n    if( db<res.x )\r\n    {\r\n    const float gf = 2.0;\r\n    \r\n    vec3 qos = pos * gf;\r\n    vec2 n = floor( qos.xz );\r\n    vec2 f = fract( qos.xz );\r\n\r\n    for( int k=ZERO; k<2; k++ )\r\n    {\r\n        for( int j=-1; j<=1; j++ )\r\n        for( int i=-1; i<=1; i++ )\r\n        {\r\n            vec2  g = vec2( float(i), float(j) );\r\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\r\n            vec2  r = g - f + o;\r\n\r\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\r\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\r\n\r\n            float mh = 0.5 + 1.0*ra2.y;\r\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\r\n\r\n            vec3 rr = vec3(r.x,ros.y,r.y);\r\n\r\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\r\n\r\n            rr.xz += 0.5*(-1.0+2.0*ra2);\r\n            vec2 se  = sdLineOriY( rr, gf*mh );\r\n            float sey = se.y;\r\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\r\n\r\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\r\n\r\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)/0.4 ), 1.57 );\r\n            float cc = cos(an);\r\n            float ss = sin(an);\r\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\r\n\r\n            pp.xz = abs(pp.xz);\r\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \r\n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\r\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\r\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\r\n\r\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\r\n            d = smin( d, d2, 0.05 );\r\n\r\n            d /= gf;\r\n            d *= 0.9;\r\n            if( d<res.x )\r\n            {\r\n                res.x = d;\r\n                res.y = MAT_MOSS;\r\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\r\n                float e = clamp((pos.y - h)/1.0,0.0,1.0);\r\n                res.z *= 0.02 + 0.98*e*e;\r\n                \r\n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    }\r\n    \r\n    return res;\r\n}\r\n\r\n\r\nvec3 worldToLadyBug( in vec3 p )\r\n{\r\n    // TODO: combine all of the above in a single 4x4 matrix\r\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\r\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\r\n    p.y += 0.2;\r\n    return p;\r\n}\r\n\r\n\r\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\r\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\r\n\r\nfloat terrain( in vec2 pos )\r\n{\r\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\r\n}\r\n\r\nvec3 mapShadow( in vec3 pos )\r\n{\r\n    float h = terrain( pos.xz );\r\n    float d = pos.y - h;\r\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\r\n    \r\n    res = mapGrass(pos,h,res);\r\n    res = mapMoss(pos,h,res);\r\n\r\n    vec3 m1 =  pos - mushroomPos1;\r\n    vec3 m2 = (pos - mushroomPos2).zyx;\r\n    if( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\tres = mapMushroom(m1, res);\r\n\r\n\r\n    vec3 q = worldToLadyBug(pos);\r\n    vec3 d3 = mapLadyBug(q, res.x*4.0); d3.x/=4.0;\r\n    if( d3.x<res.x ) res = d3;\r\n\r\n    return res;\r\n}\r\n\r\n\r\nvec3 map( in vec3 pos )\r\n{\r\n    vec3 res = mapShadow(pos);\r\n        \r\n    res = mapCrapInTheAir(pos, res);\r\n\r\n    return res;\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n#if 0    \r\n    vec2 e = vec2(0.002,0.0); \r\n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\r\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\r\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\r\n#else\r\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*0.002).x;\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n}\r\n    \r\nfloat calcShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    float res = 1.0;\r\n    float t = 0.01;\r\n    for( int i=ZERO; i<100; i++ )\r\n    {\r\n        vec3 pos = ro + rd*t;\r\n        float h = mapShadow( pos ).x;\r\n        res = min( res, 16.0*max(h,0.0)/t );\r\n        if( h<0.0001 || pos.y>3.0 ) break;\r\n        \r\n        t += clamp(h,0.01,0.2);\r\n    }\r\n    \r\n    return clamp(res,0.0,1.0);\r\n}\r\n\r\nvec3 intersect( in vec3 ro, in vec3 rd )\r\n{\r\n    const float tmax = 12.0;\r\n    \r\n\tvec3 res = vec3(1.0,-1.0, 0.0);\r\n\r\n    for( int i=ZERO; i<256; i++ )\r\n    {\r\n        vec3 h = map( ro + rd*res.x );\r\n        if( h.x<(0.00015*res.x) || res.x>tmax )\r\n            break;\r\n        res.x += h.x;\r\n        res.y = h.y;\r\n        res.z = h.z;\r\n    }\r\n    \r\n    if( res.x>=tmax ) res.y = -1.0;\r\n    \r\n    return res;\r\n}\r\n\r\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\r\n                out vec3 matColor, out float matRough,\r\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\r\n{\r\n    matNor = nor;\r\n    matOcc = 1.0;\r\n    matSSS = 0.0;\r\n    matRough = 1.0;\r\n    matRefOcc = 1.0;\r\n    matGamma = vec3(1.0);\r\n    \r\n    if( matID<MAT_MUSH_HEAD+0.5 )\r\n    {\r\n        vec3 m1 =  pos - mushroomPos1;\r\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\r\n    \tif( length2(m2.xz) < length2(m1.xz) ) m1 = m2;\r\n\r\n        vec3 qos = worldToMushrom( m1 );\r\n\r\n        matColor = vec3(0.26,0.21,0.15);\r\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\r\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\r\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\r\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\r\n        matColor *= 0.4*0.45;\r\n        matColor = max( matColor, 0.0 );\r\n        \r\n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\r\n        \r\n        matRough = 0.6;\r\n        matSSS = 1.0;\r\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.87,1.0);\r\n    }\r\n    else if( matID<MAT_MUSH_NECK+0.5 )\r\n    {\r\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0/3.14159) );\r\n\r\n        matColor = vec3(0.42,0.35,0.15);\r\n        \r\n        float pa = smoothstep(0.3,0.8,pos.y);\r\n\r\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\r\n        matColor = max(vec3(0.0),matColor);\r\n        \r\n        matColor *= 0.22;\r\n        matColor = clamp( matColor, 0.0, 1.0 );\r\n        \r\n        matRough = 0.7;\r\n        matSSS = 1.0;\r\n        \r\n        matOcc = clamp( (pos.y-0.5)/1.3,0.0,1.0);\r\n        matOcc = matOcc*matOcc;\r\n        matOcc *= clamp( 1.0-(pos.y-1.2)/1.2,0.0,1.0);\r\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.75,0.95,1.0);\r\n\r\n    }\r\n    else if( matID<MAT_LADY_BODY+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n            \r\n        // red\r\n        matColor = vec3(0.16,0.008,0.0);\r\n\r\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\r\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\r\n        \r\n        qos.x = abs(qos.x);\r\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\r\n\r\n        // white\r\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\r\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\r\n\r\n        // black\r\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\r\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\r\n        \r\n        \r\n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\r\n        matColor *= 1.0 - 0.5*f;\r\n        f = texture( iChannel1, 4.0*qos.xz ).x;\r\n        matColor *= 1.0 - 0.99*f*f;\r\n        \r\n        \r\n        matColor *= 1.3;\r\n        matRough = 0.15;\r\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\r\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\r\n    }\r\n    else if( matID<MAT_LADY_HEAD+.5 )\r\n    {\r\n        vec3 qos = worldToLadyBug( pos );\r\n\r\n        matColor = vec3(0.001);\r\n\r\n        qos.z += -0.22;\r\n        qos.y += -0.7;\r\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\r\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\r\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\r\n        matRough = 0.2;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_LADY_LEGS+.5 )\r\n    {\r\n        matColor = vec3(0.0,0.0,0.0);\r\n        matRough = 0.8;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_GRASS+0.5 )\r\n    {\r\n    \tmatColor = vec3(0.1,0.15,0.03);\r\n        \r\n        float h = terrain( pos.xz );\r\n        float e = clamp(pos.y-h,0.0,1.0);\r\n        matOcc = 0.01 + 0.99*e*e;\r\n        \r\n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\r\n        matColor += 0.04*sin(matID2*41.0);\r\n        \r\n        matSSS = 0.2;\r\n        matColor *= 0.75;\r\n        matRough = 0.5;\r\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        //matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.9,0.9,1.0);\r\n    }\r\n    else if( matID<MAT_GROUND+0.5 )\r\n    {\r\n        matColor = vec3(0.2,0.2,0.0);\r\n        matRough = 1.0;\r\n        matOcc = 0.02;\r\n        matRefOcc = matOcc;\r\n    }\r\n    else if( matID<MAT_MOSS+0.5 )\r\n    {\r\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\r\n        \r\n        float f = texture( iChannel1, pos.xy*8.0 ).x;\r\n        matColor *= 0.55 + f;\r\n            \r\n        matOcc = abs(matID2);\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\r\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\r\n        matRough = 0.25;\r\n        matSSS = 0.5;\r\n        matRefOcc = matOcc;\r\n        matGamma = vec3(0.7,0.7,1.0);\r\n        \r\n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\r\n    }\r\n    else //if( matID<MAT_CITA+0.5 )\r\n    {\r\n        matColor = vec3(1.0);\r\n        matSSS = 1.0;\r\n        matRough = 1.0;\r\n        matGamma = vec3(0.5);\r\n    }\r\n}\r\n\r\n\r\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\r\n               in float occ,\r\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\r\n               in vec3 matGamma )\r\n{\r\n    vec3 col = vec3(0.0);\r\n\r\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\r\n    \r\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\r\n    \r\n    float pn = exp2( 10.0*(1.0-matRough) );\r\n    \r\n\r\n    // sun light\r\n    {\r\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\r\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\r\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\r\n        float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );\r\n        vec3 hal = normalize( sun - rd );\r\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\r\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\r\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\r\n    }\r\n\r\n    // sky light\r\n    {\r\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\r\n        float dif = 0.5 + 0.5*nor.y;\r\n        col += matColor * skyColor * dif * occ;\r\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\r\n    }\r\n\r\n    // bounce light\r\n    {\r\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\r\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\r\n        col += matColor * bouColor * dif * occ;\r\n    }\r\n\r\n    col += fre*matColor*occ*matSSS;\r\n    col = pow( max(col,0.0), matGamma );\r\n\r\n    return col;\r\n}\r\n\r\nvec3 background(in vec3 d)\r\n{\r\n    // cheap cubemap\r\n    vec3 n = abs(d);\r\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \r\n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\r\n                                     d.xy/d.z;\r\n    \r\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\r\n}\r\n\r\nmat3 calcCamera( in vec3 ro, in vec3 ta )\r\n{\r\n    vec3 w = normalize( ro-ta );\r\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\r\n    vec3 v =          ( cross( w, u ) );\r\n    \r\n    return mat3( u, v, w );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) / iResolution.y;\r\n    \r\n    // camera\r\n    vec3 ro = vec3(0.0,2.7,-3.0);\r\n    vec3 ta = vec3(0.0,1.9,0.0);\r\n    ro.x += 0.3*sin(0.03*iTime);    \r\n    mat3 camRot = calcCamera( ro, ta );\r\n    \r\n    // ray\r\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\r\n    \r\n    // background\r\n    vec3 col = background(rd);\r\n \r\n    // scene\r\n    vec3 tm = intersect(ro,rd);\r\n    float t = tm.x;\r\n    float matID = tm.y;\r\n    if( matID>0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n    \tvec3 nor = calcNormal( pos ); \r\n        \r\n        vec3 matNormal, matColor, matGamma;\r\n        float matRough, matOcc, matSSS, matRefOcc;\r\n        \r\n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\r\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\r\n    }\r\n    else\r\n    {\r\n        t = 30.0;\r\n    }\r\n    \r\n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\r\n\tfragColor = pow(fragColor,vec4(1.0/2.2));\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/* This is free and unencumbered software released into the public domain. https://unlicense.org/\r\n\r\nTrying to get some interesting looking lens flares, seems like it worked. \r\nSee https://www.shadertoy.com/view/lsBGDK for a more avanced, generalized solution\r\n\r\nIf you find this useful send me an email at peterekepeter at gmail dot com, \r\nI've seen this shader pop up before in other works, but I'm curious where it ends up.\r\n\r\nIf you want to use it, feel free to do so, there is no need to credit but it is appreciated.\r\n\r\n\r\nUsed in:\r\n\r\n Water World - https://www.shadertoy.com/view/lslGDB\r\n\r\n Floating Mountains - https://www.shadertoy.com/view/XsSGDy\r\n \r\n Clouds and Sun With Flare - https://www.shadertoy.com/view/4sl3zl\r\n \r\n musk's lens flare mod - https://www.shadertoy.com/view/XdfXRX\r\n\r\n Land of Dreams - https://github.com/Tomius/LoD\r\n\r\n Where is Starman? - https://spacein3d.com/starman\r\n\r\n\r\nChangelog:\r\n\r\n 13/08/13: \r\n\tfirst published\r\n\r\n 17/11/27\r\n    fixed seam, thanks to Shane\r\n\r\n 19/08/08:\r\n    updated description and license change\r\n\r\n 20/06/24:\r\n    renamed to Lens Flare Example, updated description\r\n\r\n*/\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat noise(float t)\r\n{\r\n\treturn value_noise(vec2(t,.0)/iResolution.xy*234.0);\r\n}\r\nfloat noise(vec2 t)\r\n{\r\n\treturn value_noise(t/iResolution.xy*234.0);\r\n}\r\n\r\nvec3 lensflare(vec2 uv,vec2 pos)\r\n{\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat ang = atan(main.x,main.y);\r\n\tfloat dist=length(main); dist = pow(dist,.1);\r\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\r\n\t\r\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tf0 = f0 + f0*(sin(noise(sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-.4);\r\n\t\r\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\r\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\r\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\r\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\r\n\tc = c*1.3 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\r\n{\r\n\tfloat w = color.x+color.y+color.z;\r\n\treturn mix(color,vec3(w)*factor,w*factor2);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\r\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tif (iMouse.z<.5)\r\n\t{\r\n\t\tmouse.x=sin(iTime)*.5;\r\n\t\tmouse.y=sin(iTime*.913)*.5;\r\n\t}\r\n\t\r\n\tvec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);\r\n\tcolor -= noise(fragCoord.xy)*.015;\r\n\tcolor = cc(color,.5,.1);\r\n\tfragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"/* This is free and unencumbered software released into the public domain. https://unlicense.org/\r\n\r\nTrying to get some interesting looking lens flares, seems like it worked. \r\nSee https://www.shadertoy.com/view/lsBGDK for a more avanced, generalized solution\r\n\r\nIf you find this useful send me an email at peterekepeter at gmail dot com, \r\nI've seen this shader pop up before in other works, but I'm curious where it ends up.\r\n\r\nIf you want to use it, feel free to do so, there is no need to credit but it is appreciated.\r\n\r\n\r\nUsed in:\r\n\r\n Water World - https://www.shadertoy.com/view/lslGDB\r\n\r\n Floating Mountains - https://www.shadertoy.com/view/XsSGDy\r\n \r\n Clouds and Sun With Flare - https://www.shadertoy.com/view/4sl3zl\r\n \r\n musk's lens flare mod - https://www.shadertoy.com/view/XdfXRX\r\n\r\n Land of Dreams - https://github.com/Tomius/LoD\r\n\r\n Where is Starman? - https://spacein3d.com/starman\r\n\r\n\r\nChangelog:\r\n\r\n 13/08/13: \r\n\tfirst published\r\n\r\n 17/11/27\r\n    fixed seam, thanks to Shane\r\n\r\n 19/08/08:\r\n    updated description and license change\r\n\r\n 20/06/24:\r\n    renamed to Lens Flare Example, updated description\r\n\r\n*/\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat noise(float t)\r\n{\r\n\treturn value_noise(vec2(t,.0)/iResolution.xy*234.0);\r\n}\r\nfloat noise(vec2 t)\r\n{\r\n\treturn value_noise(t/iResolution.xy*234.0);\r\n}\r\n\r\nvec3 lensflare(vec2 uv,vec2 pos)\r\n{\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat ang = atan(main.x,main.y);\r\n\tfloat dist=length(main); dist = pow(dist,.1);\r\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\r\n\t\r\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tf0 = f0 + f0*(sin(noise(sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-.4);\r\n\t\r\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\r\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\r\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\r\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\r\n\tc = c*1.3 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\r\n{\r\n\tfloat w = color.x+color.y+color.z;\r\n\treturn mix(color,vec3(w)*factor,w*factor2);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\r\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tif (iMouse.z<.5)\r\n\t{\r\n\t\tmouse.x=sin(iTime)*.5;\r\n\t\tmouse.y=sin(iTime*.913)*.5;\r\n\t}\r\n\t\r\n\tvec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);\r\n\tcolor -= noise(fragCoord.xy)*.015;\r\n\tcolor = cc(color,.5,.1);\r\n\tfragColor = vec4(color,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Lens Flare Example ","id":"9e980511f9714413b8dab7400641a73f","date":null,"viewed":0,"name":"Lens Flare Example ","description":"Trying to get some interesting looking lens flares.\nhttps://www.shadertoy.com/view/4sX3Rs","likes":0,"published":null,"tags":["2d"," lens"," flare"]},"ver":null,"info":{"Name":"Lens Flare Example ","id":"9e980511f9714413b8dab7400641a73f","date":null,"viewed":0,"name":"Lens Flare Example ","description":"Trying to get some interesting looking lens flares.\nhttps://www.shadertoy.com/view/4sX3Rs","likes":0,"published":null,"tags":["2d"," lens"," flare"]},"renderpass":[{"Code":"/* This is free and unencumbered software released into the public domain. https://unlicense.org/\r\n\r\nTrying to get some interesting looking lens flares, seems like it worked. \r\nSee https://www.shadertoy.com/view/lsBGDK for a more avanced, generalized solution\r\n\r\nIf you find this useful send me an email at peterekepeter at gmail dot com, \r\nI've seen this shader pop up before in other works, but I'm curious where it ends up.\r\n\r\nIf you want to use it, feel free to do so, there is no need to credit but it is appreciated.\r\n\r\n\r\nUsed in:\r\n\r\n Water World - https://www.shadertoy.com/view/lslGDB\r\n\r\n Floating Mountains - https://www.shadertoy.com/view/XsSGDy\r\n \r\n Clouds and Sun With Flare - https://www.shadertoy.com/view/4sl3zl\r\n \r\n musk's lens flare mod - https://www.shadertoy.com/view/XdfXRX\r\n\r\n Land of Dreams - https://github.com/Tomius/LoD\r\n\r\n Where is Starman? - https://spacein3d.com/starman\r\n\r\n\r\nChangelog:\r\n\r\n 13/08/13: \r\n\tfirst published\r\n\r\n 17/11/27\r\n    fixed seam, thanks to Shane\r\n\r\n 19/08/08:\r\n    updated description and license change\r\n\r\n 20/06/24:\r\n    renamed to Lens Flare Example, updated description\r\n\r\n*/\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat noise(float t)\r\n{\r\n\treturn value_noise(vec2(t,.0)/iResolution.xy*234.0);\r\n}\r\nfloat noise(vec2 t)\r\n{\r\n\treturn value_noise(t/iResolution.xy*234.0);\r\n}\r\n\r\nvec3 lensflare(vec2 uv,vec2 pos)\r\n{\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat ang = atan(main.x,main.y);\r\n\tfloat dist=length(main); dist = pow(dist,.1);\r\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\r\n\t\r\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tf0 = f0 + f0*(sin(noise(sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-.4);\r\n\t\r\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\r\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\r\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\r\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\r\n\tc = c*1.3 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\r\n{\r\n\tfloat w = color.x+color.y+color.z;\r\n\treturn mix(color,vec3(w)*factor,w*factor2);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\r\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tif (iMouse.z<.5)\r\n\t{\r\n\t\tmouse.x=sin(iTime)*.5;\r\n\t\tmouse.y=sin(iTime*.913)*.5;\r\n\t}\r\n\t\r\n\tvec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);\r\n\tcolor -= noise(fragCoord.xy)*.015;\r\n\tcolor = cc(color,.5,.1);\r\n\tfragColor = vec4(color,1.0);\r\n}","inputs":[],"outputs":[],"code":"/* This is free and unencumbered software released into the public domain. https://unlicense.org/\r\n\r\nTrying to get some interesting looking lens flares, seems like it worked. \r\nSee https://www.shadertoy.com/view/lsBGDK for a more avanced, generalized solution\r\n\r\nIf you find this useful send me an email at peterekepeter at gmail dot com, \r\nI've seen this shader pop up before in other works, but I'm curious where it ends up.\r\n\r\nIf you want to use it, feel free to do so, there is no need to credit but it is appreciated.\r\n\r\n\r\nUsed in:\r\n\r\n Water World - https://www.shadertoy.com/view/lslGDB\r\n\r\n Floating Mountains - https://www.shadertoy.com/view/XsSGDy\r\n \r\n Clouds and Sun With Flare - https://www.shadertoy.com/view/4sl3zl\r\n \r\n musk's lens flare mod - https://www.shadertoy.com/view/XdfXRX\r\n\r\n Land of Dreams - https://github.com/Tomius/LoD\r\n\r\n Where is Starman? - https://spacein3d.com/starman\r\n\r\n\r\nChangelog:\r\n\r\n 13/08/13: \r\n\tfirst published\r\n\r\n 17/11/27\r\n    fixed seam, thanks to Shane\r\n\r\n 19/08/08:\r\n    updated description and license change\r\n\r\n 20/06/24:\r\n    renamed to Lens Flare Example, updated description\r\n\r\n*/\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat noise(float t)\r\n{\r\n\treturn value_noise(vec2(t,.0)/iResolution.xy*234.0);\r\n}\r\nfloat noise(vec2 t)\r\n{\r\n\treturn value_noise(t/iResolution.xy*234.0);\r\n}\r\n\r\nvec3 lensflare(vec2 uv,vec2 pos)\r\n{\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat ang = atan(main.x,main.y);\r\n\tfloat dist=length(main); dist = pow(dist,.1);\r\n\tfloat n = noise(vec2(ang*16.0,dist*32.0));\r\n\t\r\n\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tf0 = f0 + f0*(sin(noise(sin(ang*2.+pos.x)*4.0 - cos(ang*3.+pos.y))*16.)*.1 + dist*.1 + .8);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-.4);\r\n\t\r\n\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\r\n\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\r\n\t\r\n\tuvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\r\n\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\r\n\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\r\n\tc = c*1.3 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\r\n{\r\n\tfloat w = color.x+color.y+color.z;\r\n\treturn mix(color,vec3(w)*factor,w*factor2);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\r\n\tmouse.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n\tif (iMouse.z<.5)\r\n\t{\r\n\t\tmouse.x=sin(iTime)*.5;\r\n\t\tmouse.y=sin(iTime*.913)*.5;\r\n\t}\r\n\t\r\n\tvec3 color = vec3(1.4,1.2,1.0)*lensflare(uv,mouse.xy);\r\n\tcolor -= noise(fragCoord.xy)*.015;\r\n\tcolor = cc(color,.5,.1);\r\n\tfragColor = vec4(color,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Mandelbrot Set Render","id":"wtlSW8","date":"1562830347","viewed":89,"name":"Mandelbrot Set Render","description":"mandelbrot set Render2\nreferences:\nhttps://www.shadertoy.com/view/lsX3W4\n","likes":1,"published":"Public","tags":["fractal"]},"ver":"0.1","info":{"Name":"Mandelbrot Set Render","id":"wtlSW8","date":"1562830347","viewed":89,"name":"Mandelbrot Set Render","description":"mandelbrot set Render2\nreferences:\nhttps://www.shadertoy.com/view/lsX3W4\n","likes":1,"published":"Public","tags":["fractal"]},"renderpass":[{"Code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\t\n\tfloat tz = 0.5 - 0.5*cos(0.225*iTime);\n    float zoo = pow( 0.5, 13.0*tz );//[1/2^12,1]\n\tvec2 c = vec2(-0.05,.6805) + p*zoo;\n\n    // iterate\n    bool isIn = true;\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    for( int i=0; i<200; i++ )\n    {\n        if( m2>1024.0 ) { isIn=false; break; }\n\n\t\t// Z' -> 2\u00B7Z\u00B7Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> Z\u00B2 + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n    }\n\n    // distance\t\n\t// d(c) = |Z|\u00B7log|Z|/|Z'|\n    float d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    if (isIn)\n        d = 0.0;\n\t\n    // estimate density in the pixel area\n    vec2 pixelScale = vec2(zoo/iResolution.y*iResolution.x/iResolution.y,zoo/iResolution.y);\n    float pixelArea = pixelScale.x * pixelScale.y;\n    float k = 2.0;\n    float density = clamp((pixelArea - 3.1415926*d*d*k)/pixelArea, 0.0, 1.0);\n    density = pow(density,3.0);\n                  \n    vec3 col = vec3( mix(1.0,0.0,density) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Marble Material","id":"Wtc3DM","date":"1576576570","viewed":47,"name":"Marble Material","description":"\u7A0B\u5E8F\u6027\u7684\u5927\u7406\u77F3\u6750\u8D28\uFF0C\u770B\u8D77\u6765\u66F4\u50CF\u62FC\u5408\u677F","likes":2,"published":"Public","tags":["marble","fractalnoise"]},"ver":"0.1","info":{"Name":"Marble Material","id":"Wtc3DM","date":"1576576570","viewed":47,"name":"Marble Material","description":"\u7A0B\u5E8F\u6027\u7684\u5927\u7406\u77F3\u6750\u8D28\uFF0C\u770B\u8D77\u6765\u66F4\u50CF\u62FC\u5408\u677F","likes":2,"published":"Public","tags":["marble","fractalnoise"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\n#define PALE_BLUE vec3(0.25,0.25,0.35)\n#define MEDIUM_BLUE vec3(0.10,0.10,0.30)\n#define DARK_BLUE vec3(0.05,0.05,0.26)\n#define DARKER_BLUE vec3(0.03,0.03,0.20)\n\n#define Ambient vec3(0.1,0.1,0.1)\n\n#define NearClipPlaneDist 2.0\n\n#define AA 2\n\nfloat hash31(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise3d( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    return mix(mix(mix( hash31(i+vec3(0,0,0)), \n                        hash31(i+vec3(1,0,0)),f.x),\n                   mix( hash31(i+vec3(0,1,0)), \n                        hash31(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash31(i+vec3(0,0,1)), \n                        hash31(i+vec3(1,0,1)),f.x),\n                   mix( hash31(i+vec3(0,1,1)), \n                        hash31(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat marble(vec3 p){\n    float m = 0.0;\n    float f = 1.0;\n    for(float i = 0.0; i < 4.0; i += 1.0){\n        m += noise3d(p*f)/f;\n        f*=2.17;\n    }\n    return m;\n}\n\n//\u6839\u636Em\u5728colors[1]\u5230colors[n-1]\u4E4B\u95F4\u8FDB\u884C\u6837\u6761\u7EBF\u63D2\u503C\nvec3 marbleColor(float m){\n    m = clamp(m,0.0,1.0);\n    float nspan = 10.0;\n    vec3 colors[13];\n    colors[0]=PALE_BLUE;\n    colors[1]=PALE_BLUE;\n    colors[2]=MEDIUM_BLUE;\n    colors[3]=MEDIUM_BLUE;\n    colors[4]=MEDIUM_BLUE;\n    colors[5]=PALE_BLUE;\n    colors[6]=PALE_BLUE;\n    colors[7]=DARK_BLUE;\n    colors[8]=DARK_BLUE;\n    colors[9]=DARKER_BLUE;\n    colors[10]=DARKER_BLUE;\n    colors[11]=PALE_BLUE;\n    colors[12]=DARKER_BLUE;\n    colors[12]=DARKER_BLUE;\n    \n    m = clamp(m,0.0,1.0)*nspan;\n    float span = floor(m);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    m -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    vec3 c3 = CR00*colors[p0] + CR01*colors[p1] + CR02*colors[p2] + CR03*colors[p3];\n    vec3 c2 = CR10*colors[p0] + CR11*colors[p1] + CR12*colors[p2] + CR13*colors[p3];\n    vec3 c1 = CR20*colors[p0] + CR21*colors[p1] + CR22*colors[p2] + CR23*colors[p3];\n    vec3 c0 = CR30*colors[p0] + CR31*colors[p1] + CR32*colors[p2] + CR33*colors[p3];\n    return ((c3*m+c2)*m+c1)*m+c0;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n    res = opU(res, vec2(sdBox(pos, vec3(1.5,0.1,1.0)),1));\n    //res = opU(res, vec2(sdSphere(pos + vec3(0,-1,0), 1.0),1));\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 normal = vec3(0,0,0);\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = Ambient;\n    } else {\n        float ma = marble(pos*2.0);\n        ma = 0.5*ma;\n        col = marbleColor(ma);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    \n    vec3 lookAtPos = vec3(0,0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 pixelPosInCameraCoor = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(pixelPosInCameraCoor.xy, NearClipPlaneDist));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    sum /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(sum, 1);\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Moon craters","id":"3dd2b8aeda434ee7ac8f0e4cccb86100","date":null,"viewed":0,"name":"Moon craters","description":"Trying to mimic a moon surface with craters ","likes":0,"published":null,"tags":["3d"," moon"," craters"]},"ver":null,"info":{"Name":"Moon craters","id":"3dd2b8aeda434ee7ac8f0e4cccb86100","date":null,"viewed":0,"name":"Moon craters","description":"Trying to mimic a moon surface with craters ","likes":0,"published":null,"tags":["3d"," moon"," craters"]},"renderpass":[{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S.Guillitte\r\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\r\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\r\n\r\n#define PI 3.14159265358979\r\n\r\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\r\n\r\n\r\nfloat hash( in vec3 p ) \r\n{\r\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\r\n}\r\n\r\nvec3 hash3( in vec3 p )\r\n{\r\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\r\n}\r\n\r\n//mat2 m2= mat2(.8,.6,-.6,.8);\r\n\r\n\r\nfloat voronoi3(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float v = .8;//cell variability <1.   \r\n    float va = 0.0;\r\n   \tfloat wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++) \r\n    for (int k=-1; k<=1; k++)    \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;\r\n        vec3 h = hash3((ip - o));\r\n        vec3 pp = fp +o  -h;\r\n        float d = dot(pp, pp);\r\n        float w = exp(-d*4.5);\r\n        wt +=w;\r\n       \r\n\t}    \r\n    return pow(wt-.7,4.);\r\n}\r\n\r\n\r\n  \r\n\r\n//concentric waves variant\r\nfloat gavoronoi3b(in vec3 p)\r\n{    \r\n    vec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\r\n    float v = .8;//cell variability <1.\r\n    float va = 0.0;\r\n    float wt = 0.0;\r\n    for (int i=-1; i<=1; i++) \r\n\tfor (int j=-1; j<=1; j++)\r\n    for (int k=-1; k<=1; k++)     \r\n\t{\t\t\r\n        vec3 o = vec3(i, j, k)-.5;       \t\t\r\n        vec3 pp = fp +o  - v*hash3(ip - o);\r\n        float d = length(pp);\r\n        float w = exp(-d*4.);\r\n        wt +=w;\r\n        va +=sin(sqrt(d)*f)*w;\r\n\t}    \r\n    return va/wt;\r\n}\r\n\r\n\r\n\r\nfloat fbmabs( vec3 p ) {\r\n\t\r\n\tfloat f=1.2;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<5;i++){\t\r\n\t\tr += abs(gavoronoi3b( p*f ))/f;       \r\n\t    f *=2.3;\r\n\t}\r\n\treturn r/2.;\r\n}\r\n\r\nfloat fbm( vec3 p ) {\r\n\t\r\n\tfloat f=1.;\r\n   \r\n\tfloat r = 0.0;\t\r\n    for(int i = 0;i<3;i++){\t\r\n\t\tr += voronoi3( p*f )/f;       \r\n\t    f *=2.;\r\n\t}\r\n\treturn r/4.;\r\n}\r\n\r\nfloat map(vec3 p){\r\n\r\n    \r\n    return 1.2*fbmabs(p);\r\n}\r\n\r\nvec3 calcNormal(in vec3 p)\r\n{\r\n\tconst vec2 e = vec2(0.00001, 0.0);\r\n\treturn normalize(p*.00002+vec3(\r\n\t\tmap(p + e.xyy) - map(p - e.xyy),\r\n\t\tmap(p + e.yxy) - map(p - e.yxy),\r\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\r\n}\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time+1.);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\tvec3 li = normalize(vec3(0.5, 1.8, 3.0));\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\r\n\r\n\tfloat c;\r\n    \r\n   \tif (tmm.x<0.)c =  fbm(40.*rd)/2.+fbm(80.*rd)/1.5;\r\n    else c= map(ro+rd*tmm.x)/2.;\r\n    vec3 col = vec3( c*c*.8,c*c,c*.5);\r\n    if (tmm.x>0.){\r\n        \r\n        float k = dot(ro+rd*tmm.x, li);\r\n        col*=.4;\r\n        if(k>0.){\r\n            \r\n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\r\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.5,.55,.84);\r\n        }\r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    //col =  1.5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n\t\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// see also full black body spectrum: https://www.shadertoy.com/view/4tdGWM\r\n// deeper in fluids: https://www.shadertoy.com/view/XldGDM\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n    U /= iResolution.xy;\r\n    float y = 2.* U.y; \r\n    \r\n    O = \r\n    // secret 1 for natural colors for luminous phenomena:\r\n    // - real-life color spectrum is never zero in any channel\r\n    // - intensities are 0 to infinity\r\n    // - captors (camera,eye) saturates early\r\n\ty > 1. ? vec4(1,1./4.,1./16.,1) * exp(4.*U.x - 1.)  // i.e. exp(T) * exp(-z)\r\n\r\n    // secret 2 for natural colors for volumetric phenomena:\r\n    // - transparency decrease as the power of distance ( T^l )\r\n    // - T value varies with frequency ( i.e. color channel )\r\n    // - real life transparency is never exactly 1 at any frequency\r\n   : pow(vec4(.1, .7, .8, 1), vec4(4.*U.x));\r\n        \r\n    \r\n}","inputs":[],"outputs":[],"code":"// see also full black body spectrum: https://www.shadertoy.com/view/4tdGWM\r\n// deeper in fluids: https://www.shadertoy.com/view/XldGDM\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n    U /= iResolution.xy;\r\n    float y = 2.* U.y; \r\n    \r\n    O = \r\n    // secret 1 for natural colors for luminous phenomena:\r\n    // - real-life color spectrum is never zero in any channel\r\n    // - intensities are 0 to infinity\r\n    // - captors (camera,eye) saturates early\r\n\ty > 1. ? vec4(1,1./4.,1./16.,1) * exp(4.*U.x - 1.)  // i.e. exp(T) * exp(-z)\r\n\r\n    // secret 2 for natural colors for volumetric phenomena:\r\n    // - transparency decrease as the power of distance ( T^l )\r\n    // - T value varies with frequency ( i.e. color channel )\r\n    // - real life transparency is never exactly 1 at any frequency\r\n   : pow(vec4(.1, .7, .8, 1), vec4(4.*U.x));\r\n        \r\n    \r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"natural colors (fire, water,...) ","id":"bbd447266c924ea1abaaa7ea51aac8e4","date":null,"viewed":0,"name":"natural colors (fire, water,...) ","description":".non-linearity creates variations of chrominance\nsimple natural ones:  saturation (clamp) and multiplication (pow, exp)\nhttps://www.shadertoy.com/view/MlcGD7","likes":0,"published":null,"tags":["tutorial"," color"," sky"," blackbody"]},"ver":null,"info":{"Name":"natural colors (fire, water,...) ","id":"bbd447266c924ea1abaaa7ea51aac8e4","date":null,"viewed":0,"name":"natural colors (fire, water,...) ","description":".non-linearity creates variations of chrominance\nsimple natural ones:  saturation (clamp) and multiplication (pow, exp)\nhttps://www.shadertoy.com/view/MlcGD7","likes":0,"published":null,"tags":["tutorial"," color"," sky"," blackbody"]},"renderpass":[{"Code":"// see also full black body spectrum: https://www.shadertoy.com/view/4tdGWM\r\n// deeper in fluids: https://www.shadertoy.com/view/XldGDM\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n    U /= iResolution.xy;\r\n    float y = 2.* U.y; \r\n    \r\n    O = \r\n    // secret 1 for natural colors for luminous phenomena:\r\n    // - real-life color spectrum is never zero in any channel\r\n    // - intensities are 0 to infinity\r\n    // - captors (camera,eye) saturates early\r\n\ty > 1. ? vec4(1,1./4.,1./16.,1) * exp(4.*U.x - 1.)  // i.e. exp(T) * exp(-z)\r\n\r\n    // secret 2 for natural colors for volumetric phenomena:\r\n    // - transparency decrease as the power of distance ( T^l )\r\n    // - T value varies with frequency ( i.e. color channel )\r\n    // - real life transparency is never exactly 1 at any frequency\r\n   : pow(vec4(.1, .7, .8, 1), vec4(4.*U.x));\r\n        \r\n    \r\n}","inputs":[],"outputs":[],"code":"// see also full black body spectrum: https://www.shadertoy.com/view/4tdGWM\r\n// deeper in fluids: https://www.shadertoy.com/view/XldGDM\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n    U /= iResolution.xy;\r\n    float y = 2.* U.y; \r\n    \r\n    O = \r\n    // secret 1 for natural colors for luminous phenomena:\r\n    // - real-life color spectrum is never zero in any channel\r\n    // - intensities are 0 to infinity\r\n    // - captors (camera,eye) saturates early\r\n\ty > 1. ? vec4(1,1./4.,1./16.,1) * exp(4.*U.x - 1.)  // i.e. exp(T) * exp(-z)\r\n\r\n    // secret 2 for natural colors for volumetric phenomena:\r\n    // - transparency decrease as the power of distance ( T^l )\r\n    // - T value varies with frequency ( i.e. color channel )\r\n    // - real life transparency is never exactly 1 at any frequency\r\n   : pow(vec4(.1, .7, .8, 1), vec4(4.*U.x));\r\n        \r\n    \r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// --- adapted from 3D noise of inigo quilez \r\n// https://www.shadertoy.com/view/XslGRr\r\n\r\n#define FULL_PROCEDURAL\r\n#ifdef FULL_PROCEDURAL\r\n\r\n// hash based 3d value noise\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n#else\r\n\r\n// LUT based 3d value noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\n#define mynoise(q) (1.-abs(2.*noise(q)-1.))\r\n\r\nfloat fbm( in vec3 q )\r\n{\r\n\tfloat f;\r\n    f  = 0.5000*mynoise( q ); q = q*2.02;\r\n    f += 0.2500*mynoise( q ); q = q*2.03;\r\n    f += 0.1250*mynoise( q ); q = q*2.01;\r\n    f += 0.0625*mynoise( q );\r\n\treturn f;\r\n}\r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel1,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// shape\r\nvec4 map( in vec3 p )\r\n{\r\n\t\r\n\tfloat l = length(p);\r\n\t\r\n\t// profile: \r\n\t//    dens max on sphere shell l = 1\r\n\t//    density slope stiffer inside (shockwave)\r\n\tfloat d = 1. - l;\r\n    if (d>0.) d = -3.*d;\r\n\t// d = -sqrt(-d);\r\n\t\r\n\t// add noise to profile.\r\n\t// noise = supercondensed \"fire\" fbm \r\n\tfloat n = pow(fbm(p),4.);\r\n\td += 2.5 * n;\r\n\r\n\t// volume cut, for debug\r\n\tif (key_toggle(32.))  if (p.x>0.) d = 0.;\r\n\t\r\n\tvec4 res;\r\n\tres.w = clamp(d, 0., 1. ); // density\r\n\t// color: orange on the shell then darkening red\r\n\tres.xyz = vec3(1./pow(l*1.,1.),.6/pow(l,3.),0.); \r\n\t// transparent blue inside\r\n\tif (!key_toggle(66.)) \r\n\t\tif ((l<1.) && (res.w==0.)) res += vec4(0.,0.,1.,.1);\r\n\t\r\n\treturn clamp(res, 0.0, 1.0 );;\r\n}\r\n\r\n\r\n\r\nvec4 raymarch( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 sum = vec4(0, 0, 0, 0);\r\n\r\n\tfloat t = 0.0;\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\tif( sum.a > 0.99 ) continue;\r\n\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tvec4 col = map( pos ); // .w = density\r\n\t\t\r\n\tif (key_toggle(79.))  // Ombrage\r\n\t{\r\n\t\tvec3 sundir = -normalize(pos); // vec3(-1.0,0.0,0.0);\r\n#define EPS .3\t\r\n\t\tfloat dif = (col.w - map(pos+EPS*sundir).w)/EPS; // grad(dens).L\r\n\r\n\t\tcol.xyz *= .5+.5*clamp(.5*dif, 0.,1.);\r\n\t}\r\n\t\t\r\n\t\tcol.a *= 0.35;\r\n\t\tcol.rgb *= col.a;\r\n\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\t\tt += max(0.1,0.025*t);\r\n\t}\r\n\r\n\tsum.xyz /= (0.001+sum.w);\r\n\r\n\treturn clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = 2.*(fragCoord.xy / iResolution.y -vec2(.8,.7));\r\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\r\n    \r\n    // camera\r\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\r\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\r\n\r\n\t\r\n    vec4 col = raymarch( ro, rd );\r\n\r\n\tvec4 sky;\r\n\t//sky = vec4(1.,1.,1.,1.); \r\n\tsky = vec4(.1,.0,.0,1.);\r\n    fragColor = mix(sky,col,col.w);\r\n}\r\n","inputs":[],"outputs":[],"code":"// --- adapted from 3D noise of inigo quilez \r\n// https://www.shadertoy.com/view/XslGRr\r\n\r\n#define FULL_PROCEDURAL\r\n#ifdef FULL_PROCEDURAL\r\n\r\n// hash based 3d value noise\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n#else\r\n\r\n// LUT based 3d value noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\n#define mynoise(q) (1.-abs(2.*noise(q)-1.))\r\n\r\nfloat fbm( in vec3 q )\r\n{\r\n\tfloat f;\r\n    f  = 0.5000*mynoise( q ); q = q*2.02;\r\n    f += 0.2500*mynoise( q ); q = q*2.03;\r\n    f += 0.1250*mynoise( q ); q = q*2.01;\r\n    f += 0.0625*mynoise( q );\r\n\treturn f;\r\n}\r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel1,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// shape\r\nvec4 map( in vec3 p )\r\n{\r\n\t\r\n\tfloat l = length(p);\r\n\t\r\n\t// profile: \r\n\t//    dens max on sphere shell l = 1\r\n\t//    density slope stiffer inside (shockwave)\r\n\tfloat d = 1. - l;\r\n    if (d>0.) d = -3.*d;\r\n\t// d = -sqrt(-d);\r\n\t\r\n\t// add noise to profile.\r\n\t// noise = supercondensed \"fire\" fbm \r\n\tfloat n = pow(fbm(p),4.);\r\n\td += 2.5 * n;\r\n\r\n\t// volume cut, for debug\r\n\tif (key_toggle(32.))  if (p.x>0.) d = 0.;\r\n\t\r\n\tvec4 res;\r\n\tres.w = clamp(d, 0., 1. ); // density\r\n\t// color: orange on the shell then darkening red\r\n\tres.xyz = vec3(1./pow(l*1.,1.),.6/pow(l,3.),0.); \r\n\t// transparent blue inside\r\n\tif (!key_toggle(66.)) \r\n\t\tif ((l<1.) && (res.w==0.)) res += vec4(0.,0.,1.,.1);\r\n\t\r\n\treturn clamp(res, 0.0, 1.0 );;\r\n}\r\n\r\n\r\n\r\nvec4 raymarch( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 sum = vec4(0, 0, 0, 0);\r\n\r\n\tfloat t = 0.0;\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\tif( sum.a > 0.99 ) continue;\r\n\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tvec4 col = map( pos ); // .w = density\r\n\t\t\r\n\tif (key_toggle(79.))  // Ombrage\r\n\t{\r\n\t\tvec3 sundir = -normalize(pos); // vec3(-1.0,0.0,0.0);\r\n#define EPS .3\t\r\n\t\tfloat dif = (col.w - map(pos+EPS*sundir).w)/EPS; // grad(dens).L\r\n\r\n\t\tcol.xyz *= .5+.5*clamp(.5*dif, 0.,1.);\r\n\t}\r\n\t\t\r\n\t\tcol.a *= 0.35;\r\n\t\tcol.rgb *= col.a;\r\n\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\t\tt += max(0.1,0.025*t);\r\n\t}\r\n\r\n\tsum.xyz /= (0.001+sum.w);\r\n\r\n\treturn clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = 2.*(fragCoord.xy / iResolution.y -vec2(.8,.7));\r\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\r\n    \r\n    // camera\r\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\r\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\r\n\r\n\t\r\n    vec4 col = raymarch( ro, rd );\r\n\r\n\tvec4 sky;\r\n\t//sky = vec4(1.,1.,1.,1.); \r\n\tsky = vec4(.1,.0,.0,1.);\r\n    fragColor = mix(sky,col,col.w);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"nebula2","id":"c368cc9712214ffcbf65556854a9646a","date":null,"viewed":0,"name":"nebula2","description":"rendering of a nebula.\nSPACE: toggle volume cut.\nB: toggle blue center \nO:  toggle shadowing\nhttps://www.shadertoy.com/view/4dBGDR","likes":0,"published":null,"tags":["volumelighting"]},"ver":null,"info":{"Name":"nebula2","id":"c368cc9712214ffcbf65556854a9646a","date":null,"viewed":0,"name":"nebula2","description":"rendering of a nebula.\nSPACE: toggle volume cut.\nB: toggle blue center \nO:  toggle shadowing\nhttps://www.shadertoy.com/view/4dBGDR","likes":0,"published":null,"tags":["volumelighting"]},"renderpass":[{"Code":"// --- adapted from 3D noise of inigo quilez \r\n// https://www.shadertoy.com/view/XslGRr\r\n\r\n#define FULL_PROCEDURAL\r\n#ifdef FULL_PROCEDURAL\r\n\r\n// hash based 3d value noise\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n#else\r\n\r\n// LUT based 3d value noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\n#define mynoise(q) (1.-abs(2.*noise(q)-1.))\r\n\r\nfloat fbm( in vec3 q )\r\n{\r\n\tfloat f;\r\n    f  = 0.5000*mynoise( q ); q = q*2.02;\r\n    f += 0.2500*mynoise( q ); q = q*2.03;\r\n    f += 0.1250*mynoise( q ); q = q*2.01;\r\n    f += 0.0625*mynoise( q );\r\n\treturn f;\r\n}\r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel1,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// shape\r\nvec4 map( in vec3 p )\r\n{\r\n\t\r\n\tfloat l = length(p);\r\n\t\r\n\t// profile: \r\n\t//    dens max on sphere shell l = 1\r\n\t//    density slope stiffer inside (shockwave)\r\n\tfloat d = 1. - l;\r\n    if (d>0.) d = -3.*d;\r\n\t// d = -sqrt(-d);\r\n\t\r\n\t// add noise to profile.\r\n\t// noise = supercondensed \"fire\" fbm \r\n\tfloat n = pow(fbm(p),4.);\r\n\td += 2.5 * n;\r\n\r\n\t// volume cut, for debug\r\n\tif (key_toggle(32.))  if (p.x>0.) d = 0.;\r\n\t\r\n\tvec4 res;\r\n\tres.w = clamp(d, 0., 1. ); // density\r\n\t// color: orange on the shell then darkening red\r\n\tres.xyz = vec3(1./pow(l*1.,1.),.6/pow(l,3.),0.); \r\n\t// transparent blue inside\r\n\tif (!key_toggle(66.)) \r\n\t\tif ((l<1.) && (res.w==0.)) res += vec4(0.,0.,1.,.1);\r\n\t\r\n\treturn clamp(res, 0.0, 1.0 );;\r\n}\r\n\r\n\r\n\r\nvec4 raymarch( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 sum = vec4(0, 0, 0, 0);\r\n\r\n\tfloat t = 0.0;\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\tif( sum.a > 0.99 ) continue;\r\n\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tvec4 col = map( pos ); // .w = density\r\n\t\t\r\n\tif (key_toggle(79.))  // Ombrage\r\n\t{\r\n\t\tvec3 sundir = -normalize(pos); // vec3(-1.0,0.0,0.0);\r\n#define EPS .3\t\r\n\t\tfloat dif = (col.w - map(pos+EPS*sundir).w)/EPS; // grad(dens).L\r\n\r\n\t\tcol.xyz *= .5+.5*clamp(.5*dif, 0.,1.);\r\n\t}\r\n\t\t\r\n\t\tcol.a *= 0.35;\r\n\t\tcol.rgb *= col.a;\r\n\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\t\tt += max(0.1,0.025*t);\r\n\t}\r\n\r\n\tsum.xyz /= (0.001+sum.w);\r\n\r\n\treturn clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = 2.*(fragCoord.xy / iResolution.y -vec2(.8,.7));\r\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\r\n    \r\n    // camera\r\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\r\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\r\n\r\n\t\r\n    vec4 col = raymarch( ro, rd );\r\n\r\n\tvec4 sky;\r\n\t//sky = vec4(1.,1.,1.,1.); \r\n\tsky = vec4(.1,.0,.0,1.);\r\n    fragColor = mix(sky,col,col.w);\r\n}\r\n","inputs":[],"outputs":[],"code":"// --- adapted from 3D noise of inigo quilez \r\n// https://www.shadertoy.com/view/XslGRr\r\n\r\n#define FULL_PROCEDURAL\r\n#ifdef FULL_PROCEDURAL\r\n\r\n// hash based 3d value noise\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n}\r\n#else\r\n\r\n// LUT based 3d value noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n#endif\r\n\r\n#define mynoise(q) (1.-abs(2.*noise(q)-1.))\r\n\r\nfloat fbm( in vec3 q )\r\n{\r\n\tfloat f;\r\n    f  = 0.5000*mynoise( q ); q = q*2.02;\r\n    f += 0.2500*mynoise( q ); q = q*2.03;\r\n    f += 0.1250*mynoise( q ); q = q*2.01;\r\n    f += 0.0625*mynoise( q );\r\n\treturn f;\r\n}\r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel1,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// shape\r\nvec4 map( in vec3 p )\r\n{\r\n\t\r\n\tfloat l = length(p);\r\n\t\r\n\t// profile: \r\n\t//    dens max on sphere shell l = 1\r\n\t//    density slope stiffer inside (shockwave)\r\n\tfloat d = 1. - l;\r\n    if (d>0.) d = -3.*d;\r\n\t// d = -sqrt(-d);\r\n\t\r\n\t// add noise to profile.\r\n\t// noise = supercondensed \"fire\" fbm \r\n\tfloat n = pow(fbm(p),4.);\r\n\td += 2.5 * n;\r\n\r\n\t// volume cut, for debug\r\n\tif (key_toggle(32.))  if (p.x>0.) d = 0.;\r\n\t\r\n\tvec4 res;\r\n\tres.w = clamp(d, 0., 1. ); // density\r\n\t// color: orange on the shell then darkening red\r\n\tres.xyz = vec3(1./pow(l*1.,1.),.6/pow(l,3.),0.); \r\n\t// transparent blue inside\r\n\tif (!key_toggle(66.)) \r\n\t\tif ((l<1.) && (res.w==0.)) res += vec4(0.,0.,1.,.1);\r\n\t\r\n\treturn clamp(res, 0.0, 1.0 );;\r\n}\r\n\r\n\r\n\r\nvec4 raymarch( in vec3 ro, in vec3 rd )\r\n{\r\n\tvec4 sum = vec4(0, 0, 0, 0);\r\n\r\n\tfloat t = 0.0;\r\n\tfor(int i=0; i<64; i++)\r\n\t{\r\n\t\tif( sum.a > 0.99 ) continue;\r\n\r\n\t\tvec3 pos = ro + t*rd;\r\n\t\tvec4 col = map( pos ); // .w = density\r\n\t\t\r\n\tif (key_toggle(79.))  // Ombrage\r\n\t{\r\n\t\tvec3 sundir = -normalize(pos); // vec3(-1.0,0.0,0.0);\r\n#define EPS .3\t\r\n\t\tfloat dif = (col.w - map(pos+EPS*sundir).w)/EPS; // grad(dens).L\r\n\r\n\t\tcol.xyz *= .5+.5*clamp(.5*dif, 0.,1.);\r\n\t}\r\n\t\t\r\n\t\tcol.a *= 0.35;\r\n\t\tcol.rgb *= col.a;\r\n\r\n\t\tsum = sum + col*(1.0 - sum.a);\t\r\n\t\tt += max(0.1,0.025*t);\r\n\t}\r\n\r\n\tsum.xyz /= (0.001+sum.w);\r\n\r\n\treturn clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = 2.*(fragCoord.xy / iResolution.y -vec2(.8,.7));\r\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\r\n    \r\n    // camera\r\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\r\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\r\n    vec3 ww = normalize( ta - ro);\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\r\n\r\n\t\r\n    vec4 col = raymarch( ro, rd );\r\n\r\n\tvec4 sky;\r\n\t//sky = vec4(1.,1.,1.,1.); \r\n\tsky = vec4(.1,.0,.0,1.);\r\n    fragColor = mix(sky,col,col.w);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Noise animation - Electric\r\n// by nimitz (stormoid.com) (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//The domain is displaced by two fbm calls one for each axis.\r\n//Turbulent fbm (aka ridged) is used for better effect.\r\n\r\n#define time iTime*0.15\r\n#define tau 6.2831853\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\n//float noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat fbm(in vec2 p)\r\n{\t\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 6.;i++)\r\n\t{\r\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\r\n\t\tz = z*2.;\r\n\t\tp = p*2.;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\nfloat dualfbm(in vec2 p)\r\n{\r\n    //get two rotated fbm calls and displace the domain\r\n\tvec2 p2 = p*.7;\r\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\r\n\tbasis = (basis-.5)*.2;\r\n\tp += basis;\r\n\t\r\n\t//coloring\r\n\treturn fbm(p*makem2(time*0.2));\r\n}\r\n\r\nfloat circ(vec2 p) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(sqrt(r));\r\n\treturn abs(mod(r*4.,tau)-3.14)*3.+.2;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//setup system\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*=4.;\r\n\t\r\n    float rz = dualfbm(p);\r\n\t\r\n\t//rings\r\n\tp /= exp(mod(time*10.,3.14159));\r\n\trz *= pow(abs((0.1-circ(p))),.9);\r\n\t\r\n\t//final color\r\n\tvec3 col = vec3(.2,0.1,0.4)/rz;\r\n\tcol=pow(abs(col),vec3(.99));\r\n\tfragColor = vec4(col,1.);\r\n}","inputs":[],"outputs":[],"code":"// Noise animation - Electric\r\n// by nimitz (stormoid.com) (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//The domain is displaced by two fbm calls one for each axis.\r\n//Turbulent fbm (aka ridged) is used for better effect.\r\n\r\n#define time iTime*0.15\r\n#define tau 6.2831853\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\n//float noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat fbm(in vec2 p)\r\n{\t\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 6.;i++)\r\n\t{\r\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\r\n\t\tz = z*2.;\r\n\t\tp = p*2.;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\nfloat dualfbm(in vec2 p)\r\n{\r\n    //get two rotated fbm calls and displace the domain\r\n\tvec2 p2 = p*.7;\r\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\r\n\tbasis = (basis-.5)*.2;\r\n\tp += basis;\r\n\t\r\n\t//coloring\r\n\treturn fbm(p*makem2(time*0.2));\r\n}\r\n\r\nfloat circ(vec2 p) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(sqrt(r));\r\n\treturn abs(mod(r*4.,tau)-3.14)*3.+.2;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//setup system\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*=4.;\r\n\t\r\n    float rz = dualfbm(p);\r\n\t\r\n\t//rings\r\n\tp /= exp(mod(time*10.,3.14159));\r\n\trz *= pow(abs((0.1-circ(p))),.9);\r\n\t\r\n\t//final color\r\n\tvec3 col = vec3(.2,0.1,0.4)/rz;\r\n\tcol=pow(abs(col),vec3(.99));\r\n\tfragColor = vec4(col,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Noise animation - Electric","id":"04b4a594e57d4039bb1b975953e370ec","date":null,"viewed":0,"name":"Noise animation - Electric","description":"Playing with different ways of animating noise. In this version, the domain is displaced by two random fbm noise calls (one for each axis).\nhttps://www.shadertoy.com/view/ldlXRS","likes":0,"published":null,"tags":["procedural"," 2d"," noise"]},"ver":null,"info":{"Name":"Noise animation - Electric","id":"04b4a594e57d4039bb1b975953e370ec","date":null,"viewed":0,"name":"Noise animation - Electric","description":"Playing with different ways of animating noise. In this version, the domain is displaced by two random fbm noise calls (one for each axis).\nhttps://www.shadertoy.com/view/ldlXRS","likes":0,"published":null,"tags":["procedural"," 2d"," noise"]},"renderpass":[{"Code":"// Noise animation - Electric\r\n// by nimitz (stormoid.com) (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//The domain is displaced by two fbm calls one for each axis.\r\n//Turbulent fbm (aka ridged) is used for better effect.\r\n\r\n#define time iTime*0.15\r\n#define tau 6.2831853\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\n//float noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat fbm(in vec2 p)\r\n{\t\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 6.;i++)\r\n\t{\r\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\r\n\t\tz = z*2.;\r\n\t\tp = p*2.;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\nfloat dualfbm(in vec2 p)\r\n{\r\n    //get two rotated fbm calls and displace the domain\r\n\tvec2 p2 = p*.7;\r\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\r\n\tbasis = (basis-.5)*.2;\r\n\tp += basis;\r\n\t\r\n\t//coloring\r\n\treturn fbm(p*makem2(time*0.2));\r\n}\r\n\r\nfloat circ(vec2 p) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(sqrt(r));\r\n\treturn abs(mod(r*4.,tau)-3.14)*3.+.2;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//setup system\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*=4.;\r\n\t\r\n    float rz = dualfbm(p);\r\n\t\r\n\t//rings\r\n\tp /= exp(mod(time*10.,3.14159));\r\n\trz *= pow(abs((0.1-circ(p))),.9);\r\n\t\r\n\t//final color\r\n\tvec3 col = vec3(.2,0.1,0.4)/rz;\r\n\tcol=pow(abs(col),vec3(.99));\r\n\tfragColor = vec4(col,1.);\r\n}","inputs":[],"outputs":[],"code":"// Noise animation - Electric\r\n// by nimitz (stormoid.com) (twitter: @stormoid)\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//The domain is displaced by two fbm calls one for each axis.\r\n//Turbulent fbm (aka ridged) is used for better effect.\r\n\r\n#define time iTime*0.15\r\n#define tau 6.2831853\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\n//float noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat fbm(in vec2 p)\r\n{\t\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 6.;i++)\r\n\t{\r\n\t\trz+= abs((noise(p)-0.5)*2.)/z;\r\n\t\tz = z*2.;\r\n\t\tp = p*2.;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\nfloat dualfbm(in vec2 p)\r\n{\r\n    //get two rotated fbm calls and displace the domain\r\n\tvec2 p2 = p*.7;\r\n\tvec2 basis = vec2(fbm(p2-time*1.6),fbm(p2+time*1.7));\r\n\tbasis = (basis-.5)*.2;\r\n\tp += basis;\r\n\t\r\n\t//coloring\r\n\treturn fbm(p*makem2(time*0.2));\r\n}\r\n\r\nfloat circ(vec2 p) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(sqrt(r));\r\n\treturn abs(mod(r*4.,tau)-3.14)*3.+.2;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t//setup system\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*=4.;\r\n\t\r\n    float rz = dualfbm(p);\r\n\t\r\n\t//rings\r\n\tp /= exp(mod(time*10.,3.14159));\r\n\trz *= pow(abs((0.1-circ(p))),.9);\r\n\t\r\n\t//final color\r\n\tvec3 col = vec3(.2,0.1,0.4)/rz;\r\n\tcol=pow(abs(col),vec3(.99));\r\n\tfragColor = vec4(col,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Noise animation - Flow\r\n// 2014 by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/MdlXRS\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n\r\n//Somewhat inspired by the concepts behind \"flow noise\"\r\n//every octave of noise is modulated separately\r\n//with displacement using a rotated vector field\r\n\r\n//normalization is used to created \"swirls\"\r\n//usually not a good idea, depending on the type of noise\r\n//you are going for.\r\n\r\n//Sinus ridged fbm is used for better effect.\r\n\r\n#define time iTime*0.1\r\n#define tau 6.2831853\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\nfloat noise( in vec2 x ){return value_noise(x*12.);}\r\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat grid(vec2 p)\r\n{\r\n\tfloat s = sin(p.x)*cos(p.y);\r\n\treturn s;\r\n}\r\n\r\nfloat flow(in vec2 p)\r\n{\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 7.;i++ )\r\n\t{\r\n\t\tbp += time*1.5;\r\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\r\n\t\tgr = normalize(gr)*0.4;\r\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\r\n\t\tp += gr*0.5;\r\n\t\t\r\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) /z;\r\n\t\t\r\n\t\tp = mix(bp,p,.5);\r\n\t\tz *= 1.7;\r\n\t\tp *= 2.5;\r\n\t\tp*=m2;\r\n\t\tbp *= 2.5;\r\n\t\tbp*=m2;\r\n\t}\r\n\treturn rz;\t\r\n}\r\n\r\nfloat spiral(vec2 p,float scl) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(r);\r\n\tfloat a = atan(p.y, p.x);\r\n\treturn abs(mod(scl*(r-2./scl*a),tau)-1.)*2.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*= 3.;\r\n\tfloat rz = flow(p);\r\n\tp /= exp(mod(time*3.,2.1));\r\n\trz *= (6.-spiral(p,3.))*.9;\r\n\tvec3 col = vec3(.2,0.07,0.01)/rz;\r\n\tcol=pow(abs(col),vec3(1.01));\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Noise animation - Flow\r\n// 2014 by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/MdlXRS\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n\r\n//Somewhat inspired by the concepts behind \"flow noise\"\r\n//every octave of noise is modulated separately\r\n//with displacement using a rotated vector field\r\n\r\n//normalization is used to created \"swirls\"\r\n//usually not a good idea, depending on the type of noise\r\n//you are going for.\r\n\r\n//Sinus ridged fbm is used for better effect.\r\n\r\n#define time iTime*0.1\r\n#define tau 6.2831853\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\nfloat noise( in vec2 x ){return value_noise(x*12.);}\r\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat grid(vec2 p)\r\n{\r\n\tfloat s = sin(p.x)*cos(p.y);\r\n\treturn s;\r\n}\r\n\r\nfloat flow(in vec2 p)\r\n{\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 7.;i++ )\r\n\t{\r\n\t\tbp += time*1.5;\r\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\r\n\t\tgr = normalize(gr)*0.4;\r\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\r\n\t\tp += gr*0.5;\r\n\t\t\r\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) /z;\r\n\t\t\r\n\t\tp = mix(bp,p,.5);\r\n\t\tz *= 1.7;\r\n\t\tp *= 2.5;\r\n\t\tp*=m2;\r\n\t\tbp *= 2.5;\r\n\t\tbp*=m2;\r\n\t}\r\n\treturn rz;\t\r\n}\r\n\r\nfloat spiral(vec2 p,float scl) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(r);\r\n\tfloat a = atan(p.y, p.x);\r\n\treturn abs(mod(scl*(r-2./scl*a),tau)-1.)*2.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*= 3.;\r\n\tfloat rz = flow(p);\r\n\tp /= exp(mod(time*3.,2.1));\r\n\trz *= (6.-spiral(p,3.))*.9;\r\n\tvec3 col = vec3(.2,0.07,0.01)/rz;\r\n\tcol=pow(abs(col),vec3(1.01));\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Noise animation - Flow","id":"7780d394fe074db1959978331a7d2da1","date":null,"viewed":0,"name":"Noise animation - Flow","description":"Playing with different ways of animating noise. In this version, the noise is made using a technique similar to \"flow noise\" (maybe it even qualifies as flow noise)\nhttps://www.shadertoy.com/view/MdlXRS","likes":0,"published":null,"tags":["procedural"," 2d"," noise"]},"ver":null,"info":{"Name":"Noise animation - Flow","id":"7780d394fe074db1959978331a7d2da1","date":null,"viewed":0,"name":"Noise animation - Flow","description":"Playing with different ways of animating noise. In this version, the noise is made using a technique similar to \"flow noise\" (maybe it even qualifies as flow noise)\nhttps://www.shadertoy.com/view/MdlXRS","likes":0,"published":null,"tags":["procedural"," 2d"," noise"]},"renderpass":[{"Code":"// Noise animation - Flow\r\n// 2014 by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/MdlXRS\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n\r\n//Somewhat inspired by the concepts behind \"flow noise\"\r\n//every octave of noise is modulated separately\r\n//with displacement using a rotated vector field\r\n\r\n//normalization is used to created \"swirls\"\r\n//usually not a good idea, depending on the type of noise\r\n//you are going for.\r\n\r\n//Sinus ridged fbm is used for better effect.\r\n\r\n#define time iTime*0.1\r\n#define tau 6.2831853\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\nfloat noise( in vec2 x ){return value_noise(x*12.);}\r\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat grid(vec2 p)\r\n{\r\n\tfloat s = sin(p.x)*cos(p.y);\r\n\treturn s;\r\n}\r\n\r\nfloat flow(in vec2 p)\r\n{\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 7.;i++ )\r\n\t{\r\n\t\tbp += time*1.5;\r\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\r\n\t\tgr = normalize(gr)*0.4;\r\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\r\n\t\tp += gr*0.5;\r\n\t\t\r\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) /z;\r\n\t\t\r\n\t\tp = mix(bp,p,.5);\r\n\t\tz *= 1.7;\r\n\t\tp *= 2.5;\r\n\t\tp*=m2;\r\n\t\tbp *= 2.5;\r\n\t\tbp*=m2;\r\n\t}\r\n\treturn rz;\t\r\n}\r\n\r\nfloat spiral(vec2 p,float scl) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(r);\r\n\tfloat a = atan(p.y, p.x);\r\n\treturn abs(mod(scl*(r-2./scl*a),tau)-1.)*2.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*= 3.;\r\n\tfloat rz = flow(p);\r\n\tp /= exp(mod(time*3.,2.1));\r\n\trz *= (6.-spiral(p,3.))*.9;\r\n\tvec3 col = vec3(.2,0.07,0.01)/rz;\r\n\tcol=pow(abs(col),vec3(1.01));\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Noise animation - Flow\r\n// 2014 by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/MdlXRS\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n\r\n//Somewhat inspired by the concepts behind \"flow noise\"\r\n//every octave of noise is modulated separately\r\n//with displacement using a rotated vector field\r\n\r\n//normalization is used to created \"swirls\"\r\n//usually not a good idea, depending on the type of noise\r\n//you are going for.\r\n\r\n//Sinus ridged fbm is used for better effect.\r\n\r\n#define time iTime*0.1\r\n#define tau 6.2831853\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u767D\u566A\u58F0\nfloat white_noise(vec2 p){\n    return hash21(ceil(fract(0.77)*12.0)*p);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\r\nfloat noise( in vec2 x ){return value_noise(x*12.);}\r\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat grid(vec2 p)\r\n{\r\n\tfloat s = sin(p.x)*cos(p.y);\r\n\treturn s;\r\n}\r\n\r\nfloat flow(in vec2 p)\r\n{\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec2 bp = p;\r\n\tfor (float i= 1.;i < 7.;i++ )\r\n\t{\r\n\t\tbp += time*1.5;\r\n\t\tvec2 gr = vec2(grid(p*3.-time*2.),grid(p*3.+4.-time*2.))*0.4;\r\n\t\tgr = normalize(gr)*0.4;\r\n\t\tgr *= makem2((p.x+p.y)*.3+time*10.);\r\n\t\tp += gr*0.5;\r\n\t\t\r\n\t\trz+= (sin(noise(p)*8.)*0.5+0.5) /z;\r\n\t\t\r\n\t\tp = mix(bp,p,.5);\r\n\t\tz *= 1.7;\r\n\t\tp *= 2.5;\r\n\t\tp*=m2;\r\n\t\tbp *= 2.5;\r\n\t\tbp*=m2;\r\n\t}\r\n\treturn rz;\t\r\n}\r\n\r\nfloat spiral(vec2 p,float scl) \r\n{\r\n\tfloat r = length(p);\r\n\tr = log(r);\r\n\tfloat a = atan(p.y, p.x);\r\n\treturn abs(mod(scl*(r-2./scl*a),tau)-1.)*2.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n\tp*= 3.;\r\n\tfloat rz = flow(p);\r\n\tp /= exp(mod(time*3.,2.1));\r\n\trz *= (6.-spiral(p,3.))*.9;\r\n\tvec3 col = vec3(.2,0.07,0.01)/rz;\r\n\tcol=pow(abs(col),vec3(1.01));\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define SAMPLE 200      // per 1x1 pixel bin\r\n#define STEP 32.        // bin width\r\n#define LAZZY 1         // lazzy exact noise evaluation\r\n#define SMOOTH 0.       // smooth histogramm on 3 values.  0. / 1. / sub-relaxation\r\n#define NOISE_SRC 1  \t// 0: texture 1: math\r\n\r\n\r\n#define NOISE_TYPE 1    // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n\r\n#define ANIM 1          \r\n#define PI 3.14159\r\n\r\nfloat t;\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n#if NOISE_SRC==0\r\n\treturn texture(iChannel0,vec2(n,n/256.)).r;\r\n#elif NOISE_SRC==1\r\n\treturn fract(sin(n-765.36334)*43758.5453);\r\n#endif\r\n   \r\n    \r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE_TYPE==1\r\n\treturn res;\r\n#elif NOISE_TYPE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE_TYPE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n// for noise to be thresholded, we not always need to compute high freq\r\n\r\nfloat fbm_lazzy( vec3 p , float v0, float v1) // v0,v1: min/max thresholds\r\n{\r\n    float v01 = .5*(v0+v1), dv = .5*(v1-v0);\r\n\tfloat s=1.,f,r=1.,t;\r\n\t\r\n\t              s*=.5; f  = s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.02; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.03; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r;\r\n\tp = m*p*2.01; s*=.5; f += s*noise( p );\r\n\r\n    return f;\r\n}\r\n\r\n\r\n// calc histogramm of noise\r\n\r\nfloat histogramm(vec2 uv) {\r\n\tfloat dx = dFdx(uv.x)*STEP;   // slice size\r\n\tfloat s = 0., q=0., n;\r\n#if ANIM\r\n  float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\t\r\n\tfor (int j=0; j<= SAMPLE; j++)\r\n\t{\r\n\t\tfloat y = float(j)/float(SAMPLE);\r\n#if !LAZZY\r\n\t\tn = fbm(8.*vec3(0.,y,t));\r\n#else\r\n\t\tn = fbm_lazzy(8.*vec3(0.,y,t), uv.x, uv.x+dx);\r\n#endif\r\n\r\n\t\tif (abs(n-uv.x) < .5*dx) s++;\r\n\t\tq++;\r\n\t}\r\n\treturn .1*s/(q*dx);\r\n}\r\n\r\n\r\n// smmothing using hardware derivatives. if SMOOTH <1, sub-relaxation\r\n\r\nfloat smoothf(float v)\r\n{\r\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\r\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\r\n\r\n\treturn v + SMOOTH*(vx+vy)/3.;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    FragCoord=fragCoord;\r\n\tvec3 col=vec3(0.);\r\n\tif (uv.y < exp(-.5*pow((uv.x-.5)/.15,2.))*.5) col = vec3(0.,0.,.5);\r\n\tif (mod(uv.y,.1)<=1./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.y,.5)<=4./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.x,.1)<=1./iResolution.x) col = vec3(1.,0.,0.);\r\n\tif (mod(uv.x,.5)<=4./iResolution.x) col = vec3(1.,0.,0.);\r\n\t\r\n\t\r\n\tfloat t = histogramm(uv);\r\n\t\r\n\tif (SMOOTH != 0.) t = smoothf(t);  // average with neightboor pixels\r\n\tif (t > uv.y)  col=vec3(1.);\t\t     // draw bar\r\n\t\r\n\tfragColor = vec4(col,1.); \r\n}\r\n","inputs":[],"outputs":[],"code":"#define SAMPLE 200      // per 1x1 pixel bin\r\n#define STEP 32.        // bin width\r\n#define LAZZY 1         // lazzy exact noise evaluation\r\n#define SMOOTH 0.       // smooth histogramm on 3 values.  0. / 1. / sub-relaxation\r\n#define NOISE_SRC 1  \t// 0: texture 1: math\r\n\r\n\r\n#define NOISE_TYPE 1    // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n\r\n#define ANIM 1          \r\n#define PI 3.14159\r\n\r\nfloat t;\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n#if NOISE_SRC==0\r\n\treturn texture(iChannel0,vec2(n,n/256.)).r;\r\n#elif NOISE_SRC==1\r\n\treturn fract(sin(n-765.36334)*43758.5453);\r\n#endif\r\n   \r\n    \r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE_TYPE==1\r\n\treturn res;\r\n#elif NOISE_TYPE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE_TYPE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n// for noise to be thresholded, we not always need to compute high freq\r\n\r\nfloat fbm_lazzy( vec3 p , float v0, float v1) // v0,v1: min/max thresholds\r\n{\r\n    float v01 = .5*(v0+v1), dv = .5*(v1-v0);\r\n\tfloat s=1.,f,r=1.,t;\r\n\t\r\n\t              s*=.5; f  = s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.02; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.03; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r;\r\n\tp = m*p*2.01; s*=.5; f += s*noise( p );\r\n\r\n    return f;\r\n}\r\n\r\n\r\n// calc histogramm of noise\r\n\r\nfloat histogramm(vec2 uv) {\r\n\tfloat dx = dFdx(uv.x)*STEP;   // slice size\r\n\tfloat s = 0., q=0., n;\r\n#if ANIM\r\n  float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\t\r\n\tfor (int j=0; j<= SAMPLE; j++)\r\n\t{\r\n\t\tfloat y = float(j)/float(SAMPLE);\r\n#if !LAZZY\r\n\t\tn = fbm(8.*vec3(0.,y,t));\r\n#else\r\n\t\tn = fbm_lazzy(8.*vec3(0.,y,t), uv.x, uv.x+dx);\r\n#endif\r\n\r\n\t\tif (abs(n-uv.x) < .5*dx) s++;\r\n\t\tq++;\r\n\t}\r\n\treturn .1*s/(q*dx);\r\n}\r\n\r\n\r\n// smmothing using hardware derivatives. if SMOOTH <1, sub-relaxation\r\n\r\nfloat smoothf(float v)\r\n{\r\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\r\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\r\n\r\n\treturn v + SMOOTH*(vx+vy)/3.;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    FragCoord=fragCoord;\r\n\tvec3 col=vec3(0.);\r\n\tif (uv.y < exp(-.5*pow((uv.x-.5)/.15,2.))*.5) col = vec3(0.,0.,.5);\r\n\tif (mod(uv.y,.1)<=1./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.y,.5)<=4./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.x,.1)<=1./iResolution.x) col = vec3(1.,0.,0.);\r\n\tif (mod(uv.x,.5)<=4./iResolution.x) col = vec3(1.,0.,0.);\r\n\t\r\n\t\r\n\tfloat t = histogramm(uv);\r\n\t\r\n\tif (SMOOTH != 0.) t = smoothf(t);  // average with neightboor pixels\r\n\tif (t > uv.y)  col=vec3(1.);\t\t     // draw bar\r\n\t\r\n\tfragColor = vec4(col,1.); \r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"noise histogramm 2","id":"e41919e0fd744327ada0b1108b8953de","date":null,"viewed":0,"name":"noise histogramm 2","description":"Evaluates histogramm of Perlin noise algorithms.\nIn theory fbm should be Gaussian...\nTry larger STEP to better average.\nhttps://www.shadertoy.com/view/XdXSR8","likes":0,"published":null,"tags":["noise"," perlin"," histogramm"]},"ver":null,"info":{"Name":"noise histogramm 2","id":"e41919e0fd744327ada0b1108b8953de","date":null,"viewed":0,"name":"noise histogramm 2","description":"Evaluates histogramm of Perlin noise algorithms.\nIn theory fbm should be Gaussian...\nTry larger STEP to better average.\nhttps://www.shadertoy.com/view/XdXSR8","likes":0,"published":null,"tags":["noise"," perlin"," histogramm"]},"renderpass":[{"Code":"#define SAMPLE 200      // per 1x1 pixel bin\r\n#define STEP 32.        // bin width\r\n#define LAZZY 1         // lazzy exact noise evaluation\r\n#define SMOOTH 0.       // smooth histogramm on 3 values.  0. / 1. / sub-relaxation\r\n#define NOISE_SRC 1  \t// 0: texture 1: math\r\n\r\n\r\n#define NOISE_TYPE 1    // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n\r\n#define ANIM 1          \r\n#define PI 3.14159\r\n\r\nfloat t;\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n#if NOISE_SRC==0\r\n\treturn texture(iChannel0,vec2(n,n/256.)).r;\r\n#elif NOISE_SRC==1\r\n\treturn fract(sin(n-765.36334)*43758.5453);\r\n#endif\r\n   \r\n    \r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE_TYPE==1\r\n\treturn res;\r\n#elif NOISE_TYPE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE_TYPE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n// for noise to be thresholded, we not always need to compute high freq\r\n\r\nfloat fbm_lazzy( vec3 p , float v0, float v1) // v0,v1: min/max thresholds\r\n{\r\n    float v01 = .5*(v0+v1), dv = .5*(v1-v0);\r\n\tfloat s=1.,f,r=1.,t;\r\n\t\r\n\t              s*=.5; f  = s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.02; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.03; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r;\r\n\tp = m*p*2.01; s*=.5; f += s*noise( p );\r\n\r\n    return f;\r\n}\r\n\r\n\r\n// calc histogramm of noise\r\n\r\nfloat histogramm(vec2 uv) {\r\n\tfloat dx = dFdx(uv.x)*STEP;   // slice size\r\n\tfloat s = 0., q=0., n;\r\n#if ANIM\r\n  float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\t\r\n\tfor (int j=0; j<= SAMPLE; j++)\r\n\t{\r\n\t\tfloat y = float(j)/float(SAMPLE);\r\n#if !LAZZY\r\n\t\tn = fbm(8.*vec3(0.,y,t));\r\n#else\r\n\t\tn = fbm_lazzy(8.*vec3(0.,y,t), uv.x, uv.x+dx);\r\n#endif\r\n\r\n\t\tif (abs(n-uv.x) < .5*dx) s++;\r\n\t\tq++;\r\n\t}\r\n\treturn .1*s/(q*dx);\r\n}\r\n\r\n\r\n// smmothing using hardware derivatives. if SMOOTH <1, sub-relaxation\r\n\r\nfloat smoothf(float v)\r\n{\r\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\r\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\r\n\r\n\treturn v + SMOOTH*(vx+vy)/3.;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    FragCoord=fragCoord;\r\n\tvec3 col=vec3(0.);\r\n\tif (uv.y < exp(-.5*pow((uv.x-.5)/.15,2.))*.5) col = vec3(0.,0.,.5);\r\n\tif (mod(uv.y,.1)<=1./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.y,.5)<=4./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.x,.1)<=1./iResolution.x) col = vec3(1.,0.,0.);\r\n\tif (mod(uv.x,.5)<=4./iResolution.x) col = vec3(1.,0.,0.);\r\n\t\r\n\t\r\n\tfloat t = histogramm(uv);\r\n\t\r\n\tif (SMOOTH != 0.) t = smoothf(t);  // average with neightboor pixels\r\n\tif (t > uv.y)  col=vec3(1.);\t\t     // draw bar\r\n\t\r\n\tfragColor = vec4(col,1.); \r\n}\r\n","inputs":[],"outputs":[],"code":"#define SAMPLE 200      // per 1x1 pixel bin\r\n#define STEP 32.        // bin width\r\n#define LAZZY 1         // lazzy exact noise evaluation\r\n#define SMOOTH 0.       // smooth histogramm on 3 values.  0. / 1. / sub-relaxation\r\n#define NOISE_SRC 1  \t// 0: texture 1: math\r\n\r\n\r\n#define NOISE_TYPE 1    // 1: linear  2: blobby (abs)  3:  hairy (1-abs)\r\n\r\n\r\n#define ANIM 1          \r\n#define PI 3.14159\r\n\r\nfloat t;\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )  // base rand in [0,1]; \r\n{\r\n#if NOISE_SRC==0\r\n\treturn texture(iChannel0,vec2(n,n/256.)).r;\r\n#elif NOISE_SRC==1\r\n\treturn fract(sin(n-765.36334)*43758.5453);\r\n#endif\r\n   \r\n    \r\n}\r\n\r\nfloat noise( in vec3 x ) // base noise in [0,1]; \r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n#if NOISE_TYPE==1\r\n\treturn res;\r\n#elif NOISE_TYPE==2\r\n\treturn abs(2.*res-1.);\r\n#elif NOISE_TYPE==3\r\n\treturn 1.-abs(2.*res-1.);\r\n#endif\r\n}\r\n\r\nfloat fbm( vec3 p ) // turbulent (=fractal) noise in [0,1]; \r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\n\r\n// for noise to be thresholded, we not always need to compute high freq\r\n\r\nfloat fbm_lazzy( vec3 p , float v0, float v1) // v0,v1: min/max thresholds\r\n{\r\n    float v01 = .5*(v0+v1), dv = .5*(v1-v0);\r\n\tfloat s=1.,f,r=1.,t;\r\n\t\r\n\t              s*=.5; f  = s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.02; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r; \r\n\tp = m*p*2.03; s*=.5; f += s*noise( p ); r-=s; if (abs(f-v01)>r+dv) return f+.5*r;\r\n\tp = m*p*2.01; s*=.5; f += s*noise( p );\r\n\r\n    return f;\r\n}\r\n\r\n\r\n// calc histogramm of noise\r\n\r\nfloat histogramm(vec2 uv) {\r\n\tfloat dx = dFdx(uv.x)*STEP;   // slice size\r\n\tfloat s = 0., q=0., n;\r\n#if ANIM\r\n  float t = iTime;\r\n#else\r\n  float t = 0.; \r\n#endif\t\r\n\tfor (int j=0; j<= SAMPLE; j++)\r\n\t{\r\n\t\tfloat y = float(j)/float(SAMPLE);\r\n#if !LAZZY\r\n\t\tn = fbm(8.*vec3(0.,y,t));\r\n#else\r\n\t\tn = fbm_lazzy(8.*vec3(0.,y,t), uv.x, uv.x+dx);\r\n#endif\r\n\r\n\t\tif (abs(n-uv.x) < .5*dx) s++;\r\n\t\tq++;\r\n\t}\r\n\treturn .1*s/(q*dx);\r\n}\r\n\r\n\r\n// smmothing using hardware derivatives. if SMOOTH <1, sub-relaxation\r\n\r\nfloat smoothf(float v)\r\n{\r\n\tfloat vx = -dFdx(v)*(2.*mod(FragCoord.x-.5,2.)-1.),\r\n\t\t  vy = -dFdy(v)*(2.*mod(FragCoord.y-.5,2.)-1.);\r\n\r\n\treturn v + SMOOTH*(vx+vy)/3.;\r\n}\r\n\r\n// main loop\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    FragCoord=fragCoord;\r\n\tvec3 col=vec3(0.);\r\n\tif (uv.y < exp(-.5*pow((uv.x-.5)/.15,2.))*.5) col = vec3(0.,0.,.5);\r\n\tif (mod(uv.y,.1)<=1./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.y,.5)<=4./iResolution.y) col = vec3(0.,1.,0.);\r\n\tif (mod(uv.x,.1)<=1./iResolution.x) col = vec3(1.,0.,0.);\r\n\tif (mod(uv.x,.5)<=4./iResolution.x) col = vec3(1.,0.,0.);\r\n\t\r\n\t\r\n\tfloat t = histogramm(uv);\r\n\t\r\n\tif (SMOOTH != 0.) t = smoothf(t);  // average with neightboor pixels\r\n\tif (t > uv.y)  col=vec3(1.);\t\t     // draw bar\r\n\t\r\n\tfragColor = vec4(col,1.); \r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Noise-Based Procedural Flame","id":"Wtc3RB","date":"0","viewed":0,"name":"Noise-Based Procedural Flame","description":"\u8FC7\u7A0B\u6027\u706B\u7130","likes":0,"published":"Private","tags":["procedural","noise","flame"]},"ver":"0.1","info":{"Name":"Noise-Based Procedural Flame","id":"Wtc3RB","date":"0","viewed":0,"name":"Noise-Based Procedural Flame","description":"\u8FC7\u7A0B\u6027\u706B\u7130","likes":0,"published":"Private","tags":["procedural","noise","flame"]},"renderpass":[{"Code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CR00 -0.5\n#define CR01 1.5\n#define CR02 -1.5\n#define CR03 0.5\n#define CR10 1.0\n#define CR11 -2.5\n#define CR12 2.0\n#define CR13 -0.5\n#define CR20 -0.5\n#define CR21 0.0\n#define CR22 0.5\n#define CR23 0.0\n#define CR30 0.0\n#define CR31 1.0\n#define CR32 0.0\n#define CR33 0.0\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat spline(float x){  \n    x = clamp(x,0.0,1.0);\n    float nspan = 3.0;\n    float knots[6];\n    knots[0]=1.0;\n    knots[1]=1.0;\n    knots[2]=0.8;\n    knots[3]=0.1;\n    knots[4]=0.0;\n    knots[5]=0.0;\n    \n    x = clamp(x,0.0,1.0)*nspan;\n    float span = floor(x);\n    if(span>=nspan){\n        span = nspan - 1.0;\n    }\n    x -= span;\n    int p0 = int(span);\n    int p1 = int(span+1.0);\n    int p2 = int(span+2.0);\n    int p3 = int(span+3.0);\n    float c3 = CR00*knots[p0] + CR01*knots[p1] + CR02*knots[p2] + CR03*knots[p3];\n    float c2 = CR10*knots[p0] + CR11*knots[p1] + CR12*knots[p2] + CR13*knots[p3];\n    float c1 = CR20*knots[p0] + CR21*knots[p1] + CR22*knots[p2] + CR23*knots[p3];\n    float c0 = CR30*knots[p0] + CR31*knots[p1] + CR32*knots[p2] + CR33*knots[p3];\n    return ((c3*x+c2)*x+c1)*x+c0;\n}\n\nvec3 flame(vec2 p){\n    float anim = iTime*0.2;\n    vec2 t = p;\n    t.y += anim;\n    t.x *= 4.0;\n    t.y *= 2.0;\n    float turb;\n    float a = 1.0;\n    for(int i=0;i<5;i++){\n        turb += a*noise(vec3(t,0));\n        a /= 2.0;\n        //t.x = t.x*2.0*0.866+t.y*2.0*0.5;\n        //t.y = t.x*2.0*(-0.5)+t.y*2.0*(0.866);\n        t.x = t.x*0.866+t.x*0.5;\n        t.y = t.y*(-0.5)+t.y*(-0.866);\n        t *= 2.0;\n    }\n    \n    float flameTemperature = 0.6;\n    vec3 flameColor = vec3(1.0,flameTemperature,flameTemperature-0.2);\n    \n    float turbScale = 0.4 + 0.6*(1.0-p.y);\n    float flameDensity = (1.0/sqrt(p.y))*(abs(2.0*p.x-1.0)+turbScale*turb);\n    flameDensity = 4.5*spline(clamp(flameDensity,0.0,1.0));\n    vec3 color = flameColor*flameDensity;\n    \n    //color = vec3(turb);\n    //color = vec3(edgeDensity);\n    //color = vec3((1.0/sqrt(p.y))*(abs(2.0*p.x-1.0))+turbScale*turb);\n    //color = vec3(flameDensity);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p.y = 1.0-p.y;\n    vec3 col = flame(p);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Path to the colorful infinity","id":"b7c3b842a33a42eeb6a3da114dc57cfc","date":null,"viewed":0,"name":"Path to the colorful infinity","description":"Moving forward through layers of my \"sponge \"shader (https://www.shadertoy.com/view/MsjfDK)\r\nhttps://www.shadertoy.com/view/WtjyzR","likes":0,"published":null,"tags":["2d"," fractal"," colors"," space"," abstract"," recursive"," generative"," pseudo3d"," inversion"," layers"," symmetries"," travel"," spacefolding"]},"ver":null,"info":{"Name":"Path to the colorful infinity","id":"b7c3b842a33a42eeb6a3da114dc57cfc","date":null,"viewed":0,"name":"Path to the colorful infinity","description":"Moving forward through layers of my \"sponge \"shader (https://www.shadertoy.com/view/MsjfDK)\r\nhttps://www.shadertoy.com/view/WtjyzR","likes":0,"published":null,"tags":["2d"," fractal"," colors"," space"," abstract"," recursive"," generative"," pseudo3d"," inversion"," layers"," symmetries"," travel"," spacefolding"]},"renderpass":[{"Code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Created by Benoit Marini - 2020\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Try it fullscreen ;)\r\n// Try NUM_LAYERS 80. if your GPU can\r\n\r\n#define NUM_LAYERS 16.\r\n#define ITER 23\r\n\r\nvec4 tex(vec3 p)\r\n{\r\n    float t = iTime+78.;\r\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\r\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\r\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\r\n    return o;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 col = vec3(0);   \r\n    float t= iTime* .3;\r\n    \r\n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\r\n    {\r\n        float d = fract(i+t); // depth\r\n        float s = mix(5.,.5,d); // scale\r\n        float f = d * smoothstep(1.,.9,d); //fade\r\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\r\n    }\r\n    \r\n    col/=NUM_LAYERS;\r\n    col*=vec3(2,1.,2.);\r\n   \tcol=pow(col,vec3(.5 ));  \r\n\r\n    fragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2018\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\r\n// Youtube version: https://www.youtube.com/watch?v=q1OBrqtl7Yo\r\n\r\n#if HW_PERFORMANCE==0\r\n#define AA 1\r\n#else\r\n#define AA 2  // Change AA to 1 if it renders too slow for you\r\n#endif\r\n\r\n//#define INTERACTIVE\r\n\r\nmat3 makeBase( in vec3 w )\r\n{\r\n\tfloat k = inversesqrt(1.0-w.y*w.y);\r\n    return mat3( vec3(-w.z,0.0,w.x)*k, \r\n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\r\n                 w);\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\r\n{\r\n\tfloat b = dot( ro, rd );\r\n\tfloat c = dot( ro, ro ) - rad*rad;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt(h);\r\n\treturn vec2(-b-h,-b+h);\r\n}\r\n\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( in vec3 p, in float b, in float r )\r\n{\r\n    float h = clamp( p.z/b, 0.0, 1.0 );\r\n    return length( p - vec3(0.0,0.0,b)*h ) - r;//*(0.2+1.6*h);\r\n}\r\n\r\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\r\nvec4 inverseSF( in vec3 p, const in float n )\r\n{\r\n    const float PI = 3.14159265359;\r\n\tconst float PHI = 1.61803398875;\r\n\r\n    float phi = min(atan(p.y,p.x),PI);\r\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\r\n    float Fk  = pow(PHI,k)/sqrt(5.0);\r\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\r\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \r\n    \r\n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\r\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\r\n\r\n    float ma = 0.0;\r\n    vec4 res = vec4(0);\r\n    for( int s=0; s<4; s++ )\r\n    {\r\n        vec2 uv = vec2(s&1,s>>1);\r\n        float i = dot(F,uv+c);\r\n        float phi = 2.0*PI*fract(i*PHI);\r\n        float cT = 1.0 - (2.0*i+1.0)/n;\r\n        float sT = sqrt(1.0-cT*cT);\r\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\r\n        float a = dot(p,q);\r\n        if (a > ma)\r\n        {\r\n            ma = a;\r\n            res.xyz = q;\r\n            res.w = i;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\r\n{\r\n    float lp = length(p);\r\n    float dmin = lp-1.0;\r\n    {\r\n    vec3 w = p/lp;\r\n    vec4 fibo = inverseSF(w, 700.0);\r\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\r\n    dmin -= 0.07*hh;\r\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\r\n    }\r\n    \r\n    \r\n    float s = 1.0;\r\n    \r\n    #ifdef INTERACTIVE\r\n  //float tt = mod(iTime,5.0);\r\n    float tt = 4.0*iMouse.x/iResolution.x;\r\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\r\n    #endif\r\n    \r\n    for( int i=0; i<3; i++ )\r\n    {\r\n        float h = float(i)/float(3-1);\r\n        \r\n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\r\n        \r\n        // snap\r\n        p -= f.xyz;\r\n\r\n        // orient to surface\r\n        p = p*makeBase(f.xyz);\r\n\r\n        // scale\r\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\r\n        p *= scale;\r\n        p.xy *= 1.2;\r\n        \r\n        //translate\r\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\r\n            \r\n        // measure distance\r\n        s *= scale;\r\n        #ifdef INTERACTIVE\r\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\r\n        #else\r\n        float d = sdCapsule( p, -6.0, 0.42 );\r\n        #endif\r\n        d /= s;\r\n\r\n        if( d<dmin )\r\n        {\r\n            if( doColor )\r\n            {\r\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\r\n\r\n                if( i==0 ) \r\n                {\r\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall\r\n                  //color.xyz = vec3(0.4,0.8,0.1);         // summer\r\n                  //color.xyz = vec3(0.4,0.4,0.8);         // winter\r\n                }\r\n\r\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\r\n                color.xyz = max(color.xyz,0.0);\r\n            }\r\n            dmin = d;\r\n        }\r\n        else\r\n        {\r\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\r\n        }\r\n    }\r\n    \r\n    return dmin;\r\n}\r\n\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcNormal( in vec3 pos, in float ep )\r\n{\r\n    vec4 kk;\r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773;\r\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\r\n#else\r\n    // prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*ep, kk, false);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n    \r\n}\r\n\r\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\r\n{\r\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n    tmin = max(tmin,bound.x);\r\n    tmax = min(tmax,bound.y);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = tmin;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n    \tvec4 kk;\r\n\t\tfloat h = map( ro + rd*t, kk, false );\r\n        res = min( res, k*h/t );\r\n        t += clamp( h, 0.02, 0.20 );\r\n        if( res<0.005 || t>tmax ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\r\n{\r\n    vec4 kk;\r\n    float t = tmin;\r\n\tfor( int i=0; i<512; i++ )\r\n    {\r\n\t\tvec3 p = ro + t*rd;\r\n        float h = map(p,kk,false);\r\n\t\tif( abs(h)<(0.15*t/iResolution.x) ) break;\r\n\t\tt += h*0.5;\r\n        if( t>tmax ) return -1.0;;\r\n\t}\r\n    //if( t>tmax ) t=-1.0;\r\n\r\n    return t;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float an = (iTime-10.0)*0.05;\r\n    \r\n    // camera\t\r\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\r\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\r\n    // camera-to-world rotation\r\n    mat3 ca = makeBase( normalize(ta-ro) );\r\n\r\n    // render    \r\n    vec3 tot = vec3(0.0);\r\n    \r\n    #if AA>1\r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n        #else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n        #endif\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\r\n    \r\n        // background\r\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\r\n\r\n        // bounding volume\r\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n\t\tif( bound.x>0.0 )\r\n        {\r\n        // raycast\r\n        float t = raycast(ro, rd, bound.x, bound.y );\r\n        if( t>0.0 )\r\n        {\r\n            // local geometry            \r\n            vec3 pos = ro + t*rd;\r\n        \tvec3 nor = calcNormal(pos, 0.01);\r\n            vec3 upp = normalize(pos);\r\n            \r\n            // color and occlusion\r\n            vec4 mate; map(pos, mate, true);\r\n            \r\n            // lighting            \r\n            col = vec3(0.0);\r\n        \r\n            // key ligh\r\n            {\r\n                // dif\r\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\r\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\r\n\t\t\t\t// spec\r\n                vec3 hal = normalize(lig-rd);\r\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\r\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\r\n                fre = 0.2 + 0.8*pow(fre,5.0);\r\n                spe *= spe;\r\n                spe *= spe;\r\n                spe *= spe;\r\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\r\n            }\r\n\r\n            // back light\r\n           \t{\r\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\r\n            }\r\n\r\n            // dome light\r\n            {\r\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\r\n                #if 0\r\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\r\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\r\n                #else\r\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\r\n                #endif\r\n            }\r\n            \r\n            // fake sss\r\n            {\r\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\r\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\r\n            }\r\n            \r\n            // grade/sss\r\n            {\r\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\r\n            }\r\n            \r\n            // exposure control\r\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\r\n            \r\n            // display fake occlusion\r\n            //col = mate.www;\r\n        }\r\n        }\r\n    \r\n \r\n        // gamma\r\n        col = pow( col, vec3(0.4545) );\r\n    \r\n        tot += col;\r\n    #if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n    #endif\r\n\r\n    // vignetting\r\n \tvec2 q = fragCoord/iResolution.xy;\r\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2018\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\r\n// Youtube version: https://www.youtube.com/watch?v=q1OBrqtl7Yo\r\n\r\n#if HW_PERFORMANCE==0\r\n#define AA 1\r\n#else\r\n#define AA 2  // Change AA to 1 if it renders too slow for you\r\n#endif\r\n\r\n//#define INTERACTIVE\r\n\r\nmat3 makeBase( in vec3 w )\r\n{\r\n\tfloat k = inversesqrt(1.0-w.y*w.y);\r\n    return mat3( vec3(-w.z,0.0,w.x)*k, \r\n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\r\n                 w);\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\r\n{\r\n\tfloat b = dot( ro, rd );\r\n\tfloat c = dot( ro, ro ) - rad*rad;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt(h);\r\n\treturn vec2(-b-h,-b+h);\r\n}\r\n\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( in vec3 p, in float b, in float r )\r\n{\r\n    float h = clamp( p.z/b, 0.0, 1.0 );\r\n    return length( p - vec3(0.0,0.0,b)*h ) - r;//*(0.2+1.6*h);\r\n}\r\n\r\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\r\nvec4 inverseSF( in vec3 p, const in float n )\r\n{\r\n    const float PI = 3.14159265359;\r\n\tconst float PHI = 1.61803398875;\r\n\r\n    float phi = min(atan(p.y,p.x),PI);\r\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\r\n    float Fk  = pow(PHI,k)/sqrt(5.0);\r\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\r\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \r\n    \r\n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\r\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\r\n\r\n    float ma = 0.0;\r\n    vec4 res = vec4(0);\r\n    for( int s=0; s<4; s++ )\r\n    {\r\n        vec2 uv = vec2(s&1,s>>1);\r\n        float i = dot(F,uv+c);\r\n        float phi = 2.0*PI*fract(i*PHI);\r\n        float cT = 1.0 - (2.0*i+1.0)/n;\r\n        float sT = sqrt(1.0-cT*cT);\r\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\r\n        float a = dot(p,q);\r\n        if (a > ma)\r\n        {\r\n            ma = a;\r\n            res.xyz = q;\r\n            res.w = i;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\r\n{\r\n    float lp = length(p);\r\n    float dmin = lp-1.0;\r\n    {\r\n    vec3 w = p/lp;\r\n    vec4 fibo = inverseSF(w, 700.0);\r\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\r\n    dmin -= 0.07*hh;\r\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\r\n    }\r\n    \r\n    \r\n    float s = 1.0;\r\n    \r\n    #ifdef INTERACTIVE\r\n  //float tt = mod(iTime,5.0);\r\n    float tt = 4.0*iMouse.x/iResolution.x;\r\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\r\n    #endif\r\n    \r\n    for( int i=0; i<3; i++ )\r\n    {\r\n        float h = float(i)/float(3-1);\r\n        \r\n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\r\n        \r\n        // snap\r\n        p -= f.xyz;\r\n\r\n        // orient to surface\r\n        p = p*makeBase(f.xyz);\r\n\r\n        // scale\r\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\r\n        p *= scale;\r\n        p.xy *= 1.2;\r\n        \r\n        //translate\r\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\r\n            \r\n        // measure distance\r\n        s *= scale;\r\n        #ifdef INTERACTIVE\r\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\r\n        #else\r\n        float d = sdCapsule( p, -6.0, 0.42 );\r\n        #endif\r\n        d /= s;\r\n\r\n        if( d<dmin )\r\n        {\r\n            if( doColor )\r\n            {\r\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\r\n\r\n                if( i==0 ) \r\n                {\r\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall\r\n                  //color.xyz = vec3(0.4,0.8,0.1);         // summer\r\n                  //color.xyz = vec3(0.4,0.4,0.8);         // winter\r\n                }\r\n\r\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\r\n                color.xyz = max(color.xyz,0.0);\r\n            }\r\n            dmin = d;\r\n        }\r\n        else\r\n        {\r\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\r\n        }\r\n    }\r\n    \r\n    return dmin;\r\n}\r\n\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcNormal( in vec3 pos, in float ep )\r\n{\r\n    vec4 kk;\r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773;\r\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\r\n#else\r\n    // prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*ep, kk, false);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n    \r\n}\r\n\r\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\r\n{\r\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n    tmin = max(tmin,bound.x);\r\n    tmax = min(tmax,bound.y);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = tmin;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n    \tvec4 kk;\r\n\t\tfloat h = map( ro + rd*t, kk, false );\r\n        res = min( res, k*h/t );\r\n        t += clamp( h, 0.02, 0.20 );\r\n        if( res<0.005 || t>tmax ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\r\n{\r\n    vec4 kk;\r\n    float t = tmin;\r\n\tfor( int i=0; i<512; i++ )\r\n    {\r\n\t\tvec3 p = ro + t*rd;\r\n        float h = map(p,kk,false);\r\n\t\tif( abs(h)<(0.15*t/iResolution.x) ) break;\r\n\t\tt += h*0.5;\r\n        if( t>tmax ) return -1.0;;\r\n\t}\r\n    //if( t>tmax ) t=-1.0;\r\n\r\n    return t;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float an = (iTime-10.0)*0.05;\r\n    \r\n    // camera\t\r\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\r\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\r\n    // camera-to-world rotation\r\n    mat3 ca = makeBase( normalize(ta-ro) );\r\n\r\n    // render    \r\n    vec3 tot = vec3(0.0);\r\n    \r\n    #if AA>1\r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n        #else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n        #endif\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\r\n    \r\n        // background\r\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\r\n\r\n        // bounding volume\r\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n\t\tif( bound.x>0.0 )\r\n        {\r\n        // raycast\r\n        float t = raycast(ro, rd, bound.x, bound.y );\r\n        if( t>0.0 )\r\n        {\r\n            // local geometry            \r\n            vec3 pos = ro + t*rd;\r\n        \tvec3 nor = calcNormal(pos, 0.01);\r\n            vec3 upp = normalize(pos);\r\n            \r\n            // color and occlusion\r\n            vec4 mate; map(pos, mate, true);\r\n            \r\n            // lighting            \r\n            col = vec3(0.0);\r\n        \r\n            // key ligh\r\n            {\r\n                // dif\r\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\r\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\r\n\t\t\t\t// spec\r\n                vec3 hal = normalize(lig-rd);\r\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\r\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\r\n                fre = 0.2 + 0.8*pow(fre,5.0);\r\n                spe *= spe;\r\n                spe *= spe;\r\n                spe *= spe;\r\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\r\n            }\r\n\r\n            // back light\r\n           \t{\r\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\r\n            }\r\n\r\n            // dome light\r\n            {\r\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\r\n                #if 0\r\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\r\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\r\n                #else\r\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\r\n                #endif\r\n            }\r\n            \r\n            // fake sss\r\n            {\r\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\r\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\r\n            }\r\n            \r\n            // grade/sss\r\n            {\r\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\r\n            }\r\n            \r\n            // exposure control\r\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\r\n            \r\n            // display fake occlusion\r\n            //col = mate.www;\r\n        }\r\n        }\r\n    \r\n \r\n        // gamma\r\n        col = pow( col, vec3(0.4545) );\r\n    \r\n        tot += col;\r\n    #if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n    #endif\r\n\r\n    // vignetting\r\n \tvec2 q = fragCoord/iResolution.xy;\r\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Planet Fall","id":"d724204b01764542b01c2a1224d01441","date":null,"viewed":0,"name":"Planet Fall","description":"Pretty much a modification to Klems' shader https://www.shadertoy.com/view/XlcfRs. Make AA 1 in line 7 if it renders too slow for you","likes":0,"published":null,"tags":["3d"," raymarching"," fractal"," distancefield"," sdf"]},"ver":null,"info":{"Name":"Planet Fall","id":"d724204b01764542b01c2a1224d01441","date":null,"viewed":0,"name":"Planet Fall","description":"Pretty much a modification to Klems' shader https://www.shadertoy.com/view/XlcfRs. Make AA 1 in line 7 if it renders too slow for you","likes":0,"published":null,"tags":["3d"," raymarching"," fractal"," distancefield"," sdf"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2018\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\r\n// Youtube version: https://www.youtube.com/watch?v=q1OBrqtl7Yo\r\n\r\n#if HW_PERFORMANCE==0\r\n#define AA 1\r\n#else\r\n#define AA 2  // Change AA to 1 if it renders too slow for you\r\n#endif\r\n\r\n//#define INTERACTIVE\r\n\r\nmat3 makeBase( in vec3 w )\r\n{\r\n\tfloat k = inversesqrt(1.0-w.y*w.y);\r\n    return mat3( vec3(-w.z,0.0,w.x)*k, \r\n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\r\n                 w);\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\r\n{\r\n\tfloat b = dot( ro, rd );\r\n\tfloat c = dot( ro, ro ) - rad*rad;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt(h);\r\n\treturn vec2(-b-h,-b+h);\r\n}\r\n\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( in vec3 p, in float b, in float r )\r\n{\r\n    float h = clamp( p.z/b, 0.0, 1.0 );\r\n    return length( p - vec3(0.0,0.0,b)*h ) - r;//*(0.2+1.6*h);\r\n}\r\n\r\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\r\nvec4 inverseSF( in vec3 p, const in float n )\r\n{\r\n    const float PI = 3.14159265359;\r\n\tconst float PHI = 1.61803398875;\r\n\r\n    float phi = min(atan(p.y,p.x),PI);\r\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\r\n    float Fk  = pow(PHI,k)/sqrt(5.0);\r\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\r\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \r\n    \r\n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\r\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\r\n\r\n    float ma = 0.0;\r\n    vec4 res = vec4(0);\r\n    for( int s=0; s<4; s++ )\r\n    {\r\n        vec2 uv = vec2(s&1,s>>1);\r\n        float i = dot(F,uv+c);\r\n        float phi = 2.0*PI*fract(i*PHI);\r\n        float cT = 1.0 - (2.0*i+1.0)/n;\r\n        float sT = sqrt(1.0-cT*cT);\r\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\r\n        float a = dot(p,q);\r\n        if (a > ma)\r\n        {\r\n            ma = a;\r\n            res.xyz = q;\r\n            res.w = i;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\r\n{\r\n    float lp = length(p);\r\n    float dmin = lp-1.0;\r\n    {\r\n    vec3 w = p/lp;\r\n    vec4 fibo = inverseSF(w, 700.0);\r\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\r\n    dmin -= 0.07*hh;\r\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\r\n    }\r\n    \r\n    \r\n    float s = 1.0;\r\n    \r\n    #ifdef INTERACTIVE\r\n  //float tt = mod(iTime,5.0);\r\n    float tt = 4.0*iMouse.x/iResolution.x;\r\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\r\n    #endif\r\n    \r\n    for( int i=0; i<3; i++ )\r\n    {\r\n        float h = float(i)/float(3-1);\r\n        \r\n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\r\n        \r\n        // snap\r\n        p -= f.xyz;\r\n\r\n        // orient to surface\r\n        p = p*makeBase(f.xyz);\r\n\r\n        // scale\r\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\r\n        p *= scale;\r\n        p.xy *= 1.2;\r\n        \r\n        //translate\r\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\r\n            \r\n        // measure distance\r\n        s *= scale;\r\n        #ifdef INTERACTIVE\r\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\r\n        #else\r\n        float d = sdCapsule( p, -6.0, 0.42 );\r\n        #endif\r\n        d /= s;\r\n\r\n        if( d<dmin )\r\n        {\r\n            if( doColor )\r\n            {\r\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\r\n\r\n                if( i==0 ) \r\n                {\r\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall\r\n                  //color.xyz = vec3(0.4,0.8,0.1);         // summer\r\n                  //color.xyz = vec3(0.4,0.4,0.8);         // winter\r\n                }\r\n\r\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\r\n                color.xyz = max(color.xyz,0.0);\r\n            }\r\n            dmin = d;\r\n        }\r\n        else\r\n        {\r\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\r\n        }\r\n    }\r\n    \r\n    return dmin;\r\n}\r\n\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcNormal( in vec3 pos, in float ep )\r\n{\r\n    vec4 kk;\r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773;\r\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\r\n#else\r\n    // prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*ep, kk, false);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n    \r\n}\r\n\r\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\r\n{\r\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n    tmin = max(tmin,bound.x);\r\n    tmax = min(tmax,bound.y);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = tmin;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n    \tvec4 kk;\r\n\t\tfloat h = map( ro + rd*t, kk, false );\r\n        res = min( res, k*h/t );\r\n        t += clamp( h, 0.02, 0.20 );\r\n        if( res<0.005 || t>tmax ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\r\n{\r\n    vec4 kk;\r\n    float t = tmin;\r\n\tfor( int i=0; i<512; i++ )\r\n    {\r\n\t\tvec3 p = ro + t*rd;\r\n        float h = map(p,kk,false);\r\n\t\tif( abs(h)<(0.15*t/iResolution.x) ) break;\r\n\t\tt += h*0.5;\r\n        if( t>tmax ) return -1.0;;\r\n\t}\r\n    //if( t>tmax ) t=-1.0;\r\n\r\n    return t;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float an = (iTime-10.0)*0.05;\r\n    \r\n    // camera\t\r\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\r\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\r\n    // camera-to-world rotation\r\n    mat3 ca = makeBase( normalize(ta-ro) );\r\n\r\n    // render    \r\n    vec3 tot = vec3(0.0);\r\n    \r\n    #if AA>1\r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n        #else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n        #endif\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\r\n    \r\n        // background\r\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\r\n\r\n        // bounding volume\r\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n\t\tif( bound.x>0.0 )\r\n        {\r\n        // raycast\r\n        float t = raycast(ro, rd, bound.x, bound.y );\r\n        if( t>0.0 )\r\n        {\r\n            // local geometry            \r\n            vec3 pos = ro + t*rd;\r\n        \tvec3 nor = calcNormal(pos, 0.01);\r\n            vec3 upp = normalize(pos);\r\n            \r\n            // color and occlusion\r\n            vec4 mate; map(pos, mate, true);\r\n            \r\n            // lighting            \r\n            col = vec3(0.0);\r\n        \r\n            // key ligh\r\n            {\r\n                // dif\r\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\r\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\r\n\t\t\t\t// spec\r\n                vec3 hal = normalize(lig-rd);\r\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\r\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\r\n                fre = 0.2 + 0.8*pow(fre,5.0);\r\n                spe *= spe;\r\n                spe *= spe;\r\n                spe *= spe;\r\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\r\n            }\r\n\r\n            // back light\r\n           \t{\r\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\r\n            }\r\n\r\n            // dome light\r\n            {\r\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\r\n                #if 0\r\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\r\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\r\n                #else\r\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\r\n                #endif\r\n            }\r\n            \r\n            // fake sss\r\n            {\r\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\r\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\r\n            }\r\n            \r\n            // grade/sss\r\n            {\r\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\r\n            }\r\n            \r\n            // exposure control\r\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\r\n            \r\n            // display fake occlusion\r\n            //col = mate.www;\r\n        }\r\n        }\r\n    \r\n \r\n        // gamma\r\n        col = pow( col, vec3(0.4545) );\r\n    \r\n        tot += col;\r\n    #if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n    #endif\r\n\r\n    // vignetting\r\n \tvec2 q = fragCoord/iResolution.xy;\r\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2018\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\r\n// Youtube version: https://www.youtube.com/watch?v=q1OBrqtl7Yo\r\n\r\n#if HW_PERFORMANCE==0\r\n#define AA 1\r\n#else\r\n#define AA 2  // Change AA to 1 if it renders too slow for you\r\n#endif\r\n\r\n//#define INTERACTIVE\r\n\r\nmat3 makeBase( in vec3 w )\r\n{\r\n\tfloat k = inversesqrt(1.0-w.y*w.y);\r\n    return mat3( vec3(-w.z,0.0,w.x)*k, \r\n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\r\n                 w);\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\n\r\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\r\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\r\n{\r\n\tfloat b = dot( ro, rd );\r\n\tfloat c = dot( ro, ro ) - rad*rad;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n    h = sqrt(h);\r\n\treturn vec2(-b-h,-b+h);\r\n}\r\n\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\nfloat sdCapsule( in vec3 p, in float b, in float r )\r\n{\r\n    float h = clamp( p.z/b, 0.0, 1.0 );\r\n    return length( p - vec3(0.0,0.0,b)*h ) - r;//*(0.2+1.6*h);\r\n}\r\n\r\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\r\nvec4 inverseSF( in vec3 p, const in float n )\r\n{\r\n    const float PI = 3.14159265359;\r\n\tconst float PHI = 1.61803398875;\r\n\r\n    float phi = min(atan(p.y,p.x),PI);\r\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\r\n    float Fk  = pow(PHI,k)/sqrt(5.0);\r\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\r\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \r\n    \r\n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\r\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\r\n\r\n    float ma = 0.0;\r\n    vec4 res = vec4(0);\r\n    for( int s=0; s<4; s++ )\r\n    {\r\n        vec2 uv = vec2(s&1,s>>1);\r\n        float i = dot(F,uv+c);\r\n        float phi = 2.0*PI*fract(i*PHI);\r\n        float cT = 1.0 - (2.0*i+1.0)/n;\r\n        float sT = sqrt(1.0-cT*cT);\r\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\r\n        float a = dot(p,q);\r\n        if (a > ma)\r\n        {\r\n            ma = a;\r\n            res.xyz = q;\r\n            res.w = i;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\r\n{\r\n    float lp = length(p);\r\n    float dmin = lp-1.0;\r\n    {\r\n    vec3 w = p/lp;\r\n    vec4 fibo = inverseSF(w, 700.0);\r\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\r\n    dmin -= 0.07*hh;\r\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\r\n    }\r\n    \r\n    \r\n    float s = 1.0;\r\n    \r\n    #ifdef INTERACTIVE\r\n  //float tt = mod(iTime,5.0);\r\n    float tt = 4.0*iMouse.x/iResolution.x;\r\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\r\n    #endif\r\n    \r\n    for( int i=0; i<3; i++ )\r\n    {\r\n        float h = float(i)/float(3-1);\r\n        \r\n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\r\n        \r\n        // snap\r\n        p -= f.xyz;\r\n\r\n        // orient to surface\r\n        p = p*makeBase(f.xyz);\r\n\r\n        // scale\r\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\r\n        p *= scale;\r\n        p.xy *= 1.2;\r\n        \r\n        //translate\r\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\r\n            \r\n        // measure distance\r\n        s *= scale;\r\n        #ifdef INTERACTIVE\r\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\r\n        #else\r\n        float d = sdCapsule( p, -6.0, 0.42 );\r\n        #endif\r\n        d /= s;\r\n\r\n        if( d<dmin )\r\n        {\r\n            if( doColor )\r\n            {\r\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\r\n\r\n                if( i==0 ) \r\n                {\r\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall\r\n                  //color.xyz = vec3(0.4,0.8,0.1);         // summer\r\n                  //color.xyz = vec3(0.4,0.4,0.8);         // winter\r\n                }\r\n\r\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\r\n                color.xyz = max(color.xyz,0.0);\r\n            }\r\n            dmin = d;\r\n        }\r\n        else\r\n        {\r\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\r\n        }\r\n    }\r\n    \r\n    return dmin;\r\n}\r\n\r\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\r\nvec3 calcNormal( in vec3 pos, in float ep )\r\n{\r\n    vec4 kk;\r\n#if 0\r\n    vec2 e = vec2(1.0,-1.0)*0.5773;\r\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\r\n#else\r\n    // prevent the compiler from inlining map() 4 times\r\n    vec3 n = vec3(0.0);\r\n    for( int i=ZERO; i<4; i++ )\r\n    {\r\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\r\n        n += e*map(pos+e*ep, kk, false);\r\n    }\r\n    return normalize(n);\r\n#endif    \r\n    \r\n}\r\n\r\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\r\n{\r\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n    tmin = max(tmin,bound.x);\r\n    tmax = min(tmax,bound.y);\r\n    \r\n\tfloat res = 1.0;\r\n    float t = tmin;\r\n    for( int i=0; i<50; i++ )\r\n    {\r\n    \tvec4 kk;\r\n\t\tfloat h = map( ro + rd*t, kk, false );\r\n        res = min( res, k*h/t );\r\n        t += clamp( h, 0.02, 0.20 );\r\n        if( res<0.005 || t>tmax ) break;\r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\r\n{\r\n    vec4 kk;\r\n    float t = tmin;\r\n\tfor( int i=0; i<512; i++ )\r\n    {\r\n\t\tvec3 p = ro + t*rd;\r\n        float h = map(p,kk,false);\r\n\t\tif( abs(h)<(0.15*t/iResolution.x) ) break;\r\n\t\tt += h*0.5;\r\n        if( t>tmax ) return -1.0;;\r\n\t}\r\n    //if( t>tmax ) t=-1.0;\r\n\r\n    return t;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float an = (iTime-10.0)*0.05;\r\n    \r\n    // camera\t\r\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\r\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\r\n    // camera-to-world rotation\r\n    mat3 ca = makeBase( normalize(ta-ro) );\r\n\r\n    // render    \r\n    vec3 tot = vec3(0.0);\r\n    \r\n    #if AA>1\r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n        #else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n        #endif\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\r\n    \r\n        // background\r\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\r\n\r\n        // bounding volume\r\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\r\n\t\tif( bound.x>0.0 )\r\n        {\r\n        // raycast\r\n        float t = raycast(ro, rd, bound.x, bound.y );\r\n        if( t>0.0 )\r\n        {\r\n            // local geometry            \r\n            vec3 pos = ro + t*rd;\r\n        \tvec3 nor = calcNormal(pos, 0.01);\r\n            vec3 upp = normalize(pos);\r\n            \r\n            // color and occlusion\r\n            vec4 mate; map(pos, mate, true);\r\n            \r\n            // lighting            \r\n            col = vec3(0.0);\r\n        \r\n            // key ligh\r\n            {\r\n                // dif\r\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\r\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\r\n\t\t\t\t// spec\r\n                vec3 hal = normalize(lig-rd);\r\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\r\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\r\n                fre = 0.2 + 0.8*pow(fre,5.0);\r\n                spe *= spe;\r\n                spe *= spe;\r\n                spe *= spe;\r\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\r\n            }\r\n\r\n            // back light\r\n           \t{\r\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\r\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\r\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\r\n            }\r\n\r\n            // dome light\r\n            {\r\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\r\n                #if 0\r\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\r\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\r\n                #else\r\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\r\n                #endif\r\n            }\r\n            \r\n            // fake sss\r\n            {\r\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\r\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\r\n            }\r\n            \r\n            // grade/sss\r\n            {\r\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\r\n            }\r\n            \r\n            // exposure control\r\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\r\n            \r\n            // display fake occlusion\r\n            //col = mate.www;\r\n        }\r\n        }\r\n    \r\n \r\n        // gamma\r\n        col = pow( col, vec3(0.4545) );\r\n    \r\n        tot += col;\r\n    #if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n    #endif\r\n\r\n    // vignetting\r\n \tvec2 q = fragCoord/iResolution.xy;\r\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Planet Shadertoy. Created by Reinder Nijhoff 2015\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/4tjGRh\r\n//\r\n// It uses code from the following shaders:\r\n//\r\n// Wet stone by TDM\r\n// Atmospheric Scattering by GLtracy\r\n// Seascape by TDM\r\n// Elevated and Terrain Tubes by IQ\r\n// LLamels by Eiffie\r\n// Lens flare by Musk\r\n// \r\n\r\n//#define HIGH_QUALITY\r\n//#define MED_QUALITY\r\n//#define LOW_QUALITY\r\n#define VERY_LOW_QUALITY\r\n\r\nconst float PI = 3.14159265359;\r\nconst float DEG_TO_RAD = (PI / 180.0);\r\nconst float MAX = 10000.0;\r\n\r\nconst float EARTH_RADIUS = 1000.;\r\nconst float EARTH_ATMOSPHERE = 5.;\r\nconst float EARTH_CLOUDS = 1.;\r\n\r\nconst float RING_INNER_RADIUS = 1500.;\r\nconst float RING_OUTER_RADIUS = 2300.;\r\nconst float RING_HEIGHT = 2.;\r\n\r\n#ifdef HIGH_QUALITY\r\n    const int   SEA_NUM_STEPS = 7;\r\n    const int\tTERRAIN_NUM_STEPS = 140;\r\n    const int   ASTEROID_NUM_STEPS = 11;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\r\n    const int   RING_VOXEL_STEPS = 25;\r\n    const float ASTEROID_MAX_DISTANCE = 1.1; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\r\n\r\n    #define DISPLAY_LLAMEL\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n#endif\r\n\r\n#ifdef MED_QUALITY\r\n    const int   SEA_NUM_STEPS = 6;\r\n    const int\tTERRAIN_NUM_STEPS = 100;\r\n    const int   ASTEROID_NUM_STEPS = 10;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\r\n    const int   RING_VOXEL_STEPS = 24;\r\n    const float ASTEROID_MAX_DISTANCE = 1.; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n#endif\r\n\r\n#ifdef LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 5;\r\n    const int\tTERRAIN_NUM_STEPS = 75;\r\n    const int   ASTEROID_NUM_STEPS = 9;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\r\n    const int   RING_VOXEL_STEPS = 20;\r\n    const float ASTEROID_MAX_DISTANCE = .85; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\r\n#endif\r\n\r\n#ifdef VERY_LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 4;\r\n    const int\tTERRAIN_NUM_STEPS = 60;\r\n    const int   ASTEROID_NUM_STEPS = 7;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\r\n    const int   RING_VOXEL_STEPS = 16;\r\n    const float ASTEROID_MAX_DISTANCE = .67; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\r\n\t#define HIDE_TERRAIN\r\n#endif\r\n\r\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\r\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\r\n\r\nfloat time;\r\n\r\n//-----------------------------------------------------\r\n// Noise functions\r\n//-----------------------------------------------------\r\n\r\nfloat hash( const in float n ) {\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\nfloat hash( const in vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat hash( const in vec3 p ) {\r\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nvec3 hash31( const in float p) {\r\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\r\n    return fract(sin(h)*43758.543123);\r\n}\r\nvec3 hash33( const in vec3 p) {\r\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\r\n}\r\n\r\nfloat noise( const in  float p ) {    \r\n    float i = floor( p );\r\n    float f = fract( p );\t\r\n\tfloat u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\r\n}\r\n\r\nfloat noise( const in  vec2 p ) {    \r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat noise( const in  vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\r\n}\r\n\r\nfloat tri( const in vec2 p ) {\r\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\r\n   \r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( in vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); \r\n    \r\n#ifndef LOW_QUALITY\r\n#ifndef VERY_LOW_QUALITY\r\n    p = m2*p*2.01;\r\n    f += 0.0625*noise( p );\r\n#endif\r\n#endif\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm( const in vec3 p, const in float a, const in float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < FBM_STEPS; i++) {\r\n        float n = pow(noise(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lightning functions\r\n//-----------------------------------------------------\r\n\r\nfloat diffuse( const in vec3 n, const in vec3 l) { \r\n    return clamp(dot(n,l),0.,1.);\r\n}\r\n\r\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\r\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Math functions\r\n//-----------------------------------------------------\r\n\r\nvec2 rotate(float angle, vec2 v) {\r\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\r\n}\r\n\r\nfloat boolSub(float a,float b) { \r\n    return max(a,-b); \r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Intersection functions (by iq)\r\n//-----------------------------------------------------\r\n\r\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\r\n    return (pos-sph.xyz)/sph.w;\r\n}\r\n\r\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return -1.0;\r\n\treturn -b - sqrt( h );\r\n}\r\n\r\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return -MAX;\r\n\treturn -b + sqrt( d );\r\n}\r\n\r\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\r\n\td = sqrt( d );\r\n\treturn vec2( -b - d, -b + d );\r\n}\r\n\r\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\r\n    return obj.xyz;\r\n}\r\n\r\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\r\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Wet stone by TDM\r\n// \r\n// https://www.shadertoy.com/view/ldSSzV\r\n//-----------------------------------------------------\r\n\r\nconst float ASTEROID_TRESHOLD \t= 0.001;\r\nconst float ASTEROID_EPSILON \t= 1e-6;\r\nconst float ASTEROID_DISPLACEMENT = 0.1;\r\nconst float ASTEROID_RADIUS = 0.13;\r\n\r\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\r\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\r\n\r\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \r\n    float d = sphere(p,ASTEROID_RADIUS);    \r\n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\r\n        float ii = float(i)+id.x;\r\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( xyangle, ro.xy );\r\n    \r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( yzangle, ro.yz );\r\n}\r\n\r\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( -yzangle, ro.yz );\r\n\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( -xyangle, ro.xy );  \r\n}\r\n\r\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\r\n    asteroidTransForm( p, id );\r\n    \r\n    vec3 n;\r\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\r\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\r\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\r\n    n = normalize(n-asteroidMapDetailed(p, id));\r\n    \r\n    asteroidUnTransForm( n, id );\r\n    return n;\r\n}\r\n\r\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\r\n    asteroidTransForm( ori, id );\r\n    asteroidTransForm( dir, id );\r\n    \r\n    vec2 td = vec2(0,1);\r\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\r\n        td.y = asteroidMap(ori + dir * td.x, id);\r\n        td.x += td.y;\r\n    }\r\n    return td;\r\n}\r\n\r\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nconst float RING_DETAIL_DISTANCE = 40.;\r\nconst float RING_VOXEL_STEP_SIZE = .03;\r\n\r\nvec3 ringShadowColor( const in vec3 ro ) {\r\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\r\n        return vec3(0.);\r\n    }\r\n    return vec3(1.);\r\n}\r\n\r\nbool ringMap( const in vec3 ro ) {\r\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\r\n}\r\n\r\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \r\n// find startpoint \r\n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\r\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\r\n    \r\n    float d = min( max(d1,0.), max(d2,0.) );\r\n   \r\n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\r\n        return vec4( 0. );\r\n    } else {\r\n        vec3 ros = ro + rd*d;\r\n\r\n        // avoid precision problems..\r\n        vec2 mroxy = mod(ros.xy, vec2(10.));\r\n        vec2 roxy = ros.xy - mroxy;\r\n        ros.xy -= roxy;\r\n        ros /= RING_VOXEL_STEP_SIZE;\r\n        //ros.xy -= vec2(.013,.112)*time*.5;\r\n\r\n        vec3 pos = floor(ros);\r\n        vec3 ri = 1.0/rd;\r\n        vec3 rs = sign(rd);\r\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\r\n\r\n        float alpha = 0., dint;\r\n        vec3 offset = vec3(0), id, asteroidro;\r\n        vec2 asteroid = vec2(0);\r\n\r\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\r\n            if( ringMap(pos) ) {\r\n                id = hash33(pos);\r\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\r\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\r\n\r\n                if( dint > 0. ) {\r\n                    asteroidro = ros+rd*dint-(pos+offset);\r\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\r\n\r\n                    if( asteroid.y < .1 ) {\r\n                        alpha = 1.;\r\n                        break;\t    \r\n                    }\r\n                }\r\n\r\n            }\r\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\r\n            dis += mm * rs * ri;\r\n            pos += mm * rs;\r\n        }\r\n\r\n        if( alpha > 0. ) {       \r\n            vec3 intersection = ros + rd*(asteroid.x+dint);\r\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\r\n\r\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\r\n\r\n            intersection *= RING_VOXEL_STEP_SIZE;\r\n            intersection.xy += roxy;\r\n          //  col *= ringShadowColor( intersection );\r\n\r\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. ) {\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n        } else {\r\n            return 0.;\r\n        }\r\n    } else {\r\n\t    return 0.;\r\n    }\r\n}\r\n\r\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. && d < maxd ) {\r\n        maxd = d;\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\r\n            \r\n            col *= ringShadowColor( intersection );\r\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\r\n\t\t\tcol *= SUN_COLOR;\r\n            return vec4( col, dens );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    } else {\r\n\t    return vec4(0.);\r\n    }\r\n}\r\n\r\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    vec4 far = renderRingFar( ro, rd, maxd );\r\n    float l = length( ro.xy );\r\n\r\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \r\n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \r\n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\r\n     \t\r\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\r\n        far.xyz *= detail;    \r\n    }\r\n    \r\n\t// are asteroids neaded ?\r\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \r\n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \r\n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\r\n        \r\n        vec4 near = renderRingNear( ro, rd );\r\n        far = mix( far, near, near.w );\r\n        maxd=0.;\r\n    }\r\n            \r\n    return far;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Stars (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderStars( const in vec3 rd ) {\r\n\tvec3 rds = rd;\r\n\tvec3 col = vec3(0);\r\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\r\n    \r\n    vec2 xy = vec2(rds.y * v, rds.x * v);\r\n    float s = noise(rds*134.);\r\n    \r\n    s += noise(rds*470.);\r\n    s = pow(s,19.0) * 0.00001;\r\n    if (s > 0.5) {\r\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \r\n        col += backStars;\r\n    }\r\n\treturn   vec4( col, 1 ); \r\n} \r\n\r\n//-----------------------------------------------------\r\n// Atmospheric Scattering by GLtracy\r\n// \r\n// https://www.shadertoy.com/view/lslXDr\r\n//-----------------------------------------------------\r\n\r\nconst float ATMOSPHERE_K_R = 0.166;\r\nconst float ATMOSPHERE_K_M = 0.0025;\r\nconst float ATMOSPHERE_E = 12.3;\r\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\r\nconst float ATMOSPHERE_G_M = -0.85;\r\n\r\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\r\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\r\n\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\r\n\r\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\r\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\r\n\r\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\r\n\tfloat gg = g * g;\r\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\r\n\tfloat b = 1.0 + gg - 2.0 * g * c;\r\n    \r\n\tb *= sqrt( b );\r\n\tb *= 2.0 + gg;\t\r\n\t\r\n\treturn 1.5 * a / b;\r\n}\r\n\r\nfloat atmosphericPhaseReyleigh( float cc ) {\r\n\treturn 0.75 * ( 1.0 + cc );\r\n}\r\n\r\nfloat atmosphericDensity( vec3 p ){\r\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\r\n}\r\n\r\nfloat atmosphericOptic( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n    float sumdensity = 0.;\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\r\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\r\n\t\tfloat dens = atmosphericDensity( v );\r\n  \r\n\t    float m = MAX;\r\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \r\n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\r\n \t\tsumdensity += dens;\r\n        \r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \r\n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\r\n}\r\n\r\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\r\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\r\n\t    float m = MAX;\r\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\r\n}\r\n\r\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \r\n    // inside or outside atmosphere?\r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\r\n        \r\n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\r\n        if( d < e.y ) {\r\n            e.y = d;\r\n        }\r\n\t\td = e.y;\r\n\t    e.x = 0.;\r\n        \r\n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\r\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\r\n\t\t}\r\n    } else {\r\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\r\n        \r\n        if ( e.x > e.y ) {\r\n        \td = MAX;\r\n\t\t\treturn vec4(0.);\r\n\t\t}\r\n\t\td = e.y = min( e.y, f.x );\r\n    }\r\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n    e.x = 0.;\r\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Seascape by TDM\r\n// \r\n// https://www.shadertoy.com/view/Ms2SD1\r\n//-----------------------------------------------------\r\n\r\nconst int   SEA_ITER_GEOMETRY = 3;\r\nconst int   SEA_ITER_FRAGMENT = 5;\r\n\r\nconst float SEA_EPSILON\t= 1e-3;\r\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\r\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\r\nfloat       SEA_TIME;\r\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\nfloat seaOctave( in vec2 uv, const in float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat seaMap(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat seaMapHigh(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \r\n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \r\n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \r\n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\r\n    \r\n    color += upc*SEA_WATER_COLOR * (att * 0.18);\r\n    color += sunc * vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\r\n    vec3 n;\r\n    n.y = seaMapHigh(p);    \r\n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = seaMap(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = seaMap(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = seaMap(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 seaTransform( in vec3 x ) {\r\n    x.yz = rotate( 0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvec3 seaUntransform( in vec3 x ) {\r\n    x.yz = rotate( -0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \r\n    vec3 p,\r\n    rom = seaTransform(ro),\r\n    rdm = seaTransform(rd);\r\n    \r\n    rom.y -= EARTH_RADIUS;\r\n    rom *= 1000.;\r\n    rom.xz += vec2(3.1,.2)*time;\r\n\r\n    SEA_TIME = time * SEA_SPEED;\r\n    \r\n    seaHeightMapTracing(rom,rdm,p);\r\n    float squareddist = dot(p - rom, p-rom );\r\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\r\n    \r\n    n = seaUntransform(n);\r\n    \r\n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Terrain based on Elevated and Terrain Tubes by IQ\r\n//\r\n// https://www.shadertoy.com/view/MdX3Rr\r\n// https://www.shadertoy.com/view/4sjXzG\r\n//-----------------------------------------------------\r\n\r\n#ifndef HIDE_TERRAIN\r\n\r\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\r\n\r\nfloat terrainLow( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<2; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMed( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<6; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n            \r\n    return t*33.0;\r\n}\r\n\r\nfloat terrainHigh( vec2 p ) {\r\n    vec2 q = p;\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<7; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n    \r\n    t += t*0.015*fbm( q );\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMap( const in vec3 pos ) {\r\n\treturn pos.y - terrainMed(pos.xz);  \r\n}\r\n\r\nfloat terrainMapH( const in vec3 pos ) {\r\n    float y = terrainHigh(pos.xz);\r\n    float h = pos.y - y;\r\n    return h;\r\n}\r\n\r\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\r\n    float t = tmin;\r\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\r\n        vec3 pos = ro + t*rd;\r\n        float res = terrainMap( pos );\r\n        if( res<(0.001*t) || t>tmax  ) break;\r\n        t += res*.9;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\r\n\tvec2  eps = vec2(150.0,0.0);\r\n    float h1 = terrainMed( ro.xz );\r\n    float h2 = terrainLow( ro.xz );\r\n    \r\n    float d1 = 10.0;\r\n    float d2 = 80.0;\r\n    float d3 = 200.0;\r\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\r\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\r\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\r\n\r\n    return min(min(s1,s2),s3);\r\n}\r\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\r\n\r\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\r\n}\r\n\r\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\r\n\tfloat e = 0.005*t;\r\n    vec2  eps = vec2(e,0.0);\r\n    float h = terrainMed( pos.xz );\r\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\r\n}\r\n\r\nvec3 terrainTransform( in vec3 x ) {\r\n    x.zy = rotate( -.83, x.zy );\r\n    return x;\r\n}\r\n\r\nvec3 terrainUntransform( in vec3 x ) {\r\n    x.zy = rotate( .83, x.zy );\r\n    return x;\r\n}\r\n\r\n\r\nfloat llamelTime;\r\nconst float llamelScale = 5.;\r\n\r\nvec3 llamelPosition() {\r\n    llamelTime = time*2.5;\r\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\r\n    return vec3( pos.x, terrainMed( pos ), pos.y );\r\n}\r\n\r\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \r\n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\r\n    float dif = diffuse( n, sunDirection );\r\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\r\n    float sha = terrainCalcShadow( pos, sunDirection );\r\n    float amb = clamp( n.y,0.0,1.0);\r\n        \r\n    vec3 lin  = vec3(0.0);\r\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\r\n    lin += 0.2*amb*upc;\r\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\r\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\r\n}\r\n\r\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    vec3 nor = terrainCalcNormalHigh( pos, t );\r\n    vec3 sor = terrainCalcNormalMed( pos, t );\r\n        \r\n    float spec = 0.005;\r\n\r\n#ifdef DISPLAY_TERRAIN_DETAIL\r\n    float no = noise(5.*fbm(1.11*pos.xz));\r\n#else\r\n    const float no = 0.;\r\n#endif\r\n    float r = .5+.5*fbm(.95*pos.xz);\r\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\r\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\r\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\r\n    col *= .88+.12*no;\r\n        \r\n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\r\n    float sf = fwidth(s) * 1.5;\r\n    s = smoothstep(0.84-sf, 0.84+sf, s );\r\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\r\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\r\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\r\n\r\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\r\n\r\n#ifdef DISPLAY_LLAMEL\r\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\r\n#endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 terrainTransformRo( const in vec3 ro ) {\r\n    vec3 rom = terrainTransform(ro);\r\n    rom.y -= EARTH_RADIUS - 100.;\r\n    rom.xz *= 5.;\r\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \r\n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\r\n    return rom;\r\n}\r\n\r\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \r\n    vec3 p,\r\n    rom = terrainTransformRo(ro),\r\n    rdm = terrainTransform(rd);\r\n        \r\n    float tmin = 10.0;\r\n    float tmax = 3200.0;\r\n    \r\n    float res = terrainIntersect( rom, rdm, tmin, tmax );\r\n    \r\n    if( res > tmax ) {\r\n        res = -1.;\r\n    } else {\r\n        vec3 pos =  rom+rdm*res;\r\n        n = terrainCalcNormalMed( pos, res );\r\n        n = terrainUntransform( n );\r\n        \r\n        intersection = ro+rd*res/100.;\r\n    }\r\n    return vec4(res, rom+rdm*res);\r\n}\r\n\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// LLamels by Eiffie\r\n//\r\n// https://www.shadertoy.com/view/ltsGz4\r\n//-----------------------------------------------------\r\n#ifdef DISPLAY_LLAMEL\r\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\r\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\r\n}\r\n\r\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\r\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\r\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\r\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\r\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\r\n\tu=p-j0;q=j1-j0;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\r\n\tu=p-j1;q=j2-j1;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\r\n\tu=p-j2;q=j3-j2;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\r\n}\r\n\r\nfloat llamelMap(in vec3 p) {\r\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\r\n\tp.y += 0.25*llamelScale;\r\n    p.xz -= 0.5*llamelScale;\r\n    p.xz = vec2(-p.z, p.x);\r\n    vec3 pori = p;\r\n        \r\n    p /= llamelScale;\r\n    \r\n\tvec2 c=floor(p.xz);\r\n\tp.xz=fract(p.xz)-vec2(0.5);\r\n    p.y -= p.x*.04*llamelScale;\r\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\r\n\r\n    float b=0.83-abs(p.z);\r\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\r\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\r\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\r\n\tp.y-=0.03;\r\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\r\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\r\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\r\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\r\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\r\n\ta=max(abs(p.z),p.y)+0.05;\r\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\r\n}\r\n\r\nvec3 llamelGetNormal( in vec3 ro ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001;\r\n\r\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\r\n}\r\n\r\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    ro -= llamelPosition();\r\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\r\n\tfor(int i=0;i<36;i++){\r\n\t\tt+=d=llamelMap(ro+rd*t);\r\n\t\tif(d<dm){dm=d;tm=t;}\r\n\t\tif(t>1000.0 || d<0.00001)break;\r\n\t}\r\n\tdm=max(0.0,dm);\r\n    if( dm < .02 ) {\r\n        vec3 col = vec3(0.45,.30,0.15)*.2;\r\n        vec3 pos = ro + rd*tm;\r\n        vec3 nor = llamelGetNormal( pos );\r\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \r\n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\r\n    }\r\n    \r\n    return vec4(0.);\r\n}\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// Clouds (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \r\n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\r\n\tvec3 intersection = ro+rd*d;\r\n    vec3 cint = intersection*0.009;\r\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\r\n\r\n    cint.xy = rotate( rot, cint.xy );\r\n\r\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\r\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\r\n\r\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\r\n\r\n#ifdef DISPLAY_CLOUDS_DETAIL\r\n    if( d < 200. ) {\r\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\r\n    }\r\n#endif\r\n\r\n    shadow = clamp(1.-clouds, 0., 1.);\r\n\r\n    clouds = clamp(clouds, 0., 1.);\r\n    clouds *= clouds;\r\n    clouds *= smoothstep(0.,0.4,d);\r\n\r\n    vec3 clbasecolor = vec3(1.);\r\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\r\n    clcol += .3*clbasecolor*sunColor;\r\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \r\n    \r\n    return vec4( clcol, clouds );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Planet (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\r\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n\r\n    vec3 intersection = ro + rd*d;\r\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n    vec4 res;\r\n\r\n#ifndef HIDE_TERRAIN\r\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \r\n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\r\n#endif\r\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \r\n    float mixDetailColor = 0.;\r\n        \r\n\tif( d < 0. || d > maxd) {\r\n#ifndef HIDE_TERRAIN\r\n        if( renderTerrainDetail ) {\r\n       \t\tintersection = ro;\r\n            n = normalize( ro );\r\n        } else { \t       \r\n\t        return vec4(0);\r\n        }\r\n#else \r\n      \treturn vec4(0.);\r\n#endif\r\n\t}\r\n    if( d > 0. ) {\r\n\t    maxd = d;\r\n    }\r\n    float att = 0.;\r\n    \r\n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\r\n    \r\n    float dm = MAX, e = 0.;\r\n    vec3 col, detailCol, nDetail;\r\n    \r\n    // normal and intersection \r\n#ifndef HIDE_TERRAIN\r\n    if( renderTerrainDetail ) {   \r\n        res = renderTerrain( ro, rd, intersection, nDetail );\r\n        if( res.x < 0. && d < 0. ) {\r\n\t        return vec4(0);\r\n        }\r\n        if( res.x >= 0. ) {\r\n            maxd = pow(res.x/4000.,4.)*50.;\r\n            e = -10.;\r\n        }\r\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\r\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\r\n    } else \r\n#endif        \r\n    if( renderSeaDetail ) {    \r\n        float attsea, mf = smoothstep(.5,1.,d);\r\n\r\n        renderSea( ro, rd, nDetail, attsea );\r\n\r\n        n = normalize(mix( nDetail, n, mf ));\r\n        att = mix( attsea, att, mf );\r\n    } else {\r\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\r\n#ifndef HIDE_TERRAIN\r\n        if( d < 1500. ) {\r\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\r\n        }\r\n#endif  \r\n    }\r\n    \r\n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \r\n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \r\n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \r\n                 \r\n    // color  \r\n#ifndef HIDE_TERRAIN\r\n    if(renderTerrainDetail ) {\r\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\r\n\t\td = 0.;\r\n    }   \r\n#endif\r\n     \r\n    if( mixDetailColor < 1. ) {\r\n        if( e < .45 ) {\r\n            // sea\r\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \r\n        } else {\r\n            // planet (land) far\r\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\r\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\r\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\r\n\r\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\r\n            vec3 landColor2 = RING_COLOR_1 * land2;\r\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\r\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\r\n\r\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\r\n#ifdef HIGH_QUALITY\r\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\r\n#endif\r\n        }\r\n    }\r\n    \r\n    if( mixDetailColor > 0. ) {\r\n        col = mix( col, detailCol, mixDetailColor );\r\n    }\r\n        \r\n#ifdef DISPLAY_LLAMEL\r\n    if(renderTerrainDetail ) {\r\n        vec3 rom = terrainTransformRo(ro),\r\n        rdm = terrainTransform(rd);\r\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\r\n        if( d > 0. ) {\r\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\r\n            col = mix(col, llamel.rgb, llamel.a);\r\n        }\r\n    }\r\n#endif\r\n    \r\n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\r\n    if( d > 0. ) { \r\n        float shadow;\r\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\r\n        col *= shadow; \r\n        col = mix( col, clouds.rgb, clouds.w );\r\n    }\r\n    \r\n    float m = MAX;\r\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\r\n\r\n \treturn vec4( col, 1. ); \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lens flare by musk\r\n//\r\n// https://www.shadertoy.com/view/4sX3Rs\r\n//-----------------------------------------------------\r\n\r\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\r\n\tc = c*.5 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// cameraPath\r\n//-----------------------------------------------------\r\n\r\nvec3 pro, pta, pup;\r\nfloat dro, dta, dup;\r\n\r\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\r\n    if( t >= prevt && t <= prevt+duration ) {\r\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\r\n    }\r\n    prev = dest;\r\n    prevt += duration;\r\n}\r\n\r\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\r\n#ifndef HIDE_TERRAIN\r\n    time = t = mod( t, 92. );\r\n#else\r\n    time = t = mod( t, 66. );\r\n#endif\r\n    dro = dta = dup = 0.;\r\n\r\n    pro = ro = vec3(900. ,7000. ,1500. );\r\n    pta = ta = vec3(    0. ,    0. ,   0. );\r\n    pup = up = vec3(    0. ,    0.4,   1. ); \r\n   \r\n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\r\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \r\n \r\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\r\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\r\n\r\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\r\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\r\n    \r\n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7.,roe, pro, dro );\r\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\r\n    camint( up, t, 6., upe, pup, dup );\r\n        \r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n    \r\n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\r\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\r\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \r\n#ifndef HIDE_TERRAIN    \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7., roe, pro, dro );\r\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\r\n    camint( up, t, 2., upe, pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\r\n    camint( ro, t, 4.,roe, pro, dro );\r\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\r\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\r\n#endif    \r\n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\r\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \r\n    \r\n    up = normalize( up );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// mainImage\r\n//-----------------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    \r\n    vec3 col;\r\n    \r\n// black bands\r\n    vec2 bandy = vec2(.1,.9);\r\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\r\n        col = vec3(0.);\r\n    } else {\r\n        // camera\r\n        vec3 ro, ta, up;\r\n        cameraPath( iTime*.7, ro, ta, up );\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,up) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        float maxd = MAX;  \r\n        col = renderStars( rd ).xyz;\r\n\r\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \r\n        if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n        float atmosphered = maxd;\r\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n        vec4 ring = renderRing( ro, rd, maxd );\r\n        if( ring.w > 0. && atmosphered < maxd ) {\r\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \r\n        }\r\n        col = col * (1.-ring.w ) + ring.xyz;\r\n\r\n#ifdef DISPLAY_CLOUDS\r\n        float lro = length(ro);\r\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\r\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \r\n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \r\n\r\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\r\n                // clouds\r\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\r\n                if( d < maxd ) {\r\n                    float shadow;\r\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\r\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\r\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\r\n                }\r\n            }\r\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\r\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\r\n        }\r\n#endif \r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);      \r\n\r\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\r\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\r\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\r\n\r\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\r\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \r\n    }\r\n    fragColor = vec4( col ,1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n    float maxd = MAX;  \r\n    time = iTime * .7;\r\n    \r\n    rd = rd.xzy;\r\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\r\n    \r\n    vec3 col = renderStars( rd ).xyz;\r\n\r\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \r\n    if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n    float atmosphered = maxd;\r\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n    vec4 ring = renderRing( ro, rd, maxd );\r\n    col = col * (1.-ring.w ) + ring.xyz;\r\n    \r\n    // post processing\r\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n    col *= vec3(1.,0.99,0.95);   \r\n    col = clamp(1.06*col-0.03, 0., 1.);      \r\n    fragColor = vec4( col ,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Planet Shadertoy. Created by Reinder Nijhoff 2015\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/4tjGRh\r\n//\r\n// It uses code from the following shaders:\r\n//\r\n// Wet stone by TDM\r\n// Atmospheric Scattering by GLtracy\r\n// Seascape by TDM\r\n// Elevated and Terrain Tubes by IQ\r\n// LLamels by Eiffie\r\n// Lens flare by Musk\r\n// \r\n\r\n//#define HIGH_QUALITY\r\n//#define MED_QUALITY\r\n//#define LOW_QUALITY\r\n#define VERY_LOW_QUALITY\r\n\r\nconst float PI = 3.14159265359;\r\nconst float DEG_TO_RAD = (PI / 180.0);\r\nconst float MAX = 10000.0;\r\n\r\nconst float EARTH_RADIUS = 1000.;\r\nconst float EARTH_ATMOSPHERE = 5.;\r\nconst float EARTH_CLOUDS = 1.;\r\n\r\nconst float RING_INNER_RADIUS = 1500.;\r\nconst float RING_OUTER_RADIUS = 2300.;\r\nconst float RING_HEIGHT = 2.;\r\n\r\n#ifdef HIGH_QUALITY\r\n    const int   SEA_NUM_STEPS = 7;\r\n    const int\tTERRAIN_NUM_STEPS = 140;\r\n    const int   ASTEROID_NUM_STEPS = 11;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\r\n    const int   RING_VOXEL_STEPS = 25;\r\n    const float ASTEROID_MAX_DISTANCE = 1.1; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\r\n\r\n    #define DISPLAY_LLAMEL\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n#endif\r\n\r\n#ifdef MED_QUALITY\r\n    const int   SEA_NUM_STEPS = 6;\r\n    const int\tTERRAIN_NUM_STEPS = 100;\r\n    const int   ASTEROID_NUM_STEPS = 10;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\r\n    const int   RING_VOXEL_STEPS = 24;\r\n    const float ASTEROID_MAX_DISTANCE = 1.; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n#endif\r\n\r\n#ifdef LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 5;\r\n    const int\tTERRAIN_NUM_STEPS = 75;\r\n    const int   ASTEROID_NUM_STEPS = 9;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\r\n    const int   RING_VOXEL_STEPS = 20;\r\n    const float ASTEROID_MAX_DISTANCE = .85; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\r\n#endif\r\n\r\n#ifdef VERY_LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 4;\r\n    const int\tTERRAIN_NUM_STEPS = 60;\r\n    const int   ASTEROID_NUM_STEPS = 7;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\r\n    const int   RING_VOXEL_STEPS = 16;\r\n    const float ASTEROID_MAX_DISTANCE = .67; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\r\n\t#define HIDE_TERRAIN\r\n#endif\r\n\r\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\r\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\r\n\r\nfloat time;\r\n\r\n//-----------------------------------------------------\r\n// Noise functions\r\n//-----------------------------------------------------\r\n\r\nfloat hash( const in float n ) {\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\nfloat hash( const in vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat hash( const in vec3 p ) {\r\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nvec3 hash31( const in float p) {\r\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\r\n    return fract(sin(h)*43758.543123);\r\n}\r\nvec3 hash33( const in vec3 p) {\r\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\r\n}\r\n\r\nfloat noise( const in  float p ) {    \r\n    float i = floor( p );\r\n    float f = fract( p );\t\r\n\tfloat u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\r\n}\r\n\r\nfloat noise( const in  vec2 p ) {    \r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat noise( const in  vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\r\n}\r\n\r\nfloat tri( const in vec2 p ) {\r\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\r\n   \r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( in vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); \r\n    \r\n#ifndef LOW_QUALITY\r\n#ifndef VERY_LOW_QUALITY\r\n    p = m2*p*2.01;\r\n    f += 0.0625*noise( p );\r\n#endif\r\n#endif\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm( const in vec3 p, const in float a, const in float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < FBM_STEPS; i++) {\r\n        float n = pow(noise(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lightning functions\r\n//-----------------------------------------------------\r\n\r\nfloat diffuse( const in vec3 n, const in vec3 l) { \r\n    return clamp(dot(n,l),0.,1.);\r\n}\r\n\r\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\r\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Math functions\r\n//-----------------------------------------------------\r\n\r\nvec2 rotate(float angle, vec2 v) {\r\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\r\n}\r\n\r\nfloat boolSub(float a,float b) { \r\n    return max(a,-b); \r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Intersection functions (by iq)\r\n//-----------------------------------------------------\r\n\r\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\r\n    return (pos-sph.xyz)/sph.w;\r\n}\r\n\r\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return -1.0;\r\n\treturn -b - sqrt( h );\r\n}\r\n\r\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return -MAX;\r\n\treturn -b + sqrt( d );\r\n}\r\n\r\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\r\n\td = sqrt( d );\r\n\treturn vec2( -b - d, -b + d );\r\n}\r\n\r\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\r\n    return obj.xyz;\r\n}\r\n\r\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\r\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Wet stone by TDM\r\n// \r\n// https://www.shadertoy.com/view/ldSSzV\r\n//-----------------------------------------------------\r\n\r\nconst float ASTEROID_TRESHOLD \t= 0.001;\r\nconst float ASTEROID_EPSILON \t= 1e-6;\r\nconst float ASTEROID_DISPLACEMENT = 0.1;\r\nconst float ASTEROID_RADIUS = 0.13;\r\n\r\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\r\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\r\n\r\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \r\n    float d = sphere(p,ASTEROID_RADIUS);    \r\n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\r\n        float ii = float(i)+id.x;\r\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( xyangle, ro.xy );\r\n    \r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( yzangle, ro.yz );\r\n}\r\n\r\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( -yzangle, ro.yz );\r\n\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( -xyangle, ro.xy );  \r\n}\r\n\r\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\r\n    asteroidTransForm( p, id );\r\n    \r\n    vec3 n;\r\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\r\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\r\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\r\n    n = normalize(n-asteroidMapDetailed(p, id));\r\n    \r\n    asteroidUnTransForm( n, id );\r\n    return n;\r\n}\r\n\r\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\r\n    asteroidTransForm( ori, id );\r\n    asteroidTransForm( dir, id );\r\n    \r\n    vec2 td = vec2(0,1);\r\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\r\n        td.y = asteroidMap(ori + dir * td.x, id);\r\n        td.x += td.y;\r\n    }\r\n    return td;\r\n}\r\n\r\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nconst float RING_DETAIL_DISTANCE = 40.;\r\nconst float RING_VOXEL_STEP_SIZE = .03;\r\n\r\nvec3 ringShadowColor( const in vec3 ro ) {\r\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\r\n        return vec3(0.);\r\n    }\r\n    return vec3(1.);\r\n}\r\n\r\nbool ringMap( const in vec3 ro ) {\r\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\r\n}\r\n\r\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \r\n// find startpoint \r\n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\r\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\r\n    \r\n    float d = min( max(d1,0.), max(d2,0.) );\r\n   \r\n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\r\n        return vec4( 0. );\r\n    } else {\r\n        vec3 ros = ro + rd*d;\r\n\r\n        // avoid precision problems..\r\n        vec2 mroxy = mod(ros.xy, vec2(10.));\r\n        vec2 roxy = ros.xy - mroxy;\r\n        ros.xy -= roxy;\r\n        ros /= RING_VOXEL_STEP_SIZE;\r\n        //ros.xy -= vec2(.013,.112)*time*.5;\r\n\r\n        vec3 pos = floor(ros);\r\n        vec3 ri = 1.0/rd;\r\n        vec3 rs = sign(rd);\r\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\r\n\r\n        float alpha = 0., dint;\r\n        vec3 offset = vec3(0), id, asteroidro;\r\n        vec2 asteroid = vec2(0);\r\n\r\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\r\n            if( ringMap(pos) ) {\r\n                id = hash33(pos);\r\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\r\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\r\n\r\n                if( dint > 0. ) {\r\n                    asteroidro = ros+rd*dint-(pos+offset);\r\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\r\n\r\n                    if( asteroid.y < .1 ) {\r\n                        alpha = 1.;\r\n                        break;\t    \r\n                    }\r\n                }\r\n\r\n            }\r\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\r\n            dis += mm * rs * ri;\r\n            pos += mm * rs;\r\n        }\r\n\r\n        if( alpha > 0. ) {       \r\n            vec3 intersection = ros + rd*(asteroid.x+dint);\r\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\r\n\r\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\r\n\r\n            intersection *= RING_VOXEL_STEP_SIZE;\r\n            intersection.xy += roxy;\r\n          //  col *= ringShadowColor( intersection );\r\n\r\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. ) {\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n        } else {\r\n            return 0.;\r\n        }\r\n    } else {\r\n\t    return 0.;\r\n    }\r\n}\r\n\r\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. && d < maxd ) {\r\n        maxd = d;\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\r\n            \r\n            col *= ringShadowColor( intersection );\r\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\r\n\t\t\tcol *= SUN_COLOR;\r\n            return vec4( col, dens );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    } else {\r\n\t    return vec4(0.);\r\n    }\r\n}\r\n\r\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    vec4 far = renderRingFar( ro, rd, maxd );\r\n    float l = length( ro.xy );\r\n\r\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \r\n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \r\n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\r\n     \t\r\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\r\n        far.xyz *= detail;    \r\n    }\r\n    \r\n\t// are asteroids neaded ?\r\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \r\n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \r\n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\r\n        \r\n        vec4 near = renderRingNear( ro, rd );\r\n        far = mix( far, near, near.w );\r\n        maxd=0.;\r\n    }\r\n            \r\n    return far;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Stars (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderStars( const in vec3 rd ) {\r\n\tvec3 rds = rd;\r\n\tvec3 col = vec3(0);\r\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\r\n    \r\n    vec2 xy = vec2(rds.y * v, rds.x * v);\r\n    float s = noise(rds*134.);\r\n    \r\n    s += noise(rds*470.);\r\n    s = pow(s,19.0) * 0.00001;\r\n    if (s > 0.5) {\r\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \r\n        col += backStars;\r\n    }\r\n\treturn   vec4( col, 1 ); \r\n} \r\n\r\n//-----------------------------------------------------\r\n// Atmospheric Scattering by GLtracy\r\n// \r\n// https://www.shadertoy.com/view/lslXDr\r\n//-----------------------------------------------------\r\n\r\nconst float ATMOSPHERE_K_R = 0.166;\r\nconst float ATMOSPHERE_K_M = 0.0025;\r\nconst float ATMOSPHERE_E = 12.3;\r\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\r\nconst float ATMOSPHERE_G_M = -0.85;\r\n\r\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\r\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\r\n\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\r\n\r\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\r\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\r\n\r\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\r\n\tfloat gg = g * g;\r\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\r\n\tfloat b = 1.0 + gg - 2.0 * g * c;\r\n    \r\n\tb *= sqrt( b );\r\n\tb *= 2.0 + gg;\t\r\n\t\r\n\treturn 1.5 * a / b;\r\n}\r\n\r\nfloat atmosphericPhaseReyleigh( float cc ) {\r\n\treturn 0.75 * ( 1.0 + cc );\r\n}\r\n\r\nfloat atmosphericDensity( vec3 p ){\r\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\r\n}\r\n\r\nfloat atmosphericOptic( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n    float sumdensity = 0.;\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\r\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\r\n\t\tfloat dens = atmosphericDensity( v );\r\n  \r\n\t    float m = MAX;\r\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \r\n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\r\n \t\tsumdensity += dens;\r\n        \r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \r\n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\r\n}\r\n\r\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\r\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\r\n\t    float m = MAX;\r\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\r\n}\r\n\r\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \r\n    // inside or outside atmosphere?\r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\r\n        \r\n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\r\n        if( d < e.y ) {\r\n            e.y = d;\r\n        }\r\n\t\td = e.y;\r\n\t    e.x = 0.;\r\n        \r\n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\r\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\r\n\t\t}\r\n    } else {\r\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\r\n        \r\n        if ( e.x > e.y ) {\r\n        \td = MAX;\r\n\t\t\treturn vec4(0.);\r\n\t\t}\r\n\t\td = e.y = min( e.y, f.x );\r\n    }\r\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n    e.x = 0.;\r\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Seascape by TDM\r\n// \r\n// https://www.shadertoy.com/view/Ms2SD1\r\n//-----------------------------------------------------\r\n\r\nconst int   SEA_ITER_GEOMETRY = 3;\r\nconst int   SEA_ITER_FRAGMENT = 5;\r\n\r\nconst float SEA_EPSILON\t= 1e-3;\r\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\r\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\r\nfloat       SEA_TIME;\r\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\nfloat seaOctave( in vec2 uv, const in float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat seaMap(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat seaMapHigh(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \r\n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \r\n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \r\n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\r\n    \r\n    color += upc*SEA_WATER_COLOR * (att * 0.18);\r\n    color += sunc * vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\r\n    vec3 n;\r\n    n.y = seaMapHigh(p);    \r\n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = seaMap(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = seaMap(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = seaMap(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 seaTransform( in vec3 x ) {\r\n    x.yz = rotate( 0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvec3 seaUntransform( in vec3 x ) {\r\n    x.yz = rotate( -0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \r\n    vec3 p,\r\n    rom = seaTransform(ro),\r\n    rdm = seaTransform(rd);\r\n    \r\n    rom.y -= EARTH_RADIUS;\r\n    rom *= 1000.;\r\n    rom.xz += vec2(3.1,.2)*time;\r\n\r\n    SEA_TIME = time * SEA_SPEED;\r\n    \r\n    seaHeightMapTracing(rom,rdm,p);\r\n    float squareddist = dot(p - rom, p-rom );\r\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\r\n    \r\n    n = seaUntransform(n);\r\n    \r\n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Terrain based on Elevated and Terrain Tubes by IQ\r\n//\r\n// https://www.shadertoy.com/view/MdX3Rr\r\n// https://www.shadertoy.com/view/4sjXzG\r\n//-----------------------------------------------------\r\n\r\n#ifndef HIDE_TERRAIN\r\n\r\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\r\n\r\nfloat terrainLow( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<2; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMed( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<6; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n            \r\n    return t*33.0;\r\n}\r\n\r\nfloat terrainHigh( vec2 p ) {\r\n    vec2 q = p;\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<7; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n    \r\n    t += t*0.015*fbm( q );\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMap( const in vec3 pos ) {\r\n\treturn pos.y - terrainMed(pos.xz);  \r\n}\r\n\r\nfloat terrainMapH( const in vec3 pos ) {\r\n    float y = terrainHigh(pos.xz);\r\n    float h = pos.y - y;\r\n    return h;\r\n}\r\n\r\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\r\n    float t = tmin;\r\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\r\n        vec3 pos = ro + t*rd;\r\n        float res = terrainMap( pos );\r\n        if( res<(0.001*t) || t>tmax  ) break;\r\n        t += res*.9;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\r\n\tvec2  eps = vec2(150.0,0.0);\r\n    float h1 = terrainMed( ro.xz );\r\n    float h2 = terrainLow( ro.xz );\r\n    \r\n    float d1 = 10.0;\r\n    float d2 = 80.0;\r\n    float d3 = 200.0;\r\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\r\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\r\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\r\n\r\n    return min(min(s1,s2),s3);\r\n}\r\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\r\n\r\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\r\n}\r\n\r\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\r\n\tfloat e = 0.005*t;\r\n    vec2  eps = vec2(e,0.0);\r\n    float h = terrainMed( pos.xz );\r\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\r\n}\r\n\r\nvec3 terrainTransform( in vec3 x ) {\r\n    x.zy = rotate( -.83, x.zy );\r\n    return x;\r\n}\r\n\r\nvec3 terrainUntransform( in vec3 x ) {\r\n    x.zy = rotate( .83, x.zy );\r\n    return x;\r\n}\r\n\r\n\r\nfloat llamelTime;\r\nconst float llamelScale = 5.;\r\n\r\nvec3 llamelPosition() {\r\n    llamelTime = time*2.5;\r\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\r\n    return vec3( pos.x, terrainMed( pos ), pos.y );\r\n}\r\n\r\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \r\n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\r\n    float dif = diffuse( n, sunDirection );\r\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\r\n    float sha = terrainCalcShadow( pos, sunDirection );\r\n    float amb = clamp( n.y,0.0,1.0);\r\n        \r\n    vec3 lin  = vec3(0.0);\r\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\r\n    lin += 0.2*amb*upc;\r\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\r\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\r\n}\r\n\r\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    vec3 nor = terrainCalcNormalHigh( pos, t );\r\n    vec3 sor = terrainCalcNormalMed( pos, t );\r\n        \r\n    float spec = 0.005;\r\n\r\n#ifdef DISPLAY_TERRAIN_DETAIL\r\n    float no = noise(5.*fbm(1.11*pos.xz));\r\n#else\r\n    const float no = 0.;\r\n#endif\r\n    float r = .5+.5*fbm(.95*pos.xz);\r\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\r\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\r\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\r\n    col *= .88+.12*no;\r\n        \r\n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\r\n    float sf = fwidth(s) * 1.5;\r\n    s = smoothstep(0.84-sf, 0.84+sf, s );\r\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\r\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\r\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\r\n\r\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\r\n\r\n#ifdef DISPLAY_LLAMEL\r\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\r\n#endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 terrainTransformRo( const in vec3 ro ) {\r\n    vec3 rom = terrainTransform(ro);\r\n    rom.y -= EARTH_RADIUS - 100.;\r\n    rom.xz *= 5.;\r\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \r\n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\r\n    return rom;\r\n}\r\n\r\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \r\n    vec3 p,\r\n    rom = terrainTransformRo(ro),\r\n    rdm = terrainTransform(rd);\r\n        \r\n    float tmin = 10.0;\r\n    float tmax = 3200.0;\r\n    \r\n    float res = terrainIntersect( rom, rdm, tmin, tmax );\r\n    \r\n    if( res > tmax ) {\r\n        res = -1.;\r\n    } else {\r\n        vec3 pos =  rom+rdm*res;\r\n        n = terrainCalcNormalMed( pos, res );\r\n        n = terrainUntransform( n );\r\n        \r\n        intersection = ro+rd*res/100.;\r\n    }\r\n    return vec4(res, rom+rdm*res);\r\n}\r\n\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// LLamels by Eiffie\r\n//\r\n// https://www.shadertoy.com/view/ltsGz4\r\n//-----------------------------------------------------\r\n#ifdef DISPLAY_LLAMEL\r\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\r\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\r\n}\r\n\r\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\r\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\r\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\r\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\r\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\r\n\tu=p-j0;q=j1-j0;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\r\n\tu=p-j1;q=j2-j1;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\r\n\tu=p-j2;q=j3-j2;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\r\n}\r\n\r\nfloat llamelMap(in vec3 p) {\r\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\r\n\tp.y += 0.25*llamelScale;\r\n    p.xz -= 0.5*llamelScale;\r\n    p.xz = vec2(-p.z, p.x);\r\n    vec3 pori = p;\r\n        \r\n    p /= llamelScale;\r\n    \r\n\tvec2 c=floor(p.xz);\r\n\tp.xz=fract(p.xz)-vec2(0.5);\r\n    p.y -= p.x*.04*llamelScale;\r\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\r\n\r\n    float b=0.83-abs(p.z);\r\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\r\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\r\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\r\n\tp.y-=0.03;\r\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\r\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\r\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\r\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\r\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\r\n\ta=max(abs(p.z),p.y)+0.05;\r\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\r\n}\r\n\r\nvec3 llamelGetNormal( in vec3 ro ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001;\r\n\r\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\r\n}\r\n\r\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    ro -= llamelPosition();\r\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\r\n\tfor(int i=0;i<36;i++){\r\n\t\tt+=d=llamelMap(ro+rd*t);\r\n\t\tif(d<dm){dm=d;tm=t;}\r\n\t\tif(t>1000.0 || d<0.00001)break;\r\n\t}\r\n\tdm=max(0.0,dm);\r\n    if( dm < .02 ) {\r\n        vec3 col = vec3(0.45,.30,0.15)*.2;\r\n        vec3 pos = ro + rd*tm;\r\n        vec3 nor = llamelGetNormal( pos );\r\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \r\n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\r\n    }\r\n    \r\n    return vec4(0.);\r\n}\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// Clouds (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \r\n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\r\n\tvec3 intersection = ro+rd*d;\r\n    vec3 cint = intersection*0.009;\r\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\r\n\r\n    cint.xy = rotate( rot, cint.xy );\r\n\r\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\r\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\r\n\r\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\r\n\r\n#ifdef DISPLAY_CLOUDS_DETAIL\r\n    if( d < 200. ) {\r\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\r\n    }\r\n#endif\r\n\r\n    shadow = clamp(1.-clouds, 0., 1.);\r\n\r\n    clouds = clamp(clouds, 0., 1.);\r\n    clouds *= clouds;\r\n    clouds *= smoothstep(0.,0.4,d);\r\n\r\n    vec3 clbasecolor = vec3(1.);\r\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\r\n    clcol += .3*clbasecolor*sunColor;\r\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \r\n    \r\n    return vec4( clcol, clouds );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Planet (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\r\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n\r\n    vec3 intersection = ro + rd*d;\r\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n    vec4 res;\r\n\r\n#ifndef HIDE_TERRAIN\r\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \r\n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\r\n#endif\r\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \r\n    float mixDetailColor = 0.;\r\n        \r\n\tif( d < 0. || d > maxd) {\r\n#ifndef HIDE_TERRAIN\r\n        if( renderTerrainDetail ) {\r\n       \t\tintersection = ro;\r\n            n = normalize( ro );\r\n        } else { \t       \r\n\t        return vec4(0);\r\n        }\r\n#else \r\n      \treturn vec4(0.);\r\n#endif\r\n\t}\r\n    if( d > 0. ) {\r\n\t    maxd = d;\r\n    }\r\n    float att = 0.;\r\n    \r\n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\r\n    \r\n    float dm = MAX, e = 0.;\r\n    vec3 col, detailCol, nDetail;\r\n    \r\n    // normal and intersection \r\n#ifndef HIDE_TERRAIN\r\n    if( renderTerrainDetail ) {   \r\n        res = renderTerrain( ro, rd, intersection, nDetail );\r\n        if( res.x < 0. && d < 0. ) {\r\n\t        return vec4(0);\r\n        }\r\n        if( res.x >= 0. ) {\r\n            maxd = pow(res.x/4000.,4.)*50.;\r\n            e = -10.;\r\n        }\r\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\r\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\r\n    } else \r\n#endif        \r\n    if( renderSeaDetail ) {    \r\n        float attsea, mf = smoothstep(.5,1.,d);\r\n\r\n        renderSea( ro, rd, nDetail, attsea );\r\n\r\n        n = normalize(mix( nDetail, n, mf ));\r\n        att = mix( attsea, att, mf );\r\n    } else {\r\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\r\n#ifndef HIDE_TERRAIN\r\n        if( d < 1500. ) {\r\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\r\n        }\r\n#endif  \r\n    }\r\n    \r\n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \r\n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \r\n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \r\n                 \r\n    // color  \r\n#ifndef HIDE_TERRAIN\r\n    if(renderTerrainDetail ) {\r\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\r\n\t\td = 0.;\r\n    }   \r\n#endif\r\n     \r\n    if( mixDetailColor < 1. ) {\r\n        if( e < .45 ) {\r\n            // sea\r\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \r\n        } else {\r\n            // planet (land) far\r\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\r\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\r\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\r\n\r\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\r\n            vec3 landColor2 = RING_COLOR_1 * land2;\r\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\r\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\r\n\r\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\r\n#ifdef HIGH_QUALITY\r\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\r\n#endif\r\n        }\r\n    }\r\n    \r\n    if( mixDetailColor > 0. ) {\r\n        col = mix( col, detailCol, mixDetailColor );\r\n    }\r\n        \r\n#ifdef DISPLAY_LLAMEL\r\n    if(renderTerrainDetail ) {\r\n        vec3 rom = terrainTransformRo(ro),\r\n        rdm = terrainTransform(rd);\r\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\r\n        if( d > 0. ) {\r\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\r\n            col = mix(col, llamel.rgb, llamel.a);\r\n        }\r\n    }\r\n#endif\r\n    \r\n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\r\n    if( d > 0. ) { \r\n        float shadow;\r\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\r\n        col *= shadow; \r\n        col = mix( col, clouds.rgb, clouds.w );\r\n    }\r\n    \r\n    float m = MAX;\r\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\r\n\r\n \treturn vec4( col, 1. ); \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lens flare by musk\r\n//\r\n// https://www.shadertoy.com/view/4sX3Rs\r\n//-----------------------------------------------------\r\n\r\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\r\n\tc = c*.5 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// cameraPath\r\n//-----------------------------------------------------\r\n\r\nvec3 pro, pta, pup;\r\nfloat dro, dta, dup;\r\n\r\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\r\n    if( t >= prevt && t <= prevt+duration ) {\r\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\r\n    }\r\n    prev = dest;\r\n    prevt += duration;\r\n}\r\n\r\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\r\n#ifndef HIDE_TERRAIN\r\n    time = t = mod( t, 92. );\r\n#else\r\n    time = t = mod( t, 66. );\r\n#endif\r\n    dro = dta = dup = 0.;\r\n\r\n    pro = ro = vec3(900. ,7000. ,1500. );\r\n    pta = ta = vec3(    0. ,    0. ,   0. );\r\n    pup = up = vec3(    0. ,    0.4,   1. ); \r\n   \r\n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\r\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \r\n \r\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\r\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\r\n\r\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\r\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\r\n    \r\n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7.,roe, pro, dro );\r\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\r\n    camint( up, t, 6., upe, pup, dup );\r\n        \r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n    \r\n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\r\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\r\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \r\n#ifndef HIDE_TERRAIN    \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7., roe, pro, dro );\r\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\r\n    camint( up, t, 2., upe, pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\r\n    camint( ro, t, 4.,roe, pro, dro );\r\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\r\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\r\n#endif    \r\n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\r\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \r\n    \r\n    up = normalize( up );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// mainImage\r\n//-----------------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    \r\n    vec3 col;\r\n    \r\n// black bands\r\n    vec2 bandy = vec2(.1,.9);\r\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\r\n        col = vec3(0.);\r\n    } else {\r\n        // camera\r\n        vec3 ro, ta, up;\r\n        cameraPath( iTime*.7, ro, ta, up );\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,up) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        float maxd = MAX;  \r\n        col = renderStars( rd ).xyz;\r\n\r\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \r\n        if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n        float atmosphered = maxd;\r\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n        vec4 ring = renderRing( ro, rd, maxd );\r\n        if( ring.w > 0. && atmosphered < maxd ) {\r\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \r\n        }\r\n        col = col * (1.-ring.w ) + ring.xyz;\r\n\r\n#ifdef DISPLAY_CLOUDS\r\n        float lro = length(ro);\r\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\r\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \r\n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \r\n\r\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\r\n                // clouds\r\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\r\n                if( d < maxd ) {\r\n                    float shadow;\r\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\r\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\r\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\r\n                }\r\n            }\r\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\r\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\r\n        }\r\n#endif \r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);      \r\n\r\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\r\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\r\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\r\n\r\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\r\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \r\n    }\r\n    fragColor = vec4( col ,1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n    float maxd = MAX;  \r\n    time = iTime * .7;\r\n    \r\n    rd = rd.xzy;\r\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\r\n    \r\n    vec3 col = renderStars( rd ).xyz;\r\n\r\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \r\n    if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n    float atmosphered = maxd;\r\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n    vec4 ring = renderRing( ro, rd, maxd );\r\n    col = col * (1.-ring.w ) + ring.xyz;\r\n    \r\n    // post processing\r\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n    col *= vec3(1.,0.99,0.95);   \r\n    col = clamp(1.06*col-0.03, 0., 1.);      \r\n    fragColor = vec4( col ,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Planet Shadertoy","id":"83057a172f5245499c274f0e948a36f5","date":null,"viewed":0,"name":"Planet Shadertoy","description":"A seamless space-to-surface flight. This is a tribute to all the great shaders on Shadertoy! Use chrome without angle (or a Mac) and run this shader on med, or high settings (line 4 or 5) to get the full shader and the detail I was aiming for.\r\nhttps://www.shadertoy.com/view/4tjGRh","likes":0,"published":null,"tags":["terrain"," sea"," space"," ocean"," planet"," shadertoy"," vr"," asteroids"]},"ver":null,"info":{"Name":"Planet Shadertoy","id":"83057a172f5245499c274f0e948a36f5","date":null,"viewed":0,"name":"Planet Shadertoy","description":"A seamless space-to-surface flight. This is a tribute to all the great shaders on Shadertoy! Use chrome without angle (or a Mac) and run this shader on med, or high settings (line 4 or 5) to get the full shader and the detail I was aiming for.\r\nhttps://www.shadertoy.com/view/4tjGRh","likes":0,"published":null,"tags":["terrain"," sea"," space"," ocean"," planet"," shadertoy"," vr"," asteroids"]},"renderpass":[{"Code":"// Planet Shadertoy. Created by Reinder Nijhoff 2015\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/4tjGRh\r\n//\r\n// It uses code from the following shaders:\r\n//\r\n// Wet stone by TDM\r\n// Atmospheric Scattering by GLtracy\r\n// Seascape by TDM\r\n// Elevated and Terrain Tubes by IQ\r\n// LLamels by Eiffie\r\n// Lens flare by Musk\r\n// \r\n\r\n//#define HIGH_QUALITY\r\n//#define MED_QUALITY\r\n//#define LOW_QUALITY\r\n#define VERY_LOW_QUALITY\r\n\r\nconst float PI = 3.14159265359;\r\nconst float DEG_TO_RAD = (PI / 180.0);\r\nconst float MAX = 10000.0;\r\n\r\nconst float EARTH_RADIUS = 1000.;\r\nconst float EARTH_ATMOSPHERE = 5.;\r\nconst float EARTH_CLOUDS = 1.;\r\n\r\nconst float RING_INNER_RADIUS = 1500.;\r\nconst float RING_OUTER_RADIUS = 2300.;\r\nconst float RING_HEIGHT = 2.;\r\n\r\n#ifdef HIGH_QUALITY\r\n    const int   SEA_NUM_STEPS = 7;\r\n    const int\tTERRAIN_NUM_STEPS = 140;\r\n    const int   ASTEROID_NUM_STEPS = 11;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\r\n    const int   RING_VOXEL_STEPS = 25;\r\n    const float ASTEROID_MAX_DISTANCE = 1.1; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\r\n\r\n    #define DISPLAY_LLAMEL\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n#endif\r\n\r\n#ifdef MED_QUALITY\r\n    const int   SEA_NUM_STEPS = 6;\r\n    const int\tTERRAIN_NUM_STEPS = 100;\r\n    const int   ASTEROID_NUM_STEPS = 10;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\r\n    const int   RING_VOXEL_STEPS = 24;\r\n    const float ASTEROID_MAX_DISTANCE = 1.; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n#endif\r\n\r\n#ifdef LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 5;\r\n    const int\tTERRAIN_NUM_STEPS = 75;\r\n    const int   ASTEROID_NUM_STEPS = 9;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\r\n    const int   RING_VOXEL_STEPS = 20;\r\n    const float ASTEROID_MAX_DISTANCE = .85; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\r\n#endif\r\n\r\n#ifdef VERY_LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 4;\r\n    const int\tTERRAIN_NUM_STEPS = 60;\r\n    const int   ASTEROID_NUM_STEPS = 7;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\r\n    const int   RING_VOXEL_STEPS = 16;\r\n    const float ASTEROID_MAX_DISTANCE = .67; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\r\n\t#define HIDE_TERRAIN\r\n#endif\r\n\r\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\r\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\r\n\r\nfloat time;\r\n\r\n//-----------------------------------------------------\r\n// Noise functions\r\n//-----------------------------------------------------\r\n\r\nfloat hash( const in float n ) {\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\nfloat hash( const in vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat hash( const in vec3 p ) {\r\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nvec3 hash31( const in float p) {\r\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\r\n    return fract(sin(h)*43758.543123);\r\n}\r\nvec3 hash33( const in vec3 p) {\r\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\r\n}\r\n\r\nfloat noise( const in  float p ) {    \r\n    float i = floor( p );\r\n    float f = fract( p );\t\r\n\tfloat u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\r\n}\r\n\r\nfloat noise( const in  vec2 p ) {    \r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat noise( const in  vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\r\n}\r\n\r\nfloat tri( const in vec2 p ) {\r\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\r\n   \r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( in vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); \r\n    \r\n#ifndef LOW_QUALITY\r\n#ifndef VERY_LOW_QUALITY\r\n    p = m2*p*2.01;\r\n    f += 0.0625*noise( p );\r\n#endif\r\n#endif\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm( const in vec3 p, const in float a, const in float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < FBM_STEPS; i++) {\r\n        float n = pow(noise(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lightning functions\r\n//-----------------------------------------------------\r\n\r\nfloat diffuse( const in vec3 n, const in vec3 l) { \r\n    return clamp(dot(n,l),0.,1.);\r\n}\r\n\r\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\r\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Math functions\r\n//-----------------------------------------------------\r\n\r\nvec2 rotate(float angle, vec2 v) {\r\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\r\n}\r\n\r\nfloat boolSub(float a,float b) { \r\n    return max(a,-b); \r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Intersection functions (by iq)\r\n//-----------------------------------------------------\r\n\r\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\r\n    return (pos-sph.xyz)/sph.w;\r\n}\r\n\r\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return -1.0;\r\n\treturn -b - sqrt( h );\r\n}\r\n\r\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return -MAX;\r\n\treturn -b + sqrt( d );\r\n}\r\n\r\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\r\n\td = sqrt( d );\r\n\treturn vec2( -b - d, -b + d );\r\n}\r\n\r\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\r\n    return obj.xyz;\r\n}\r\n\r\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\r\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Wet stone by TDM\r\n// \r\n// https://www.shadertoy.com/view/ldSSzV\r\n//-----------------------------------------------------\r\n\r\nconst float ASTEROID_TRESHOLD \t= 0.001;\r\nconst float ASTEROID_EPSILON \t= 1e-6;\r\nconst float ASTEROID_DISPLACEMENT = 0.1;\r\nconst float ASTEROID_RADIUS = 0.13;\r\n\r\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\r\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\r\n\r\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \r\n    float d = sphere(p,ASTEROID_RADIUS);    \r\n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\r\n        float ii = float(i)+id.x;\r\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( xyangle, ro.xy );\r\n    \r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( yzangle, ro.yz );\r\n}\r\n\r\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( -yzangle, ro.yz );\r\n\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( -xyangle, ro.xy );  \r\n}\r\n\r\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\r\n    asteroidTransForm( p, id );\r\n    \r\n    vec3 n;\r\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\r\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\r\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\r\n    n = normalize(n-asteroidMapDetailed(p, id));\r\n    \r\n    asteroidUnTransForm( n, id );\r\n    return n;\r\n}\r\n\r\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\r\n    asteroidTransForm( ori, id );\r\n    asteroidTransForm( dir, id );\r\n    \r\n    vec2 td = vec2(0,1);\r\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\r\n        td.y = asteroidMap(ori + dir * td.x, id);\r\n        td.x += td.y;\r\n    }\r\n    return td;\r\n}\r\n\r\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nconst float RING_DETAIL_DISTANCE = 40.;\r\nconst float RING_VOXEL_STEP_SIZE = .03;\r\n\r\nvec3 ringShadowColor( const in vec3 ro ) {\r\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\r\n        return vec3(0.);\r\n    }\r\n    return vec3(1.);\r\n}\r\n\r\nbool ringMap( const in vec3 ro ) {\r\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\r\n}\r\n\r\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \r\n// find startpoint \r\n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\r\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\r\n    \r\n    float d = min( max(d1,0.), max(d2,0.) );\r\n   \r\n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\r\n        return vec4( 0. );\r\n    } else {\r\n        vec3 ros = ro + rd*d;\r\n\r\n        // avoid precision problems..\r\n        vec2 mroxy = mod(ros.xy, vec2(10.));\r\n        vec2 roxy = ros.xy - mroxy;\r\n        ros.xy -= roxy;\r\n        ros /= RING_VOXEL_STEP_SIZE;\r\n        //ros.xy -= vec2(.013,.112)*time*.5;\r\n\r\n        vec3 pos = floor(ros);\r\n        vec3 ri = 1.0/rd;\r\n        vec3 rs = sign(rd);\r\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\r\n\r\n        float alpha = 0., dint;\r\n        vec3 offset = vec3(0), id, asteroidro;\r\n        vec2 asteroid = vec2(0);\r\n\r\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\r\n            if( ringMap(pos) ) {\r\n                id = hash33(pos);\r\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\r\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\r\n\r\n                if( dint > 0. ) {\r\n                    asteroidro = ros+rd*dint-(pos+offset);\r\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\r\n\r\n                    if( asteroid.y < .1 ) {\r\n                        alpha = 1.;\r\n                        break;\t    \r\n                    }\r\n                }\r\n\r\n            }\r\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\r\n            dis += mm * rs * ri;\r\n            pos += mm * rs;\r\n        }\r\n\r\n        if( alpha > 0. ) {       \r\n            vec3 intersection = ros + rd*(asteroid.x+dint);\r\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\r\n\r\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\r\n\r\n            intersection *= RING_VOXEL_STEP_SIZE;\r\n            intersection.xy += roxy;\r\n          //  col *= ringShadowColor( intersection );\r\n\r\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. ) {\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n        } else {\r\n            return 0.;\r\n        }\r\n    } else {\r\n\t    return 0.;\r\n    }\r\n}\r\n\r\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. && d < maxd ) {\r\n        maxd = d;\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\r\n            \r\n            col *= ringShadowColor( intersection );\r\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\r\n\t\t\tcol *= SUN_COLOR;\r\n            return vec4( col, dens );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    } else {\r\n\t    return vec4(0.);\r\n    }\r\n}\r\n\r\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    vec4 far = renderRingFar( ro, rd, maxd );\r\n    float l = length( ro.xy );\r\n\r\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \r\n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \r\n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\r\n     \t\r\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\r\n        far.xyz *= detail;    \r\n    }\r\n    \r\n\t// are asteroids neaded ?\r\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \r\n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \r\n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\r\n        \r\n        vec4 near = renderRingNear( ro, rd );\r\n        far = mix( far, near, near.w );\r\n        maxd=0.;\r\n    }\r\n            \r\n    return far;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Stars (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderStars( const in vec3 rd ) {\r\n\tvec3 rds = rd;\r\n\tvec3 col = vec3(0);\r\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\r\n    \r\n    vec2 xy = vec2(rds.y * v, rds.x * v);\r\n    float s = noise(rds*134.);\r\n    \r\n    s += noise(rds*470.);\r\n    s = pow(s,19.0) * 0.00001;\r\n    if (s > 0.5) {\r\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \r\n        col += backStars;\r\n    }\r\n\treturn   vec4( col, 1 ); \r\n} \r\n\r\n//-----------------------------------------------------\r\n// Atmospheric Scattering by GLtracy\r\n// \r\n// https://www.shadertoy.com/view/lslXDr\r\n//-----------------------------------------------------\r\n\r\nconst float ATMOSPHERE_K_R = 0.166;\r\nconst float ATMOSPHERE_K_M = 0.0025;\r\nconst float ATMOSPHERE_E = 12.3;\r\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\r\nconst float ATMOSPHERE_G_M = -0.85;\r\n\r\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\r\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\r\n\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\r\n\r\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\r\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\r\n\r\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\r\n\tfloat gg = g * g;\r\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\r\n\tfloat b = 1.0 + gg - 2.0 * g * c;\r\n    \r\n\tb *= sqrt( b );\r\n\tb *= 2.0 + gg;\t\r\n\t\r\n\treturn 1.5 * a / b;\r\n}\r\n\r\nfloat atmosphericPhaseReyleigh( float cc ) {\r\n\treturn 0.75 * ( 1.0 + cc );\r\n}\r\n\r\nfloat atmosphericDensity( vec3 p ){\r\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\r\n}\r\n\r\nfloat atmosphericOptic( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n    float sumdensity = 0.;\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\r\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\r\n\t\tfloat dens = atmosphericDensity( v );\r\n  \r\n\t    float m = MAX;\r\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \r\n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\r\n \t\tsumdensity += dens;\r\n        \r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \r\n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\r\n}\r\n\r\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\r\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\r\n\t    float m = MAX;\r\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\r\n}\r\n\r\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \r\n    // inside or outside atmosphere?\r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\r\n        \r\n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\r\n        if( d < e.y ) {\r\n            e.y = d;\r\n        }\r\n\t\td = e.y;\r\n\t    e.x = 0.;\r\n        \r\n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\r\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\r\n\t\t}\r\n    } else {\r\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\r\n        \r\n        if ( e.x > e.y ) {\r\n        \td = MAX;\r\n\t\t\treturn vec4(0.);\r\n\t\t}\r\n\t\td = e.y = min( e.y, f.x );\r\n    }\r\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n    e.x = 0.;\r\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Seascape by TDM\r\n// \r\n// https://www.shadertoy.com/view/Ms2SD1\r\n//-----------------------------------------------------\r\n\r\nconst int   SEA_ITER_GEOMETRY = 3;\r\nconst int   SEA_ITER_FRAGMENT = 5;\r\n\r\nconst float SEA_EPSILON\t= 1e-3;\r\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\r\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\r\nfloat       SEA_TIME;\r\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\nfloat seaOctave( in vec2 uv, const in float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat seaMap(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat seaMapHigh(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \r\n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \r\n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \r\n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\r\n    \r\n    color += upc*SEA_WATER_COLOR * (att * 0.18);\r\n    color += sunc * vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\r\n    vec3 n;\r\n    n.y = seaMapHigh(p);    \r\n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = seaMap(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = seaMap(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = seaMap(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 seaTransform( in vec3 x ) {\r\n    x.yz = rotate( 0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvec3 seaUntransform( in vec3 x ) {\r\n    x.yz = rotate( -0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \r\n    vec3 p,\r\n    rom = seaTransform(ro),\r\n    rdm = seaTransform(rd);\r\n    \r\n    rom.y -= EARTH_RADIUS;\r\n    rom *= 1000.;\r\n    rom.xz += vec2(3.1,.2)*time;\r\n\r\n    SEA_TIME = time * SEA_SPEED;\r\n    \r\n    seaHeightMapTracing(rom,rdm,p);\r\n    float squareddist = dot(p - rom, p-rom );\r\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\r\n    \r\n    n = seaUntransform(n);\r\n    \r\n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Terrain based on Elevated and Terrain Tubes by IQ\r\n//\r\n// https://www.shadertoy.com/view/MdX3Rr\r\n// https://www.shadertoy.com/view/4sjXzG\r\n//-----------------------------------------------------\r\n\r\n#ifndef HIDE_TERRAIN\r\n\r\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\r\n\r\nfloat terrainLow( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<2; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMed( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<6; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n            \r\n    return t*33.0;\r\n}\r\n\r\nfloat terrainHigh( vec2 p ) {\r\n    vec2 q = p;\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<7; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n    \r\n    t += t*0.015*fbm( q );\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMap( const in vec3 pos ) {\r\n\treturn pos.y - terrainMed(pos.xz);  \r\n}\r\n\r\nfloat terrainMapH( const in vec3 pos ) {\r\n    float y = terrainHigh(pos.xz);\r\n    float h = pos.y - y;\r\n    return h;\r\n}\r\n\r\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\r\n    float t = tmin;\r\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\r\n        vec3 pos = ro + t*rd;\r\n        float res = terrainMap( pos );\r\n        if( res<(0.001*t) || t>tmax  ) break;\r\n        t += res*.9;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\r\n\tvec2  eps = vec2(150.0,0.0);\r\n    float h1 = terrainMed( ro.xz );\r\n    float h2 = terrainLow( ro.xz );\r\n    \r\n    float d1 = 10.0;\r\n    float d2 = 80.0;\r\n    float d3 = 200.0;\r\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\r\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\r\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\r\n\r\n    return min(min(s1,s2),s3);\r\n}\r\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\r\n\r\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\r\n}\r\n\r\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\r\n\tfloat e = 0.005*t;\r\n    vec2  eps = vec2(e,0.0);\r\n    float h = terrainMed( pos.xz );\r\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\r\n}\r\n\r\nvec3 terrainTransform( in vec3 x ) {\r\n    x.zy = rotate( -.83, x.zy );\r\n    return x;\r\n}\r\n\r\nvec3 terrainUntransform( in vec3 x ) {\r\n    x.zy = rotate( .83, x.zy );\r\n    return x;\r\n}\r\n\r\n\r\nfloat llamelTime;\r\nconst float llamelScale = 5.;\r\n\r\nvec3 llamelPosition() {\r\n    llamelTime = time*2.5;\r\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\r\n    return vec3( pos.x, terrainMed( pos ), pos.y );\r\n}\r\n\r\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \r\n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\r\n    float dif = diffuse( n, sunDirection );\r\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\r\n    float sha = terrainCalcShadow( pos, sunDirection );\r\n    float amb = clamp( n.y,0.0,1.0);\r\n        \r\n    vec3 lin  = vec3(0.0);\r\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\r\n    lin += 0.2*amb*upc;\r\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\r\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\r\n}\r\n\r\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    vec3 nor = terrainCalcNormalHigh( pos, t );\r\n    vec3 sor = terrainCalcNormalMed( pos, t );\r\n        \r\n    float spec = 0.005;\r\n\r\n#ifdef DISPLAY_TERRAIN_DETAIL\r\n    float no = noise(5.*fbm(1.11*pos.xz));\r\n#else\r\n    const float no = 0.;\r\n#endif\r\n    float r = .5+.5*fbm(.95*pos.xz);\r\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\r\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\r\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\r\n    col *= .88+.12*no;\r\n        \r\n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\r\n    float sf = fwidth(s) * 1.5;\r\n    s = smoothstep(0.84-sf, 0.84+sf, s );\r\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\r\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\r\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\r\n\r\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\r\n\r\n#ifdef DISPLAY_LLAMEL\r\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\r\n#endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 terrainTransformRo( const in vec3 ro ) {\r\n    vec3 rom = terrainTransform(ro);\r\n    rom.y -= EARTH_RADIUS - 100.;\r\n    rom.xz *= 5.;\r\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \r\n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\r\n    return rom;\r\n}\r\n\r\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \r\n    vec3 p,\r\n    rom = terrainTransformRo(ro),\r\n    rdm = terrainTransform(rd);\r\n        \r\n    float tmin = 10.0;\r\n    float tmax = 3200.0;\r\n    \r\n    float res = terrainIntersect( rom, rdm, tmin, tmax );\r\n    \r\n    if( res > tmax ) {\r\n        res = -1.;\r\n    } else {\r\n        vec3 pos =  rom+rdm*res;\r\n        n = terrainCalcNormalMed( pos, res );\r\n        n = terrainUntransform( n );\r\n        \r\n        intersection = ro+rd*res/100.;\r\n    }\r\n    return vec4(res, rom+rdm*res);\r\n}\r\n\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// LLamels by Eiffie\r\n//\r\n// https://www.shadertoy.com/view/ltsGz4\r\n//-----------------------------------------------------\r\n#ifdef DISPLAY_LLAMEL\r\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\r\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\r\n}\r\n\r\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\r\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\r\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\r\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\r\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\r\n\tu=p-j0;q=j1-j0;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\r\n\tu=p-j1;q=j2-j1;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\r\n\tu=p-j2;q=j3-j2;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\r\n}\r\n\r\nfloat llamelMap(in vec3 p) {\r\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\r\n\tp.y += 0.25*llamelScale;\r\n    p.xz -= 0.5*llamelScale;\r\n    p.xz = vec2(-p.z, p.x);\r\n    vec3 pori = p;\r\n        \r\n    p /= llamelScale;\r\n    \r\n\tvec2 c=floor(p.xz);\r\n\tp.xz=fract(p.xz)-vec2(0.5);\r\n    p.y -= p.x*.04*llamelScale;\r\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\r\n\r\n    float b=0.83-abs(p.z);\r\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\r\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\r\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\r\n\tp.y-=0.03;\r\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\r\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\r\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\r\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\r\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\r\n\ta=max(abs(p.z),p.y)+0.05;\r\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\r\n}\r\n\r\nvec3 llamelGetNormal( in vec3 ro ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001;\r\n\r\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\r\n}\r\n\r\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    ro -= llamelPosition();\r\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\r\n\tfor(int i=0;i<36;i++){\r\n\t\tt+=d=llamelMap(ro+rd*t);\r\n\t\tif(d<dm){dm=d;tm=t;}\r\n\t\tif(t>1000.0 || d<0.00001)break;\r\n\t}\r\n\tdm=max(0.0,dm);\r\n    if( dm < .02 ) {\r\n        vec3 col = vec3(0.45,.30,0.15)*.2;\r\n        vec3 pos = ro + rd*tm;\r\n        vec3 nor = llamelGetNormal( pos );\r\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \r\n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\r\n    }\r\n    \r\n    return vec4(0.);\r\n}\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// Clouds (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \r\n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\r\n\tvec3 intersection = ro+rd*d;\r\n    vec3 cint = intersection*0.009;\r\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\r\n\r\n    cint.xy = rotate( rot, cint.xy );\r\n\r\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\r\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\r\n\r\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\r\n\r\n#ifdef DISPLAY_CLOUDS_DETAIL\r\n    if( d < 200. ) {\r\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\r\n    }\r\n#endif\r\n\r\n    shadow = clamp(1.-clouds, 0., 1.);\r\n\r\n    clouds = clamp(clouds, 0., 1.);\r\n    clouds *= clouds;\r\n    clouds *= smoothstep(0.,0.4,d);\r\n\r\n    vec3 clbasecolor = vec3(1.);\r\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\r\n    clcol += .3*clbasecolor*sunColor;\r\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \r\n    \r\n    return vec4( clcol, clouds );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Planet (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\r\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n\r\n    vec3 intersection = ro + rd*d;\r\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n    vec4 res;\r\n\r\n#ifndef HIDE_TERRAIN\r\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \r\n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\r\n#endif\r\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \r\n    float mixDetailColor = 0.;\r\n        \r\n\tif( d < 0. || d > maxd) {\r\n#ifndef HIDE_TERRAIN\r\n        if( renderTerrainDetail ) {\r\n       \t\tintersection = ro;\r\n            n = normalize( ro );\r\n        } else { \t       \r\n\t        return vec4(0);\r\n        }\r\n#else \r\n      \treturn vec4(0.);\r\n#endif\r\n\t}\r\n    if( d > 0. ) {\r\n\t    maxd = d;\r\n    }\r\n    float att = 0.;\r\n    \r\n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\r\n    \r\n    float dm = MAX, e = 0.;\r\n    vec3 col, detailCol, nDetail;\r\n    \r\n    // normal and intersection \r\n#ifndef HIDE_TERRAIN\r\n    if( renderTerrainDetail ) {   \r\n        res = renderTerrain( ro, rd, intersection, nDetail );\r\n        if( res.x < 0. && d < 0. ) {\r\n\t        return vec4(0);\r\n        }\r\n        if( res.x >= 0. ) {\r\n            maxd = pow(res.x/4000.,4.)*50.;\r\n            e = -10.;\r\n        }\r\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\r\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\r\n    } else \r\n#endif        \r\n    if( renderSeaDetail ) {    \r\n        float attsea, mf = smoothstep(.5,1.,d);\r\n\r\n        renderSea( ro, rd, nDetail, attsea );\r\n\r\n        n = normalize(mix( nDetail, n, mf ));\r\n        att = mix( attsea, att, mf );\r\n    } else {\r\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\r\n#ifndef HIDE_TERRAIN\r\n        if( d < 1500. ) {\r\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\r\n        }\r\n#endif  \r\n    }\r\n    \r\n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \r\n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \r\n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \r\n                 \r\n    // color  \r\n#ifndef HIDE_TERRAIN\r\n    if(renderTerrainDetail ) {\r\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\r\n\t\td = 0.;\r\n    }   \r\n#endif\r\n     \r\n    if( mixDetailColor < 1. ) {\r\n        if( e < .45 ) {\r\n            // sea\r\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \r\n        } else {\r\n            // planet (land) far\r\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\r\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\r\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\r\n\r\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\r\n            vec3 landColor2 = RING_COLOR_1 * land2;\r\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\r\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\r\n\r\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\r\n#ifdef HIGH_QUALITY\r\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\r\n#endif\r\n        }\r\n    }\r\n    \r\n    if( mixDetailColor > 0. ) {\r\n        col = mix( col, detailCol, mixDetailColor );\r\n    }\r\n        \r\n#ifdef DISPLAY_LLAMEL\r\n    if(renderTerrainDetail ) {\r\n        vec3 rom = terrainTransformRo(ro),\r\n        rdm = terrainTransform(rd);\r\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\r\n        if( d > 0. ) {\r\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\r\n            col = mix(col, llamel.rgb, llamel.a);\r\n        }\r\n    }\r\n#endif\r\n    \r\n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\r\n    if( d > 0. ) { \r\n        float shadow;\r\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\r\n        col *= shadow; \r\n        col = mix( col, clouds.rgb, clouds.w );\r\n    }\r\n    \r\n    float m = MAX;\r\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\r\n\r\n \treturn vec4( col, 1. ); \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lens flare by musk\r\n//\r\n// https://www.shadertoy.com/view/4sX3Rs\r\n//-----------------------------------------------------\r\n\r\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\r\n\tc = c*.5 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// cameraPath\r\n//-----------------------------------------------------\r\n\r\nvec3 pro, pta, pup;\r\nfloat dro, dta, dup;\r\n\r\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\r\n    if( t >= prevt && t <= prevt+duration ) {\r\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\r\n    }\r\n    prev = dest;\r\n    prevt += duration;\r\n}\r\n\r\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\r\n#ifndef HIDE_TERRAIN\r\n    time = t = mod( t, 92. );\r\n#else\r\n    time = t = mod( t, 66. );\r\n#endif\r\n    dro = dta = dup = 0.;\r\n\r\n    pro = ro = vec3(900. ,7000. ,1500. );\r\n    pta = ta = vec3(    0. ,    0. ,   0. );\r\n    pup = up = vec3(    0. ,    0.4,   1. ); \r\n   \r\n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\r\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \r\n \r\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\r\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\r\n\r\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\r\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\r\n    \r\n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7.,roe, pro, dro );\r\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\r\n    camint( up, t, 6., upe, pup, dup );\r\n        \r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n    \r\n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\r\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\r\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \r\n#ifndef HIDE_TERRAIN    \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7., roe, pro, dro );\r\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\r\n    camint( up, t, 2., upe, pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\r\n    camint( ro, t, 4.,roe, pro, dro );\r\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\r\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\r\n#endif    \r\n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\r\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \r\n    \r\n    up = normalize( up );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// mainImage\r\n//-----------------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    \r\n    vec3 col;\r\n    \r\n// black bands\r\n    vec2 bandy = vec2(.1,.9);\r\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\r\n        col = vec3(0.);\r\n    } else {\r\n        // camera\r\n        vec3 ro, ta, up;\r\n        cameraPath( iTime*.7, ro, ta, up );\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,up) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        float maxd = MAX;  \r\n        col = renderStars( rd ).xyz;\r\n\r\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \r\n        if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n        float atmosphered = maxd;\r\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n        vec4 ring = renderRing( ro, rd, maxd );\r\n        if( ring.w > 0. && atmosphered < maxd ) {\r\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \r\n        }\r\n        col = col * (1.-ring.w ) + ring.xyz;\r\n\r\n#ifdef DISPLAY_CLOUDS\r\n        float lro = length(ro);\r\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\r\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \r\n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \r\n\r\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\r\n                // clouds\r\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\r\n                if( d < maxd ) {\r\n                    float shadow;\r\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\r\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\r\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\r\n                }\r\n            }\r\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\r\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\r\n        }\r\n#endif \r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);      \r\n\r\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\r\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\r\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\r\n\r\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\r\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \r\n    }\r\n    fragColor = vec4( col ,1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n    float maxd = MAX;  \r\n    time = iTime * .7;\r\n    \r\n    rd = rd.xzy;\r\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\r\n    \r\n    vec3 col = renderStars( rd ).xyz;\r\n\r\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \r\n    if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n    float atmosphered = maxd;\r\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n    vec4 ring = renderRing( ro, rd, maxd );\r\n    col = col * (1.-ring.w ) + ring.xyz;\r\n    \r\n    // post processing\r\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n    col *= vec3(1.,0.99,0.95);   \r\n    col = clamp(1.06*col-0.03, 0., 1.);      \r\n    fragColor = vec4( col ,1.0);\r\n}","inputs":[],"outputs":[],"code":"// Planet Shadertoy. Created by Reinder Nijhoff 2015\r\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n// @reindernijhoff\r\n//\r\n// https://www.shadertoy.com/view/4tjGRh\r\n//\r\n// It uses code from the following shaders:\r\n//\r\n// Wet stone by TDM\r\n// Atmospheric Scattering by GLtracy\r\n// Seascape by TDM\r\n// Elevated and Terrain Tubes by IQ\r\n// LLamels by Eiffie\r\n// Lens flare by Musk\r\n// \r\n\r\n//#define HIGH_QUALITY\r\n//#define MED_QUALITY\r\n//#define LOW_QUALITY\r\n#define VERY_LOW_QUALITY\r\n\r\nconst float PI = 3.14159265359;\r\nconst float DEG_TO_RAD = (PI / 180.0);\r\nconst float MAX = 10000.0;\r\n\r\nconst float EARTH_RADIUS = 1000.;\r\nconst float EARTH_ATMOSPHERE = 5.;\r\nconst float EARTH_CLOUDS = 1.;\r\n\r\nconst float RING_INNER_RADIUS = 1500.;\r\nconst float RING_OUTER_RADIUS = 2300.;\r\nconst float RING_HEIGHT = 2.;\r\n\r\n#ifdef HIGH_QUALITY\r\n    const int   SEA_NUM_STEPS = 7;\r\n    const int\tTERRAIN_NUM_STEPS = 140;\r\n    const int   ASTEROID_NUM_STEPS = 11;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\r\n    const int   RING_VOXEL_STEPS = 25;\r\n    const float ASTEROID_MAX_DISTANCE = 1.1; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\r\n\r\n    #define DISPLAY_LLAMEL\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n#endif\r\n\r\n#ifdef MED_QUALITY\r\n    const int   SEA_NUM_STEPS = 6;\r\n    const int\tTERRAIN_NUM_STEPS = 100;\r\n    const int   ASTEROID_NUM_STEPS = 10;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\r\n    const int   RING_VOXEL_STEPS = 24;\r\n    const float ASTEROID_MAX_DISTANCE = 1.; \r\n\tconst int   FBM_STEPS = 4;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\r\n    #define DISPLAY_CLOUDS\r\n    #define DISPLAY_TERRAIN_DETAIL\r\n    #define DISPLAY_CLOUDS_DETAIL\r\n#endif\r\n\r\n#ifdef LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 5;\r\n    const int\tTERRAIN_NUM_STEPS = 75;\r\n    const int   ASTEROID_NUM_STEPS = 9;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\r\n    const int   RING_VOXEL_STEPS = 20;\r\n    const float ASTEROID_MAX_DISTANCE = .85; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\r\n#endif\r\n\r\n#ifdef VERY_LOW_QUALITY\r\n    const int   SEA_NUM_STEPS = 4;\r\n    const int\tTERRAIN_NUM_STEPS = 60;\r\n    const int   ASTEROID_NUM_STEPS = 7;\r\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\r\n    const int   RING_VOXEL_STEPS = 16;\r\n    const float ASTEROID_MAX_DISTANCE = .67; \r\n\tconst int   FBM_STEPS = 3;\r\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\r\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\r\n\t#define HIDE_TERRAIN\r\n#endif\r\n\r\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\r\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\r\n\r\nfloat time;\r\n\r\n//-----------------------------------------------------\r\n// Noise functions\r\n//-----------------------------------------------------\r\n\r\nfloat hash( const in float n ) {\r\n    return fract(sin(n)*43758.5453123);\r\n}\r\nfloat hash( const in vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat hash( const in vec3 p ) {\r\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nvec3 hash31( const in float p) {\r\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\r\n    return fract(sin(h)*43758.543123);\r\n}\r\nvec3 hash33( const in vec3 p) {\r\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\r\n}\r\n\r\nfloat noise( const in  float p ) {    \r\n    float i = floor( p );\r\n    float f = fract( p );\t\r\n\tfloat u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\r\n}\r\n\r\nfloat noise( const in  vec2 p ) {    \r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat noise( const in  vec3 x ) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y*157.0 + 113.0*p.z;\r\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\r\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\r\n}\r\n\r\nfloat tri( const in vec2 p ) {\r\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\r\n   \r\n}\r\n\r\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\r\n\r\nfloat fbm( in vec2 p ) {\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n    f += 0.1250*noise( p ); \r\n    \r\n#ifndef LOW_QUALITY\r\n#ifndef VERY_LOW_QUALITY\r\n    p = m2*p*2.01;\r\n    f += 0.0625*noise( p );\r\n#endif\r\n#endif\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm( const in vec3 p, const in float a, const in float f) {\r\n    float ret = 0.0;    \r\n    float amp = 1.0;\r\n    float frq = 1.0;\r\n    for(int i = 0; i < FBM_STEPS; i++) {\r\n        float n = pow(noise(p * frq),2.0);\r\n        ret += n * amp;\r\n        frq *= f;\r\n        amp *= a * (pow(n,0.2));\r\n    }\r\n    return ret;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lightning functions\r\n//-----------------------------------------------------\r\n\r\nfloat diffuse( const in vec3 n, const in vec3 l) { \r\n    return clamp(dot(n,l),0.,1.);\r\n}\r\n\r\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \r\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\r\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Math functions\r\n//-----------------------------------------------------\r\n\r\nvec2 rotate(float angle, vec2 v) {\r\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\r\n}\r\n\r\nfloat boolSub(float a,float b) { \r\n    return max(a,-b); \r\n}\r\nfloat sphere(vec3 p,float r) {\r\n\treturn length(p)-r;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Intersection functions (by iq)\r\n//-----------------------------------------------------\r\n\r\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\r\n    return (pos-sph.xyz)/sph.w;\r\n}\r\n\r\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return -1.0;\r\n\treturn -b - sqrt( h );\r\n}\r\n\r\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return -MAX;\r\n\treturn -b + sqrt( d );\r\n}\r\n\r\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\r\n\tfloat b = dot( p, dir );\r\n\tfloat c = dot( p, p ) - r * r;\r\n\tfloat d = b * b - c;\r\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\r\n\td = sqrt( d );\r\n\treturn vec2( -b - d, -b + d );\r\n}\r\n\r\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\r\n    return obj.xyz;\r\n}\r\n\r\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\r\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Wet stone by TDM\r\n// \r\n// https://www.shadertoy.com/view/ldSSzV\r\n//-----------------------------------------------------\r\n\r\nconst float ASTEROID_TRESHOLD \t= 0.001;\r\nconst float ASTEROID_EPSILON \t= 1e-6;\r\nconst float ASTEROID_DISPLACEMENT = 0.1;\r\nconst float ASTEROID_RADIUS = 0.13;\r\n\r\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\r\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\r\n\r\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \r\n    float d = sphere(p,ASTEROID_RADIUS);    \r\n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\r\n        float ii = float(i)+id.x;\r\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\r\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\r\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \r\n    }\r\n    return d;\r\n}\r\n\r\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\r\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\r\n    return d;\r\n}\r\n\r\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( xyangle, ro.xy );\r\n    \r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( yzangle, ro.yz );\r\n}\r\n\r\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\r\n    float yzangle = (id.y-.5)*time*2.;\r\n    ro.yz = rotate( -yzangle, ro.yz );\r\n\r\n    float xyangle = (id.x-.5)*time*2.;\r\n    ro.xy = rotate( -xyangle, ro.xy );  \r\n}\r\n\r\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\r\n    asteroidTransForm( p, id );\r\n    \r\n    vec3 n;\r\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\r\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\r\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\r\n    n = normalize(n-asteroidMapDetailed(p, id));\r\n    \r\n    asteroidUnTransForm( n, id );\r\n    return n;\r\n}\r\n\r\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\r\n    asteroidTransForm( ori, id );\r\n    asteroidTransForm( dir, id );\r\n    \r\n    vec2 td = vec2(0,1);\r\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\r\n        td.y = asteroidMap(ori + dir * td.x, id);\r\n        td.x += td.y;\r\n    }\r\n    return td;\r\n}\r\n\r\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\r\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nconst float RING_DETAIL_DISTANCE = 40.;\r\nconst float RING_VOXEL_STEP_SIZE = .03;\r\n\r\nvec3 ringShadowColor( const in vec3 ro ) {\r\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\r\n        return vec3(0.);\r\n    }\r\n    return vec3(1.);\r\n}\r\n\r\nbool ringMap( const in vec3 ro ) {\r\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\r\n}\r\n\r\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \r\n// find startpoint \r\n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\r\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\r\n    \r\n    float d = min( max(d1,0.), max(d2,0.) );\r\n   \r\n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\r\n        return vec4( 0. );\r\n    } else {\r\n        vec3 ros = ro + rd*d;\r\n\r\n        // avoid precision problems..\r\n        vec2 mroxy = mod(ros.xy, vec2(10.));\r\n        vec2 roxy = ros.xy - mroxy;\r\n        ros.xy -= roxy;\r\n        ros /= RING_VOXEL_STEP_SIZE;\r\n        //ros.xy -= vec2(.013,.112)*time*.5;\r\n\r\n        vec3 pos = floor(ros);\r\n        vec3 ri = 1.0/rd;\r\n        vec3 rs = sign(rd);\r\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\r\n\r\n        float alpha = 0., dint;\r\n        vec3 offset = vec3(0), id, asteroidro;\r\n        vec2 asteroid = vec2(0);\r\n\r\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\r\n            if( ringMap(pos) ) {\r\n                id = hash33(pos);\r\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\r\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\r\n\r\n                if( dint > 0. ) {\r\n                    asteroidro = ros+rd*dint-(pos+offset);\r\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\r\n\r\n                    if( asteroid.y < .1 ) {\r\n                        alpha = 1.;\r\n                        break;\t    \r\n                    }\r\n                }\r\n\r\n            }\r\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\r\n            dis += mm * rs * ri;\r\n            pos += mm * rs;\r\n        }\r\n\r\n        if( alpha > 0. ) {       \r\n            vec3 intersection = ros + rd*(asteroid.x+dint);\r\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\r\n\r\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\r\n\r\n            intersection *= RING_VOXEL_STEP_SIZE;\r\n            intersection.xy += roxy;\r\n          //  col *= ringShadowColor( intersection );\r\n\r\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Ring (by me ;))\r\n//-----------------------------------------------------\r\n\r\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. ) {\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n        } else {\r\n            return 0.;\r\n        }\r\n    } else {\r\n\t    return 0.;\r\n    }\r\n}\r\n\r\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    // intersect plane\r\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n    \r\n    if( d > 0. && d < maxd ) {\r\n        maxd = d;\r\n\t    vec3 intersection = ro + rd*d;\r\n        float l = length(intersection.xy);\r\n        \r\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\r\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\r\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\r\n            \r\n            col *= ringShadowColor( intersection );\r\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\r\n\t\t\tcol *= SUN_COLOR;\r\n            return vec4( col, dens );\r\n        } else {\r\n            return vec4(0.);\r\n        }\r\n    } else {\r\n\t    return vec4(0.);\r\n    }\r\n}\r\n\r\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\r\n    vec4 far = renderRingFar( ro, rd, maxd );\r\n    float l = length( ro.xy );\r\n\r\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \r\n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \r\n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\r\n     \t\r\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\r\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\r\n        far.xyz *= detail;    \r\n    }\r\n    \r\n\t// are asteroids neaded ?\r\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \r\n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \r\n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\r\n        \r\n        vec4 near = renderRingNear( ro, rd );\r\n        far = mix( far, near, near.w );\r\n        maxd=0.;\r\n    }\r\n            \r\n    return far;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Stars (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderStars( const in vec3 rd ) {\r\n\tvec3 rds = rd;\r\n\tvec3 col = vec3(0);\r\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\r\n    \r\n    vec2 xy = vec2(rds.y * v, rds.x * v);\r\n    float s = noise(rds*134.);\r\n    \r\n    s += noise(rds*470.);\r\n    s = pow(s,19.0) * 0.00001;\r\n    if (s > 0.5) {\r\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \r\n        col += backStars;\r\n    }\r\n\treturn   vec4( col, 1 ); \r\n} \r\n\r\n//-----------------------------------------------------\r\n// Atmospheric Scattering by GLtracy\r\n// \r\n// https://www.shadertoy.com/view/lslXDr\r\n//-----------------------------------------------------\r\n\r\nconst float ATMOSPHERE_K_R = 0.166;\r\nconst float ATMOSPHERE_K_M = 0.0025;\r\nconst float ATMOSPHERE_E = 12.3;\r\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\r\nconst float ATMOSPHERE_G_M = -0.85;\r\n\r\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\r\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\r\n\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\r\n\r\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\r\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\r\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\r\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\r\n\r\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\r\n\tfloat gg = g * g;\r\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\r\n\tfloat b = 1.0 + gg - 2.0 * g * c;\r\n    \r\n\tb *= sqrt( b );\r\n\tb *= 2.0 + gg;\t\r\n\t\r\n\treturn 1.5 * a / b;\r\n}\r\n\r\nfloat atmosphericPhaseReyleigh( float cc ) {\r\n\treturn 0.75 * ( 1.0 + cc );\r\n}\r\n\r\nfloat atmosphericDensity( vec3 p ){\r\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\r\n}\r\n\r\nfloat atmosphericOptic( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n    float sumdensity = 0.;\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\r\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\r\n\t\tfloat dens = atmosphericDensity( v );\r\n  \r\n\t    float m = MAX;\r\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \r\n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\r\n \t\tsumdensity += dens;\r\n        \r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \r\n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\r\n}\r\n\r\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\r\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\r\n\tvec3 v = p + step * 0.5;\r\n\t\r\n\tfloat sum = 0.0;\r\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\r\n\t\tsum += atmosphericDensity( v );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\r\n\t\r\n\treturn sum;\r\n}\r\n\r\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\r\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\r\n\tvec3 step = dir * len;\r\n\tvec3 p = o + dir * e.x;\r\n\tvec3 v = p + dir * ( len * 0.5 );\r\n\r\n\tvec3 sum = vec3( 0.0 );\r\n\r\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\r\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\r\n\t    float m = MAX;\r\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\r\n\t\tv += step;\r\n\t}\r\n\tsum *= len * ATMOSPHERE_SCALE_L;\r\n\t\r\n\tfloat c  = dot( dir, -l );\r\n\tfloat cc = c * c;\r\n\t\r\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \r\n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\r\n}\r\n\r\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \r\n    // inside or outside atmosphere?\r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\r\n        \r\n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\r\n        if( d < e.y ) {\r\n            e.y = d;\r\n        }\r\n\t\td = e.y;\r\n\t    e.x = 0.;\r\n        \r\n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\r\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\r\n\t\t}\r\n    } else {\r\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\r\n        \r\n        if ( e.x > e.y ) {\r\n        \td = MAX;\r\n\t\t\treturn vec4(0.);\r\n\t\t}\r\n\t\td = e.y = min( e.y, f.x );\r\n    }\r\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \r\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\r\n    e.x = 0.;\r\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Seascape by TDM\r\n// \r\n// https://www.shadertoy.com/view/Ms2SD1\r\n//-----------------------------------------------------\r\n\r\nconst int   SEA_ITER_GEOMETRY = 3;\r\nconst int   SEA_ITER_FRAGMENT = 5;\r\n\r\nconst float SEA_EPSILON\t= 1e-3;\r\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\r\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\r\nfloat       SEA_TIME;\r\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\nfloat seaOctave( in vec2 uv, const in float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat seaMap(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat seaMapHigh(const in vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \r\n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\r\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \r\n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \r\n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \r\n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\r\n    \r\n    color += upc*SEA_WATER_COLOR * (att * 0.18);\r\n    color += sunc * vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\r\n    vec3 n;\r\n    n.y = seaMapHigh(p);    \r\n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = seaMap(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = seaMap(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = seaMap(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 seaTransform( in vec3 x ) {\r\n    x.yz = rotate( 0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvec3 seaUntransform( in vec3 x ) {\r\n    x.yz = rotate( -0.8, x.yz );\r\n    return x;\r\n}\r\n\r\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \r\n    vec3 p,\r\n    rom = seaTransform(ro),\r\n    rdm = seaTransform(rd);\r\n    \r\n    rom.y -= EARTH_RADIUS;\r\n    rom *= 1000.;\r\n    rom.xz += vec2(3.1,.2)*time;\r\n\r\n    SEA_TIME = time * SEA_SPEED;\r\n    \r\n    seaHeightMapTracing(rom,rdm,p);\r\n    float squareddist = dot(p - rom, p-rom );\r\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\r\n    \r\n    n = seaUntransform(n);\r\n    \r\n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Terrain based on Elevated and Terrain Tubes by IQ\r\n//\r\n// https://www.shadertoy.com/view/MdX3Rr\r\n// https://www.shadertoy.com/view/4sjXzG\r\n//-----------------------------------------------------\r\n\r\n#ifndef HIDE_TERRAIN\r\n\r\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\r\n\r\nfloat terrainLow( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<2; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMed( vec2 p ) {\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<6; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n            \r\n    return t*33.0;\r\n}\r\n\r\nfloat terrainHigh( vec2 p ) {\r\n    vec2 q = p;\r\n    p *= 0.0013;\r\n\r\n    float s = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor( int i=0; i<7; i++ ) {\r\n        t += s*tri( p );\r\n\t\ts *= 0.5 + 0.1*t;\r\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\r\n\t}\r\n    \r\n    t += t*0.015*fbm( q );\r\n\treturn t*33.0;\r\n}\r\n\r\nfloat terrainMap( const in vec3 pos ) {\r\n\treturn pos.y - terrainMed(pos.xz);  \r\n}\r\n\r\nfloat terrainMapH( const in vec3 pos ) {\r\n    float y = terrainHigh(pos.xz);\r\n    float h = pos.y - y;\r\n    return h;\r\n}\r\n\r\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\r\n    float t = tmin;\r\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\r\n        vec3 pos = ro + t*rd;\r\n        float res = terrainMap( pos );\r\n        if( res<(0.001*t) || t>tmax  ) break;\r\n        t += res*.9;\r\n\t}\r\n\r\n\treturn t;\r\n}\r\n\r\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\r\n\tvec2  eps = vec2(150.0,0.0);\r\n    float h1 = terrainMed( ro.xz );\r\n    float h2 = terrainLow( ro.xz );\r\n    \r\n    float d1 = 10.0;\r\n    float d2 = 80.0;\r\n    float d3 = 200.0;\r\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\r\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\r\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\r\n\r\n    return min(min(s1,s2),s3);\r\n}\r\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\r\n\r\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\r\n}\r\n\r\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\r\n\tfloat e = 0.005*t;\r\n    vec2  eps = vec2(e,0.0);\r\n    float h = terrainMed( pos.xz );\r\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\r\n}\r\n\r\nvec3 terrainTransform( in vec3 x ) {\r\n    x.zy = rotate( -.83, x.zy );\r\n    return x;\r\n}\r\n\r\nvec3 terrainUntransform( in vec3 x ) {\r\n    x.zy = rotate( .83, x.zy );\r\n    return x;\r\n}\r\n\r\n\r\nfloat llamelTime;\r\nconst float llamelScale = 5.;\r\n\r\nvec3 llamelPosition() {\r\n    llamelTime = time*2.5;\r\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\r\n    return vec3( pos.x, terrainMed( pos ), pos.y );\r\n}\r\n\r\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \r\n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\r\n    float dif = diffuse( n, sunDirection );\r\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\r\n    float sha = terrainCalcShadow( pos, sunDirection );\r\n    float amb = clamp( n.y,0.0,1.0);\r\n        \r\n    vec3 lin  = vec3(0.0);\r\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\r\n    lin += 0.2*amb*upc;\r\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\r\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\r\n}\r\n\r\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    vec3 nor = terrainCalcNormalHigh( pos, t );\r\n    vec3 sor = terrainCalcNormalMed( pos, t );\r\n        \r\n    float spec = 0.005;\r\n\r\n#ifdef DISPLAY_TERRAIN_DETAIL\r\n    float no = noise(5.*fbm(1.11*pos.xz));\r\n#else\r\n    const float no = 0.;\r\n#endif\r\n    float r = .5+.5*fbm(.95*pos.xz);\r\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\r\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\r\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\r\n    col *= .88+.12*no;\r\n        \r\n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\r\n    float sf = fwidth(s) * 1.5;\r\n    s = smoothstep(0.84-sf, 0.84+sf, s );\r\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\r\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\r\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\r\n\r\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\r\n\r\n#ifdef DISPLAY_LLAMEL\r\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\r\n#endif\r\n    \r\n    return col;\r\n}\r\n\r\nvec3 terrainTransformRo( const in vec3 ro ) {\r\n    vec3 rom = terrainTransform(ro);\r\n    rom.y -= EARTH_RADIUS - 100.;\r\n    rom.xz *= 5.;\r\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \r\n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\r\n    return rom;\r\n}\r\n\r\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \r\n    vec3 p,\r\n    rom = terrainTransformRo(ro),\r\n    rdm = terrainTransform(rd);\r\n        \r\n    float tmin = 10.0;\r\n    float tmax = 3200.0;\r\n    \r\n    float res = terrainIntersect( rom, rdm, tmin, tmax );\r\n    \r\n    if( res > tmax ) {\r\n        res = -1.;\r\n    } else {\r\n        vec3 pos =  rom+rdm*res;\r\n        n = terrainCalcNormalMed( pos, res );\r\n        n = terrainUntransform( n );\r\n        \r\n        intersection = ro+rd*res/100.;\r\n    }\r\n    return vec4(res, rom+rdm*res);\r\n}\r\n\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// LLamels by Eiffie\r\n//\r\n// https://www.shadertoy.com/view/ltsGz4\r\n//-----------------------------------------------------\r\n#ifdef DISPLAY_LLAMEL\r\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\r\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\r\n}\r\n\r\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\r\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\r\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\r\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\r\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\r\n\tu=p-j0;q=j1-j0;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\r\n\tu=p-j1;q=j2-j1;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\r\n\tu=p-j2;q=j3-j2;\r\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\r\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\r\n}\r\n\r\nfloat llamelMap(in vec3 p) {\r\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\r\n\tp.y += 0.25*llamelScale;\r\n    p.xz -= 0.5*llamelScale;\r\n    p.xz = vec2(-p.z, p.x);\r\n    vec3 pori = p;\r\n        \r\n    p /= llamelScale;\r\n    \r\n\tvec2 c=floor(p.xz);\r\n\tp.xz=fract(p.xz)-vec2(0.5);\r\n    p.y -= p.x*.04*llamelScale;\r\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\r\n\r\n    float b=0.83-abs(p.z);\r\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\r\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\r\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\r\n\tp.y-=0.03;\r\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\r\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\r\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\r\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\r\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\r\n\ta=max(abs(p.z),p.y)+0.05;\r\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\r\n}\r\n\r\nvec3 llamelGetNormal( in vec3 ro ) {\r\n    vec2 e = vec2(1.0,-1.0)*0.001;\r\n\r\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\r\n}\r\n\r\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\r\n    ro -= llamelPosition();\r\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\r\n\tfor(int i=0;i<36;i++){\r\n\t\tt+=d=llamelMap(ro+rd*t);\r\n\t\tif(d<dm){dm=d;tm=t;}\r\n\t\tif(t>1000.0 || d<0.00001)break;\r\n\t}\r\n\tdm=max(0.0,dm);\r\n    if( dm < .02 ) {\r\n        vec3 col = vec3(0.45,.30,0.15)*.2;\r\n        vec3 pos = ro + rd*tm;\r\n        vec3 nor = llamelGetNormal( pos );\r\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \r\n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\r\n    }\r\n    \r\n    return vec4(0.);\r\n}\r\n#endif\r\n\r\n//-----------------------------------------------------\r\n// Clouds (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \r\n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\r\n\tvec3 intersection = ro+rd*d;\r\n    vec3 cint = intersection*0.009;\r\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\r\n\r\n    cint.xy = rotate( rot, cint.xy );\r\n\r\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\r\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\r\n\r\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\r\n\r\n#ifdef DISPLAY_CLOUDS_DETAIL\r\n    if( d < 200. ) {\r\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\r\n    }\r\n#endif\r\n\r\n    shadow = clamp(1.-clouds, 0., 1.);\r\n\r\n    clouds = clamp(clouds, 0., 1.);\r\n    clouds *= clouds;\r\n    clouds *= smoothstep(0.,0.4,d);\r\n\r\n    vec3 clbasecolor = vec3(1.);\r\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\r\n    clcol += .3*clbasecolor*sunColor;\r\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \r\n    \r\n    return vec4( clcol, clouds );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// Planet (by me ;))\r\n//-----------------------------------------------------\r\n\r\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\r\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n\r\n    vec3 intersection = ro + rd*d;\r\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\r\n    vec4 res;\r\n\r\n#ifndef HIDE_TERRAIN\r\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \r\n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\r\n#endif\r\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \r\n    float mixDetailColor = 0.;\r\n        \r\n\tif( d < 0. || d > maxd) {\r\n#ifndef HIDE_TERRAIN\r\n        if( renderTerrainDetail ) {\r\n       \t\tintersection = ro;\r\n            n = normalize( ro );\r\n        } else { \t       \r\n\t        return vec4(0);\r\n        }\r\n#else \r\n      \treturn vec4(0.);\r\n#endif\r\n\t}\r\n    if( d > 0. ) {\r\n\t    maxd = d;\r\n    }\r\n    float att = 0.;\r\n    \r\n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\r\n    \r\n    float dm = MAX, e = 0.;\r\n    vec3 col, detailCol, nDetail;\r\n    \r\n    // normal and intersection \r\n#ifndef HIDE_TERRAIN\r\n    if( renderTerrainDetail ) {   \r\n        res = renderTerrain( ro, rd, intersection, nDetail );\r\n        if( res.x < 0. && d < 0. ) {\r\n\t        return vec4(0);\r\n        }\r\n        if( res.x >= 0. ) {\r\n            maxd = pow(res.x/4000.,4.)*50.;\r\n            e = -10.;\r\n        }\r\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\r\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\r\n    } else \r\n#endif        \r\n    if( renderSeaDetail ) {    \r\n        float attsea, mf = smoothstep(.5,1.,d);\r\n\r\n        renderSea( ro, rd, nDetail, attsea );\r\n\r\n        n = normalize(mix( nDetail, n, mf ));\r\n        att = mix( attsea, att, mf );\r\n    } else {\r\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\r\n#ifndef HIDE_TERRAIN\r\n        if( d < 1500. ) {\r\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\r\n        }\r\n#endif  \r\n    }\r\n    \r\n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \r\n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \r\n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \r\n                 \r\n    // color  \r\n#ifndef HIDE_TERRAIN\r\n    if(renderTerrainDetail ) {\r\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\r\n\t\td = 0.;\r\n    }   \r\n#endif\r\n     \r\n    if( mixDetailColor < 1. ) {\r\n        if( e < .45 ) {\r\n            // sea\r\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \r\n        } else {\r\n            // planet (land) far\r\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\r\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\r\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\r\n\r\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\r\n            vec3 landColor2 = RING_COLOR_1 * land2;\r\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\r\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\r\n\r\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\r\n#ifdef HIGH_QUALITY\r\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\r\n#endif\r\n        }\r\n    }\r\n    \r\n    if( mixDetailColor > 0. ) {\r\n        col = mix( col, detailCol, mixDetailColor );\r\n    }\r\n        \r\n#ifdef DISPLAY_LLAMEL\r\n    if(renderTerrainDetail ) {\r\n        vec3 rom = terrainTransformRo(ro),\r\n        rdm = terrainTransform(rd);\r\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\r\n        if( d > 0. ) {\r\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\r\n            col = mix(col, llamel.rgb, llamel.a);\r\n        }\r\n    }\r\n#endif\r\n    \r\n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\r\n    if( d > 0. ) { \r\n        float shadow;\r\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\r\n        col *= shadow; \r\n        col = mix( col, clouds.rgb, clouds.w );\r\n    }\r\n    \r\n    float m = MAX;\r\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\r\n\r\n \treturn vec4( col, 1. ); \r\n}\r\n\r\n//-----------------------------------------------------\r\n// Lens flare by musk\r\n//\r\n// https://www.shadertoy.com/view/4sX3Rs\r\n//-----------------------------------------------------\r\n\r\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\r\n\tvec2 main = uv-pos;\r\n\tvec2 uvd = uv*(length(uv));\r\n\t\r\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\r\n\t\r\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n\r\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n\t\r\n\tvec2 uvx = mix(uv,uvd,-0.5);\r\n\t\r\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n\t\r\n\tvec3 c = vec3(.0);\r\n\t\r\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\r\n\tc = c*.5 - vec3(length(uvd)*.05);\r\n\tc+=vec3(f0);\r\n\t\r\n\treturn c;\r\n}\r\n\r\n//-----------------------------------------------------\r\n// cameraPath\r\n//-----------------------------------------------------\r\n\r\nvec3 pro, pta, pup;\r\nfloat dro, dta, dup;\r\n\r\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\r\n    if( t >= prevt && t <= prevt+duration ) {\r\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\r\n    }\r\n    prev = dest;\r\n    prevt += duration;\r\n}\r\n\r\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\r\n#ifndef HIDE_TERRAIN\r\n    time = t = mod( t, 92. );\r\n#else\r\n    time = t = mod( t, 66. );\r\n#endif\r\n    dro = dta = dup = 0.;\r\n\r\n    pro = ro = vec3(900. ,7000. ,1500. );\r\n    pta = ta = vec3(    0. ,    0. ,   0. );\r\n    pup = up = vec3(    0. ,    0.4,   1. ); \r\n   \r\n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\r\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \r\n \r\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\r\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\r\n\r\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\r\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\r\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\r\n    \r\n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7.,roe, pro, dro );\r\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\r\n    camint( up, t, 6., upe, pup, dup );\r\n        \r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n    \r\n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\r\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\r\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \r\n#ifndef HIDE_TERRAIN    \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\r\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\r\n    \r\n    camint( ro, t, 7., roe, pro, dro );\r\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\r\n    camint( up, t, 2., upe, pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\r\n    camint( ro, t, 17.,roe, pro, dro );\r\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\r\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\r\n        \r\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\r\n    camint( ro, t, 4.,roe, pro, dro );\r\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\r\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\r\n#endif    \r\n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\r\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\r\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \r\n    \r\n    up = normalize( up );\r\n}\r\n\r\n//-----------------------------------------------------\r\n// mainImage\r\n//-----------------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    \r\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    \r\n    vec3 col;\r\n    \r\n// black bands\r\n    vec2 bandy = vec2(.1,.9);\r\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\r\n        col = vec3(0.);\r\n    } else {\r\n        // camera\r\n        vec3 ro, ta, up;\r\n        cameraPath( iTime*.7, ro, ta, up );\r\n\r\n        vec3 ww = normalize( ta - ro );\r\n        vec3 uu = normalize( cross(ww,up) );\r\n        vec3 vv = normalize( cross(uu,ww));\r\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\r\n\r\n        float maxd = MAX;  \r\n        col = renderStars( rd ).xyz;\r\n\r\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \r\n        if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n        float atmosphered = maxd;\r\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n        vec4 ring = renderRing( ro, rd, maxd );\r\n        if( ring.w > 0. && atmosphered < maxd ) {\r\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \r\n        }\r\n        col = col * (1.-ring.w ) + ring.xyz;\r\n\r\n#ifdef DISPLAY_CLOUDS\r\n        float lro = length(ro);\r\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\r\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \r\n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \r\n\r\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\r\n                // clouds\r\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\r\n                if( d < maxd ) {\r\n                    float shadow;\r\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\r\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\r\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\r\n                }\r\n            }\r\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\r\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\r\n        }\r\n#endif \r\n\r\n        // post processing\r\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n        col *= vec3(1.,0.99,0.95);   \r\n        col = clamp(1.06*col-0.03, 0., 1.);      \r\n\r\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\r\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\r\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\r\n\r\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\r\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \r\n    }\r\n    fragColor = vec4( col ,1.0);\r\n}\r\n\r\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\r\n    float maxd = MAX;  \r\n    time = iTime * .7;\r\n    \r\n    rd = rd.xzy;\r\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\r\n    \r\n    vec3 col = renderStars( rd ).xyz;\r\n\r\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \r\n    if( planet.w > 0. ) col.xyz = planet.xyz;\r\n\r\n    float atmosphered = maxd;\r\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\r\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \r\n\r\n    vec4 ring = renderRing( ro, rd, maxd );\r\n    col = col * (1.-ring.w ) + ring.xyz;\r\n    \r\n    // post processing\r\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\r\n    col *= vec3(1.,0.99,0.95);   \r\n    col = clamp(1.06*col-0.03, 0., 1.);      \r\n    fragColor = vec4( col ,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n    \r\n    vec3 bg = vec3(0.2,0.0,0.34);\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = bg;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += bg * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n    \r\n    vec3 bg = vec3(0.2,0.0,0.34);\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = bg;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += bg * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Playing marble","id":"86efa73517ab4d49974faa5490fa27a4","date":null,"viewed":0,"name":"Playing marble","description":"3d marble texture ","likes":0,"published":null,"tags":["3d"," fractal"," volumetric"]},"ver":null,"info":{"Name":"Playing marble","id":"86efa73517ab4d49974faa5490fa27a4","date":null,"viewed":0,"name":"Playing marble","description":"3d marble texture ","likes":0,"published":null,"tags":["3d"," fractal"," volumetric"]},"renderpass":[{"Code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n    \r\n    vec3 bg = vec3(0.2,0.0,0.34);\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = bg;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += bg * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","inputs":[],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// Created by S. Guillitte 2015\r\n\r\nfloat zoom=1.;\r\n\r\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\r\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\r\n\r\n\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\r\n}\r\n\r\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\r\n{\r\n\tvec3 oc = ro - sph.xyz;\r\n\tfloat b = dot( oc, rd );\r\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\r\n\tfloat h = b*b - c;\r\n\tif( h<0.0 ) return vec2(-1.0);\r\n\th = sqrt(h);\r\n\treturn vec2(-b-h, -b+h );\r\n}\r\n\r\nfloat map(in vec3 p) {\r\n\t\r\n\tfloat res = 0.;\r\n\t\r\n    vec3 c = p;\r\n\tfor (int i = 0; i < 10; ++i) {\r\n        p =.7*abs(p)/dot(p,p) -.7;\r\n        p.yz= csqr(p.yz);\r\n        p=p.zxy;\r\n        res += exp(-19. * abs(dot(p,c)));\r\n        \r\n\t}\r\n\treturn res/2.;\r\n}\r\n\r\n\r\n\r\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\r\n{\r\n    float t = tminmax.x;\r\n    float dt = .02;\r\n    //float dt = .2 - .195*cos(iTime*.05);//animated\r\n    vec3 col= vec3(0.);\r\n    float c = 0.;\r\n    for( int i=0; i<64; i++ )\r\n\t{\r\n        t+=dt*exp(-2.*c);\r\n        if(t>tminmax.y)break;\r\n        vec3 pos = ro+t*rd;\r\n        \r\n        c = map(ro+t*rd);               \r\n        \r\n        col = .99*col+ .08*vec3(c*c, c, c*c*c);//green\t\r\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\r\n    }    \r\n    return col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfloat time = iTime;\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0 * q;\r\n    p.x *= iResolution.x/iResolution.y;\r\n    vec2 m = vec2(0.);\r\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\r\n    m-=.5;\r\n\r\n    // camera\r\n\r\n    vec3 ro = zoom*vec3(4.);\r\n    ro.yz*=rot(m.y);\r\n    ro.xz*=rot(m.x+ 0.1*time);\r\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\r\n    vec3 ww = normalize( ta - ro );\r\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\r\n    vec3 vv = normalize( cross(uu,ww));\r\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\r\n\r\n    \r\n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\r\n    \r\n    vec3 bg = vec3(0.2,0.0,0.34);\r\n\t// raymarch\r\n    vec3 col = raymarch(ro,rd,tmm);\r\n    if (tmm.x<0.)col = bg;\r\n    else {\r\n        vec3 nor=(ro+tmm.x*rd)/2.;\r\n        nor = reflect(rd, nor);        \r\n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,1.0), 3. )*1.3;\r\n        col += bg * fre;\r\n    \r\n    }\r\n\t\r\n\t// shade\r\n    \r\n    col =  .5 *(log(1.+col));\r\n    col = clamp(col,0.,1.);\r\n    fragColor = vec4( col, 1.0 );\r\n\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Procedural Brick Texture 2D","id":"wlcGRM","date":"1576151122","viewed":55,"name":"Procedural Brick Texture 2D","description":"2D\u53CD\u952F\u9F7F\u7816\u5757\u8D34\u56FE","likes":4,"published":"Public","tags":["2d","brick","antialiase"]},"ver":"0.1","info":{"Name":"Procedural Brick Texture 2D","id":"wlcGRM","date":"1576151122","viewed":55,"name":"Procedural Brick Texture 2D","description":"2D\u53CD\u952F\u9F7F\u7816\u5757\u8D34\u56FE","likes":4,"published":"Public","tags":["2d","brick","antialiase"]},"renderpass":[{"Code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRICKWIDTH 0.25\n#define BRICKHEIGHT 0.08\n#define MORTARTHICKNESS 0.01\n\n#define BMWIDTH (BRICKWIDTH+MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT+MORTARTHICKNESS)\n\n#define MWF (MORTARTHICKNESS*0.5/BMWIDTH)\n#define MHF (MORTARTHICKNESS*0.5/BMHEIGHT)\n\n#define CBrick vec3(0.5,0.15,0.14)\n#define CMortar vec3(0.5,0.5,0.5)\n\n\n#define frac(x) mod((x),1.0)\n#define sIntegral(s) (floor(s)*(1.0-2.0*MWF)+min(1.0-2.0*MWF,max(0.0,frac(s)-MWF)))\n#define tIntegral(t) (floor(t)*(1.0-2.0*MHF)+min(1.0-2.0*MHF,max(0.0,frac(t)-MHF)))\n\n\nfloat xPixelWidth;\nfloat yPixelWidth;\n\nvec3 brick(vec2 p)\n{\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    \n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    //\u50CF\u7D20\u70B9\u6240\u5728\u7816\u5757\u7F16\u53F7\n    float sBrick = floor(s);\n    float tBrick = floor(t);\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    s -= sBrick;\n    t -= tBrick;\n    float w = step(MWF,s) - step(1.0-MWF,t);\n    float h = step(MHF,s) - step(1.0-MHF,t);\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvec3 brickAntialiase(vec2 p){\n    float s = p.x/BMWIDTH;\n    float t = p.y/BMHEIGHT;\n    float ds = xPixelWidth/BMWIDTH;\n    float dt = yPixelWidth/BMHEIGHT;\n    if(mod(floor(t),2.0)==1.0)//\u5947\u6570\u884C\u6C34\u5E73\u504F\u79FB\u534A\u4E2A\u7816\u5757\n        s += 0.5;\n    ///\u50CF\u7D20\u70B9\u5728\u7816\u5757\u5185\u5750\u6807\n    float w = (sIntegral(s+ds)-sIntegral(s))/ds;\n    float h = (tIntegral(t+dt)-tIntegral(t))/dt;\n    vec3 col = mix(CMortar, CBrick, w*h);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    p = p*2.0-1.0;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float anim = sin(fract(iTime/4.0)*3.1415926);\n    float scale = anim*2.0+0.1;\n    \n    xPixelWidth = yPixelWidth = 2.0/iResolution.y*scale;\n    \n    vec3 col;\n    if(p.x<0.0)\n    {\n        col = brick(p*scale);\n    }else if(p.x>0.0)\n    {\n        col = brickAntialiase(p*scale);\n    }\n   \n    float f = smoothstep(0.0,0.01,abs(p.x));\n    col*=f;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Procedural Five-Point Star","id":"3ttGDr","date":"1576051881","viewed":39,"name":"Procedural Five-Point Star","description":"\u4E94\u89D2\u661F","likes":1,"published":"Public","tags":["procedural","2d","fivepointstar"]},"ver":"0.1","info":{"Name":"Procedural Five-Point Star","id":"3ttGDr","date":"1576051881","viewed":39,"name":"Procedural Five-Point Star","description":"\u4E94\u89D2\u661F","likes":1,"published":"Public","tags":["procedural","2d","fivepointstar"]},"renderpass":[{"Code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 FivePointStar(vec2 p, vec2 center, float rmin, float rmax, vec3 starColor)\n{\n    float npoints = 5.0;\n    float starAngle = 2.0*3.1415926/npoints;//72\u5EA6\n    vec3 p0 = rmax*vec3(cos(starAngle/2.0),sin(starAngle/2.0),0.0);\n    vec3 p1 = rmin*vec3(cos(0.0),sin(0.0),0.0);\n    vec3 d = p1-p0;\n    p -= center;\n    float r = sqrt(p.x*p.x+p.y*p.y);\n    float angle = atan(p.y,p.x)+3.1415926-0.28;\n    //\u6839\u636E\u5BF9\u79F0\u6027\uFF0C\u6BCF\u4E2A\u7740\u8272\u70B9\u662F\u5426\u5728\u4E94\u89D2\u661F\u5185\u53EF\u5F52\u7EA6\u4E3A\u5728\u5728\u67D0\u4E2A\u89D2(72\u5EA6)\u7684\u8303\u56F4\uFF0C\u50CF\u7D20\u662F\u5426\u5176\u5185\u90E8\n    //a\u6210\u4E3A\u7740\u8272\u70B9\u5728\u89D2\u4E2D\u7684\u7279\u5F81\u503C\n    float a = mod(angle,starAngle)/starAngle;\n    if(a>=0.5)//\u6BCF\u4E2A\u89D2\u6839\u636E\u4E2D\u5FC3\u5230\u89D2\u70B9\u7684\u8FDE\u7EBF\u5BF9\u79F0\uFF0C\u56E0\u6B64\u8BA1\u7B97\u4E00\u534A\u5C31\u591F\u4E86\n        a = 1.0-a;\n    vec3 d1 = r*vec3(cos(a*starAngle),sin(a*starAngle),0) - p0;\n    //\u56E0\u6B64\uFF0C\u5BF9\u4E8E\u5728\u8FD9\u4E2A\u8303\u56F4\u5185\u7684\u70B9\uFF0C\u70B9\u5728\u4E94\u89D2\u661F\u5185\uFF0C\u5F53\u4E14\u4EC5\u5F53d1\u5728d\u7684\u53F3\u4FA7\n    float in_out = step(0.0,cross(d,d1).z);\n    vec3 col = mix(starColor, vec3(0.8,0.1,0.1),in_out);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = FivePointStar(p,vec2(0.0,0.0),0.25,0.7,vec3(1.0,0.9,0.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define SCALE 1.\r\n#define LINEAR_DENSITY 1        // 0: constant\r\n#define DENS (2./SCALE)         // tau.rho\r\n#define rad (.3*SCALE )         // sphere radius\r\n#define H   (.05*SCALE)         // skin layer thickness (for linear density)\r\n#define CAMERA_DIST (SCALE)  // distance between camera and sphere center\r\n#define ANIM true               // true/false\r\n#define NOISE true              // true/false\r\n#define PI 3.14159\r\n\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    if (NOISE) cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,CAMERA_DIST);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","inputs":[],"outputs":[],"code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define SCALE 1.\r\n#define LINEAR_DENSITY 1        // 0: constant\r\n#define DENS (2./SCALE)         // tau.rho\r\n#define rad (.3*SCALE )         // sphere radius\r\n#define H   (.05*SCALE)         // skin layer thickness (for linear density)\r\n#define CAMERA_DIST (SCALE)  // distance between camera and sphere center\r\n#define ANIM true               // true/false\r\n#define NOISE true              // true/false\r\n#define PI 3.14159\r\n\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    if (NOISE) cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,CAMERA_DIST);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Pseudo-surface illumination","id":"9a04decb39e34dddb789dab27208e966","date":null,"viewed":0,"name":"Pseudo-surface illumination","description":"Pseudo-surface macrosopic reflexion due to microscopic scattering.\nhttps://www.shadertoy.com/view/MsX3DM","likes":0,"published":null,"tags":["pseudosurfaceillumination"]},"ver":null,"info":{"Name":"Pseudo-surface illumination","id":"9a04decb39e34dddb789dab27208e966","date":null,"viewed":0,"name":"Pseudo-surface illumination","description":"Pseudo-surface macrosopic reflexion due to microscopic scattering.\nhttps://www.shadertoy.com/view/MsX3DM","likes":0,"published":null,"tags":["pseudosurfaceillumination"]},"renderpass":[{"Code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define SCALE 1.\r\n#define LINEAR_DENSITY 1        // 0: constant\r\n#define DENS (2./SCALE)         // tau.rho\r\n#define rad (.3*SCALE )         // sphere radius\r\n#define H   (.05*SCALE)         // skin layer thickness (for linear density)\r\n#define CAMERA_DIST (SCALE)  // distance between camera and sphere center\r\n#define ANIM true               // true/false\r\n#define NOISE true              // true/false\r\n#define PI 3.14159\r\n\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    if (NOISE) cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,CAMERA_DIST);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","inputs":[],"outputs":[],"code":"// Mikael Lemercier & Fabrice Neyret , June, 2013\r\n\r\n#define SCALE 1.\r\n#define LINEAR_DENSITY 1        // 0: constant\r\n#define DENS (2./SCALE)         // tau.rho\r\n#define rad (.3*SCALE )         // sphere radius\r\n#define H   (.05*SCALE)         // skin layer thickness (for linear density)\r\n#define CAMERA_DIST (SCALE)  // distance between camera and sphere center\r\n#define ANIM true               // true/false\r\n#define NOISE true              // true/false\r\n#define PI 3.14159\r\n\r\n\r\nvec4 skyColor =     vec4(.7,.8,1.,1.);\r\nvec3 sunColor = 10.*vec3(1.,.7,.1);   // NB: is Energy \r\n\r\nvec2 FragCoord;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of: Created by inigo quilez --------------------\r\n\r\nvec3 noise3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,4567.8,-123.4));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec3 fbm3( vec3 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(p);\r\n    float fy = fbm(p+vec3(1345.67,0,45.67));\r\n    float fz = fbm(p+vec3(0,4567.8,-123.4));\r\nreturn vec3(fx,fy,fz);\r\n}\r\nvec3 perturb3(vec3 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm3(p/scaleX); // usually, to be added to p\r\n}\r\n\r\nfloat constantDensityTransmittance(float NDotL,float NDotO)\r\n{\r\n    return NDotL/(DENS*(NDotL+NDotO));\r\n}\r\n\r\nfloat linearDensityTransmittance(float NDotL,float NDotO,float LDotO)\r\n{\r\n    if (FragCoord.y/iResolution.y>.42)\r\n\t\treturn sqrt(PI/2.) / sqrt(DENS/H* NDotO/NDotL*(NDotL+NDotO) ) ; // test1\r\n\telse\r\n     // return .15*DENS*NDotL/(NDotL+NDotO)*sqrt(1.-LDotO*LDotO);       // test2\r\n\t\treturn .15*DENS*NDotL/(NDotL+NDotO);                            // test3\r\n}\r\n\r\nfloat Rz=0.;  // 1/2 ray length inside object\r\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\r\n{\r\n    vec3 op = vec3(0.0, 0.0, 0.0) - rpos;\r\n    //float rad = 0.3;\r\n  \r\n    float eps = 1e-5;\r\n    float b = dot(op, rdir);\r\n    float det = b*b - dot(op, op) + rad*rad;\r\n      \r\n    if (det > 0.0)\r\n    {\r\n        det = sqrt(det);\r\n        float t = b - det;\r\n        if (t > eps)\r\n        {\r\n            vec4 P = vec4(normalize(rpos+rdir*t), t);\r\n            Rz = rad*P.z;   // 1/2 ray length inside object\r\n#if LINEAR_DENSITY    \r\n            // skin layer counts less\r\n            float dH = 1.+H*(H-2.*rad)/(Rz*Rz);\r\n            if (dH>0.) // core region\r\n                Rz *= .5*(1.+sqrt(dH));\r\n            else\r\n                Rz *= .5*rad*(1.-sqrt(1.-Rz*Rz/(rad*rad)))/H;\r\n#endif\r\n            return P;\r\n        }\r\n    }\r\n  \r\n    return vec4(0.0);\r\n}\r\n\r\nbool computeNormal(in vec3 cameraPos, in vec3 cameraDir, out vec3 normal)\r\n{\r\n    if (NOISE) cameraPos = cameraPos+perturb3(cameraDir,.06,1.5);\r\n    vec4 intersect = intersectSphere(cameraPos,cameraDir);\r\n    if ( intersect.w > 0.)\r\n    {\r\n        normal = intersect.xyz;\r\n        //normal = normalize(normal+perturb3(normal,.3,30.));\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfloat computeTransmittance( in vec3 cameraPos, in vec3 cameraDir, in vec3 lightDir )\r\n{\r\n    vec3 normal;\r\n    if ( computeNormal(cameraPos,cameraDir,normal))\r\n    {\r\n        float NDotL = clamp(dot(normal,lightDir),0.,1.);\r\n        float NDotO = clamp(dot(normal,cameraPos),0.,1.);\r\n        float LDotO = clamp(dot(lightDir,cameraPos),0.,1.);\r\n      \r\n#if LINEAR_DENSITY\r\n        float transmittance = linearDensityTransmittance(NDotL,NDotO,LDotO)*.5;\r\n#else\r\n        float transmittance = constantDensityTransmittance(NDotL,NDotO);\r\n#endif\r\n        return transmittance;\r\n    }\r\n\r\n    return -1.;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    FragCoord=fragCoord;\r\n    \r\n    //camera\r\n    vec3 cameraPos = vec3(0.0,0.0,CAMERA_DIST);      \r\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\r\n    vec3 ww = normalize( cameraPos - cameraTarget );\r\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n    vec3 vv = normalize(cross(ww,uu));\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x/ iResolution.y;\r\n    vec3 cameraDir = normalize( p.x*uu + p.y*vv - 1.5*ww );\r\n \r\n    //light\r\n    float theta = (iMouse.x / iResolution.x *2. - 1.)*PI;\r\n    float phi = (iMouse.y / iResolution.y - .5)*PI;\r\n    vec3 lightDir =vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\r\n  \r\n\t// shade object\r\n    float transmittance = computeTransmittance( cameraPos, cameraDir, lightDir );\r\n\t\r\n\t// display: special cases\r\n\tif (abs(q.y-.42)*iResolution.y<.5)  fragColor = vec4(.75);\r\n    else if (transmittance<0.) \t\t    fragColor = skyColor;\r\n\telse if (transmittance>1.) \t\t    fragColor = vec4(1.,0.,0.,1.); \t\t\r\n\telse\r\n\t{ // display: object\r\n\t\tRz = 1.-exp(-8.*DENS*Rz);\r\n\t    float alpha = Rz;\r\n    \t//fragColor = vec4(alpha); return; // for tests\r\n    \tvec3 frag = vec3(transmittance,transmittance,transmittance);\r\n   \t\tfragColor = vec4(frag*sunColor,alpha) + (1.-alpha)*skyColor;\r\n\t}\r\n\t\r\n    //display: light\r\n    float d = length(vec2(lightDir)-p)*iResolution.x;\r\n    float Z; if (lightDir.z>0.) Z=1.; else Z=0.;\r\n    if (d<10.) fragColor = vec4(1.,Z,.5,1.);\r\n  \r\n    //vec3 normal;\r\n    //computeNormal(cameraPos,cameraDir, normal);\r\n    //fragColor = vec4(normal,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// The MIT License\r\n// Copyright \u00A9 2018 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\r\n//\r\n// List of some other 2D distances:\r\n//\r\n// Circle:               https://www.shadertoy.com/view/3ltSW2\r\n// Segment:              https://www.shadertoy.com/view/3tdSDj\r\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\r\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\r\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\r\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\r\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\r\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\r\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\r\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\r\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\r\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\r\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\r\n// Star5:                https://www.shadertoy.com/view/wlcGzB\r\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\r\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\r\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\r\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\r\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\r\n// Cross:                https://www.shadertoy.com/view/XtGfzw\r\n// Pie:                  https://www.shadertoy.com/view/3l23RK\r\n// Arc:                  https://www.shadertoy.com/view/wl23RK\r\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\r\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\r\n// Parabola Segment:     https://www.shadertoy.com/view/3lSczz\r\n// Rounded X:            https://www.shadertoy.com/view/3dKSDc\r\n// Joint:                https://www.shadertoy.com/view/WldGWM\r\n// Simple Egg:           https://www.shadertoy.com/view/Wdjfz3\r\n//\r\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\r\n\r\n\r\n\r\nfloat dot2( in vec2 v ) { return dot(v,v); }\r\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\r\n    \r\n// unsigned distance to a quadratic bezier\r\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        res = dot2(d+(c+b*t)*t);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        res = min( dot2(d+(c+b*t.x)*t.x),\r\n                   dot2(d+(c+b*t.y)*t.y) );\r\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\r\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\r\n    }\r\n    \r\n    return sqrt( res );\r\n}\r\n\r\n// signed distance to a quadratic bezier\r\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n    float sgn = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        vec2  q = d+(c+b*t)*t;\r\n        res = dot2(q);\r\n    \tsgn = cross2(c+2.0*b*t,q);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\r\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\r\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\r\n    }\r\n    \r\n    return sqrt( res )*sign(sgn);\r\n}\r\n\r\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p - a;\r\n\tvec2 ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    \r\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\r\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\r\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,1.0) );\r\n    \r\n    float d = sdBezier( p, v0,v1,v2 ); \r\n    \r\n    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\r\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,f);\r\n\tcol *= 1.0 - exp(-4.0*abs(d));\r\n\tcol *= 0.8 + 0.2*cos(140.0*d);\r\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\r\n    \r\n    if( cos(0.5*iTime)<-0.5 )\r\n    {\r\n        d = min( udSegment(p,v0,v1),\r\n                 udSegment(p,v1,v2) );\r\n        d = min( d, length(p-v0)-0.02 );\r\n        d = min( d, length(p-v1)-0.02 );\r\n        d = min( d, length(p-v2)-0.02 );\r\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\r\n    }\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// The MIT License\r\n// Copyright \u00A9 2018 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\r\n//\r\n// List of some other 2D distances:\r\n//\r\n// Circle:               https://www.shadertoy.com/view/3ltSW2\r\n// Segment:              https://www.shadertoy.com/view/3tdSDj\r\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\r\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\r\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\r\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\r\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\r\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\r\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\r\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\r\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\r\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\r\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\r\n// Star5:                https://www.shadertoy.com/view/wlcGzB\r\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\r\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\r\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\r\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\r\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\r\n// Cross:                https://www.shadertoy.com/view/XtGfzw\r\n// Pie:                  https://www.shadertoy.com/view/3l23RK\r\n// Arc:                  https://www.shadertoy.com/view/wl23RK\r\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\r\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\r\n// Parabola Segment:     https://www.shadertoy.com/view/3lSczz\r\n// Rounded X:            https://www.shadertoy.com/view/3dKSDc\r\n// Joint:                https://www.shadertoy.com/view/WldGWM\r\n// Simple Egg:           https://www.shadertoy.com/view/Wdjfz3\r\n//\r\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\r\n\r\n\r\n\r\nfloat dot2( in vec2 v ) { return dot(v,v); }\r\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\r\n    \r\n// unsigned distance to a quadratic bezier\r\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        res = dot2(d+(c+b*t)*t);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        res = min( dot2(d+(c+b*t.x)*t.x),\r\n                   dot2(d+(c+b*t.y)*t.y) );\r\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\r\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\r\n    }\r\n    \r\n    return sqrt( res );\r\n}\r\n\r\n// signed distance to a quadratic bezier\r\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n    float sgn = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        vec2  q = d+(c+b*t)*t;\r\n        res = dot2(q);\r\n    \tsgn = cross2(c+2.0*b*t,q);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\r\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\r\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\r\n    }\r\n    \r\n    return sqrt( res )*sign(sgn);\r\n}\r\n\r\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p - a;\r\n\tvec2 ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    \r\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\r\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\r\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,1.0) );\r\n    \r\n    float d = sdBezier( p, v0,v1,v2 ); \r\n    \r\n    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\r\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,f);\r\n\tcol *= 1.0 - exp(-4.0*abs(d));\r\n\tcol *= 0.8 + 0.2*cos(140.0*d);\r\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\r\n    \r\n    if( cos(0.5*iTime)<-0.5 )\r\n    {\r\n        d = min( udSegment(p,v0,v1),\r\n                 udSegment(p,v1,v2) );\r\n        d = min( d, length(p-v0)-0.02 );\r\n        d = min( d, length(p-v1)-0.02 );\r\n        d = min( d, length(p-v2)-0.02 );\r\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\r\n    }\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Quadratic Bezier - 2D Distance","id":"642aa62f032c4a7790211df6a27c0969","date":null,"viewed":0,"name":"Quadratic Bezier - 2D Distance","description":"Distance to a quadratic Bezier segment, which can be computer analytically by solving a cubic equation.","likes":0,"published":null,"tags":["2d"," distancefield"," sdf"," bezier"," cubic"," quadratic"]},"ver":null,"info":{"Name":"Quadratic Bezier - 2D Distance","id":"642aa62f032c4a7790211df6a27c0969","date":null,"viewed":0,"name":"Quadratic Bezier - 2D Distance","description":"Distance to a quadratic Bezier segment, which can be computer analytically by solving a cubic equation.","likes":0,"published":null,"tags":["2d"," distancefield"," sdf"," bezier"," cubic"," quadratic"]},"renderpass":[{"Code":"// The MIT License\r\n// Copyright \u00A9 2018 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\r\n//\r\n// List of some other 2D distances:\r\n//\r\n// Circle:               https://www.shadertoy.com/view/3ltSW2\r\n// Segment:              https://www.shadertoy.com/view/3tdSDj\r\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\r\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\r\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\r\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\r\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\r\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\r\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\r\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\r\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\r\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\r\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\r\n// Star5:                https://www.shadertoy.com/view/wlcGzB\r\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\r\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\r\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\r\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\r\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\r\n// Cross:                https://www.shadertoy.com/view/XtGfzw\r\n// Pie:                  https://www.shadertoy.com/view/3l23RK\r\n// Arc:                  https://www.shadertoy.com/view/wl23RK\r\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\r\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\r\n// Parabola Segment:     https://www.shadertoy.com/view/3lSczz\r\n// Rounded X:            https://www.shadertoy.com/view/3dKSDc\r\n// Joint:                https://www.shadertoy.com/view/WldGWM\r\n// Simple Egg:           https://www.shadertoy.com/view/Wdjfz3\r\n//\r\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\r\n\r\n\r\n\r\nfloat dot2( in vec2 v ) { return dot(v,v); }\r\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\r\n    \r\n// unsigned distance to a quadratic bezier\r\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        res = dot2(d+(c+b*t)*t);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        res = min( dot2(d+(c+b*t.x)*t.x),\r\n                   dot2(d+(c+b*t.y)*t.y) );\r\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\r\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\r\n    }\r\n    \r\n    return sqrt( res );\r\n}\r\n\r\n// signed distance to a quadratic bezier\r\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n    float sgn = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        vec2  q = d+(c+b*t)*t;\r\n        res = dot2(q);\r\n    \tsgn = cross2(c+2.0*b*t,q);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\r\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\r\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\r\n    }\r\n    \r\n    return sqrt( res )*sign(sgn);\r\n}\r\n\r\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p - a;\r\n\tvec2 ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    \r\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\r\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\r\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,1.0) );\r\n    \r\n    float d = sdBezier( p, v0,v1,v2 ); \r\n    \r\n    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\r\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,f);\r\n\tcol *= 1.0 - exp(-4.0*abs(d));\r\n\tcol *= 0.8 + 0.2*cos(140.0*d);\r\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\r\n    \r\n    if( cos(0.5*iTime)<-0.5 )\r\n    {\r\n        d = min( udSegment(p,v0,v1),\r\n                 udSegment(p,v1,v2) );\r\n        d = min( d, length(p-v0)-0.02 );\r\n        d = min( d, length(p-v1)-0.02 );\r\n        d = min( d, length(p-v2)-0.02 );\r\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\r\n    }\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// The MIT License\r\n// Copyright \u00A9 2018 Inigo Quilez\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n// Distance to a quadratic bezier segment, which can be solved analyically with a cubic.\r\n//\r\n// List of some other 2D distances:\r\n//\r\n// Circle:               https://www.shadertoy.com/view/3ltSW2\r\n// Segment:              https://www.shadertoy.com/view/3tdSDj\r\n// Triangle:             https://www.shadertoy.com/view/XsXSz4\r\n// Isosceles Triangle:   https://www.shadertoy.com/view/MldcD7\r\n// Regular Triangle:     https://www.shadertoy.com/view/Xl2yDW\r\n// Regular Pentagon:     https://www.shadertoy.com/view/llVyWW\r\n// Regular Octogon:      https://www.shadertoy.com/view/llGfDG\r\n// Rounded Rectangle:    https://www.shadertoy.com/view/4llXD7\r\n// Rhombus:              https://www.shadertoy.com/view/XdXcRB\r\n// Trapezoid:            https://www.shadertoy.com/view/MlycD3\r\n// Polygon:              https://www.shadertoy.com/view/wdBXRW\r\n// Hexagram:             https://www.shadertoy.com/view/tt23RR\r\n// Regular Star:         https://www.shadertoy.com/view/3tSGDy\r\n// Star5:                https://www.shadertoy.com/view/wlcGzB\r\n// Ellipse 1:            https://www.shadertoy.com/view/4sS3zz\r\n// Ellipse 2:            https://www.shadertoy.com/view/4lsXDN\r\n// Quadratic Bezier:     https://www.shadertoy.com/view/MlKcDD\r\n// Uneven Capsule:       https://www.shadertoy.com/view/4lcBWn\r\n// Vesica:               https://www.shadertoy.com/view/XtVfRW\r\n// Cross:                https://www.shadertoy.com/view/XtGfzw\r\n// Pie:                  https://www.shadertoy.com/view/3l23RK\r\n// Arc:                  https://www.shadertoy.com/view/wl23RK\r\n// Horseshoe:            https://www.shadertoy.com/view/WlSGW1\r\n// Parabola:             https://www.shadertoy.com/view/ws3GD7\r\n// Parabola Segment:     https://www.shadertoy.com/view/3lSczz\r\n// Rounded X:            https://www.shadertoy.com/view/3dKSDc\r\n// Joint:                https://www.shadertoy.com/view/WldGWM\r\n// Simple Egg:           https://www.shadertoy.com/view/Wdjfz3\r\n//\r\n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\r\n\r\n\r\n\r\nfloat dot2( in vec2 v ) { return dot(v,v); }\r\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\r\n    \r\n// unsigned distance to a quadratic bezier\r\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        res = dot2(d+(c+b*t)*t);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        res = min( dot2(d+(c+b*t.x)*t.x),\r\n                   dot2(d+(c+b*t.y)*t.y) );\r\n        // the third root cannot be the closest. See https://www.shadertoy.com/view/4dsfRS\r\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\r\n    }\r\n    \r\n    return sqrt( res );\r\n}\r\n\r\n// signed distance to a quadratic bezier\r\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\r\n{    \r\n    vec2 a = B - A;\r\n    vec2 b = A - 2.0*B + C;\r\n    vec2 c = a * 2.0;\r\n    vec2 d = A - pos;\r\n\r\n    float kk = 1.0/dot(b,b);\r\n    float kx = kk * dot(a,b);\r\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\r\n    float kz = kk * dot(d,a);      \r\n\r\n    float res = 0.0;\r\n    float sgn = 0.0;\r\n\r\n    float p = ky - kx*kx;\r\n    float p3 = p*p*p;\r\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\r\n    float h = q*q + 4.0*p3;\r\n\r\n    if( h>=0.0 ) \r\n    {   // 1 root\r\n        h = sqrt(h);\r\n        vec2 x = (vec2(h,-h)-q)/2.0;\r\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\r\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\r\n        vec2  q = d+(c+b*t)*t;\r\n        res = dot2(q);\r\n    \tsgn = cross2(c+2.0*b*t,q);\r\n    }\r\n    else \r\n    {   // 3 roots\r\n        float z = sqrt(-p);\r\n        float v = acos(q/(p*z*2.0))/3.0;\r\n        float m = cos(v);\r\n        float n = sin(v)*1.732050808;\r\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\r\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cross2(c+2.0*b*t.x,qx);\r\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cross2(c+2.0*b*t.y,qy);\r\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\r\n    }\r\n    \r\n    return sqrt( res )*sign(sgn);\r\n}\r\n\r\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n\tvec2 pa = p - a;\r\n\tvec2 ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    \r\n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\r\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\r\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,1.0) );\r\n    \r\n    float d = sdBezier( p, v0,v1,v2 ); \r\n    \r\n    float f = smoothstep(-0.2,0.2,cos(2.0*iTime));\r\n    vec3 col = vec3(1.0) - vec3(0.1,0.4,0.7)*mix(sign(d),1.0,f);\r\n\tcol *= 1.0 - exp(-4.0*abs(d));\r\n\tcol *= 0.8 + 0.2*cos(140.0*d);\r\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\r\n    \r\n    if( cos(0.5*iTime)<-0.5 )\r\n    {\r\n        d = min( udSegment(p,v0,v1),\r\n                 udSegment(p,v1,v2) );\r\n        d = min( d, length(p-v0)-0.02 );\r\n        d = min( d, length(p-v1)-0.02 );\r\n        d = min( d, length(p-v2)-0.02 );\r\n        col = mix( col, vec3(1,0,0), 1.0-smoothstep(0.0,0.007,d) );\r\n    }\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\r\n{\r\n    float glow = 0.06 * iResolution.y;\r\n    float twopi = 6.28318530718;\r\n    float curve = 1.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 100.0 / iResolution.x * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.25 * vscale + iResolution.y / 2.0));\r\n    float i = clamp(curve, 0.0, 1.0);\r\n    i += clamp((glow + curve) / glow, 0.0, 1.0) * 0.4 ;\r\n    return i * color;\r\n}\r\n\r\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\r\n{\r\n    float theta = atan(iResolution.y / 2.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.13 * iResolution.x);\r\n\tfloat len = iResolution.y * (10.0 + sin(theta * 20.0 + float(int(iTime * 20.0)) * -35.0)) / 11.0;\r\n    float d = max(-0.6, 1.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 2.0) + pow(abs(iResolution.y / 2.0 - ((fragCoord.y - iResolution.y / 2.0) * 4.0 + iResolution.y / 2.0)), 2.0)) / len));\r\n    return vec3(d * (1.0 + sin(theta * 10.0 + floor(iTime * 20.0) * 10.77) * 0.5), d * (1.0 + -cos(theta * 8.0 - floor(iTime * 20.0) * 8.77) * 0.5), d * (1.0 + -sin(theta * 6.0 - floor(iTime * 20.0) * 134.77) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float timescale = 4.0;\r\n\tvec3 c = vec3(0, 0, 0);\r\n    c += Strand(fragCoord, vec3(1.0, 0, 0), 0.7934 + 1.0 + sin(iTime) * 30.0, 1.0, 0.16, 10.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 0.0), 0.645 + 1.0 + sin(iTime) * 30.0, 1.5, 0.2, 10.3 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 0.0, 1.0), 0.735 + 1.0 + sin(iTime) * 30.0, 1.3, 0.19, 8.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 1.0, 0.0), 0.9245 + 1.0 + sin(iTime) * 30.0, 1.6, 0.14, 12.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 1.0), 0.7234 + 1.0 + sin(iTime) * 30.0, 1.9, 0.23, 14.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 0.0, 1.0), 0.84525 + 1.0 + sin(iTime) * 30.0, 1.2, 0.18, 9.0 * timescale);\r\n    c += clamp(Muzzle(fragCoord, timescale), 0.0, 1.0);\r\n\tfragColor = vec4(c.r, c.g, c.b, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\r\n{\r\n    float glow = 0.06 * iResolution.y;\r\n    float twopi = 6.28318530718;\r\n    float curve = 1.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 100.0 / iResolution.x * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.25 * vscale + iResolution.y / 2.0));\r\n    float i = clamp(curve, 0.0, 1.0);\r\n    i += clamp((glow + curve) / glow, 0.0, 1.0) * 0.4 ;\r\n    return i * color;\r\n}\r\n\r\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\r\n{\r\n    float theta = atan(iResolution.y / 2.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.13 * iResolution.x);\r\n\tfloat len = iResolution.y * (10.0 + sin(theta * 20.0 + float(int(iTime * 20.0)) * -35.0)) / 11.0;\r\n    float d = max(-0.6, 1.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 2.0) + pow(abs(iResolution.y / 2.0 - ((fragCoord.y - iResolution.y / 2.0) * 4.0 + iResolution.y / 2.0)), 2.0)) / len));\r\n    return vec3(d * (1.0 + sin(theta * 10.0 + floor(iTime * 20.0) * 10.77) * 0.5), d * (1.0 + -cos(theta * 8.0 - floor(iTime * 20.0) * 8.77) * 0.5), d * (1.0 + -sin(theta * 6.0 - floor(iTime * 20.0) * 134.77) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float timescale = 4.0;\r\n\tvec3 c = vec3(0, 0, 0);\r\n    c += Strand(fragCoord, vec3(1.0, 0, 0), 0.7934 + 1.0 + sin(iTime) * 30.0, 1.0, 0.16, 10.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 0.0), 0.645 + 1.0 + sin(iTime) * 30.0, 1.5, 0.2, 10.3 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 0.0, 1.0), 0.735 + 1.0 + sin(iTime) * 30.0, 1.3, 0.19, 8.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 1.0, 0.0), 0.9245 + 1.0 + sin(iTime) * 30.0, 1.6, 0.14, 12.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 1.0), 0.7234 + 1.0 + sin(iTime) * 30.0, 1.9, 0.23, 14.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 0.0, 1.0), 0.84525 + 1.0 + sin(iTime) * 30.0, 1.2, 0.18, 9.0 * timescale);\r\n    c += clamp(Muzzle(fragCoord, timescale), 0.0, 1.0);\r\n\tfragColor = vec4(c.r, c.g, c.b, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Rainbow Laser Beam","id":"8165905b573a4c9ba1035abe1d5cb7e0","date":null,"viewed":0,"name":"Rainbow Laser Beam","description":"Need to dispatch some pesky enemies with love, grace, and style? I've got just the weapon for you!\nFirst shadertoy!\nNeeds a more laser-y sound for the muzzle/emitter. Maybe sound in stereo?\nhttps://www.shadertoy.com/view/XtBXW3","likes":0,"published":null,"tags":["2d"," beam"," rainbow"]},"ver":null,"info":{"Name":"Rainbow Laser Beam","id":"8165905b573a4c9ba1035abe1d5cb7e0","date":null,"viewed":0,"name":"Rainbow Laser Beam","description":"Need to dispatch some pesky enemies with love, grace, and style? I've got just the weapon for you!\nFirst shadertoy!\nNeeds a more laser-y sound for the muzzle/emitter. Maybe sound in stereo?\nhttps://www.shadertoy.com/view/XtBXW3","likes":0,"published":null,"tags":["2d"," beam"," rainbow"]},"renderpass":[{"Code":"vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\r\n{\r\n    float glow = 0.06 * iResolution.y;\r\n    float twopi = 6.28318530718;\r\n    float curve = 1.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 100.0 / iResolution.x * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.25 * vscale + iResolution.y / 2.0));\r\n    float i = clamp(curve, 0.0, 1.0);\r\n    i += clamp((glow + curve) / glow, 0.0, 1.0) * 0.4 ;\r\n    return i * color;\r\n}\r\n\r\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\r\n{\r\n    float theta = atan(iResolution.y / 2.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.13 * iResolution.x);\r\n\tfloat len = iResolution.y * (10.0 + sin(theta * 20.0 + float(int(iTime * 20.0)) * -35.0)) / 11.0;\r\n    float d = max(-0.6, 1.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 2.0) + pow(abs(iResolution.y / 2.0 - ((fragCoord.y - iResolution.y / 2.0) * 4.0 + iResolution.y / 2.0)), 2.0)) / len));\r\n    return vec3(d * (1.0 + sin(theta * 10.0 + floor(iTime * 20.0) * 10.77) * 0.5), d * (1.0 + -cos(theta * 8.0 - floor(iTime * 20.0) * 8.77) * 0.5), d * (1.0 + -sin(theta * 6.0 - floor(iTime * 20.0) * 134.77) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float timescale = 4.0;\r\n\tvec3 c = vec3(0, 0, 0);\r\n    c += Strand(fragCoord, vec3(1.0, 0, 0), 0.7934 + 1.0 + sin(iTime) * 30.0, 1.0, 0.16, 10.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 0.0), 0.645 + 1.0 + sin(iTime) * 30.0, 1.5, 0.2, 10.3 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 0.0, 1.0), 0.735 + 1.0 + sin(iTime) * 30.0, 1.3, 0.19, 8.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 1.0, 0.0), 0.9245 + 1.0 + sin(iTime) * 30.0, 1.6, 0.14, 12.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 1.0), 0.7234 + 1.0 + sin(iTime) * 30.0, 1.9, 0.23, 14.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 0.0, 1.0), 0.84525 + 1.0 + sin(iTime) * 30.0, 1.2, 0.18, 9.0 * timescale);\r\n    c += clamp(Muzzle(fragCoord, timescale), 0.0, 1.0);\r\n\tfragColor = vec4(c.r, c.g, c.b, 1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"vec3 Strand(in vec2 fragCoord, in vec3 color, in float hoffset, in float hscale, in float vscale, in float timescale)\r\n{\r\n    float glow = 0.06 * iResolution.y;\r\n    float twopi = 6.28318530718;\r\n    float curve = 1.0 - abs(fragCoord.y - (sin(mod(fragCoord.x * hscale / 100.0 / iResolution.x * 1000.0 + iTime * timescale + hoffset, twopi)) * iResolution.y * 0.25 * vscale + iResolution.y / 2.0));\r\n    float i = clamp(curve, 0.0, 1.0);\r\n    i += clamp((glow + curve) / glow, 0.0, 1.0) * 0.4 ;\r\n    return i * color;\r\n}\r\n\r\nvec3 Muzzle(in vec2 fragCoord, in float timescale)\r\n{\r\n    float theta = atan(iResolution.y / 2.0 - fragCoord.y, iResolution.x - fragCoord.x + 0.13 * iResolution.x);\r\n\tfloat len = iResolution.y * (10.0 + sin(theta * 20.0 + float(int(iTime * 20.0)) * -35.0)) / 11.0;\r\n    float d = max(-0.6, 1.0 - (sqrt(pow(abs(iResolution.x - fragCoord.x), 2.0) + pow(abs(iResolution.y / 2.0 - ((fragCoord.y - iResolution.y / 2.0) * 4.0 + iResolution.y / 2.0)), 2.0)) / len));\r\n    return vec3(d * (1.0 + sin(theta * 10.0 + floor(iTime * 20.0) * 10.77) * 0.5), d * (1.0 + -cos(theta * 8.0 - floor(iTime * 20.0) * 8.77) * 0.5), d * (1.0 + -sin(theta * 6.0 - floor(iTime * 20.0) * 134.77) * 0.5));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float timescale = 4.0;\r\n\tvec3 c = vec3(0, 0, 0);\r\n    c += Strand(fragCoord, vec3(1.0, 0, 0), 0.7934 + 1.0 + sin(iTime) * 30.0, 1.0, 0.16, 10.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 0.0), 0.645 + 1.0 + sin(iTime) * 30.0, 1.5, 0.2, 10.3 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 0.0, 1.0), 0.735 + 1.0 + sin(iTime) * 30.0, 1.3, 0.19, 8.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 1.0, 0.0), 0.9245 + 1.0 + sin(iTime) * 30.0, 1.6, 0.14, 12.0 * timescale);\r\n    c += Strand(fragCoord, vec3(0.0, 1.0, 1.0), 0.7234 + 1.0 + sin(iTime) * 30.0, 1.9, 0.23, 14.0 * timescale);\r\n    c += Strand(fragCoord, vec3(1.0, 0.0, 1.0), 0.84525 + 1.0 + sin(iTime) * 30.0, 1.2, 0.18, 9.0 * timescale);\r\n    c += clamp(Muzzle(fragCoord, timescale), 0.0, 1.0);\r\n\tfragColor = vec4(c.r, c.g, c.b, 1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Raymarch in Raymarch","id":"wllXWH","date":"0","viewed":0,"name":"Raymarch in Raymarch","description":"Raymarch tutorial","likes":0,"published":"Private","tags":["raymarch"]},"ver":"0.1","info":{"Name":"Raymarch in Raymarch","id":"wllXWH","date":"0","viewed":0,"name":"Raymarch in Raymarch","description":"Raymarch tutorial","likes":0,"published":"Private","tags":["raymarch"]},"renderpass":[{"Code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_SCREEN 0.\n#define MAT_SPHERE1 1.\n#define MAT_FLOOR  2.\n#define MAT_CORNER 3.\n#define MAT_SCREENZ 4.\n#define MAT_MARCHSPHERE 5.\n#define MAT_MARCHROUTE 6.\n#define MAT_MARCHRADIUS 7.\n#define MAT_SPHERE2 8.\n#define MAT_SPHERE3 9.\n#define MAT_RAYDIRECTION 10.\n#define MAT_HITPOINT 11.\n\nfloat uvToP = 0.0;\nfloat colToUv = 1.0;\nfloat screenZ = 2.5;\n\nfloat sphereAnim = 1.0;\nfloat radiusAnim = 1.0;\nfloat routeAnim = 1.0;\n\nfloat raySphereAlpha = 0.0;\n\nfloat cornersAlpha = 0.0;\nfloat cornersAnim = 0.0;\n\nfloat screenZAlpha = 0.0;\n\nfloat radiusAlpha = 1.0;\n\nfloat rayDirectionAnim = 0.0;\nfloat rayDirectionAnim2 = 0.0;\n\nfloat screenAlpha = 0.0;\n\n// =====================Camera========================\nvec3 cameraPos, cameraTarget;\n\n//================================\n\nfloat sum = 0.0;\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat cio(float t) {\n\treturn t < 0.5\n\t? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n\t: 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeLine(float time)\n{\n    //time += 32.;\n    float t = tl(time, 1.0, 0.5);\n    uvToP = mix(0.0, 1.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(vec3(0.0), vec3(5., 5., -2.), eio(t));\n    cameraTarget = vec3(0.0, 0.0, 5.);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(0., 1., t);\n    cornersAlpha = mix(0., 1., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cornersAnim = mix(0., 1., t);\n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    \n    t = tl(time, 0.5, 0.5);\n    screenZAlpha = mix(0., 1., t);\n\n\tt = tl(time, 0.5, .5);\n    colToUv = mix(colToUv, 0.0, eio(t));\n    \n    t = tl(time, 0.5, 1.0);\n    screenZ = mix(screenZ, 5.0, eio(t));\n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, .75, eio(t));\n    \n    \n    t = tl(time, 1.0, 1.0);\n    screenZ = mix(screenZ, 2.5, eio(t));\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cornersAlpha = mix(cornersAlpha, 0., t);\n    screenZAlpha = mix(screenZAlpha, 0., t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    \n    t = tl(time, 0.0, 0.0);\n    cornersAnim = mix(cornersAnim, 0., t);\n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(5., 15., 6.0), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 6.), eio(t));\n    \n    for (int i=0; i<6; i++) {\n        t = tl(time, 0.25, 0.25);\n        radiusAnim = mix(radiusAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        routeAnim = mix(routeAnim, float(i) + 2., t);\n        t = tl(time, 0.25, 0.25);\n        sphereAnim = mix(sphereAnim, float(i) + 2., t);\n    }\n    \n    \n    t = tl(time, 1.0, 1.0);\n    cameraPos = mix(cameraPos, vec3(2., 3., -3.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 3.0), eio(t));\n    radiusAlpha = mix(radiusAlpha, 0.0, t);\n    routeAnim = mix(routeAnim, 1.0, t);\n    sphereAnim = mix(sphereAnim, 1.0, t);\n    colToUv = mix(colToUv, 1.0, eio(t));\n    screenAlpha = mix(screenAlpha, 0.0, t);\n    \n    t = tl(time, 0.5, 1.0);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 1.0, eio(t));\n    \n    t = tl(time, 0.5, 4.0);\n    rayDirectionAnim = mix(rayDirectionAnim, 1.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    raySphereAlpha = mix(raySphereAlpha, 0.0, t);\n    rayDirectionAnim2 = mix(rayDirectionAnim2, 0.0, t);\n    \n    \n    t = tl(time, 0.5, 1.0);\n    cameraPos = mix(cameraPos, vec3(0.), eio(t));\n    cameraTarget = mix(cameraTarget, vec3(0.0, 0.0, 5.), eio(t));\n}\n\nvec2 opU(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nvec3 sunDir = normalize(vec3(.3, .25, .2));\nvec3 skyColor(vec3 rd)\n{\n    float sundot = clamp(dot(rd,sunDir),0.0,1.0);\n    // sky\t\t\n    vec3 col = mix(vec3(0.2,0.5,0.85)*1.1, vec3(0.0,0.15,0.7), rd.y);\n    col = mix( col, 0.85*vec3(0.8,0.8,0.7), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n    // sun\n    col += 0.3*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n    col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n    col += 6.0*vec3(1.0,0.8,0.6)*pow( sundot,1024.0 );\n    return col * 3.0;\n}\n\nvec3 screenPos;\n\nvec2 sceneSpheres(vec3 p)\n{\n    vec2 s1 = vec2(sdSphere(p - vec3(-2.0, 0.0, 6.0), 1.), MAT_SPHERE1);\n    vec2 s2 = vec2(sdSphere(p - vec3(0.0, 0.0, 12.0), 1.), MAT_SPHERE2);\n    vec2 s3 = vec2(sdSphere(p - vec3(2.0, 0.0, 9.0), 1.), MAT_SPHERE3);\n    return opU(opU(s1, s2), s3);\n}\n\nvec2 sceneMap(vec3 p)\n{\n    vec2 s = sceneSpheres(p);\n    vec2 p1 = vec2(p.y + 2.0, MAT_FLOOR);\n    return opU(s, p1);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    float d = sceneMap(p).x;\n    return normalize(d - vec3(sceneMap(p - e.xyy).x, sceneMap(p - e.yxy).x, sceneMap(p - e.yyx).x));\n}\n\nvoid sceneTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 70; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = sceneMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 screenMap(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 b1 = vec2(sdBox(p - vec3(0., 0., screenZ), vec3(screenSize, 0.01)), MAT_SCREEN);\n    return b1;\n}\n\nvoid screenTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 20; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = screenMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat remap(float val, float im, float ix, float om, float ox)\n{\n    return clamp(om + (val - im) * (ox - om) / (ix - im), om, ox);\n}\n\nvec2 gizmoCorners(vec3 p)\n{\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    \n    float a1 = remap(cornersAnim, 0.0, 0.25, 0.0, 1.0);\n    float a2 = remap(cornersAnim, 0.25, 0.5, 0.0, 1.0);\n    float a3 = remap(cornersAnim, 0.5, 0.75, 0.0, 1.0);\n    float a4 = remap(cornersAnim, 0.75, 1.0, 0.0, 1.0);\n    \n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ), a1), 0.02), MAT_CORNER);\n    vec2 c2 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(1.,-1.), screenZ), a2), 0.02), MAT_CORNER);\n    vec2 c3 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,-1.), screenZ), a3), 0.02), MAT_CORNER);\n    vec2 c4 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize * vec2(-1.,1.), screenZ), a4), 0.02), MAT_CORNER);\n    return opU(c1, opU(c2, opU(c3, c4)));\n}\n\nvec2 gizmoScreenZ(vec3 p)\n{\n    vec2 c1 = vec2(sdLine(p, vec3(0.), vec3(0., 0., screenZ), 0.03), MAT_SCREENZ);\n    return c1;\n}\n\nfloat sphereID = 0.0;\nvec2 gizmoMarching(vec3 p)\n{\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n    \n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n    \tvec3 pos = ray * t;\n        vec2 s = vec2(sdSphere(p - pos, 0.15), MAT_MARCHSPHERE);\n        if (s.x < d.x) {\n            d = s;\n            sphereID = float(i);\n        }\n        \n        float dist = sceneSpheres(pos).x;\n        \n        float anim = clamp(routeAnim - float(i) - 1., 0.0, 1.0);\n        vec2 c1 = vec2(sdLine(p, pos, pos + mix(vec3(0.), ray * dist, anim), 0.03), MAT_MARCHROUTE);\n        \n        d = opU(d, c1);\n        t += dist;\n    }\n    return d;\n}\n\nvec2 gizmoMarchingRadius(vec3 p)\n{\n    vec2 d = vec2(p.y, MAT_MARCHRADIUS);\n    return d;\n}\n\n\nvec2 gizmoRayDirection(vec3 p)\n{\n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999) / 20.;\n    vec2 screenSize = iResolution.xy / min(iResolution.x, iResolution.y);\n    screenSize.y *= -1.;\n    screenSize = mix(-screenSize, screenSize, vec2(a1, a2));\n    vec2 c1 = vec2(sdLine(p, vec3(0.), mix(vec3(0.), vec3(screenSize, screenZ) * 10.0, rayDirectionAnim2), 0.02), MAT_RAYDIRECTION);\n    \n    vec3 ray = normalize(vec3(screenSize, screenZ));\n    vec3 pos;\n    float t = 0.01;\n    for(int i = 0; i < 20; i++) {\n    \tpos = ray * t;\n        vec2 d = sceneMap(pos);\n        t += d.x;\n    }\n    \n    c1 = opU(c1, vec2(sdSphere(p - pos, 0.3), MAT_HITPOINT));\n    \n    return c1;\n}\n\nvec2 gizmoMap(vec3 p)\n{\n    vec2 d = opU(gizmoCorners(p), gizmoScreenZ(p));\n    d = opU(d, gizmoMarching(p));\n    d = opU(d, gizmoRayDirection(p));\n    return d;\n}\n\nvoid gizmoTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 60; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = gizmoMap(pos);\n        if (mat.x < 0.001) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nvec2 radiusMap(vec3 p)\n{\n    return gizmoMarchingRadius(p);\n}\n\nvoid radiusTrace(inout vec3 pos, vec3 ray, out vec2 mat, inout float depth, float maxD)\n{\n    vec3 ro = pos;\n    for(int i = 0; i < 40; i++) {\n        if (depth > maxD) {\n        \tdepth = maxD;\n            break;\n        }\n    \tpos = ro + ray * depth;\n        mat = radiusMap(pos);\n        if (mat.x < 0.001 || depth > maxD) {\n            break;\n        }\n        depth += mat.x;\n    }\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.1;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        vec3 pos = p + t*l;\n        float d = opU(sceneMap(pos), screenMap(pos)).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 10.0 * d / t);\n    }\n    \n    return res;\n}\n\n// checkerbord\n// https://www.shadertoy.com/view/XlcSz2\nfloat checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 sceneShade(vec2 mat, vec3 pos, vec3 ray, float depth, float maxD)\n{\n    vec3 col;\n    vec3 sky = skyColor(ray);\n    if (depth > maxD - 0.01) {\n    \treturn sky;\n    }\n    float sha = shadow(pos, sunDir, 10.);\n    vec3 norm = normal(pos);\n    vec3 albedo = vec3(0.);\n    if(mat.y == MAT_SPHERE1) {\n        albedo = vec3(1., 0., 0.);\n    } else if (mat.y == MAT_SPHERE2) {\n        albedo = vec3(0., 1., 0.);\n    } else if (mat.y == MAT_SPHERE3) {\n        albedo = vec3(0., 0., 1.);\n    } else if(mat.y == MAT_FLOOR) {\n        vec2 ddx_uvw = dFdx( pos.xz ); \n        vec2 ddy_uvw = dFdy( pos.xz ); \n        float checker = checkersTextureGradBox( pos.xz, ddy_uvw, ddy_uvw );\n        albedo = vec3(max(0.2, checker)) * vec3(.8,0.8,0.7) * 2.0;\n    }\n    \n    float diffuse = clamp(dot(norm, sunDir), 0.0, 1.0) * sha * 2.0;\n    col = albedo * (diffuse + 0.05);\n    \n    float fo = 1.0 - exp2(-0.0001 * depth * depth);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo );\n    return col;\n}\n\nvec3 screenShade(vec2 mat, vec3 pos)\n{\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 ta = vec3(0., 0., 3.);\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(pos);\n    float depth = 0.01;\n    vec3 p = ro;\n    sceneTrace(p, ray, mat, depth, 100.);\n    vec3 col = vec3(0.);\n    col = sceneShade(mat, p, ray, depth, 100.);\n    \n    float a1 = fract(rayDirectionAnim * 19.99999);\n    float a2 = floor(rayDirectionAnim * 19.99999 + 1.0) / 20.;\n    float a3 = floor(rayDirectionAnim * 19.99999) / 20.;\n    \n    float aspect = iResolution.y / iResolution.x;\n    float halfAspect = aspect * 0.5;\n    \n    a1 = step(pos.x * halfAspect + 0.5, a1);\n    a2 = step(-pos.y * 0.49 + 0.51+ 0.0, a2);\n    a3 = step(-pos.y * 0.49 + 0.51 + 0.0, a3);\n    //col *= min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0);\n    \n    vec3 uvCoord = vec3(pow(clamp(mix(pos.xy*0.5+0.5, pos.xy, uvToP), 0.0, 1.0), vec2(2.2)), 0.0);\n    col = mix(col, uvCoord, colToUv - min(screenAlpha + min(a2 * a1 + a3, 1.0), 1.0));\n    return col;\n    //return vec3(pow(clamp(pos.xy, 0.0, 1.0), vec2(2.2)), 0.0);\n}\n\nvec4 gizmoShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    if(mat.y == MAT_CORNER) {\n        col = vec4(1.,0.,0., cornersAlpha);\n    } else if (mat.y == MAT_SCREENZ) {\n    \tcol = vec4(0.05, 0.05, 1., screenZAlpha);\n    } else if (mat.y == MAT_MARCHSPHERE) {\n        float alpha = clamp(sphereAnim - sphereID, 0.0, 1.0);\n        vec3 sc = mix(vec3(.0, .1, 3.), vec3(.02, 1., .02), float(sphereID == 0. || sphereID == 6.));\n    \tcol = vec4(sc, alpha * raySphereAlpha);\n    } else if (mat.y == MAT_MARCHROUTE) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_RAYDIRECTION) {\n        col = vec4(1., 0., 0., .9);\n    } else if (mat.y == MAT_HITPOINT) {\n    \tcol = vec4(.02, 1., .02, raySphereAlpha);\n    }\n    return col;\n}\n\nvec4 radiusShade(vec2 mat, vec3 p)\n{\n    vec4 col = vec4(0.);\n\n    vec3 ray = vec3(0., 0., 1.);\n    vec2 d = vec2(10000.);\n\n    float t = 0.0;\n    for(int i=0; i<7; i++) {\n        vec3 pos = ray * t;\n        vec2 dd = sceneSpheres(pos);\n        d = vec2(sdSphere(p - pos, dd.x), MAT_MARCHSPHERE);\n        float alpha2 = step(radiusAnim, float(i) + 2.);\n        float alpha = clamp(radiusAnim - float(i) - 1., 0.0, 1.0);\n        \n        vec4 cirCol = mix(vec4(.0, 0.05, 0.1, 0.9), vec4(0.2, 1., 1.4, .6) , alpha2);\n        col = mix(col, cirCol, smoothstep(0.01, 0., d.x) * cirCol.a * alpha);\n        col = mix(col, vec4(0., 0., 0., 1.), smoothstep(0.02, 0., abs(d.x) - 0.01) * alpha);\n        t += dd.x;\n    }\n    col *= radiusAlpha;\n    return col;\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvec3 render(vec2 p) {\n    screenPos = vec3(p, 2.5);\n    vec3 ro = cameraPos;\n    vec3 ta = cameraTarget;\n    vec3 fo = normalize(ta - ro);\n    vec3 ri = normalize(cross(vec3(0.,1.,0.), fo));\n    vec3 up = normalize(cross(fo,ri));\n    mat3 cam = mat3(ri,up,fo);\n    vec3 ray = cam * normalize(screenPos);\n    float depth = 0.01;\n    vec2 mat;\n    vec3 col = vec3(0.);\n    \n    vec3 pos = ro;\n    sceneTrace(pos, ray, mat, depth, 100.);\n    \n    col = sceneShade(mat, pos, ray, depth, 100.);\n    \n    float sceneDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    screenTrace(pos, ray, mat, depth, sceneDepth);\n    if (depth < sceneDepth) {\n        col = screenShade(mat, pos);\n    }\n    \n    float sceneAndScreenDepth = depth;\n    depth = 0.01;\n    pos = ro;\n    radiusTrace(pos, ray, mat, depth, sceneAndScreenDepth);\n    if (depth < sceneAndScreenDepth) {\n        vec4 radius = radiusShade(mat, pos);\n        col = mix(col, radius.rgb, radius.a);\n    }\n    \n    float sceneAndScreenAndGizmoDepth = sceneAndScreenDepth;\n    depth = 0.01;\n    pos = ro;\n    gizmoTrace(pos, ray, mat, depth, sceneAndScreenAndGizmoDepth);\n    if (depth < sceneAndScreenAndGizmoDepth) {\n        vec4 gizmo = gizmoShade(mat, pos);\n        col = mix(col, gizmo.rgb, gizmo.a);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeLine(mod(iTime, 41.));\n\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 dp = 1. / iResolution.xy;\n\n    vec3 col = vec3(0.);\n    \n    \n    // AA\n    // https://www.shadertoy.com/view/Msl3Rr\n    for(int y = 0; y < 2; y++) {\n        for(int x = 0; x < 2; x++) {\n            vec2 off = vec2(float(x),float(y))/2.;\n            vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) / iResolution.y;\n        \tcol += render(xy)*0.25;\n        }\n    }\n    \n    col = reinhard(col, 1.0, 1000.0);\n    col = pow(col, vec3(1.0/2.2));\n    \n    //col = mix(col, vec3(mix(uv, p, uvToP), 0.), colToUv);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"RayMarch-Primitives","id":"WllGRX","date":"0","viewed":0,"name":"RayMarch-Primitives","description":"RayMarch-Primitives","likes":0,"published":"Private","tags":["primitives"]},"ver":"0.1","info":{"Name":"RayMarch-Primitives","id":"WllGRX","date":"0","viewed":0,"name":"RayMarch-Primitives","description":"RayMarch-Primitives","likes":0,"published":"Private","tags":["primitives"]},"renderpass":[{"Code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright \u00A9 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    if( pos.x>-2.5 && pos.x<0.5 )\n    {\n    res = opU( res, vec2( sdRoundCone( pos-vec3(-1.0,0.20,-2.0), 0.2, 0.1, 0.3 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(-1.0,0.30, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    }\n    if( pos.x>-1.5 && pos.x<1.5 )\n    {\n    res = opU( res, vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    }\n    if( pos.x>-0.5 && pos.x<2.5 )\n    {\n\tres = opU( res, vec2( sdOctahedron(pos-vec3( 1.0,0.15, 1.0), 0.35 ),37.0 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-2.0), vec2(0.1,0.2) ), 8.0 ) );\n    }\n    if( pos.x>0.5 )\n    {\n    res = opU( res, vec2( sdCylinder(   pos-vec3( 2.0,0.20,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.1,0.3,0.1), 0.08), 31.2 ) );\n    res = opU( res, vec2( sdRoundCone(  pos-vec3( 2.0,0.20,-1.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 51.7 ) );\n\tres = opU( res, vec2( sdCone(       pos-vec3( 2.0,0.20, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.3,0.1), 0.15, 0.05), 46.1 ) );\n    }\n    \n\n\t//res = min( res, sdBox(pos-vec3(0.5,0.4,-0.5), vec3(2.0,0.41,2.0) ) );\n    return res;\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(2.0,0.41,2.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.40*dif*vec3(1.00,0.80,0.55);\n        lin += 0.20*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.40*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 9.00*spe*vec3(1.00,0.90,0.70);\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*2.0;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+3.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Reflect Refract TIR Fresnel RayT","id":"ttX3Rs","date":"0","viewed":0,"name":"Reflect Refract TIR Fresnel RayT","description":"A raytracer to go along with a blog post about reflection, refraction, total internal reflection and fresnel.\r\nDrag mouse for orbit camera.\r\nPlay with #define parameters.\r\nhttp://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-inte\r\nhttps://www.shadertoy.com/view/4tyXDR","likes":0,"published":"Private","tags":["reflection"," refraction"," raytrace"," fresnel"," tir"]},"ver":"0.1","info":{"Name":"Reflect Refract TIR Fresnel RayT","id":"ttX3Rs","date":"0","viewed":0,"name":"Reflect Refract TIR Fresnel RayT","description":"A raytracer to go along with a blog post about reflection, refraction, total internal reflection and fresnel.\r\nDrag mouse for orbit camera.\r\nPlay with #define parameters.\r\nhttp://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-inte\r\nhttps://www.shadertoy.com/view/4tyXDR","likes":0,"published":"Private","tags":["reflection"," refraction"," raytrace"," fresnel"," tir"]},"renderpass":[{"Code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  My blog post talking about the techniques in this shadertoy:\n  http://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.125\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n\n// object type\n#define OBJECT_TYPE 0 // 0 = sphere, 1 = box, 2 = geometric gem shape\n\n// object color parameters\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0.01 // How reflective the object is. regardless of fresnel.\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object surface parameters\n#define DO_REFRACTION 1  // 0 to turn off refraction\n#define DO_REFLECTION 1  // 0 to turn off reflection\n#define DO_FRESNEL    1  // 0 to turn off fresnel. fresnel will only show up if reflection is also on.\n\n// rendering params\n#define DO_AA           1  // 0 to turn off 16x jittered SSAA\n#define MAX_RAY_BOUNCES 10 // For box, 2 seems to be max that makes a difference. For sphere, 1 seems to be!\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBox ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir)\n{\n    #if OBJECT_TYPE == 0\n    \treturn RayIntersectSphere(rayPos, rayDir, vec4(0.0, 0.0, 0.0, 0.5));\n    #elif OBJECT_TYPE == 1\n    \tvec2 uv;\n    \tvec4 ret = RayIntersectBox(rayPos, rayDir, vec3(0.5), uv);\n    \tif (dot(rayDir, ret.yzw) > 0.0)\n            ret.yzw *= -1.0;\n    \treturn ret;\n    #else\n    \tvec2 rayMinMax = vec2(-1.0, 1000.0);\n    \tvec3 nearNormal;\n    \tvec3 farNormal;\n    \n    \tfloat size = -0.5;\n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 1.0, 0.2, -0.4)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3(-1.0, 0.2, -0.4)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 1.0,  1.0)), size*0.5), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-1.0,  0.0)), size), nearNormal, farNormal);   \n    \tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0,-0.3,  1.0)), size), nearNormal, farNormal);\n\t\tTrimRayInterval(rayPos, rayDir, rayMinMax, vec4( normalize(vec3( 0.0, 0.3, -1.0)), size), nearNormal, farNormal);     \n\n    \tif (rayMinMax.x > rayMinMax.y)\n            return vec4(-1.0);\n    \n    \tif (rayMinMax.x > 0.0)\n    \t\treturn vec4(rayMinMax.x, nearNormal);\n    \telse\n            return vec4(rayMinMax.y, -farNormal);\n    #endif\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n//============================================================\nfloat FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident)\n{\n    #if DO_FRESNEL\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return 1.0;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n\n        // adjust reflect multiplier for object reflectivity\n        ret = (OBJECT_REFLECTIVITY + (1.0-OBJECT_REFLECTIVITY) * ret);\n        return ret;\n    #else\n    \treturn OBJECT_REFLECTIVITY;\n    #endif\n}\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n}\n\n//============================================================\nvec3 GetObjectInternalRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // bounce around inside the object as many times as needed (or until max bounces) due total internal reflection\n    float multiplier = 1.0;\n    vec3 ret = vec3(0.0);\n    float absorbDistance = 0.0;\n\tfor (int i = 0; i < MAX_RAY_BOUNCES; ++i)\n    {\n        // try and intersect the object\n    \tvec4 rayInfo = RayIntersectObject(rayPos, rayDir);\n        \n        // should \"never\" happen but handle it anyways\n    \tif (rayInfo.x < 0.0)  \n            return ret;\n        \n        // move the ray position to the intersection point.\n        rayPos = rayPos + rayDir * rayInfo.x;\n        \n        // calculate beer's law absorption.\n        absorbDistance += rayInfo.x;    \n        vec3 absorb = exp(-OBJECT_ABSORB * absorbDistance);\n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_INSIDE, REFRACTIVE_INDEX_OUTSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // add in refraction outside of the object\n        vec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_INSIDE / REFRACTIVE_INDEX_OUTSIDE);\n        ret += GetSceneRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier * multiplier * absorb;\n        \n        // add specular highlight based on refracted ray direction\n        ret += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, refractDir, OBJECT_SPECPOWER, false) * refractMultiplier * multiplier * absorb; \n        \n        // follow the ray down the internal reflection path.\n        rayDir = reflect(rayDir, rayInfo.yzw);\n        \n        // move the ray slightly down the reflect path\n        rayPos += rayDir * 0.001;\n        \n        // For reflection, we are only going to be reflecting what is refracted on further bounces.\n        // So, we just need to make sure the next bounce is added in at the reflectMultiplier amount, recursively.\n\t\tmultiplier *= reflectMultiplier;        \n    }\n    \n    // return the color we calculated\n    return ret;\n}\n\n//============================================================\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBox(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    // if we've hit the main object, and it's closer than the platform\n    rayInfo = RayIntersectObject(rayPos, rayDir);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {       \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // move the ray to the intersection point\n        rayPos += rayDir * rayInfo.x;    \n        \n        // calculate how much to reflect or transmit (refract or diffuse)\n        float reflectMultiplier = FresnelReflectAmount(REFRACTIVE_INDEX_OUTSIDE, REFRACTIVE_INDEX_INSIDE, rayDir, rayInfo.yzw);\n        float refractMultiplier = 1.0 - reflectMultiplier;\n        \n        // get reflection color\n        #if DO_REFLECTION\n        \tvec3 reflectDir = reflect(rayDir, rayInfo.yzw);\n        \tret += GetSceneRayColor(rayPos + reflectDir*0.001, reflectDir) * reflectMultiplier;\n        #endif\n        \n        // get refraction color\n        #if DO_REFRACTION\n        \tvec3 refractDir = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE / REFRACTIVE_INDEX_INSIDE);\n        \tret += GetObjectInternalRayColor(rayPos + refractDir*0.001, refractDir) * refractMultiplier;\n        #endif\n        \n        return ret + additiveColor;\n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        if (bestRayHitInfo.x == 1000.0)    \n            return vec3(0.0);//return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.5;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 3.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);    \n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n    #if DO_AA\n        for (int i = 1; i <= 16; ++i)\n        {\n            // calculate stratified subpixel jitter in a 4x4 grid\n            float x = mod(float(i)-1.0, 4.0);\n            float y = mod(floor(float(i) / 4.0), 4.0);\n            vec2 jitter = hash21(float(i)) / 4.0;\n            jitter.x += x / 4.0;\n            jitter.y += y / 4.0;\n            \n            // set up the jittered ray\n            rawPercent = ((fragCoord.xy + jitter) / iResolution.xy); \n            percent = rawPercent - vec2(0.5,0.5);\n\n            rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n                - (cameraLeft * percent.x * cameraViewWidth)\n                + (cameraUp * percent.y * cameraViewHeight);\n            rayDir = normalize(rayTarget);                \n           \n\t\t\t// raytrace\n            vec3 color = RayTracePixelColor(cameraPos, rayDir);\n            \n            // incrementally average our pixel color in\n            finalColor = mix(finalColor, color, 1.0 / float(i));            \n        }\n    #else\n   \t\tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    #endif\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}\n\n","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// glass refraction: ref: http://www.koppglass.com/blog/optical-properties-of-glass-how-light-and-glass-interact/\r\n//                        https://en.wikipedia.org/wiki/Cauchy's_equation\r\n\r\n#define sqr(x) ( (x)*(x) )\r\n\r\n// perceived colors: from https://www.shadertoy.com/view/llKSDz\r\n//                   based on h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n\r\n// Spectrum to xyz approx function from Sloan\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n   vec2 R = iResolution.xy;\r\n\tU /= R.x;\r\n                                      // various kind of glass coefficients\r\n\tfloat //B = 1.458, C = 0.00354;   //  n ~ B + C/lambda^2  https://en.wikipedia.org/wiki/Cauchy's_equation\r\n            B = 1.5046,C = 0.00420;\r\n          //B = 1.522, C = 0.00459;\r\n          //B = 1.569, C = 0.00531;\r\n          //B = 1.670, C = 0.00743;\r\n          //B = 1.728, C = 0.01342;\r\n    \r\n#if 0  // test: refraction index curve(lambda)   \r\n    O = vec4( ( B+C/sqr(0.4 +.35*U.x) -1.5 )/.05  < U.y );\r\n    O.r += .01/fract(100.*(U.y*.05+1.5));\r\n    return;\r\n#endif\r\n    \r\n#if 0  // test: perceived range of colors\r\n    l = 400. + 350.*U.x; // in nm\r\n    O = vec4( pow (.35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(l))), vec3(1./2.2) ), 1);\r\n    return;\r\n#endif\r\n\r\n    U -= .2;\r\n    float     a = atan(U.x,U.y), n,l,\r\n        a_glass = .72 - .05*(.5-.5*cos(.3*(iTime+2.5)));\r\n\r\n    if (U.y<0.) // glass part\r\n        { O = vec4(.5 + smoothstep(1./length(U)/R.x,.0,abs(3.1416+a-a_glass))); return; }\r\n\r\n    O -= O;\r\n    \r\n #define N 1.\r\n    for (float x = 0.; x<N; x++) { // optional loop to integrate on a thick source\r\n         a = atan(U.x+ .1*x/N,U.y);\r\n         n = sin(a)/sin(a_glass); // Snell-Descartes: 1.sin(a_air) = n_glass.sin(a_glass),\r\n         l = sqrt(C/(n-B));       // in micron\r\n\r\n         O += vec4( .35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(1e3*l))), 1);\r\n    }\r\n    O = vec4( pow (O/N, vec4(1./2.2) ) ); // gamma correction\r\n}","inputs":[],"outputs":[],"code":"// glass refraction: ref: http://www.koppglass.com/blog/optical-properties-of-glass-how-light-and-glass-interact/\r\n//                        https://en.wikipedia.org/wiki/Cauchy's_equation\r\n\r\n#define sqr(x) ( (x)*(x) )\r\n\r\n// perceived colors: from https://www.shadertoy.com/view/llKSDz\r\n//                   based on h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n\r\n// Spectrum to xyz approx function from Sloan\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n   vec2 R = iResolution.xy;\r\n\tU /= R.x;\r\n                                      // various kind of glass coefficients\r\n\tfloat //B = 1.458, C = 0.00354;   //  n ~ B + C/lambda^2  https://en.wikipedia.org/wiki/Cauchy's_equation\r\n            B = 1.5046,C = 0.00420;\r\n          //B = 1.522, C = 0.00459;\r\n          //B = 1.569, C = 0.00531;\r\n          //B = 1.670, C = 0.00743;\r\n          //B = 1.728, C = 0.01342;\r\n    \r\n#if 0  // test: refraction index curve(lambda)   \r\n    O = vec4( ( B+C/sqr(0.4 +.35*U.x) -1.5 )/.05  < U.y );\r\n    O.r += .01/fract(100.*(U.y*.05+1.5));\r\n    return;\r\n#endif\r\n    \r\n#if 0  // test: perceived range of colors\r\n    l = 400. + 350.*U.x; // in nm\r\n    O = vec4( pow (.35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(l))), vec3(1./2.2) ), 1);\r\n    return;\r\n#endif\r\n\r\n    U -= .2;\r\n    float     a = atan(U.x,U.y), n,l,\r\n        a_glass = .72 - .05*(.5-.5*cos(.3*(iTime+2.5)));\r\n\r\n    if (U.y<0.) // glass part\r\n        { O = vec4(.5 + smoothstep(1./length(U)/R.x,.0,abs(3.1416+a-a_glass))); return; }\r\n\r\n    O -= O;\r\n    \r\n #define N 1.\r\n    for (float x = 0.; x<N; x++) { // optional loop to integrate on a thick source\r\n         a = atan(U.x+ .1*x/N,U.y);\r\n         n = sin(a)/sin(a_glass); // Snell-Descartes: 1.sin(a_air) = n_glass.sin(a_glass),\r\n         l = sqrt(C/(n-B));       // in micron\r\n\r\n         O += vec4( .35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(1e3*l))), 1);\r\n    }\r\n    O = vec4( pow (O/N, vec4(1./2.2) ) ); // gamma correction\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"refraction (physical+perceptual) ","id":"2574f4a16f004f398153c065cbc66511","date":null,"viewed":0,"name":"refraction (physical+perceptual) ","description":"rainbow caused by glass-air interface, accounting for non-constant non-linear refractive index and perceived colors. \nhttps://www.shadertoy.com/view/llVSDz","likes":0,"published":null,"tags":["refraction"," prism"," rainbow"," dispersion"," wavelength"," cie"," xyzcolorspace"]},"ver":null,"info":{"Name":"refraction (physical+perceptual) ","id":"2574f4a16f004f398153c065cbc66511","date":null,"viewed":0,"name":"refraction (physical+perceptual) ","description":"rainbow caused by glass-air interface, accounting for non-constant non-linear refractive index and perceived colors. \nhttps://www.shadertoy.com/view/llVSDz","likes":0,"published":null,"tags":["refraction"," prism"," rainbow"," dispersion"," wavelength"," cie"," xyzcolorspace"]},"renderpass":[{"Code":"// glass refraction: ref: http://www.koppglass.com/blog/optical-properties-of-glass-how-light-and-glass-interact/\r\n//                        https://en.wikipedia.org/wiki/Cauchy's_equation\r\n\r\n#define sqr(x) ( (x)*(x) )\r\n\r\n// perceived colors: from https://www.shadertoy.com/view/llKSDz\r\n//                   based on h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n\r\n// Spectrum to xyz approx function from Sloan\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n   vec2 R = iResolution.xy;\r\n\tU /= R.x;\r\n                                      // various kind of glass coefficients\r\n\tfloat //B = 1.458, C = 0.00354;   //  n ~ B + C/lambda^2  https://en.wikipedia.org/wiki/Cauchy's_equation\r\n            B = 1.5046,C = 0.00420;\r\n          //B = 1.522, C = 0.00459;\r\n          //B = 1.569, C = 0.00531;\r\n          //B = 1.670, C = 0.00743;\r\n          //B = 1.728, C = 0.01342;\r\n    \r\n#if 0  // test: refraction index curve(lambda)   \r\n    O = vec4( ( B+C/sqr(0.4 +.35*U.x) -1.5 )/.05  < U.y );\r\n    O.r += .01/fract(100.*(U.y*.05+1.5));\r\n    return;\r\n#endif\r\n    \r\n#if 0  // test: perceived range of colors\r\n    l = 400. + 350.*U.x; // in nm\r\n    O = vec4( pow (.35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(l))), vec3(1./2.2) ), 1);\r\n    return;\r\n#endif\r\n\r\n    U -= .2;\r\n    float     a = atan(U.x,U.y), n,l,\r\n        a_glass = .72 - .05*(.5-.5*cos(.3*(iTime+2.5)));\r\n\r\n    if (U.y<0.) // glass part\r\n        { O = vec4(.5 + smoothstep(1./length(U)/R.x,.0,abs(3.1416+a-a_glass))); return; }\r\n\r\n    O -= O;\r\n    \r\n #define N 1.\r\n    for (float x = 0.; x<N; x++) { // optional loop to integrate on a thick source\r\n         a = atan(U.x+ .1*x/N,U.y);\r\n         n = sin(a)/sin(a_glass); // Snell-Descartes: 1.sin(a_air) = n_glass.sin(a_glass),\r\n         l = sqrt(C/(n-B));       // in micron\r\n\r\n         O += vec4( .35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(1e3*l))), 1);\r\n    }\r\n    O = vec4( pow (O/N, vec4(1./2.2) ) ); // gamma correction\r\n}","inputs":[],"outputs":[],"code":"// glass refraction: ref: http://www.koppglass.com/blog/optical-properties-of-glass-how-light-and-glass-interact/\r\n//                        https://en.wikipedia.org/wiki/Cauchy's_equation\r\n\r\n#define sqr(x) ( (x)*(x) )\r\n\r\n// perceived colors: from https://www.shadertoy.com/view/llKSDz\r\n//                   based on h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n\r\n// Spectrum to xyz approx function from Sloan\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 O,  vec2 U )\r\n{\r\n   vec2 R = iResolution.xy;\r\n\tU /= R.x;\r\n                                      // various kind of glass coefficients\r\n\tfloat //B = 1.458, C = 0.00354;   //  n ~ B + C/lambda^2  https://en.wikipedia.org/wiki/Cauchy's_equation\r\n            B = 1.5046,C = 0.00420;\r\n          //B = 1.522, C = 0.00459;\r\n          //B = 1.569, C = 0.00531;\r\n          //B = 1.670, C = 0.00743;\r\n          //B = 1.728, C = 0.01342;\r\n    \r\n#if 0  // test: refraction index curve(lambda)   \r\n    O = vec4( ( B+C/sqr(0.4 +.35*U.x) -1.5 )/.05  < U.y );\r\n    O.r += .01/fract(100.*(U.y*.05+1.5));\r\n    return;\r\n#endif\r\n    \r\n#if 0  // test: perceived range of colors\r\n    l = 400. + 350.*U.x; // in nm\r\n    O = vec4( pow (.35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(l))), vec3(1./2.2) ), 1);\r\n    return;\r\n#endif\r\n\r\n    U -= .2;\r\n    float     a = atan(U.x,U.y), n,l,\r\n        a_glass = .72 - .05*(.5-.5*cos(.3*(iTime+2.5)));\r\n\r\n    if (U.y<0.) // glass part\r\n        { O = vec4(.5 + smoothstep(1./length(U)/R.x,.0,abs(3.1416+a-a_glass))); return; }\r\n\r\n    O -= O;\r\n    \r\n #define N 1.\r\n    for (float x = 0.; x<N; x++) { // optional loop to integrate on a thick source\r\n         a = atan(U.x+ .1*x/N,U.y);\r\n         n = sin(a)/sin(a_glass); // Snell-Descartes: 1.sin(a_air) = n_glass.sin(a_glass),\r\n         l = sqrt(C/(n-B));       // in micron\r\n\r\n         O += vec4( .35* xyzToRgb(constrainXYZToSRGBGamut(xyzFit_1931(1e3*l))), 1);\r\n    }\r\n    O = vec4( pow (O/N, vec4(1./2.2) ) ); // gamma correction\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Seascape ","id":"a9cdcf805dd04ac08fa41c537e6f2872","date":null,"viewed":0,"name":"Seascape ","description":"fully-procedural sea surface computing. without textures.\r\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape\r\nhttps://www.shadertoy.com/view/Ms2SD1","likes":0,"published":null,"tags":["procedural"," noise"," waves"," sea"," water"," subsurface"]},"ver":null,"info":{"Name":"Seascape ","id":"a9cdcf805dd04ac08fa41c537e6f2872","date":null,"viewed":0,"name":"Seascape ","description":"fully-procedural sea surface computing. without textures.\r\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape\r\nhttps://www.shadertoy.com/view/Ms2SD1","likes":0,"published":null,"tags":["procedural"," noise"," waves"," sea"," water"," subsurface"]},"renderpass":[{"Code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","inputs":[],"outputs":[],"code":"/*\r\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\r\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n * Contact: tdmaav@gmail.com\r\n */\r\n\r\nconst int NUM_STEPS = 8;\r\nconst float PI\t \t= 3.141592;\r\nconst float EPSILON\t= 1e-3;\r\n#define EPSILON_NRM (0.1 / iResolution.x)\r\n#define AA\r\n\r\n// sea\r\nconst int ITER_GEOMETRY = 3;\r\nconst int ITER_FRAGMENT = 5;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\r\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\r\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\r\n\r\n// math\r\nmat3 fromEuler(vec3 ang) {\r\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\r\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\r\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\r\n    mat3 m;\r\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\r\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\r\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\r\n\treturn m;\r\n}\r\nfloat hash( vec2 p ) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\t\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\nfloat noise( in vec2 p ) {\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\t\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \r\n                     hash( i + vec2(1.0,0.0) ), u.x),\r\n                mix( hash( i + vec2(0.0,1.0) ), \r\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\n\r\n// lighting\r\nfloat diffuse(vec3 n,vec3 l,float p) {\r\n    return pow(dot(n,l) * 0.4 + 0.6,p);\r\n}\r\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\r\n}\r\n\r\n// sky\r\nvec3 getSkyColor(vec3 e) {\r\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\r\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\r\n}\r\n\r\n// sea\r\nfloat sea_octave(vec2 uv, float choppy) {\r\n    uv += noise(uv);        \r\n    vec2 wv = 1.0-abs(sin(uv));\r\n    vec2 swv = abs(cos(uv));    \r\n    wv = mix(wv,swv,wv);\r\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\r\n}\r\n\r\nfloat map(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nfloat map_detailed(vec3 p) {\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    \r\n    float d, h = 0.0;    \r\n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \r\n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\r\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\r\n        h += d * amp;        \r\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\r\n        choppy = mix(choppy,1.0,0.2);\r\n    }\r\n    return p.y - h;\r\n}\r\n\r\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \r\n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\r\n    fresnel = pow(fresnel,3.0) * 0.5;\r\n        \r\n    vec3 reflected = getSkyColor(reflect(eye,n));    \r\n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \r\n    \r\n    vec3 color = mix(refracted,reflected,fresnel);\r\n    \r\n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n    \r\n    color += vec3(specular(n,l,eye,60.0));\r\n    \r\n    return color;\r\n}\r\n\r\n// tracing\r\nvec3 getNormal(vec3 p, float eps) {\r\n    vec3 n;\r\n    n.y = map_detailed(p);    \r\n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\r\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\n\r\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \r\n    float tm = 0.0;\r\n    float tx = 1000.0;    \r\n    float hx = map(ori + dir * tx);\r\n    if(hx > 0.0) return tx;   \r\n    float hm = map(ori + dir * tm);    \r\n    float tmid = 0.0;\r\n    for(int i = 0; i < NUM_STEPS; i++) {\r\n        tmid = mix(tm,tx, hm/(hm-hx));                   \r\n        p = ori + dir * tmid;                   \r\n    \tfloat hmid = map(p);\r\n\t\tif(hmid < 0.0) {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        } else {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\n\r\nvec3 getPixel(in vec2 coord, float time) {    \r\n    vec2 uv = coord / iResolution.xy;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;    \r\n        \r\n    // ray\r\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \r\n    vec3 ori = vec3(0.0,3.5,time*5.0);\r\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\r\n    dir = normalize(dir) * fromEuler(ang);\r\n    \r\n    // tracing\r\n    vec3 p;\r\n    heightMapTracing(ori,dir,p);\r\n    vec3 dist = p - ori;\r\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\r\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \r\n             \r\n    // color\r\n    return mix(\r\n        getSkyColor(dir),\r\n        getSeaColor(p,n,light,dir,dist),\r\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\r\n}\r\n\r\n// main\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    float time = iTime * 0.3 + iMouse.x*0.01;\r\n\t\r\n#ifdef AA\r\n    vec3 color = vec3(0.0);\r\n    for(int i = -1; i <= 1; i++) {\r\n        for(int j = -1; j <= 1; j++) {\r\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\r\n    \t\tcolor += getPixel(uv, time);\r\n        }\r\n    }\r\n    color /= 9.0;\r\n#else\r\n    vec3 color = getPixel(fragCoord, time);\r\n#endif\r\n    \r\n    // post\r\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Skyline","id":"4a4c45e821064fbc8ce74dc30f117831","date":null,"viewed":0,"name":"Skyline","description":"I have always wanted to make a procedural city. The architecture was limited by what I could do in real-time, but I tried to give it enough complexity that it would look realistic.","likes":0,"published":null,"tags":["procedural"," raymarch"," city"," skyline"]},"ver":null,"info":{"Name":"Skyline","id":"4a4c45e821064fbc8ce74dc30f117831","date":null,"viewed":0,"name":"Skyline","description":"I have always wanted to make a procedural city. The architecture was limited by what I could do in real-time, but I tried to give it enough complexity that it would look realistic.","likes":0,"published":null,"tags":["procedural"," raymarch"," city"," skyline"]},"renderpass":[{"Code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","inputs":[],"outputs":[],"code":"/*--------------------------------------------------------------------------------------\r\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\r\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\r\n----------------------------------------------------------------------------------------\r\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\r\n-Otavio Good\r\n*/\r\n\r\n// ---------------- Config ----------------\r\n// This is an option that lets you render high quality frames for screenshots. It enables\r\n// stochastic antialiasing and motion blur automatically for any shader.\r\n//#define NON_REALTIME_HQ_RENDER\r\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\r\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\r\n\r\n//#define MANUAL_CAMERA\r\n\r\n\r\n// --------------------------------------------------------\r\n// These variables are for the non-realtime block renderer.\r\nfloat localTime = 0.0;\r\nfloat seed = 1.0;\r\n\r\n// Animation variables\r\nfloat fade = 1.0;\r\nvec3 sunDir;\r\nvec3 sunCol;\r\nfloat exposure = 1.0;\r\nvec3 skyCol, horizonCol;\r\n\r\n// other\r\nfloat marchCount = 0.0;\r\n\r\n// ---- noise functions ----\r\nfloat v31(vec3 a)\r\n{\r\n    return a.x + a.y * 37.0 + a.z * 521.0;\r\n}\r\nfloat v21(vec2 a)\r\n{\r\n    return a.x + a.y * 37.0;\r\n}\r\nfloat Hash11(float a)\r\n{\r\n    return fract(sin(a)*10403.9);\r\n}\r\nfloat Hash21(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nvec2 Hash22(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nvec2 Hash12(float f)\r\n{\r\n    return fract(cos(f)*vec2(10003.579, 37049.7));\r\n}\r\nfloat Hash1d(float u)\r\n{\r\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\r\n}\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0;\r\n    return fract(sin(f)*104003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(sin(f)*110003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x),\r\n             mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x),\r\n             mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\nconst float PI=3.14159265;\r\n\r\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\r\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\r\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\r\n\r\n// This function basically is a procedural environment map that makes the sun\r\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\r\n{\r\n\tvec3 localRay = normalize(rayDir);\r\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\r\n\tfloat sunIntensity = 0.05 / dist;\r\n    sunIntensity += exp(-dist*150.0)*7000.0;\r\n\tsunIntensity = min(sunIntensity, 40000.0);\r\n\treturn sunCol * sunIntensity*0.025;\r\n}\r\n\r\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir)\r\n{\r\n    // fade the sky color, multiply sunset dimming\r\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.47))*0.95;\r\n    // make clouds - just a horizontal plane with noise\r\n    float n = noise2d(rayDir.xz/rayDir.y*1.0);\r\n    n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\r\n    n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\r\n    n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\r\n    n = pow(abs(n), 3.0);\r\n    n = mix(n * 0.2, n, saturate(abs(rayDir.y * 8.0)));  // fade clouds in distance\r\n    finalColor = mix(finalColor, (vec3(1.0)+sunCol*10.0)*0.75*saturate((rayDir.y+0.2)*5.0), saturate(n*0.125));\r\n\r\n    // add the sun\r\n    finalColor += GetSunColorSmall(rayDir, sunDir);\r\n    return finalColor;\r\n}\r\n\r\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height)\r\n{\r\n    vec3 finalColor = GetEnvMap(rayDir, sunDir);\r\n\r\n    // Make a skyscraper skyline reflection.\r\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\r\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\r\n    radial *= 4.0;\r\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\r\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\r\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\r\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\r\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\r\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\r\n\r\n\treturn finalColor;\r\n}\r\n\r\n// min function that supports materials in the y component\r\nvec2 matmin(vec2 a, vec2 b)\r\n{\r\n    if (a.x < b.x) return a;\r\n    else return b;\r\n}\r\n\r\n// ---- shapes defined by distance fields ----\r\n// See this site for a reference to more distance functions...\r\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\r\n\r\n// signed box distance field\r\nfloat sdBox(vec3 p, vec3 radius)\r\n{\r\n  vec3 dist = abs(p) - radius;\r\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\r\n}\r\n\r\n// capped cylinder distance field\r\nfloat cylCap(vec3 p, float r, float lenRad)\r\n{\r\n    float a = length(p.xy) - r;\r\n    a = max(a, abs(p.z) - lenRad);\r\n    return a;\r\n}\r\n\r\n// k should be negative. -4.0 works nicely.\r\n// smooth blending function\r\nfloat smin(float a, float b, float k)\r\n{\r\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\r\n}\r\n\r\nfloat Repeat(float a, float len)\r\n{\r\n    return mod(a, len) - 0.5 * len;\r\n}\r\n\r\n// Distance function that defines the car.\r\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\r\nvec2 Car(vec3 baseCenter, float unique)\r\n{\r\n    // bottom box\r\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.001), vec3(0.01, 0.00225, 0.0275));\r\n    // top box smooth blended\r\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.008), vec3(0.005, 0.0005, 0.01)), -160.0);\r\n    // mirror the z axis to duplicate the cylinders for wheels\r\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.0);\r\n    wMirror.z = abs(wMirror.z)-0.02;\r\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\r\n    // Set materials\r\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\r\n    // Car material is some big number that's unique to each car\r\n    // so I can have each car be a different color\r\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\r\n    return distAndMat;\r\n}\r\n\r\n// How much space between voxel borders and geometry for voxel ray march optimization\r\nfloat voxelPad = 0.2;\r\n// p should be in [0..1] range on xz plane\r\n// pint is an integer pair saying which city block you are on\r\nvec2 CityBlock(vec3 p, vec2 pint)\r\n{\r\n    // Get random numbers for this block by hashing the city block variable\r\n    vec4 rand;\r\n    rand.xy = Hash22(pint);\r\n    rand.zw = Hash22(rand.xy);\r\n    vec2 rand2 = Hash22(rand.zw);\r\n\r\n    // Radius of the building\r\n    float baseRad = 0.2 + (rand.x) * 0.1;\r\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\r\n\r\n    // make position relative to the middle of the block\r\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\r\n    float height = rand.w*rand.z + 0.1; // height of first building block\r\n    // Make the city skyline higher in the middle of the city.\r\n    float downtown = saturate(4.0 / length(pint.xy));\r\n    height *= downtown;\r\n    height *= 1.5+(baseRad-0.15)*20.0;\r\n    height += 0.1;\t// minimum building height\r\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\r\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\r\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\r\n\r\n    // road\r\n    d = min(d, p.y);\r\n\r\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\r\n\r\n    // height of second building section\r\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\r\n    height2 = floor(height2*20.0)*0.05;\t// floor units\r\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\r\n    // size pieces of building\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\r\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\r\n    // second building section\r\n    if (rand2.y > 0.25)\r\n    {\r\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\r\n        // subtract off piece from top so it looks like there's a wall around the roof.\r\n        float topWidth = baseRad;\r\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\r\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\r\n    }\r\n    else\r\n    {\r\n        // Cylinder top section of building\r\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\r\n    }\r\n    // mini elevator shaft boxes on top of building\r\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\r\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\r\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\r\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\r\n    float big = sign(boxPos.x);\r\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\r\n\td = min(d, sdBox(boxPos,\r\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\r\n\r\n    // Put domes on some building tops for variety\r\n    if (rand.y < 0.04)\r\n    {\r\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\r\n    }\r\n\r\n    //d = max(d, p.y);  // flatten the city for debugging cars\r\n\r\n    // Need to make a material variable.\r\n    vec2 distAndMat = vec2(d, 0.0);\r\n    // sidewalk box with material\r\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This is the distance function that defines all the scene's geometry.\r\n// The input is a position in space.\r\n// The output is the distance to the nearest surface and a material index.\r\nvec2 DistanceToObject(vec3 p)\r\n{\r\n    //p.y += noise2d((p.xz)*0.0625)*8.0; // Hills\r\n    vec3 rep = p;\r\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\r\n    vec2 distAndMat = CityBlock(rep, floor(p.xz));\r\n\r\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\r\n    // only want to do a single call to the car distance function for all the\r\n    // cars in the scene. And there's a lot of traffic!\r\n    vec3 p2 = p;\r\n    rep.xyz = p2;\r\n    float carTime = localTime*0.2;  // Speed of car driving\r\n    float crossStreet = 1.0;  // whether we are north/south or east/west\r\n    float repeatDist = 0.25;  // Car density bumper to bumper\r\n    // If we are going north/south instead of east/west (?) make cars that are\r\n    // stopped in the street so we don't have collisions.\r\n    if (abs(fract(rep.x)-0.5) < 0.35)\r\n    {\r\n        p2.x += 0.05;\r\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\r\n        rep.xz = p2.xz;\r\n        crossStreet = 0.0;\r\n        repeatDist = 0.1;  // Denser traffic on cross streets\r\n    }\r\n    \r\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\r\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\r\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\r\n    rep.x = (rep.x*sign(rep.x))-0.09;\r\n    rep.z -= carTime * crossStreet;\t// make cars move\r\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\r\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\r\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\r\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\r\n    frontBack *= sin(localTime*2.0 + uniqueID);\r\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\r\n    vec2 carDist = Car(rep, uniqueID); // car distance function\r\n\r\n    // Drop the cars in the scene with materials\r\n    distAndMat = matmin(distAndMat, carDist);\r\n\r\n    return distAndMat;\r\n}\r\n\r\n// This basically makes a procedural texture map for the sides of the buildings.\r\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\r\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\r\n{\r\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\r\n    texColor += hue*0.4;\r\n    texColor *= 0.75;\r\n    float window = 0.0;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\r\n    if (pos.y < 0.05) window = 1.0;\r\n    float winWidth = Hash21(block*4.321)*2.0;\r\n    if ((winWidth < 1.3) && (winWidth >= 1.0)) winWidth = 1.3;\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\r\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\r\n    if (window < 0.5)\r\n    {\r\n        windowRef += 1.0;\r\n    }\r\n    window *= Hash21(block*1.123);\r\n    texColor *= window;\r\n\r\n    float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\r\n    normal.y -= max(-1.0, min(1.0, -wave*0.5));\r\n    float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\r\n    normal.z += pits*0.25;\r\n    pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\r\n    normal.x += pits*0.25;\r\n}\r\n\r\n// Input is UV coordinate of pixel to render.\r\n// Output is RGB color.\r\nvec3 RayTrace(in vec2 fragCoord )\r\n{\r\n    marchCount = 0.0;\r\n\t// -------------------------------- animate ---------------------------------------\r\n    sunCol = vec3(258.0, 248.0, 200.0) / 3555.0;\r\n\tsunDir = normalize(vec3(0.93, 1.0, 1.0));\r\n    horizonCol = vec3(1.0, 0.95, 0.85)*0.9;\r\n    skyCol = vec3(0.3,0.5,0.95);\r\n    exposure = 1.0;\r\n    fade = 1.0;\r\n\r\n\tvec3 camPos, camUp, camLookat;\r\n\t// ------------------- Set up the camera rays for ray marching --------------------\r\n    // Map uv to [-1.0..1.0]\r\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\r\n    uv /= 2.0;  // zoom in\r\n\r\n#ifdef MANUAL_CAMERA\r\n    // Camera up vector.\r\n\tcamUp=vec3(0,1,0);\r\n\r\n\t// Camera lookat.\r\n\tcamLookat=vec3(0,0.0,0);\r\n\r\n    // debugging camera\r\n    float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\r\n\tfloat my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\r\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.35;//7.35\r\n#else\r\n    // Do the camera fly-by animation and different scenes.\r\n    // Time variables for start and end of each scene\r\n    const float t0 = 0.0;\r\n    const float t1 = 8.0;\r\n    const float t2 = 14.0;\r\n    const float t3 = 24.0;\r\n    const float t4 = 38.0;\r\n    const float t5 = 56.0;\r\n    const float t6 = 58.0;\r\n    /*const float t0 = 0.0;\r\n    const float t1 = 0.0;\r\n    const float t2 = 0.0;\r\n    const float t3 = 0.0;\r\n    const float t4 = 0.0;\r\n    const float t5 = 16.0;\r\n    const float t6 = 18.0;*/\r\n    // Repeat the animation after time t6\r\n    localTime = fract(localTime / t6) * t6;\r\n    if (localTime < t1)\r\n    {\r\n        float time = localTime - t0;\r\n        float alpha = time / (t1 - t0);\r\n        fade = saturate(time);\r\n        fade *= saturate(t1 - localTime);\r\n        camPos = vec3(13.0, 3.3, -3.5);\r\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 4.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0,1.5,1.5);\r\n    } else if (localTime < t2)\r\n    {\r\n        float time = localTime - t1;\r\n        float alpha = time / (t2 - t1);\r\n        fade = saturate(time);\r\n        fade *= saturate(t2 - localTime);\r\n        camPos = vec3(26.0, 0.05+smoothstep(0.0, 1.0, alpha)*0.4, 2.0);\r\n        camPos.z -= alpha * 2.8;\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(camPos.x-0.3,-8.15,-40.0);\r\n        \r\n        sunDir = normalize(vec3(0.95, 0.6, 1.0));\r\n        sunCol = vec3(258.0, 248.0, 160.0) / 3555.0;\r\n        exposure *= 0.7;\r\n        skyCol *= 1.5;\r\n    } else if (localTime < t3)\r\n    {\r\n        float time = localTime - t2;\r\n        float alpha = time / (t3 - t2);\r\n        fade = saturate(time);\r\n        fade *= saturate(t3 - localTime);\r\n        camPos = vec3(12.0, 6.3, -0.5);\r\n        camPos.y -= alpha * 5.5;\r\n        camPos.x = cos(alpha*1.0) * 5.2;\r\n        camPos.z = sin(alpha*1.0) * 5.2;\r\n        camUp=normalize(vec3(0,1,-0.5 + alpha * 0.5));\r\n        camLookat=vec3(0,1.0,-0.5);\r\n    } else if (localTime < t4)\r\n    {\r\n        float time = localTime - t3;\r\n        float alpha = time / (t4 - t3);\r\n        fade = saturate(time);\r\n        fade *= saturate(t4 - localTime);\r\n        camPos = vec3(2.15-alpha*0.5, 0.02, -1.0-alpha*0.2);\r\n        camPos.y += smoothstep(0.0,1.0,alpha*alpha) * 3.4;\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(0,0.5+alpha,alpha*5.0);\r\n    } else if (localTime < t5)\r\n    {\r\n        float time = localTime - t4;\r\n        float alpha = time / (t5 - t4);\r\n        fade = saturate(time);\r\n        fade *= saturate(t5 - localTime);\r\n        camPos = vec3(-2.0, 1.3- alpha*1.2, -10.5-alpha*0.5);\r\n        camUp=normalize(vec3(0,1,0.0));\r\n        camLookat=vec3(-2.0,0.3+alpha,-0.0);\r\n        sunDir = normalize(vec3(0.5-alpha*0.6, 0.3-alpha*0.3, 1.0));\r\n        sunCol = vec3(258.0, 148.0, 60.0) / 3555.0;\r\n        localTime *= 16.0;\r\n        exposure *= 0.4;\r\n        horizonCol = vec3(1.0, 0.5, 0.35)*2.0;\r\n        skyCol = vec3(0.75,0.5,0.95);\r\n\r\n    } else if (localTime < t6)\r\n    {\r\n        fade = 0.0;\r\n        camPos = vec3(26.0, 100.0, 2.0);\r\n        camUp=vec3(0,1,0);\r\n        camLookat=vec3(0.3,0.15,0.0);\r\n    }\r\n#endif\r\n\r\n\t// Camera setup for ray tracing / marching\r\n\tvec3 camVec=normalize(camLookat - camPos);\r\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\r\n\tvec3 upNorm=cross(camVec, sideNorm);\r\n\tvec3 worldFacing=(camPos + camVec);\r\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\r\n\tvec3 rayVec = normalize(worldPix - camPos);\r\n\r\n\t// ----------------------------- Ray march the scene ------------------------------\r\n\tvec2 distAndMat;  // Distance and material\r\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\r\n\tconst float maxDepth = 45.0; // farthest distance rays will travel\r\n\tvec3 pos = vec3(0.0);\r\n    const float smallVal = 0.000625;\r\n\t// ray marching time\r\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\r\n    {\r\n        marchCount+=1.0;\r\n        // Step along the ray.\r\n        pos = (camPos + rayVec * t);\r\n        // This is _the_ function that defines the \"distance field\".\r\n        // It's really what makes the scene geometry. The idea is that the\r\n        // distance field returns the distance to the closest object, and then\r\n        // we know we are safe to \"march\" along the ray by that much distance\r\n        // without hitting anything. We repeat this until we get really close\r\n        // and then break because we have effectively hit the object.\r\n        distAndMat = DistanceToObject(pos);\r\n\r\n        // 2d voxel walk through the city blocks.\r\n        // The distance function is not continuous at city block boundaries,\r\n        // so we have to pause our ray march at each voxel boundary.\r\n        float walk = distAndMat.x;\r\n        float dx = -fract(pos.x);\r\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\r\n        float dz = -fract(pos.z);\r\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\r\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\r\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\r\n        walk = min(walk, nearestVoxel);\r\n\r\n        // move down the ray a safe amount\r\n        t += walk;\r\n        // If we are very close to the object, let's call it a hit and exit this loop.\r\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\r\n    }\r\n\r\n    // Ray trace a ground plane to infinity\r\n    float alpha = -camPos.y / rayVec.y;\r\n    if ((t > maxDepth) && (rayVec.y < -0.0))\r\n    {\r\n        pos.xz = camPos.xz + rayVec.xz * alpha;\r\n        pos.y = -0.0;\r\n        t = alpha;\r\n        distAndMat.y = 0.0;\r\n        distAndMat.x = 0.0;\r\n    }\r\n\t// --------------------------------------------------------------------------------\r\n\t// Now that we have done our ray marching, let's put some color on this geometry.\r\n\tvec3 finalColor = vec3(0.0);\r\n\r\n\t// If a ray actually hit the object, let's light it.\r\n    if ((t <= maxDepth) || (t == alpha))\r\n\t{\r\n        float dist = distAndMat.x;\r\n        // calculate the normal from the distance field. The distance field is a volume, so if you\r\n        // sample the current point and neighboring points, you can use the difference to get\r\n        // the normal.\r\n        vec3 smallVec = vec3(smallVal, 0, 0);\r\n        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\r\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\r\n        vec3 normal = normalize(normalU);\r\n\r\n        // calculate 2 ambient occlusion values. One for global stuff and one\r\n        // for local stuff\r\n        float ambientS = 1.0;\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\r\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\r\n        //ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\r\n        float ambient = ambientS;// * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 3.2)*1.25*0.25);\r\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4)*1.25*0.125);\r\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\r\n        ambient = saturate(ambient);\r\n\r\n        // calculate the reflection vector for highlights\r\n        vec3 ref = reflect(rayVec, normal);\r\n\r\n        // Trace a ray toward the sun for sun shadows\r\n        float sunShadow = 1.0;\r\n        float iter = 0.01;\r\n        vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\r\n\t\tfor (int i = 0; i < 40; i++)\r\n        {\r\n            vec3 shadowPos = nudgePos + sunDir * iter;\r\n            float tempDist = DistanceToObject(shadowPos).x;\r\n\t        sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\r\n            if (tempDist <= 0.0) break;\r\n\r\n            float walk = tempDist;\r\n            float dx = -fract(shadowPos.x);\r\n            if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\r\n            float dz = -fract(shadowPos.z);\r\n            if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\r\n            float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\r\n            nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\r\n            walk = min(walk, nearestVoxel);\r\n\r\n            iter += max(0.01, walk);\r\n            if (iter > 4.5) break;\r\n        }\r\n        sunShadow = saturate(sunShadow);\r\n\r\n        // make a few frequencies of noise to give it some texture\r\n        float n =0.0;\r\n        n += noise(pos*32.0);\r\n        n += noise(pos*64.0);\r\n        n += noise(pos*128.0);\r\n        n += noise(pos*256.0);\r\n        n += noise(pos*512.0);\r\n        n = mix(0.7, 0.95, n);\r\n\r\n        // ------ Calculate texture color  ------\r\n        vec2 block = floor(pos.xz);\r\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\r\n        texColor *= 0.8;\r\n        float windowRef = 0.0;\r\n        // texture map the sides of buildings\r\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\r\n        {\r\n            vec3 posdx = dFdx(pos);\r\n            vec3 posdy = dFdy(pos);\r\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\r\n\r\n            // Quincunx antialias the building texture and normal map.\r\n            // I guess procedural textures are hard to mipmap.\r\n            vec3 colTotal = vec3(0.0);\r\n            vec3 colTemp = texColor;\r\n            vec3 nTemp = vec3(0.0);\r\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\r\n            colTotal = colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            colTemp = texColor;\r\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\r\n            colTotal += colTemp;\r\n\r\n            texColor = colTotal * 0.2;\r\n            windowRef *= 0.2;\r\n\r\n            normal = normalize(normal + nTemp * 0.2);\r\n        }\r\n        else\r\n        {\r\n            // Draw the road\r\n            float xroad = abs(fract(pos.x+0.5)-0.5);\r\n            float zroad = abs(fract(pos.z+0.5)-0.5);\r\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\r\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\r\n            texColor *= mix(0.1, 1.0, road);\r\n\r\n            // double yellow line in middle of road\r\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\r\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\r\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\r\n\r\n            // white dashed lines on road\r\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\r\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\r\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\r\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\r\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\r\n            texColor = mix(texColor, vec3(0.5), whiteLine);\r\n\r\n            // crosswalk\r\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((zroad-0.15)*880.0);\r\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\r\n            crossWalk *= saturate((xroad-0.15)*880.0);\r\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\r\n            crossWalk *= n*n;\r\n            texColor = mix(texColor, vec3(0.25), crossWalk);\r\n\r\n            {\r\n                // sidewalk cracks\r\n                float sidewalk = 1.0;\r\n                vec2 blockSize = vec2(100.0);\r\n                if (pos.y > 0.1) blockSize = vec2(10.0, 50);\r\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\r\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\r\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\r\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\r\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\r\n                sidewalk = saturate((1.0-road) + sidewalk);\r\n                texColor *= sidewalk;\r\n            }\r\n        }\r\n        // Car tires are almost black to not call attention to their ugly.\r\n        if (distAndMat.y == 3.0)\r\n        {\r\n            texColor = vec3(0.05);\r\n        }\r\n\r\n        // apply noise\r\n        texColor *= vec3(1.0)*n*0.05;\r\n        texColor *= 0.7;\r\n        texColor = saturate(texColor);\r\n\r\n        float windowMask = 0.0;\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            // car texture and windows\r\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\r\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\r\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\r\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\r\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\r\n            windowMask = saturate( max(0.0, abs(pos.y - 0.0175)*3800.0)-10.0);\r\n            vec2 dirNorm = abs(normalize(normal.xz));\r\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\r\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\r\n            windowMask = max(windowMask, pillars);\r\n            texColor *= windowMask;\r\n        }\r\n\r\n        // ------ Calculate lighting color ------\r\n        // Start with sun color, standard lighting equation, and shadow\r\n        vec3 lightColor = vec3(100.0)*sunCol * saturate(dot(sunDir, normal)) * sunShadow;\r\n        // weighted average the near ambient occlusion with the far for just the right look\r\n        float ambientAvg = (ambient*3.0 + ambientS) * 0.25;\r\n        // Add sky color with ambient acclusion\r\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*2.5;\r\n        lightColor *= 4.0;\r\n\r\n        // finally, apply the light to the texture.\r\n        finalColor = texColor * lightColor;\r\n        // Reflections for cars\r\n        if (distAndMat.y >= 100.0)\r\n        {\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\r\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-1.5)*0.3*yfade*max(0.4,sunShadow);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.2,sunShadow);\r\n        }\r\n        // reflections for building windows\r\n        if (windowRef != 0.0)\r\n        {\r\n            finalColor *= mix(1.0, 0.6, windowRef);\r\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\r\n            finalColor += GetEnvMapSkyline(ref, sunDir, pos.y-0.5)*0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\r\n            //finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n            finalColor += saturate(vec3(0.0)-0.35)*0.15*max(0.25,sunShadow)*windowRef;\r\n        }\r\n        finalColor *= 0.9;\r\n        // fog that fades to reddish plus the sun color so that fog is brightest towards sun\r\n        vec3 rv2 = rayVec;\r\n        rv2.y *= saturate(sign(rv2.y));\r\n        vec3 fogColor = GetEnvMap(rv2, sunDir);\r\n        fogColor = min(vec3(9.0), fogColor);\r\n        finalColor = mix(fogColor, finalColor, exp(-t*0.02));\r\n\r\n        // visualize length of gradient of distance field to check distance field correctness\r\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\r\n        //finalColor = vec3(marchCount)/255.0;\r\n\t}\r\n    else\r\n    {\r\n        // Our ray trace hit nothing, so draw sky.\r\n        finalColor = GetEnvMap(rayVec, sunDir);\r\n    }\r\n\r\n    // vignette?\r\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\r\n    finalColor *= 1.3*exposure;\r\n\r\n\t// output the final color without gamma correction - will do gamma later.\r\n\treturn vec3(clamp(finalColor, 0.0, 1.0)*saturate(fade+0.2));\r\n}\r\n\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n// This function breaks the image down into blocks and scans\r\n// through them, rendering 1 block at a time. It's for non-\r\n// realtime things that take a long time to render.\r\n\r\n// This is the frame rate to render at. Too fast and you will\r\n// miss some blocks.\r\nconst float blockRate = 20.0;\r\nvoid BlockRender(in vec2 fragCoord)\r\n{\r\n    // blockSize is how much it will try to render in 1 frame.\r\n    // adjust this smaller for more complex scenes, bigger for\r\n    // faster render times.\r\n    const float blockSize = 64.0;\r\n    // Make the block repeatedly scan across the image based on time.\r\n    float frame = floor(iTime * blockRate);\r\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\r\n    // ugly bug with mod.\r\n    //float blockX = mod(frame, blockRes.x);\r\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\r\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\r\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\r\n    // Don't draw anything outside the current block.\r\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\r\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\r\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\r\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\r\n    {\r\n        discard;\r\n    }\r\n}\r\n#endif\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    // Optionally render a non-realtime scene with high quality\r\n    BlockRender(fragCoord);\r\n#endif\r\n\r\n    // Do a multi-pass render\r\n    vec3 finalColor = vec3(0.0);\r\n#ifdef NON_REALTIME_HQ_RENDER\r\n    for (float i = 0.0; i < antialiasingSamples; i++)\r\n    {\r\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\r\n        // Set this to the time in seconds of the frame to render.\r\n\t    localTime = frameToRenderHQ;\r\n        // This line will motion-blur the renders\r\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\r\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\r\n        vec2 jittered = fragCoord.xy + vec2(\r\n            Hash21(fragCoord + seed),\r\n            Hash21(fragCoord*7.234567 + seed)\r\n            );\r\n        // don't antialias if only 1 sample.\r\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\r\n        // Accumulate one pass of raytracing into our pixel value\r\n\t    finalColor += RayTrace(jittered);\r\n        // Change the random seed for each pass.\r\n\t    seed *= 1.01234567;\r\n    }\r\n    // Average all accumulated pixel intensities\r\n    finalColor /= antialiasingSamples;\r\n#else\r\n    // Regular real-time rendering\r\n    localTime = iTime;\r\n    finalColor = RayTrace(fragCoord);\r\n#endif\r\n\r\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\r\n}\r\n\r\n\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//    \r\n// Testing Sebastian Aaltonen's soft shadow improvement\r\n//\r\n// The technique is based on estimating a better closest point in ray\r\n// at each step by triangulating from the previous march step.\r\n//\r\n// More info about the technique at slide 39 of this presentation:\r\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\r\n//\r\n// Traditional technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\n//\r\n// Go to lines 54 to compare both.\r\n\r\n\r\n// make this 1 is your machine is too slow\r\n#define AA 2\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\r\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\r\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\r\n{\r\n\tfloat res = 1.0;\r\n    float t = mint;\r\n    float ph = 1e10; // big, such that y = 0 on the first iteration\r\n    \r\n    for( int i=0; i<32; i++ )\r\n    {\r\n\t\tfloat h = map( ro + rd*t );\r\n\r\n        // traditional technique\r\n        if( technique==0 )\r\n        {\r\n        \tres = min( res, 10.0*h/t );\r\n        }\r\n        // improved technique\r\n        else\r\n        {\r\n            // use this if you are getting artifact on the first iteration, or unroll the\r\n            // first iteration out of the loop\r\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \r\n\r\n            float y = h*h/(2.0*ph);\r\n            float d = sqrt(h*h-y*y);\r\n            res = min( res, 10.0*d/max(0.0,t-y) );\r\n            ph = h;\r\n        }\r\n        \r\n        t += h;\r\n        \r\n        if( res<0.0001 || t>tmax ) break;\r\n        \r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRay( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin = 1.0;\r\n    float tmax = 20.0;\r\n   \r\n#if 1\r\n    // bounding volume\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n#endif\r\n    \r\n    float t = tmin;\r\n    for( int i=0; i<64; i++ )\r\n    {\r\n\t    float precis = 0.0005*t;\r\n\t    float res = map( ro+rd*t );\r\n        if( res<precis || t>tmax ) break;\r\n        t += res;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return t;\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.001 + 0.15*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\r\n{ \r\n    vec3  col = vec3(0.0);\r\n    float t = castRay(ro,rd);\r\n\r\n    if( t>-0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = calcNormal( pos );\r\n        \r\n        // material        \r\n\t\tvec3 mate = vec3(0.3);\r\n\r\n        // key light\r\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\r\n        vec3  hal = normalize( lig-rd );\r\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \r\n                    calcSoftshadow( pos, lig, 0.01, 3.0, technique );\r\n\r\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\r\n                    dif *\r\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\r\n\r\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\r\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\r\n        \r\n        // ambient light\r\n        float occ = calcAO( pos, nor );\r\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\r\n        \r\n        // fog\r\n        col *= exp( -0.0005*t*t*t );\r\n    }\r\n\r\n\treturn col;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // camera\t\r\n    float an = 12.0 - sin(0.1*iTime);\r\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\r\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\r\n    // camera-to-world transformation\r\n    mat3 ca = setCamera( ro, ta, 0.0 );\r\n\r\n    int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\r\n\r\n    vec3 tot = vec3(0.0);\r\n#if AA>1\r\n    for( int m=0; m<AA; m++ )\r\n    for( int n=0; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n#else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n#endif\r\n\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\r\n\r\n        // render\t\r\n        vec3 col = render( ro, rd, technique);\r\n\r\n\t\t// gamma\r\n        col = pow( col, vec3(0.4545) );\r\n\r\n        tot += col;\r\n#if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n#endif\r\n\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"//    \r\n// Testing Sebastian Aaltonen's soft shadow improvement\r\n//\r\n// The technique is based on estimating a better closest point in ray\r\n// at each step by triangulating from the previous march step.\r\n//\r\n// More info about the technique at slide 39 of this presentation:\r\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\r\n//\r\n// Traditional technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\n//\r\n// Go to lines 54 to compare both.\r\n\r\n\r\n// make this 1 is your machine is too slow\r\n#define AA 2\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\r\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\r\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\r\n{\r\n\tfloat res = 1.0;\r\n    float t = mint;\r\n    float ph = 1e10; // big, such that y = 0 on the first iteration\r\n    \r\n    for( int i=0; i<32; i++ )\r\n    {\r\n\t\tfloat h = map( ro + rd*t );\r\n\r\n        // traditional technique\r\n        if( technique==0 )\r\n        {\r\n        \tres = min( res, 10.0*h/t );\r\n        }\r\n        // improved technique\r\n        else\r\n        {\r\n            // use this if you are getting artifact on the first iteration, or unroll the\r\n            // first iteration out of the loop\r\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \r\n\r\n            float y = h*h/(2.0*ph);\r\n            float d = sqrt(h*h-y*y);\r\n            res = min( res, 10.0*d/max(0.0,t-y) );\r\n            ph = h;\r\n        }\r\n        \r\n        t += h;\r\n        \r\n        if( res<0.0001 || t>tmax ) break;\r\n        \r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRay( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin = 1.0;\r\n    float tmax = 20.0;\r\n   \r\n#if 1\r\n    // bounding volume\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n#endif\r\n    \r\n    float t = tmin;\r\n    for( int i=0; i<64; i++ )\r\n    {\r\n\t    float precis = 0.0005*t;\r\n\t    float res = map( ro+rd*t );\r\n        if( res<precis || t>tmax ) break;\r\n        t += res;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return t;\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.001 + 0.15*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\r\n{ \r\n    vec3  col = vec3(0.0);\r\n    float t = castRay(ro,rd);\r\n\r\n    if( t>-0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = calcNormal( pos );\r\n        \r\n        // material        \r\n\t\tvec3 mate = vec3(0.3);\r\n\r\n        // key light\r\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\r\n        vec3  hal = normalize( lig-rd );\r\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \r\n                    calcSoftshadow( pos, lig, 0.01, 3.0, technique );\r\n\r\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\r\n                    dif *\r\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\r\n\r\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\r\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\r\n        \r\n        // ambient light\r\n        float occ = calcAO( pos, nor );\r\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\r\n        \r\n        // fog\r\n        col *= exp( -0.0005*t*t*t );\r\n    }\r\n\r\n\treturn col;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // camera\t\r\n    float an = 12.0 - sin(0.1*iTime);\r\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\r\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\r\n    // camera-to-world transformation\r\n    mat3 ca = setCamera( ro, ta, 0.0 );\r\n\r\n    int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\r\n\r\n    vec3 tot = vec3(0.0);\r\n#if AA>1\r\n    for( int m=0; m<AA; m++ )\r\n    for( int n=0; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n#else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n#endif\r\n\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\r\n\r\n        // render\t\r\n        vec3 col = render( ro, rd, technique);\r\n\r\n\t\t// gamma\r\n        col = pow( col, vec3(0.4545) );\r\n\r\n        tot += col;\r\n#if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n#endif\r\n\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Soft Shadow Variation ","id":"17beb202be014d28a1c23695f553aa3e","date":null,"viewed":0,"name":"Soft Shadow Variation ","description":"Testing Sebastian Aaltonen's soft shadow improvement. Go to line 54 to compare with the traditional technique for soft shadows. It's very cheap and improves shadows a lot!\r\nhttps://www.shadertoy.com/view/lsKcDD","likes":0,"published":null,"tags":["3d"," raymarching"]},"ver":null,"info":{"Name":"Soft Shadow Variation ","id":"17beb202be014d28a1c23695f553aa3e","date":null,"viewed":0,"name":"Soft Shadow Variation ","description":"Testing Sebastian Aaltonen's soft shadow improvement. Go to line 54 to compare with the traditional technique for soft shadows. It's very cheap and improves shadows a lot!\r\nhttps://www.shadertoy.com/view/lsKcDD","likes":0,"published":null,"tags":["3d"," raymarching"]},"renderpass":[{"Code":"//    \r\n// Testing Sebastian Aaltonen's soft shadow improvement\r\n//\r\n// The technique is based on estimating a better closest point in ray\r\n// at each step by triangulating from the previous march step.\r\n//\r\n// More info about the technique at slide 39 of this presentation:\r\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\r\n//\r\n// Traditional technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\n//\r\n// Go to lines 54 to compare both.\r\n\r\n\r\n// make this 1 is your machine is too slow\r\n#define AA 2\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\r\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\r\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\r\n{\r\n\tfloat res = 1.0;\r\n    float t = mint;\r\n    float ph = 1e10; // big, such that y = 0 on the first iteration\r\n    \r\n    for( int i=0; i<32; i++ )\r\n    {\r\n\t\tfloat h = map( ro + rd*t );\r\n\r\n        // traditional technique\r\n        if( technique==0 )\r\n        {\r\n        \tres = min( res, 10.0*h/t );\r\n        }\r\n        // improved technique\r\n        else\r\n        {\r\n            // use this if you are getting artifact on the first iteration, or unroll the\r\n            // first iteration out of the loop\r\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \r\n\r\n            float y = h*h/(2.0*ph);\r\n            float d = sqrt(h*h-y*y);\r\n            res = min( res, 10.0*d/max(0.0,t-y) );\r\n            ph = h;\r\n        }\r\n        \r\n        t += h;\r\n        \r\n        if( res<0.0001 || t>tmax ) break;\r\n        \r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRay( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin = 1.0;\r\n    float tmax = 20.0;\r\n   \r\n#if 1\r\n    // bounding volume\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n#endif\r\n    \r\n    float t = tmin;\r\n    for( int i=0; i<64; i++ )\r\n    {\r\n\t    float precis = 0.0005*t;\r\n\t    float res = map( ro+rd*t );\r\n        if( res<precis || t>tmax ) break;\r\n        t += res;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return t;\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.001 + 0.15*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\r\n{ \r\n    vec3  col = vec3(0.0);\r\n    float t = castRay(ro,rd);\r\n\r\n    if( t>-0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = calcNormal( pos );\r\n        \r\n        // material        \r\n\t\tvec3 mate = vec3(0.3);\r\n\r\n        // key light\r\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\r\n        vec3  hal = normalize( lig-rd );\r\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \r\n                    calcSoftshadow( pos, lig, 0.01, 3.0, technique );\r\n\r\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\r\n                    dif *\r\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\r\n\r\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\r\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\r\n        \r\n        // ambient light\r\n        float occ = calcAO( pos, nor );\r\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\r\n        \r\n        // fog\r\n        col *= exp( -0.0005*t*t*t );\r\n    }\r\n\r\n\treturn col;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // camera\t\r\n    float an = 12.0 - sin(0.1*iTime);\r\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\r\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\r\n    // camera-to-world transformation\r\n    mat3 ca = setCamera( ro, ta, 0.0 );\r\n\r\n    int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\r\n\r\n    vec3 tot = vec3(0.0);\r\n#if AA>1\r\n    for( int m=0; m<AA; m++ )\r\n    for( int n=0; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n#else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n#endif\r\n\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\r\n\r\n        // render\t\r\n        vec3 col = render( ro, rd, technique);\r\n\r\n\t\t// gamma\r\n        col = pow( col, vec3(0.4545) );\r\n\r\n        tot += col;\r\n#if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n#endif\r\n\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"//    \r\n// Testing Sebastian Aaltonen's soft shadow improvement\r\n//\r\n// The technique is based on estimating a better closest point in ray\r\n// at each step by triangulating from the previous march step.\r\n//\r\n// More info about the technique at slide 39 of this presentation:\r\n// https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx?dl=0\r\n//\r\n// Traditional technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\n//\r\n// Go to lines 54 to compare both.\r\n\r\n\r\n// make this 1 is your machine is too slow\r\n#define AA 2\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat sdPlane( vec3 p )\r\n{\r\n\treturn p.y;\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat map( in vec3 pos )\r\n{\r\n    vec3 qos = vec3( fract(pos.x+0.5)-0.5, pos.yz );\r\n    return min( sdPlane(     pos.xyz-vec3( 0.0,0.00, 0.0)),\r\n                sdBox(       qos.xyz-vec3( 0.0,0.25, 0.0), vec3(0.2,0.5,0.2) ) );\r\n}\r\n\r\n//------------------------------------------------------------------\r\n\r\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\r\n{\r\n\tfloat res = 1.0;\r\n    float t = mint;\r\n    float ph = 1e10; // big, such that y = 0 on the first iteration\r\n    \r\n    for( int i=0; i<32; i++ )\r\n    {\r\n\t\tfloat h = map( ro + rd*t );\r\n\r\n        // traditional technique\r\n        if( technique==0 )\r\n        {\r\n        \tres = min( res, 10.0*h/t );\r\n        }\r\n        // improved technique\r\n        else\r\n        {\r\n            // use this if you are getting artifact on the first iteration, or unroll the\r\n            // first iteration out of the loop\r\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \r\n\r\n            float y = h*h/(2.0*ph);\r\n            float d = sqrt(h*h-y*y);\r\n            res = min( res, 10.0*d/max(0.0,t-y) );\r\n            ph = h;\r\n        }\r\n        \r\n        t += h;\r\n        \r\n        if( res<0.0001 || t>tmax ) break;\r\n        \r\n    }\r\n    return clamp( res, 0.0, 1.0 );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos )\r\n{\r\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\r\n    return normalize( e.xyy*map( pos + e.xyy ) + \r\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \r\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \r\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\r\n}\r\n\r\nfloat castRay( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin = 1.0;\r\n    float tmax = 20.0;\r\n   \r\n#if 1\r\n    // bounding volume\r\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\r\n    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );\r\n                                                 else           tmax = min( tmax, tp2 ); }\r\n#endif\r\n    \r\n    float t = tmin;\r\n    for( int i=0; i<64; i++ )\r\n    {\r\n\t    float precis = 0.0005*t;\r\n\t    float res = map( ro+rd*t );\r\n        if( res<precis || t>tmax ) break;\r\n        t += res;\r\n    }\r\n\r\n    if( t>tmax ) t=-1.0;\r\n    return t;\r\n}\r\n\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.001 + 0.15*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n    }\r\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd, in int technique)\r\n{ \r\n    vec3  col = vec3(0.0);\r\n    float t = castRay(ro,rd);\r\n\r\n    if( t>-0.5 )\r\n    {\r\n        vec3 pos = ro + t*rd;\r\n        vec3 nor = calcNormal( pos );\r\n        \r\n        // material        \r\n\t\tvec3 mate = vec3(0.3);\r\n\r\n        // key light\r\n        vec3  lig = normalize( vec3(-0.1, 0.3, 0.6) );\r\n        vec3  hal = normalize( lig-rd );\r\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * \r\n                    calcSoftshadow( pos, lig, 0.01, 3.0, technique );\r\n\r\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\r\n                    dif *\r\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\r\n\r\n\t\tcol = mate * 4.0*dif*vec3(1.00,0.70,0.5);\r\n        col +=      12.0*spe*vec3(1.00,0.70,0.5);\r\n        \r\n        // ambient light\r\n        float occ = calcAO( pos, nor );\r\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n        col += mate*amb*occ*vec3(0.0,0.08,0.1);\r\n        \r\n        // fog\r\n        col *= exp( -0.0005*t*t*t );\r\n    }\r\n\r\n\treturn col;\r\n}\r\n\r\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\r\n{\r\n\tvec3 cw = normalize(ta-ro);\r\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n    return mat3( cu, cv, cw );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // camera\t\r\n    float an = 12.0 - sin(0.1*iTime);\r\n    vec3 ro = vec3( 3.0*cos(0.1*an), 1.0, -3.0*sin(0.1*an) );\r\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\r\n    // camera-to-world transformation\r\n    mat3 ca = setCamera( ro, ta, 0.0 );\r\n\r\n    int technique = (fract(iTime/2.0)>0.5) ? 1 : 0;\r\n\r\n    vec3 tot = vec3(0.0);\r\n#if AA>1\r\n    for( int m=0; m<AA; m++ )\r\n    for( int n=0; n<AA; n++ )\r\n    {\r\n        // pixel coordinates\r\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\r\n#else    \r\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\r\n#endif\r\n\r\n        // ray direction\r\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\r\n\r\n        // render\t\r\n        vec3 col = render( ro, rd, technique);\r\n\r\n\t\t// gamma\r\n        col = pow( col, vec3(0.4545) );\r\n\r\n        tot += col;\r\n#if AA>1\r\n    }\r\n    tot /= float(AA*AA);\r\n#endif\r\n\r\n    \r\n    fragColor = vec4( tot, 1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Sphere UV","id":"wl33W2","date":"1577591248","viewed":40,"name":"Sphere UV","description":"\u7403\u4F53UV\u5750\u6807","likes":5,"published":"Public","tags":["math","uv","sphere"]},"ver":"0.1","info":{"Name":"Sphere UV","id":"wl33W2","date":"1577591248","viewed":40,"name":"Sphere UV","description":"\u7403\u4F53UV\u5750\u6807","likes":5,"published":"Public","tags":["math","uv","sphere"]},"renderpass":[{"Code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define SpherePos vec3(0,0,0)\n#define SphereRadius 2.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos - SpherePos, SphereRadius),1));\n        \n    return res;\n}\n\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec2 getSphereUV(in vec3 pos)\n{\n    vec3 posLocal = pos - SpherePos;\n    //\u7ECF\u7EAC\u89D2\u5EA6\n    float longitudeAngle = atan(posLocal.x/posLocal.z)/3.1415926*180.0;\n    float latitudeAngle = acos(posLocal.y/SphereRadius)/3.1415926*180.0;\n    \n    return vec2(longitudeAngle,latitudeAngle);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.3,0.8,1.0);\n    } else{\n        vec2 uv = getSphereUV(pos);\n        col = vec3(checkersGradBox(uv*0.1));\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// #### realistic display of star in Hubble images ################\r\n//                            Fabrice NEYRET 15 oct 2013\r\n// toggles:\r\n//    T:      tune (R)GB  vs   Planck spectrum(T)\r\n//    SPACE:  tune 1GB  vs RG1\r\n\r\n// see also https://www.shadertoy.com/view/Xty3zc\r\n//          https://www.shadertoy.com/view/tlc3zM\r\n\r\n#define NB_STARS 200\r\n#define PERS 1          // perspective\r\n\r\n#define SCALE 40.\r\nconst float star_luminosity = 1e3;\r\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\r\n#define PI 3.1415927\r\nvec2 FragCoord, R;\r\n\r\n//--- filter integration (l0..l1) on black body spectrum(T) ---------\r\nfloat F(float x) \r\n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\r\nfloat IntPlanck(float T,float lambda1,float lambda0) \r\n{\r\n\tconst float A=1.1, B=1./1.05;\r\n\tfloat C0 = 0.014387770, C=C0/(B*T);\r\n\tT = 1.; // normalised spectrum better for display :-)\r\n\treturn 100.*A/B*pow(100.*T/C0,4.)*( F(C/lambda1) - F(C/lambda0) );\r\n}\r\n\r\n// --- Planck black body color I.spectrum(Temp) -----------------------\r\nvec3 Planck(float T) {\r\n\treturn vec3(\r\n\t\tIntPlanck(T,.7e-6,.55e-6),   // red filter\r\n        IntPlanck(T,.55e-6,.49e-6),  // green filter\r\n        IntPlanck(T,.49e-6,.4e-6)    // blue filter\r\n\t\t)*1e-14;\r\n}\r\n\r\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \r\nvec3 draw_star(vec2 pos, float I) {\r\n\t// star out of screen\r\n    const float margin = .2;\r\n\tif (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);\r\n\t\r\n\tpos -= FragCoord.xy/iResolution.y; \r\n\t\r\n// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1\r\n// pixels >> fringes -> smoothed Airy ~ 1/x^3\r\n\tfloat d = length(pos)*SCALE;\r\n\t\r\n\tvec3 col, spectrum = I*star_color;\r\n#if 1\r\n\tcol = spectrum/(d*d*d);\r\n#else\r\n\tcol = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);\r\n#endif\r\n\t\r\n// 2ndary mirror handles signature (assuming handles are long ellipses)\r\n\td = length(pos*vec2(50.,.5))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\td = length(pos*vec2(.5,50.))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\r\n\treturn col;\r\n}\r\n\r\n// --- utility functions ----------------------------------\r\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \r\nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel0,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// --- GUI: mouse tuning ----------------------------------\r\nvec3 userInterface() {\r\n\tvec2 uv = FragCoord.xy/iResolution.y - vec2(.8,.5);\r\n\tvec3 col=vec3(0.); float d;\r\n\tvec4 mouse = iMouse/iResolution.y;\r\n\r\n\tif(!key_toggle(9.)) return col; // 'TAB' key : automatic stars field -> exit\r\n\t\r\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); // 1st mouse position silly\r\n\t\r\n\td = length(uv+vec2(.8,.5)-mouse.xy); // color cursor\r\n\tif (d<.02) col = vec3(0.,0.,1.);\r\n\t\r\n\tif(key_toggle(84.))  // 'T' key : tune RGB vs Temperature->Planck Spectrum\r\n\t{   // ---  Plank Spectrum mode ---\r\n\t\tfloat T = 40000.*iMouse.x/iResolution.x;\r\n\t\tstar_color = Planck(T);\r\n\t\t// star_luminosity = pow(T,4.);\r\n\t} \r\n\telse \r\n\t{   // --- RGB mode ---\r\n\t\tstar_color.gb = mouse.xy*star_luminosity; \r\n\t\tif(key_toggle(32.))  // SPACE key: red or blue dominant, tune the 2 others\r\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\r\n\t}\r\n\t\r\n\t// display the 3-filters analyzor at bottom\r\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\r\n\t\tif (uv.y<-.402) col=  vec3(\r\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., // red frame\r\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., // green frame\r\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  // blue frame\r\n\t\t)*star_color/star_luminosity;\r\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\r\n\t}\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\n// --- main -----------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec3 col;\r\n\tFragCoord = fragCoord;\r\n    R = iResolution.xy;\r\n    float t = iTime;\r\n    \r\n\t// --- tunings (color and display mode)\r\n\tcol = userInterface(); \r\n\t\r\n\t// --- camera\r\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\r\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\r\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\r\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\r\n\tfloat c=cos(a),s=sin(a);\r\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\r\n\t//mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\r\n\t\r\n\t// --- display stars \r\n\tif(key_toggle(9.)) // 'TAB' key\r\n\t\tcol += draw_star(vec2(.8,.5),1.);  // one single centred star\r\n\telse \r\n\t{\r\n\t\t// background\r\n\t\tvec2 uv = im*(fragCoord.xy/iResolution.y)+cam.xy;\r\n\t\tfloat bg = texture(iChannel1,uv).r;\r\n\t\tcol += .5*exp(-7.*bg);\r\n\r\n\t\t// do stars\r\n\t\tfor (int i=0; i<NB_STARS; i++) {\r\n\t\t\t// random position, intensity(=surf), temperature(->color)\r\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\r\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\r\n\t\t\tstar_color = Planck(40000.*exp(-3.*rnd(6*i+5)));\r\n\r\n\t\t\t// project to screen coords\r\n\t\t\tpos = pos-cam;\r\n\t\t\tpos.xy = m*pos.xy;\r\n#if PERS // perspective\r\n\t\t\tpos.xy /= pos.z;\r\n#endif\r\n\t\t\tif (pos.z>0.)\r\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I/(pos.z*pos.z));\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// #### realistic display of star in Hubble images ################\r\n//                            Fabrice NEYRET 15 oct 2013\r\n// toggles:\r\n//    T:      tune (R)GB  vs   Planck spectrum(T)\r\n//    SPACE:  tune 1GB  vs RG1\r\n\r\n// see also https://www.shadertoy.com/view/Xty3zc\r\n//          https://www.shadertoy.com/view/tlc3zM\r\n\r\n#define NB_STARS 200\r\n#define PERS 1          // perspective\r\n\r\n#define SCALE 40.\r\nconst float star_luminosity = 1e3;\r\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\r\n#define PI 3.1415927\r\nvec2 FragCoord, R;\r\n\r\n//--- filter integration (l0..l1) on black body spectrum(T) ---------\r\nfloat F(float x) \r\n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\r\nfloat IntPlanck(float T,float lambda1,float lambda0) \r\n{\r\n\tconst float A=1.1, B=1./1.05;\r\n\tfloat C0 = 0.014387770, C=C0/(B*T);\r\n\tT = 1.; // normalised spectrum better for display :-)\r\n\treturn 100.*A/B*pow(100.*T/C0,4.)*( F(C/lambda1) - F(C/lambda0) );\r\n}\r\n\r\n// --- Planck black body color I.spectrum(Temp) -----------------------\r\nvec3 Planck(float T) {\r\n\treturn vec3(\r\n\t\tIntPlanck(T,.7e-6,.55e-6),   // red filter\r\n        IntPlanck(T,.55e-6,.49e-6),  // green filter\r\n        IntPlanck(T,.49e-6,.4e-6)    // blue filter\r\n\t\t)*1e-14;\r\n}\r\n\r\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \r\nvec3 draw_star(vec2 pos, float I) {\r\n\t// star out of screen\r\n    const float margin = .2;\r\n\tif (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);\r\n\t\r\n\tpos -= FragCoord.xy/iResolution.y; \r\n\t\r\n// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1\r\n// pixels >> fringes -> smoothed Airy ~ 1/x^3\r\n\tfloat d = length(pos)*SCALE;\r\n\t\r\n\tvec3 col, spectrum = I*star_color;\r\n#if 1\r\n\tcol = spectrum/(d*d*d);\r\n#else\r\n\tcol = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);\r\n#endif\r\n\t\r\n// 2ndary mirror handles signature (assuming handles are long ellipses)\r\n\td = length(pos*vec2(50.,.5))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\td = length(pos*vec2(.5,50.))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\r\n\treturn col;\r\n}\r\n\r\n// --- utility functions ----------------------------------\r\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \r\nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel0,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// --- GUI: mouse tuning ----------------------------------\r\nvec3 userInterface() {\r\n\tvec2 uv = FragCoord.xy/iResolution.y - vec2(.8,.5);\r\n\tvec3 col=vec3(0.); float d;\r\n\tvec4 mouse = iMouse/iResolution.y;\r\n\r\n\tif(!key_toggle(9.)) return col; // 'TAB' key : automatic stars field -> exit\r\n\t\r\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); // 1st mouse position silly\r\n\t\r\n\td = length(uv+vec2(.8,.5)-mouse.xy); // color cursor\r\n\tif (d<.02) col = vec3(0.,0.,1.);\r\n\t\r\n\tif(key_toggle(84.))  // 'T' key : tune RGB vs Temperature->Planck Spectrum\r\n\t{   // ---  Plank Spectrum mode ---\r\n\t\tfloat T = 40000.*iMouse.x/iResolution.x;\r\n\t\tstar_color = Planck(T);\r\n\t\t// star_luminosity = pow(T,4.);\r\n\t} \r\n\telse \r\n\t{   // --- RGB mode ---\r\n\t\tstar_color.gb = mouse.xy*star_luminosity; \r\n\t\tif(key_toggle(32.))  // SPACE key: red or blue dominant, tune the 2 others\r\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\r\n\t}\r\n\t\r\n\t// display the 3-filters analyzor at bottom\r\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\r\n\t\tif (uv.y<-.402) col=  vec3(\r\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., // red frame\r\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., // green frame\r\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  // blue frame\r\n\t\t)*star_color/star_luminosity;\r\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\r\n\t}\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\n// --- main -----------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec3 col;\r\n\tFragCoord = fragCoord;\r\n    R = iResolution.xy;\r\n    float t = iTime;\r\n    \r\n\t// --- tunings (color and display mode)\r\n\tcol = userInterface(); \r\n\t\r\n\t// --- camera\r\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\r\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\r\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\r\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\r\n\tfloat c=cos(a),s=sin(a);\r\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\r\n\t//mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\r\n\t\r\n\t// --- display stars \r\n\tif(key_toggle(9.)) // 'TAB' key\r\n\t\tcol += draw_star(vec2(.8,.5),1.);  // one single centred star\r\n\telse \r\n\t{\r\n\t\t// background\r\n\t\tvec2 uv = im*(fragCoord.xy/iResolution.y)+cam.xy;\r\n\t\tfloat bg = texture(iChannel1,uv).r;\r\n\t\tcol += .5*exp(-7.*bg);\r\n\r\n\t\t// do stars\r\n\t\tfor (int i=0; i<NB_STARS; i++) {\r\n\t\t\t// random position, intensity(=surf), temperature(->color)\r\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\r\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\r\n\t\t\tstar_color = Planck(40000.*exp(-3.*rnd(6*i+5)));\r\n\r\n\t\t\t// project to screen coords\r\n\t\t\tpos = pos-cam;\r\n\t\t\tpos.xy = m*pos.xy;\r\n#if PERS // perspective\r\n\t\t\tpos.xy /= pos.z;\r\n#endif\r\n\t\t\tif (pos.z>0.)\r\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I/(pos.z*pos.z));\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Star PSF","id":"0cffc693d2374c8abe55f5fb9d563626","date":null,"viewed":0,"name":"Star PSF","description":"TAB: 1 vs many. \r\n      if 1: col=BlackBody(T) vs RGB ( SPACE: mouse.xy = rGB/RGb )\r\n\r\nstar proj = fraction of sensor pixel.\r\nBut lens+aperture diffraction yields Airy spot + cross (diffract on 2ndary mirror handles). \r\nAnd bright stars saturate filters.\r\nhttps://www.shadertoy.com/view/XdsGWs","likes":0,"published":null,"tags":["astrophysics"," optics"," blackbody"," fourier"," planck"," psf"]},"ver":null,"info":{"Name":"Star PSF","id":"0cffc693d2374c8abe55f5fb9d563626","date":null,"viewed":0,"name":"Star PSF","description":"TAB: 1 vs many. \r\n      if 1: col=BlackBody(T) vs RGB ( SPACE: mouse.xy = rGB/RGb )\r\n\r\nstar proj = fraction of sensor pixel.\r\nBut lens+aperture diffraction yields Airy spot + cross (diffract on 2ndary mirror handles). \r\nAnd bright stars saturate filters.\r\nhttps://www.shadertoy.com/view/XdsGWs","likes":0,"published":null,"tags":["astrophysics"," optics"," blackbody"," fourier"," planck"," psf"]},"renderpass":[{"Code":"// #### realistic display of star in Hubble images ################\r\n//                            Fabrice NEYRET 15 oct 2013\r\n// toggles:\r\n//    T:      tune (R)GB  vs   Planck spectrum(T)\r\n//    SPACE:  tune 1GB  vs RG1\r\n\r\n// see also https://www.shadertoy.com/view/Xty3zc\r\n//          https://www.shadertoy.com/view/tlc3zM\r\n\r\n#define NB_STARS 200\r\n#define PERS 1          // perspective\r\n\r\n#define SCALE 40.\r\nconst float star_luminosity = 1e3;\r\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\r\n#define PI 3.1415927\r\nvec2 FragCoord, R;\r\n\r\n//--- filter integration (l0..l1) on black body spectrum(T) ---------\r\nfloat F(float x) \r\n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\r\nfloat IntPlanck(float T,float lambda1,float lambda0) \r\n{\r\n\tconst float A=1.1, B=1./1.05;\r\n\tfloat C0 = 0.014387770, C=C0/(B*T);\r\n\tT = 1.; // normalised spectrum better for display :-)\r\n\treturn 100.*A/B*pow(100.*T/C0,4.)*( F(C/lambda1) - F(C/lambda0) );\r\n}\r\n\r\n// --- Planck black body color I.spectrum(Temp) -----------------------\r\nvec3 Planck(float T) {\r\n\treturn vec3(\r\n\t\tIntPlanck(T,.7e-6,.55e-6),   // red filter\r\n        IntPlanck(T,.55e-6,.49e-6),  // green filter\r\n        IntPlanck(T,.49e-6,.4e-6)    // blue filter\r\n\t\t)*1e-14;\r\n}\r\n\r\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \r\nvec3 draw_star(vec2 pos, float I) {\r\n\t// star out of screen\r\n    const float margin = .2;\r\n\tif (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);\r\n\t\r\n\tpos -= FragCoord.xy/iResolution.y; \r\n\t\r\n// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1\r\n// pixels >> fringes -> smoothed Airy ~ 1/x^3\r\n\tfloat d = length(pos)*SCALE;\r\n\t\r\n\tvec3 col, spectrum = I*star_color;\r\n#if 1\r\n\tcol = spectrum/(d*d*d);\r\n#else\r\n\tcol = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);\r\n#endif\r\n\t\r\n// 2ndary mirror handles signature (assuming handles are long ellipses)\r\n\td = length(pos*vec2(50.,.5))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\td = length(pos*vec2(.5,50.))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\r\n\treturn col;\r\n}\r\n\r\n// --- utility functions ----------------------------------\r\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \r\nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel0,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// --- GUI: mouse tuning ----------------------------------\r\nvec3 userInterface() {\r\n\tvec2 uv = FragCoord.xy/iResolution.y - vec2(.8,.5);\r\n\tvec3 col=vec3(0.); float d;\r\n\tvec4 mouse = iMouse/iResolution.y;\r\n\r\n\tif(!key_toggle(9.)) return col; // 'TAB' key : automatic stars field -> exit\r\n\t\r\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); // 1st mouse position silly\r\n\t\r\n\td = length(uv+vec2(.8,.5)-mouse.xy); // color cursor\r\n\tif (d<.02) col = vec3(0.,0.,1.);\r\n\t\r\n\tif(key_toggle(84.))  // 'T' key : tune RGB vs Temperature->Planck Spectrum\r\n\t{   // ---  Plank Spectrum mode ---\r\n\t\tfloat T = 40000.*iMouse.x/iResolution.x;\r\n\t\tstar_color = Planck(T);\r\n\t\t// star_luminosity = pow(T,4.);\r\n\t} \r\n\telse \r\n\t{   // --- RGB mode ---\r\n\t\tstar_color.gb = mouse.xy*star_luminosity; \r\n\t\tif(key_toggle(32.))  // SPACE key: red or blue dominant, tune the 2 others\r\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\r\n\t}\r\n\t\r\n\t// display the 3-filters analyzor at bottom\r\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\r\n\t\tif (uv.y<-.402) col=  vec3(\r\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., // red frame\r\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., // green frame\r\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  // blue frame\r\n\t\t)*star_color/star_luminosity;\r\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\r\n\t}\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\n// --- main -----------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec3 col;\r\n\tFragCoord = fragCoord;\r\n    R = iResolution.xy;\r\n    float t = iTime;\r\n    \r\n\t// --- tunings (color and display mode)\r\n\tcol = userInterface(); \r\n\t\r\n\t// --- camera\r\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\r\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\r\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\r\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\r\n\tfloat c=cos(a),s=sin(a);\r\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\r\n\t//mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\r\n\t\r\n\t// --- display stars \r\n\tif(key_toggle(9.)) // 'TAB' key\r\n\t\tcol += draw_star(vec2(.8,.5),1.);  // one single centred star\r\n\telse \r\n\t{\r\n\t\t// background\r\n\t\tvec2 uv = im*(fragCoord.xy/iResolution.y)+cam.xy;\r\n\t\tfloat bg = texture(iChannel1,uv).r;\r\n\t\tcol += .5*exp(-7.*bg);\r\n\r\n\t\t// do stars\r\n\t\tfor (int i=0; i<NB_STARS; i++) {\r\n\t\t\t// random position, intensity(=surf), temperature(->color)\r\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\r\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\r\n\t\t\tstar_color = Planck(40000.*exp(-3.*rnd(6*i+5)));\r\n\r\n\t\t\t// project to screen coords\r\n\t\t\tpos = pos-cam;\r\n\t\t\tpos.xy = m*pos.xy;\r\n#if PERS // perspective\r\n\t\t\tpos.xy /= pos.z;\r\n#endif\r\n\t\t\tif (pos.z>0.)\r\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I/(pos.z*pos.z));\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfragColor = vec4(col,1.0);\r\n}","inputs":[],"outputs":[],"code":"// #### realistic display of star in Hubble images ################\r\n//                            Fabrice NEYRET 15 oct 2013\r\n// toggles:\r\n//    T:      tune (R)GB  vs   Planck spectrum(T)\r\n//    SPACE:  tune 1GB  vs RG1\r\n\r\n// see also https://www.shadertoy.com/view/Xty3zc\r\n//          https://www.shadertoy.com/view/tlc3zM\r\n\r\n#define NB_STARS 200\r\n#define PERS 1          // perspective\r\n\r\n#define SCALE 40.\r\nconst float star_luminosity = 1e3;\r\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\r\n#define PI 3.1415927\r\nvec2 FragCoord, R;\r\n\r\n//--- filter integration (l0..l1) on black body spectrum(T) ---------\r\nfloat F(float x) \r\n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\r\nfloat IntPlanck(float T,float lambda1,float lambda0) \r\n{\r\n\tconst float A=1.1, B=1./1.05;\r\n\tfloat C0 = 0.014387770, C=C0/(B*T);\r\n\tT = 1.; // normalised spectrum better for display :-)\r\n\treturn 100.*A/B*pow(100.*T/C0,4.)*( F(C/lambda1) - F(C/lambda0) );\r\n}\r\n\r\n// --- Planck black body color I.spectrum(Temp) -----------------------\r\nvec3 Planck(float T) {\r\n\treturn vec3(\r\n\t\tIntPlanck(T,.7e-6,.55e-6),   // red filter\r\n        IntPlanck(T,.55e-6,.49e-6),  // green filter\r\n        IntPlanck(T,.49e-6,.4e-6)    // blue filter\r\n\t\t)*1e-14;\r\n}\r\n\r\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \r\nvec3 draw_star(vec2 pos, float I) {\r\n\t// star out of screen\r\n    const float margin = .2;\r\n\tif (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);\r\n\t\r\n\tpos -= FragCoord.xy/iResolution.y; \r\n\t\r\n// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1\r\n// pixels >> fringes -> smoothed Airy ~ 1/x^3\r\n\tfloat d = length(pos)*SCALE;\r\n\t\r\n\tvec3 col, spectrum = I*star_color;\r\n#if 1\r\n\tcol = spectrum/(d*d*d);\r\n#else\r\n\tcol = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);\r\n#endif\r\n\t\r\n// 2ndary mirror handles signature (assuming handles are long ellipses)\r\n\td = length(pos*vec2(50.,.5))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\td = length(pos*vec2(.5,50.))*SCALE;\r\n\tcol += spectrum/(d*d*d);\r\n\r\n\treturn col;\r\n}\r\n\r\n// --- utility functions ----------------------------------\r\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \r\nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \r\n\r\nbool key_toggle(float ascii) { \r\n\treturn (texture(iChannel0,vec2((ascii+.5)/256.,0.75)).x > 0.); \r\n}\r\n\r\n// --- GUI: mouse tuning ----------------------------------\r\nvec3 userInterface() {\r\n\tvec2 uv = FragCoord.xy/iResolution.y - vec2(.8,.5);\r\n\tvec3 col=vec3(0.); float d;\r\n\tvec4 mouse = iMouse/iResolution.y;\r\n\r\n\tif(!key_toggle(9.)) return col; // 'TAB' key : automatic stars field -> exit\r\n\t\r\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); // 1st mouse position silly\r\n\t\r\n\td = length(uv+vec2(.8,.5)-mouse.xy); // color cursor\r\n\tif (d<.02) col = vec3(0.,0.,1.);\r\n\t\r\n\tif(key_toggle(84.))  // 'T' key : tune RGB vs Temperature->Planck Spectrum\r\n\t{   // ---  Plank Spectrum mode ---\r\n\t\tfloat T = 40000.*iMouse.x/iResolution.x;\r\n\t\tstar_color = Planck(T);\r\n\t\t// star_luminosity = pow(T,4.);\r\n\t} \r\n\telse \r\n\t{   // --- RGB mode ---\r\n\t\tstar_color.gb = mouse.xy*star_luminosity; \r\n\t\tif(key_toggle(32.))  // SPACE key: red or blue dominant, tune the 2 others\r\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\r\n\t}\r\n\t\r\n\t// display the 3-filters analyzor at bottom\r\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\r\n\t\tif (uv.y<-.402) col=  vec3(\r\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., // red frame\r\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., // green frame\r\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  // blue frame\r\n\t\t)*star_color/star_luminosity;\r\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\r\n\t}\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\n// --- main -----------------------------------------\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec3 col;\r\n\tFragCoord = fragCoord;\r\n    R = iResolution.xy;\r\n    float t = iTime;\r\n    \r\n\t// --- tunings (color and display mode)\r\n\tcol = userInterface(); \r\n\t\r\n\t// --- camera\r\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\r\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\r\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\r\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\r\n\tfloat c=cos(a),s=sin(a);\r\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\r\n\t//mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\r\n\t\r\n\t// --- display stars \r\n\tif(key_toggle(9.)) // 'TAB' key\r\n\t\tcol += draw_star(vec2(.8,.5),1.);  // one single centred star\r\n\telse \r\n\t{\r\n\t\t// background\r\n\t\tvec2 uv = im*(fragCoord.xy/iResolution.y)+cam.xy;\r\n\t\tfloat bg = texture(iChannel1,uv).r;\r\n\t\tcol += .5*exp(-7.*bg);\r\n\r\n\t\t// do stars\r\n\t\tfor (int i=0; i<NB_STARS; i++) {\r\n\t\t\t// random position, intensity(=surf), temperature(->color)\r\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\r\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\r\n\t\t\tstar_color = Planck(40000.*exp(-3.*rnd(6*i+5)));\r\n\r\n\t\t\t// project to screen coords\r\n\t\t\tpos = pos-cam;\r\n\t\t\tpos.xy = m*pos.xy;\r\n#if PERS // perspective\r\n\t\t\tpos.xy /= pos.z;\r\n#endif\r\n\t\t\tif (pos.z>0.)\r\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I/(pos.z*pos.z));\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfragColor = vec4(col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// Full telescope PSF + BB emission spectrum: see https://www.shadertoy.com/view/XdsGWs\r\n\r\n#define N 4. // oversampling (use power of 2)\r\n\r\n#define rnd(U) ( 2.* fract( 4356.17 * sin( 1e4* dot(U, vec2(1,171.3)) )) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U0 )\r\n{\r\n    float z = 3.+iTime, r;\r\n    vec2 R = iResolution.xy, U, Ur, Us;\r\n    U0 =  (2.*U0-R)/R.y;\r\n\tU = U0 * z;\r\n    Ur = U+.2*rnd(floor(U)); // local star location\r\n    \r\n    O -= O;\r\n    \r\n    //if (floor(U)==floor(Ur))\r\n        for (float x=-1.; x<=1.; x+=1./N)\r\n            for (float y=-1.; y<=1.; y+=1./N)\r\n                \r\n                Us = Ur + vec2(x,y)*z/R.y,\r\n                r = length( fract(Us)-.5 + floor(Us)-floor(U) ),\r\n\t            O += U0.x<0. \r\n                   ? 6e-4/( pow(r/z,3.) * z*z)     // pix = clamp ( Emit/dist^2 * Bessel )\r\n                   : smoothstep(1.,.8, r*8.);      // pix = disk ( R/dist )\r\n                 //? 1./( pow(r,3.) * z*z)         \r\n                 //: smoothstep(1.,.8, r/1.5*z);   \r\n\r\n    O *= vec4(1,.5,.2,1) / pow(N+N+1.,2.);         // color and sum normalization       \r\n}","inputs":[],"outputs":[],"code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// Full telescope PSF + BB emission spectrum: see https://www.shadertoy.com/view/XdsGWs\r\n\r\n#define N 4. // oversampling (use power of 2)\r\n\r\n#define rnd(U) ( 2.* fract( 4356.17 * sin( 1e4* dot(U, vec2(1,171.3)) )) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U0 )\r\n{\r\n    float z = 3.+iTime, r;\r\n    vec2 R = iResolution.xy, U, Ur, Us;\r\n    U0 =  (2.*U0-R)/R.y;\r\n\tU = U0 * z;\r\n    Ur = U+.2*rnd(floor(U)); // local star location\r\n    \r\n    O -= O;\r\n    \r\n    //if (floor(U)==floor(Ur))\r\n        for (float x=-1.; x<=1.; x+=1./N)\r\n            for (float y=-1.; y<=1.; y+=1./N)\r\n                \r\n                Us = Ur + vec2(x,y)*z/R.y,\r\n                r = length( fract(Us)-.5 + floor(Us)-floor(U) ),\r\n\t            O += U0.x<0. \r\n                   ? 6e-4/( pow(r/z,3.) * z*z)     // pix = clamp ( Emit/dist^2 * Bessel )\r\n                   : smoothstep(1.,.8, r*8.);      // pix = disk ( R/dist )\r\n                 //? 1./( pow(r,3.) * z*z)         \r\n                 //: smoothstep(1.,.8, r/1.5*z);   \r\n\r\n    O *= vec4(1,.5,.2,1) / pow(N+N+1.,2.);         // color and sum normalization       \r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"stars - PSF + saturation ","id":"20379ba94c054b23827a05e5fcea5498","date":null,"viewed":0,"name":"stars - PSF + saturation ","description":"How to draw stars as in astronomic photos ?\r\nStars are only a fraction of pixel, but hugely brighter than the max pixel value, plus the lens PSF causes bloom. So the disk you see (L) is just a clamped bloom r~=1/d^2/3, not a projected sphere r~=1/d (R). \r\nhttps://www.shadertoy.com/view/Xty3zc","likes":0,"published":null,"tags":["star"," psf"," sensor"]},"ver":null,"info":{"Name":"stars - PSF + saturation ","id":"20379ba94c054b23827a05e5fcea5498","date":null,"viewed":0,"name":"stars - PSF + saturation ","description":"How to draw stars as in astronomic photos ?\r\nStars are only a fraction of pixel, but hugely brighter than the max pixel value, plus the lens PSF causes bloom. So the disk you see (L) is just a clamped bloom r~=1/d^2/3, not a projected sphere r~=1/d (R). \r\nhttps://www.shadertoy.com/view/Xty3zc","likes":0,"published":null,"tags":["star"," psf"," sensor"]},"renderpass":[{"Code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// Full telescope PSF + BB emission spectrum: see https://www.shadertoy.com/view/XdsGWs\r\n\r\n#define N 4. // oversampling (use power of 2)\r\n\r\n#define rnd(U) ( 2.* fract( 4356.17 * sin( 1e4* dot(U, vec2(1,171.3)) )) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U0 )\r\n{\r\n    float z = 3.+iTime, r;\r\n    vec2 R = iResolution.xy, U, Ur, Us;\r\n    U0 =  (2.*U0-R)/R.y;\r\n\tU = U0 * z;\r\n    Ur = U+.2*rnd(floor(U)); // local star location\r\n    \r\n    O -= O;\r\n    \r\n    //if (floor(U)==floor(Ur))\r\n        for (float x=-1.; x<=1.; x+=1./N)\r\n            for (float y=-1.; y<=1.; y+=1./N)\r\n                \r\n                Us = Ur + vec2(x,y)*z/R.y,\r\n                r = length( fract(Us)-.5 + floor(Us)-floor(U) ),\r\n\t            O += U0.x<0. \r\n                   ? 6e-4/( pow(r/z,3.) * z*z)     // pix = clamp ( Emit/dist^2 * Bessel )\r\n                   : smoothstep(1.,.8, r*8.);      // pix = disk ( R/dist )\r\n                 //? 1./( pow(r,3.) * z*z)         \r\n                 //: smoothstep(1.,.8, r/1.5*z);   \r\n\r\n    O *= vec4(1,.5,.2,1) / pow(N+N+1.,2.);         // color and sum normalization       \r\n}","inputs":[],"outputs":[],"code":"// clamp( I0/dist^2*Bessel(r) ) ; Bessel ~ 1/r^3 \r\n// ->   pix=1 => r = I0^1/3 / dist^2/3\r\n// graph: see https://www.desmos.com/calculator/6m7cebockb\r\n// Full telescope PSF + BB emission spectrum: see https://www.shadertoy.com/view/XdsGWs\r\n\r\n#define N 4. // oversampling (use power of 2)\r\n\r\n#define rnd(U) ( 2.* fract( 4356.17 * sin( 1e4* dot(U, vec2(1,171.3)) )) -1. )\r\n\r\nvoid mainImage( out vec4 O, vec2 U0 )\r\n{\r\n    float z = 3.+iTime, r;\r\n    vec2 R = iResolution.xy, U, Ur, Us;\r\n    U0 =  (2.*U0-R)/R.y;\r\n\tU = U0 * z;\r\n    Ur = U+.2*rnd(floor(U)); // local star location\r\n    \r\n    O -= O;\r\n    \r\n    //if (floor(U)==floor(Ur))\r\n        for (float x=-1.; x<=1.; x+=1./N)\r\n            for (float y=-1.; y<=1.; y+=1./N)\r\n                \r\n                Us = Ur + vec2(x,y)*z/R.y,\r\n                r = length( fract(Us)-.5 + floor(Us)-floor(U) ),\r\n\t            O += U0.x<0. \r\n                   ? 6e-4/( pow(r/z,3.) * z*z)     // pix = clamp ( Emit/dist^2 * Bessel )\r\n                   : smoothstep(1.,.8, r*8.);      // pix = disk ( R/dist )\r\n                 //? 1./( pow(r,3.) * z*z)         \r\n                 //: smoothstep(1.,.8, r/1.5*z);   \r\n\r\n    O *= vec4(1,.5,.2,1) / pow(N+N+1.,2.);         // color and sum normalization       \r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","inputs":[],"outputs":[],"code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Stone Circle ","id":"55b24a179a814cff844d96116c51ee7a","date":null,"viewed":0,"name":"Stone Circle ","description":"Inspired by a story generated using an artificial intelligence.","likes":0,"published":null,"tags":["raymarching"," modeling"," distancemap"," stonecircle"]},"ver":null,"info":{"Name":"Stone Circle ","id":"55b24a179a814cff844d96116c51ee7a","date":null,"viewed":0,"name":"Stone Circle ","description":"Inspired by a story generated using an artificial intelligence.","likes":0,"published":null,"tags":["raymarching"," modeling"," distancemap"," stonecircle"]},"renderpass":[{"Code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","inputs":[],"outputs":[],"code":"// Hash functions by Dave Hoskins\r\n// https://www.shadertoy.com/view/4djSRW\r\nvec3 hash32(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\r\n    p3 += dot(p3, p3.yxz+33.33);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\n\r\n#define TAU (2.0*3.1415926)\r\n\r\n/**\r\nYou help her onto her horse and the both of you gallop back\r\nto the ritual. The sun is setting, casting the entire forest\r\ninto darkness. The moon is out, and the forest glows with an\r\notherworldly light. Your horse runs fast, but Zal's seems to\r\nmove even faster. She reaches the stone circle first and\r\ndismounts, running towards the center. As she runs, she pushes\r\nthe altar with her, overturning it so that the pentagram is\r\nnow upside-down.\r\n\r\n-- Text generated by AI Dungeon\r\nhttps://play.aidungeon.io\r\n*/\r\n\r\nvec2 coo;\r\n\r\nfloat sdBox( vec3 p, vec3 r )\r\n{\r\n    vec3 q = abs(p) - r;\r\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\r\n}\r\n\r\nvec3 tri(vec3 p)\r\n{\r\n    return abs(fract(p)-0.5)-0.25;\r\n}\r\n\r\nfloat map( vec3 p, out vec3 q )\r\n{\r\n    // Terrain deformation\r\n    p.z += cos(p.y*0.1) - cos(p.x*0.162);\r\n    \r\n    // For each point, calculate the distance to one stone only\r\n    float nStones = 13.;\r\n    float circleRadius = 5.0;\r\n    float d = 100.;\r\n    float th = atan(p.y, p.x);\r\n    float id = round(th/TAU * nStones);\r\n    vec2 cs = cos(TAU*id/nStones + vec2(0.,-TAU*0.25));\r\n    q = p;\r\n    // Bring back point close to the positive x axis\r\n    q.xy *= mat2(cs.x,cs.y,-cs.y,cs.x);\r\n    \r\n    // Make sure the rays don't go too far into the next stone's section\r\n    float dSection = length(abs(q.xy) - circleRadius*cos(TAU/nStones+vec2(0.,-TAU/4.))) - 1.0;\r\n    dSection = max(dSection, p.z - 2.0);\r\n    d = min(d, dSection);\r\n    \r\n    // Random size of stone block\r\n    vec3 blockSize = 0.1+vec3(0.5,0.5,1.5)*hash32(cs);\r\n    q.x -= circleRadius;\r\n    q.z -= 0.5*blockSize.z;\r\n    // Tilt stone by 45 degrees at most\r\n    cs = abs(cs); cs.xy = cs.x < cs.y ? cs.xy : cs.yx;\r\n    q.xz *= mat2(cs.y,cs.x,-cs.x,cs.y);\r\n    float dBox = sdBox(q, blockSize);\r\n    // Deform surface a bit\r\n    vec3 q2 = p;\r\n    q2.yz *= mat2(0.6,0.8,-0.8,0.6);\r\n    dBox += 0.3*dot(tri(q2), vec3(0.666));\r\n    d = min(d, dBox);\r\n    \r\n    d = min(d, p.z);\r\n    \r\n    // I would like to add some stones popping off the ground,\r\n    // but doing it this way seems to introduce discontinuities.\r\n    // Use a Voronoi pattern ?\r\n    #if 1\r\n    q2 += hash32(floor(p.xy+0.5));\r\n    d = min(d, p.z + 0.15 - 0.1*sin(p.y*0.2)*cos(p.x*0.4) + 0.5*dot(tri(q2), vec3(0.666)));\r\n    #endif\r\n    q = p;\r\n    return d;\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    vec3 q; return map(p,q);\r\n}\r\n\r\n\r\nvec3 normal( vec3 p )\r\n{\r\n    vec2 e = 0.001 * vec2(1, -1);\r\n    return normalize(\r\n          e.xxx * map(p+e.xxx)\r\n        + e.xyy * map(p+e.xyy)\r\n        + e.yxy * map(p+e.yxy)\r\n        + e.yyx * map(p+e.yyx)\r\n    );\r\n}\r\n\r\n\r\n// Ambient Occlusion computation stolen from iq\r\n// https://www.shadertoy.com/view/Xds3zN\r\nfloat calcAO( in vec3 pos, in vec3 nor )\r\n{\r\n\tfloat occ = 0.0;\r\n    float sca = 1.0;\r\n    for( int i=0; i<5; i++ )\r\n    {\r\n        float h = 0.01 + 0.12*float(i)/4.0;\r\n        float d = map( pos + h*nor );\r\n        occ += (h-d)*sca;\r\n        sca *= 0.95;\r\n        if( occ>0.5 ) break;\r\n    }\r\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\r\n}\r\n\r\nfloat calcSoftShadows( vec3 ro, vec3 rd, float softness )\r\n{\r\n    float transm = 1.0;\r\n    float d, t=0.01 + texelFetch(iChannel0, ivec2(mod(coo,1024.)), 0).x*map(ro);\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        float w = softness * t;\r\n        d = map(ro+t*rd);\r\n        transm = min(transm, smoothstep(-w,w,d));\r\n        if(transm < 0.01 || t > 20.) break;\r\n        t += d+w;\r\n        //t += max(d, 0.02);\r\n    }\r\n    return transm;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    coo = fragCoord;\r\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\r\n\r\n    float th = 3.1415*0.5*(0.5+0.5*asin(0.9*sin(0.1*iTime)));\r\n    vec3 ro = vec3(-10.*cos(th),10.*sin(th),1.5);\r\n    vec3 camFwd = normalize(vec3(0) - ro);\r\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\r\n    vec3 camUp = cross(camRight, camFwd);\r\n    float fov = 0.5;\r\n    vec3 rd = normalize(camFwd + fov * (uv.x * camRight + uv.y * camUp));\r\n    \r\n    float d, t=0.;\r\n    for(int i=0; i<256; i++)\r\n    {\r\n        d = map(ro+t*rd);\r\n        if(d < 0.001 || t > 100.) break;\r\n        t += d*0.7;\r\n    }\r\n    vec3 p = ro+t*rd;\r\n    vec3 n = normal(p);\r\n    vec3 col;\r\n    \r\n    vec3 skyCol = vec3(1.0,1.5,2.);\r\n    vec3 sunDir = normalize(vec3(1,-1,0.1));\r\n    //vec3 sunCol = vec3(2.,1.5,1.0);\r\n    vec3 sunCol = vec3(1.0, 0.25, 0.1); // Sunset\r\n    if(t > 100.)\r\n    {\r\n        col = skyCol * 0.4;\r\n        vec3 rd_mod = normalize(vec3(rd.xy+sunDir.xy, rd.z*5.0));\r\n        col += sunCol * pow(clamp(dot(rd_mod, sunDir),0.,1.), 10.)*0.6;\r\n        col += 5.0*sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 10000.);\r\n    }\r\n    else\r\n    {\r\n        //col = 0.5+0.5*n;\r\n        col = vec3(0);\r\n        vec3 q; map(p,q);\r\n        vec3 grassCol = vec3(0.3,0.5,0.2);\r\n        vec3 stoneCol = vec3(0.2,0.21,0.22)*1.5;\r\n        vec3 surfCol = mix(grassCol, stoneCol, \r\n                           smoothstep(0.,0.01,q.z));\r\n        float ao = calcAO(p, n);\r\n        float shadow = calcSoftShadows(p+0.01*n, sunDir, 0.1);\r\n        \r\n        col += sunCol * shadow * surfCol * 8.;\r\n        col += ao * 0.1 * skyCol * (0.5 + 0.5*n.z);\r\n        vec3 fillDir = vec3(-sunDir.xy, 0.);\r\n        //vec3 fillCol = 0.05*sunCol*grassCol;\r\n        //col += fillCol * clamp(dot(n, fillDir), 0., 1.);\r\n        \r\n        float fog = 1.-exp(-0.02*max(t-10.,0.));\r\n        col = mix(col, skyCol*0.4, fog);\r\n    }\r\n    \r\n    col += sunCol * pow(clamp(dot(rd, sunDir),0.,1.), 8.)*1.5;\r\n    \r\n    col = mix(col, 1.-4./27./(col*col), step(2./3.,col));\r\n    col = pow(col, vec3(1./2.2));\r\n    fragColor = vec4(col, 1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"#define ITR 170\r\n#define FAR 80.\r\n#define PRECISION 0.008\r\n#define BASE_STRIDE .75\r\n#define FAR_STRIDE 0.3\r\n#define MIN_STEP .1\r\nconst float logvl = 1.+MIN_STEP;\r\n\r\nconst vec3 SunDir = vec3(1.0,1.0,1.0);\r\nconst vec3 SunColor = vec3(1.64,1.27,0.99)*1.1;\r\nconst vec3 SkyColor = vec3(0.55294,0.78431,0.94902);\r\n\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat _terrain(vec2 p,vec2 offset,float octave, float h,float lacunarity){\r\n    float value =.0;\r\n    for(float i=0.0;i<octave;i++){\r\n        value += value_noise(p-offset)*pow(lacunarity,-h*i);\r\n        p *= lacunarity;\r\n    }\r\n    return value;\r\n}\r\n\r\nfloat H = 2.6;\r\nfloat Lacunarity = 2.0;\r\n\r\nfloat terrainL(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat terrain(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 q = abs(p) - b;\r\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\nfloat map( in vec3 p)\r\n{  \r\n    float d =  0.0;\r\n    if(p.x<-1.0 || p.x>1.0 || p.z<-1.0 || p.z>1.0){\r\n        return 0.01;\r\n        //return sdBox(p,vec3(1.0,.01,1.0))*sign(p.y-0.01);\r\n    }\r\n    \r\n    p.xz *= 2.0;\r\n    float h = terrain(p.x,p.z);\r\n    d = p.y - h;\r\n     //d = abs(d);\r\n    return d;\r\n}\r\n\r\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\r\n{\r\n    float mid = 0.;\r\n    float sgn = sign(map(rd*near+ro));\r\n    for (int i = 0; i < 6; i++)\r\n    { \r\n        mid = (near + far)*.5;\r\n        float d = map(rd*mid+ro);\r\n        if (abs(d) < PRECISION)break;\r\n        if(d*sgn < 0. ) far = mid; else  near = mid;\r\n    }\r\n    return (near+far) * .5;\r\n}\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd)\r\n{\r\n    float t = 0.;\r\n    const int itr = ITR;\r\n    float d = map(rd*t+ro);\r\n    #ifdef OPTIMIZE\r\n    bool sgn = (d > 0.0) ? true : false;\r\n    #else\r\n    float sgn = sign(d);\r\n    #endif\r\n    float told = t;\r\n    bool doBisect = false;\r\n    \r\n    for (int i=0;i<=itr;i++)\r\n    {\r\n        \r\n        if (abs(d) < PRECISION || t > FAR) break;\r\n        else if (i == itr)t = 1000.;\r\n            \r\n        //if we crossed but didn't detect, use bisection method\r\n        #ifdef OPTIMIZE\r\n        if ((d > 0.0) != sgn)\r\n        #else\r\n       \tif (sign(d) != sgn)\r\n        #endif\r\n        {\r\n            doBisect= true;\r\n            break;\r\n        }\r\n        \r\n        told = t;\r\n        #if 1\r\n        if (d > 1.)t += d*FAR_STRIDE;\r\n        else t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #else\r\n        t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #endif\r\n        d = map(rd*t+ro);\r\n    }\r\n    \r\n    if (doBisect)t = bisect(ro,rd,told,t);\r\n    \r\n    return t;\r\n}\r\n\r\nvec3 normal(in vec3 pos, in float t)\r\n{  \r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n    return normalize( vec3(\r\n           map(pos+eps.xyy) - map(pos-eps.xyy),\r\n           map(pos+eps.yxy) - map(pos-eps.yxy),\r\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\r\n}\r\n\r\nvec3 getSkyColor(vec3 ro, vec3 rd)\r\n{\r\n    vec3 blueish = vec3(0.55294,0.78431,0.94902);\r\n    return blueish;\r\n}\r\n\r\nvec3 getTerrainMaterial(vec3 p, vec3 n)\r\n{\r\n    vec3 tx =  vec3(0.2);//tex3D(iChannel1, p/8., n ); // Texture value. Pinkish limestone.\r\n    return tx;\r\n}\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t       \r\n     float camRadius = 3.0;  \r\n    float rota = 0.0;\r\n    float vertical = 1.0;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\trota = iMouse.x/iResolution.x;\r\n        vertical = iMouse.y/iResolution.y - 0.5;\r\n    }\r\n    float theta = rota*3.1415726*2.0;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,vertical*camRadius*2.0,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.0);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, rayo;\r\n    rayDir = computePixelRay( p, rayo );\r\n    \r\n    float rz = intersect(rayo,rayDir);\r\n    vec3 col = vec3(0.0);\r\n    vec3 sky = getSkyColor(rayo, rayDir);\r\n    col += sky;\r\n    \r\n    //shadng\r\n    if (rz < FAR)\r\n    {\r\n        vec3 pos = rayo+rayDir*rz;\r\n        vec3 nor = normal(pos, rz);\r\n       \r\n        float sun = clamp(dot(nor,normalize(SunDir)),0.0,1.0);\r\n                               \r\n        vec3 light = sun*SunColor;\r\n        \r\n        vec3 m = getTerrainMaterial(pos,nor);\r\n        col = m*(light+0.05);\r\n    }\r\n   \r\n    col = pow(col,vec3(1.0/2.2));\r\n\tfragColor = vec4( col, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"#define ITR 170\r\n#define FAR 80.\r\n#define PRECISION 0.008\r\n#define BASE_STRIDE .75\r\n#define FAR_STRIDE 0.3\r\n#define MIN_STEP .1\r\nconst float logvl = 1.+MIN_STEP;\r\n\r\nconst vec3 SunDir = vec3(1.0,1.0,1.0);\r\nconst vec3 SunColor = vec3(1.64,1.27,0.99)*1.1;\r\nconst vec3 SkyColor = vec3(0.55294,0.78431,0.94902);\r\n\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat _terrain(vec2 p,vec2 offset,float octave, float h,float lacunarity){\r\n    float value =.0;\r\n    for(float i=0.0;i<octave;i++){\r\n        value += value_noise(p-offset)*pow(lacunarity,-h*i);\r\n        p *= lacunarity;\r\n    }\r\n    return value;\r\n}\r\n\r\nfloat H = 2.6;\r\nfloat Lacunarity = 2.0;\r\n\r\nfloat terrainL(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat terrain(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 q = abs(p) - b;\r\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\nfloat map( in vec3 p)\r\n{  \r\n    float d =  0.0;\r\n    if(p.x<-1.0 || p.x>1.0 || p.z<-1.0 || p.z>1.0){\r\n        return 0.01;\r\n        //return sdBox(p,vec3(1.0,.01,1.0))*sign(p.y-0.01);\r\n    }\r\n    \r\n    p.xz *= 2.0;\r\n    float h = terrain(p.x,p.z);\r\n    d = p.y - h;\r\n     //d = abs(d);\r\n    return d;\r\n}\r\n\r\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\r\n{\r\n    float mid = 0.;\r\n    float sgn = sign(map(rd*near+ro));\r\n    for (int i = 0; i < 6; i++)\r\n    { \r\n        mid = (near + far)*.5;\r\n        float d = map(rd*mid+ro);\r\n        if (abs(d) < PRECISION)break;\r\n        if(d*sgn < 0. ) far = mid; else  near = mid;\r\n    }\r\n    return (near+far) * .5;\r\n}\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd)\r\n{\r\n    float t = 0.;\r\n    const int itr = ITR;\r\n    float d = map(rd*t+ro);\r\n    #ifdef OPTIMIZE\r\n    bool sgn = (d > 0.0) ? true : false;\r\n    #else\r\n    float sgn = sign(d);\r\n    #endif\r\n    float told = t;\r\n    bool doBisect = false;\r\n    \r\n    for (int i=0;i<=itr;i++)\r\n    {\r\n        \r\n        if (abs(d) < PRECISION || t > FAR) break;\r\n        else if (i == itr)t = 1000.;\r\n            \r\n        //if we crossed but didn't detect, use bisection method\r\n        #ifdef OPTIMIZE\r\n        if ((d > 0.0) != sgn)\r\n        #else\r\n       \tif (sign(d) != sgn)\r\n        #endif\r\n        {\r\n            doBisect= true;\r\n            break;\r\n        }\r\n        \r\n        told = t;\r\n        #if 1\r\n        if (d > 1.)t += d*FAR_STRIDE;\r\n        else t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #else\r\n        t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #endif\r\n        d = map(rd*t+ro);\r\n    }\r\n    \r\n    if (doBisect)t = bisect(ro,rd,told,t);\r\n    \r\n    return t;\r\n}\r\n\r\nvec3 normal(in vec3 pos, in float t)\r\n{  \r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n    return normalize( vec3(\r\n           map(pos+eps.xyy) - map(pos-eps.xyy),\r\n           map(pos+eps.yxy) - map(pos-eps.yxy),\r\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\r\n}\r\n\r\nvec3 getSkyColor(vec3 ro, vec3 rd)\r\n{\r\n    vec3 blueish = vec3(0.55294,0.78431,0.94902);\r\n    return blueish;\r\n}\r\n\r\nvec3 getTerrainMaterial(vec3 p, vec3 n)\r\n{\r\n    vec3 tx =  vec3(0.2);//tex3D(iChannel1, p/8., n ); // Texture value. Pinkish limestone.\r\n    return tx;\r\n}\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t       \r\n     float camRadius = 3.0;  \r\n    float rota = 0.0;\r\n    float vertical = 1.0;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\trota = iMouse.x/iResolution.x;\r\n        vertical = iMouse.y/iResolution.y - 0.5;\r\n    }\r\n    float theta = rota*3.1415726*2.0;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,vertical*camRadius*2.0,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.0);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, rayo;\r\n    rayDir = computePixelRay( p, rayo );\r\n    \r\n    float rz = intersect(rayo,rayDir);\r\n    vec3 col = vec3(0.0);\r\n    vec3 sky = getSkyColor(rayo, rayDir);\r\n    col += sky;\r\n    \r\n    //shadng\r\n    if (rz < FAR)\r\n    {\r\n        vec3 pos = rayo+rayDir*rz;\r\n        vec3 nor = normal(pos, rz);\r\n       \r\n        float sun = clamp(dot(nor,normalize(SunDir)),0.0,1.0);\r\n                               \r\n        vec3 light = sun*SunColor;\r\n        \r\n        vec3 m = getTerrainMaterial(pos,nor);\r\n        col = m*(light+0.05);\r\n    }\r\n   \r\n    col = pow(col,vec3(1.0/2.2));\r\n\tfragColor = vec4( col, 1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Terrain Demo1","id":"44faac1b5bb847ddb4260a5418058413","date":null,"viewed":0,"name":"Terrain Demo1","description":"Terrain Demo1","likes":0,"published":null,"tags":["terrain"," raymarch"," fbm"]},"ver":null,"info":{"Name":"Terrain Demo1","id":"44faac1b5bb847ddb4260a5418058413","date":null,"viewed":0,"name":"Terrain Demo1","description":"Terrain Demo1","likes":0,"published":null,"tags":["terrain"," raymarch"," fbm"]},"renderpass":[{"Code":"#define ITR 170\r\n#define FAR 80.\r\n#define PRECISION 0.008\r\n#define BASE_STRIDE .75\r\n#define FAR_STRIDE 0.3\r\n#define MIN_STEP .1\r\nconst float logvl = 1.+MIN_STEP;\r\n\r\nconst vec3 SunDir = vec3(1.0,1.0,1.0);\r\nconst vec3 SunColor = vec3(1.64,1.27,0.99)*1.1;\r\nconst vec3 SkyColor = vec3(0.55294,0.78431,0.94902);\r\n\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat _terrain(vec2 p,vec2 offset,float octave, float h,float lacunarity){\r\n    float value =.0;\r\n    for(float i=0.0;i<octave;i++){\r\n        value += value_noise(p-offset)*pow(lacunarity,-h*i);\r\n        p *= lacunarity;\r\n    }\r\n    return value;\r\n}\r\n\r\nfloat H = 2.6;\r\nfloat Lacunarity = 2.0;\r\n\r\nfloat terrainL(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat terrain(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 q = abs(p) - b;\r\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\nfloat map( in vec3 p)\r\n{  \r\n    float d =  0.0;\r\n    if(p.x<-1.0 || p.x>1.0 || p.z<-1.0 || p.z>1.0){\r\n        return 0.01;\r\n        //return sdBox(p,vec3(1.0,.01,1.0))*sign(p.y-0.01);\r\n    }\r\n    \r\n    p.xz *= 2.0;\r\n    float h = terrain(p.x,p.z);\r\n    d = p.y - h;\r\n     //d = abs(d);\r\n    return d;\r\n}\r\n\r\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\r\n{\r\n    float mid = 0.;\r\n    float sgn = sign(map(rd*near+ro));\r\n    for (int i = 0; i < 6; i++)\r\n    { \r\n        mid = (near + far)*.5;\r\n        float d = map(rd*mid+ro);\r\n        if (abs(d) < PRECISION)break;\r\n        if(d*sgn < 0. ) far = mid; else  near = mid;\r\n    }\r\n    return (near+far) * .5;\r\n}\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd)\r\n{\r\n    float t = 0.;\r\n    const int itr = ITR;\r\n    float d = map(rd*t+ro);\r\n    #ifdef OPTIMIZE\r\n    bool sgn = (d > 0.0) ? true : false;\r\n    #else\r\n    float sgn = sign(d);\r\n    #endif\r\n    float told = t;\r\n    bool doBisect = false;\r\n    \r\n    for (int i=0;i<=itr;i++)\r\n    {\r\n        \r\n        if (abs(d) < PRECISION || t > FAR) break;\r\n        else if (i == itr)t = 1000.;\r\n            \r\n        //if we crossed but didn't detect, use bisection method\r\n        #ifdef OPTIMIZE\r\n        if ((d > 0.0) != sgn)\r\n        #else\r\n       \tif (sign(d) != sgn)\r\n        #endif\r\n        {\r\n            doBisect= true;\r\n            break;\r\n        }\r\n        \r\n        told = t;\r\n        #if 1\r\n        if (d > 1.)t += d*FAR_STRIDE;\r\n        else t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #else\r\n        t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #endif\r\n        d = map(rd*t+ro);\r\n    }\r\n    \r\n    if (doBisect)t = bisect(ro,rd,told,t);\r\n    \r\n    return t;\r\n}\r\n\r\nvec3 normal(in vec3 pos, in float t)\r\n{  \r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n    return normalize( vec3(\r\n           map(pos+eps.xyy) - map(pos-eps.xyy),\r\n           map(pos+eps.yxy) - map(pos-eps.yxy),\r\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\r\n}\r\n\r\nvec3 getSkyColor(vec3 ro, vec3 rd)\r\n{\r\n    vec3 blueish = vec3(0.55294,0.78431,0.94902);\r\n    return blueish;\r\n}\r\n\r\nvec3 getTerrainMaterial(vec3 p, vec3 n)\r\n{\r\n    vec3 tx =  vec3(0.2);//tex3D(iChannel1, p/8., n ); // Texture value. Pinkish limestone.\r\n    return tx;\r\n}\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t       \r\n     float camRadius = 3.0;  \r\n    float rota = 0.0;\r\n    float vertical = 1.0;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\trota = iMouse.x/iResolution.x;\r\n        vertical = iMouse.y/iResolution.y - 0.5;\r\n    }\r\n    float theta = rota*3.1415726*2.0;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,vertical*camRadius*2.0,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.0);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, rayo;\r\n    rayDir = computePixelRay( p, rayo );\r\n    \r\n    float rz = intersect(rayo,rayDir);\r\n    vec3 col = vec3(0.0);\r\n    vec3 sky = getSkyColor(rayo, rayDir);\r\n    col += sky;\r\n    \r\n    //shadng\r\n    if (rz < FAR)\r\n    {\r\n        vec3 pos = rayo+rayDir*rz;\r\n        vec3 nor = normal(pos, rz);\r\n       \r\n        float sun = clamp(dot(nor,normalize(SunDir)),0.0,1.0);\r\n                               \r\n        vec3 light = sun*SunColor;\r\n        \r\n        vec3 m = getTerrainMaterial(pos,nor);\r\n        col = m*(light+0.05);\r\n    }\r\n   \r\n    col = pow(col,vec3(1.0/2.2));\r\n\tfragColor = vec4( col, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"#define ITR 170\r\n#define FAR 80.\r\n#define PRECISION 0.008\r\n#define BASE_STRIDE .75\r\n#define FAR_STRIDE 0.3\r\n#define MIN_STEP .1\r\nconst float logvl = 1.+MIN_STEP;\r\n\r\nconst vec3 SunDir = vec3(1.0,1.0,1.0);\r\nconst vec3 SunColor = vec3(1.64,1.27,0.99)*1.1;\r\nconst vec3 SkyColor = vec3(0.55294,0.78431,0.94902);\r\n\r\n\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nfloat _terrain(vec2 p,vec2 offset,float octave, float h,float lacunarity){\r\n    float value =.0;\r\n    for(float i=0.0;i<octave;i++){\r\n        value += value_noise(p-offset)*pow(lacunarity,-h*i);\r\n        p *= lacunarity;\r\n    }\r\n    return value;\r\n}\r\n\r\nfloat H = 2.6;\r\nfloat Lacunarity = 2.0;\r\n\r\nfloat terrainL(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat terrain(float x,float z)\r\n{\r\n   return _terrain(vec2(x,z),vec2(0.5,0.5),5.0,H,Lacunarity);\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n  vec3 q = abs(p) - b;\r\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\nfloat map( in vec3 p)\r\n{  \r\n    float d =  0.0;\r\n    if(p.x<-1.0 || p.x>1.0 || p.z<-1.0 || p.z>1.0){\r\n        return 0.01;\r\n        //return sdBox(p,vec3(1.0,.01,1.0))*sign(p.y-0.01);\r\n    }\r\n    \r\n    p.xz *= 2.0;\r\n    float h = terrain(p.x,p.z);\r\n    d = p.y - h;\r\n     //d = abs(d);\r\n    return d;\r\n}\r\n\r\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\r\n{\r\n    float mid = 0.;\r\n    float sgn = sign(map(rd*near+ro));\r\n    for (int i = 0; i < 6; i++)\r\n    { \r\n        mid = (near + far)*.5;\r\n        float d = map(rd*mid+ro);\r\n        if (abs(d) < PRECISION)break;\r\n        if(d*sgn < 0. ) far = mid; else  near = mid;\r\n    }\r\n    return (near+far) * .5;\r\n}\r\n\r\nfloat intersect( in vec3 ro, in vec3 rd)\r\n{\r\n    float t = 0.;\r\n    const int itr = ITR;\r\n    float d = map(rd*t+ro);\r\n    #ifdef OPTIMIZE\r\n    bool sgn = (d > 0.0) ? true : false;\r\n    #else\r\n    float sgn = sign(d);\r\n    #endif\r\n    float told = t;\r\n    bool doBisect = false;\r\n    \r\n    for (int i=0;i<=itr;i++)\r\n    {\r\n        \r\n        if (abs(d) < PRECISION || t > FAR) break;\r\n        else if (i == itr)t = 1000.;\r\n            \r\n        //if we crossed but didn't detect, use bisection method\r\n        #ifdef OPTIMIZE\r\n        if ((d > 0.0) != sgn)\r\n        #else\r\n       \tif (sign(d) != sgn)\r\n        #endif\r\n        {\r\n            doBisect= true;\r\n            break;\r\n        }\r\n        \r\n        told = t;\r\n        #if 1\r\n        if (d > 1.)t += d*FAR_STRIDE;\r\n        else t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #else\r\n        t += log(abs(d)+logvl)*BASE_STRIDE;\r\n        #endif\r\n        d = map(rd*t+ro);\r\n    }\r\n    \r\n    if (doBisect)t = bisect(ro,rd,told,t);\r\n    \r\n    return t;\r\n}\r\n\r\nvec3 normal(in vec3 pos, in float t)\r\n{  \r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n    return normalize( vec3(\r\n           map(pos+eps.xyy) - map(pos-eps.xyy),\r\n           map(pos+eps.yxy) - map(pos-eps.yxy),\r\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\r\n}\r\n\r\nvec3 getSkyColor(vec3 ro, vec3 rd)\r\n{\r\n    vec3 blueish = vec3(0.55294,0.78431,0.94902);\r\n    return blueish;\r\n}\r\n\r\nvec3 getTerrainMaterial(vec3 p, vec3 n)\r\n{\r\n    vec3 tx =  vec3(0.2);//tex3D(iChannel1, p/8., n ); // Texture value. Pinkish limestone.\r\n    return tx;\r\n}\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t       \r\n     float camRadius = 3.0;  \r\n    float rota = 0.0;\r\n    float vertical = 1.0;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\trota = iMouse.x/iResolution.x;\r\n        vertical = iMouse.y/iResolution.y - 0.5;\r\n    }\r\n    float theta = rota*3.1415726*2.0;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,vertical*camRadius*2.0,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.0);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, rayo;\r\n    rayDir = computePixelRay( p, rayo );\r\n    \r\n    float rz = intersect(rayo,rayDir);\r\n    vec3 col = vec3(0.0);\r\n    vec3 sky = getSkyColor(rayo, rayDir);\r\n    col += sky;\r\n    \r\n    //shadng\r\n    if (rz < FAR)\r\n    {\r\n        vec3 pos = rayo+rayDir*rz;\r\n        vec3 nor = normal(pos, rz);\r\n       \r\n        float sun = clamp(dot(nor,normalize(SunDir)),0.0,1.0);\r\n                               \r\n        vec3 light = sun*SunColor;\r\n        \r\n        vec3 m = getTerrainMaterial(pos,nor);\r\n        col = m*(light+0.05);\r\n    }\r\n   \r\n    col = pow(col,vec3(1.0/2.2));\r\n\tfragColor = vec4( col, 1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\r\n// https://creativecommons.org/licenses/by-sa/3.0/\r\n//\r\n//\r\n// This is the implementation for my article \"improved texture interpolation\"\r\n// \r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\n//\r\n// It shows how to get some smooth texture interpolation without resorting to the regular\r\n// bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \r\n// 4 the hardware uses for bilinear interpolation.\r\n//\r\n// With this techinique here, you van get smooth interpolation while the hardware still \r\n// uses only 4 texels, by tricking the hardware. The idea is to get the fractional part\r\n// of the texel coordinates and apply a smooth curve to it such that the derivatives are\r\n// zero at the extremes. The regular cubic or quintic smoothstep functions are just\r\n// perfect for this task.\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 p)\r\n{\r\n   return vec3(value_noise(p),value_noise(p+123.12),value_noise(p+456.43));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = fragCoord.xy / iResolution.x;\r\n    vec2 uv = p*0.1;\t\r\n\t\r\n    //---------------------------------------------\t\r\n\t// regular texture map filtering\r\n    //---------------------------------------------\t\r\n\tvec3 colA = noise23(uv*99.);// texture( iChannel0, uv ).xyz;\r\n\r\n    //---------------------------------------------\t\r\n\t// my own filtering \r\n    //---------------------------------------------\t\r\n\tfloat textureResolution = 64.0;\r\n\tuv = uv*textureResolution + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\r\n\tuv = (uv - 0.5)/textureResolution;\r\n\tvec3 colB = noise23(uv*99.);//texture( iChannel0, uv ).xyz;\r\n\t\r\n    //---------------------------------------------\t\r\n    // mix between the two colors\r\n    //---------------------------------------------\t\r\n\tfloat f = sin(3.14*p.x + 0.7*iTime);\r\n\tvec3 col = mix( colA, colB, smoothstep( -0.1, 0.1, f ) );\r\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\r\n// https://creativecommons.org/licenses/by-sa/3.0/\r\n//\r\n//\r\n// This is the implementation for my article \"improved texture interpolation\"\r\n// \r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\n//\r\n// It shows how to get some smooth texture interpolation without resorting to the regular\r\n// bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \r\n// 4 the hardware uses for bilinear interpolation.\r\n//\r\n// With this techinique here, you van get smooth interpolation while the hardware still \r\n// uses only 4 texels, by tricking the hardware. The idea is to get the fractional part\r\n// of the texel coordinates and apply a smooth curve to it such that the derivatives are\r\n// zero at the extremes. The regular cubic or quintic smoothstep functions are just\r\n// perfect for this task.\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 p)\r\n{\r\n   return vec3(value_noise(p),value_noise(p+123.12),value_noise(p+456.43));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = fragCoord.xy / iResolution.x;\r\n    vec2 uv = p*0.1;\t\r\n\t\r\n    //---------------------------------------------\t\r\n\t// regular texture map filtering\r\n    //---------------------------------------------\t\r\n\tvec3 colA = noise23(uv*99.);// texture( iChannel0, uv ).xyz;\r\n\r\n    //---------------------------------------------\t\r\n\t// my own filtering \r\n    //---------------------------------------------\t\r\n\tfloat textureResolution = 64.0;\r\n\tuv = uv*textureResolution + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\r\n\tuv = (uv - 0.5)/textureResolution;\r\n\tvec3 colB = noise23(uv*99.);//texture( iChannel0, uv ).xyz;\r\n\t\r\n    //---------------------------------------------\t\r\n    // mix between the two colors\r\n    //---------------------------------------------\t\r\n\tfloat f = sin(3.14*p.x + 0.7*iTime);\r\n\tvec3 col = mix( colA, colB, smoothstep( -0.1, 0.1, f ) );\r\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Texture - Better Filtering","id":"7ef99c906e614011b6ee064e8848183c","date":null,"viewed":0,"name":"Texture - Better Filtering","description":"This shader shows how to avoid the ugly artifacts of bilinear texture filtering. You can find more information here: http://www.iquilezles.org/www/articles/texture/texture.htm\nhttps://www.shadertoy.com/view/XsfGDn","likes":0,"published":null,"tags":["2d"," texture"," filtering"]},"ver":null,"info":{"Name":"Texture - Better Filtering","id":"7ef99c906e614011b6ee064e8848183c","date":null,"viewed":0,"name":"Texture - Better Filtering","description":"This shader shows how to avoid the ugly artifacts of bilinear texture filtering. You can find more information here: http://www.iquilezles.org/www/articles/texture/texture.htm\nhttps://www.shadertoy.com/view/XsfGDn","likes":0,"published":null,"tags":["2d"," texture"," filtering"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\r\n// https://creativecommons.org/licenses/by-sa/3.0/\r\n//\r\n//\r\n// This is the implementation for my article \"improved texture interpolation\"\r\n// \r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\n//\r\n// It shows how to get some smooth texture interpolation without resorting to the regular\r\n// bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \r\n// 4 the hardware uses for bilinear interpolation.\r\n//\r\n// With this techinique here, you van get smooth interpolation while the hardware still \r\n// uses only 4 texels, by tricking the hardware. The idea is to get the fractional part\r\n// of the texel coordinates and apply a smooth curve to it such that the derivatives are\r\n// zero at the extremes. The regular cubic or quintic smoothstep functions are just\r\n// perfect for this task.\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 p)\r\n{\r\n   return vec3(value_noise(p),value_noise(p+123.12),value_noise(p+456.43));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = fragCoord.xy / iResolution.x;\r\n    vec2 uv = p*0.1;\t\r\n\t\r\n    //---------------------------------------------\t\r\n\t// regular texture map filtering\r\n    //---------------------------------------------\t\r\n\tvec3 colA = noise23(uv*99.);// texture( iChannel0, uv ).xyz;\r\n\r\n    //---------------------------------------------\t\r\n\t// my own filtering \r\n    //---------------------------------------------\t\r\n\tfloat textureResolution = 64.0;\r\n\tuv = uv*textureResolution + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\r\n\tuv = (uv - 0.5)/textureResolution;\r\n\tvec3 colB = noise23(uv*99.);//texture( iChannel0, uv ).xyz;\r\n\t\r\n    //---------------------------------------------\t\r\n    // mix between the two colors\r\n    //---------------------------------------------\t\r\n\tfloat f = sin(3.14*p.x + 0.7*iTime);\r\n\tvec3 col = mix( colA, colB, smoothstep( -0.1, 0.1, f ) );\r\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-ShareAlike 3.0 Unported\r\n// https://creativecommons.org/licenses/by-sa/3.0/\r\n//\r\n//\r\n// This is the implementation for my article \"improved texture interpolation\"\r\n// \r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\n//\r\n// It shows how to get some smooth texture interpolation without resorting to the regular\r\n// bicubic filtering, which is pretty expensive because it needs 9 texels instead of the \r\n// 4 the hardware uses for bilinear interpolation.\r\n//\r\n// With this techinique here, you van get smooth interpolation while the hardware still \r\n// uses only 4 texels, by tricking the hardware. The idea is to get the fractional part\r\n// of the texel coordinates and apply a smooth curve to it such that the derivatives are\r\n// zero at the extremes. The regular cubic or quintic smoothstep functions are just\r\n// perfect for this task.\r\n//\u4F5C\u4E3A\u57FA\u7840\u7684\u968F\u673A\u51FD\u6570\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n//\u57FA\u4E8E\u6676\u683C\u7684\u503C\u566A\u58F0\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 p)\r\n{\r\n   return vec3(value_noise(p),value_noise(p+123.12),value_noise(p+456.43));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = fragCoord.xy / iResolution.x;\r\n    vec2 uv = p*0.1;\t\r\n\t\r\n    //---------------------------------------------\t\r\n\t// regular texture map filtering\r\n    //---------------------------------------------\t\r\n\tvec3 colA = noise23(uv*99.);// texture( iChannel0, uv ).xyz;\r\n\r\n    //---------------------------------------------\t\r\n\t// my own filtering \r\n    //---------------------------------------------\t\r\n\tfloat textureResolution = 64.0;\r\n\tuv = uv*textureResolution + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv); // fuv*fuv*fuv*(fuv*(fuv*6.0-15.0)+10.0);;\r\n\tuv = (uv - 0.5)/textureResolution;\r\n\tvec3 colB = noise23(uv*99.);//texture( iChannel0, uv ).xyz;\r\n\t\r\n    //---------------------------------------------\t\r\n    // mix between the two colors\r\n    //---------------------------------------------\t\r\n\tfloat f = sin(3.14*p.x + 0.7*iTime);\r\n\tvec3 col = mix( colA, colB, smoothstep( -0.1, 0.1, f ) );\r\n\tcol *= smoothstep( 0.0, 0.01, abs(f-0.0) );\r\n\t\r\n    fragColor = vec4( col, 1.0 );\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Gardner textured ellipsoids - https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf + bib\r\n\r\nvec3 R = vec3(2.,4.,2.);              // ellipsoid radius\r\nvec3 L = normalize(vec3(-.4,0.,1.));  // light source\r\n#define AMBIENT .4\t\t\t\t\t  // ambient luminosity\r\n\r\n#define ANIM true\r\n#define PI 3.1415927\r\nvec4 FragColor;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )    // in [0,1]\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // in [0,1]\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )    // in [0,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\nfloat snoise( in vec3 x ) // in [-1,1]\r\n{ return 2.*noise(x)-1.; }\r\n\r\nfloat sfbm( vec3 p )      // in [-1,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\r\n    f += 0.2500*snoise( p ); p = m*p*2.03;\r\n    f += 0.1250*snoise( p ); p = m*p*2.01;\r\n    f += 0.0625*snoise( p );\r\n    return f;\r\n}\r\n\r\n\r\n\r\n// --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\r\n\r\n\r\nmat3 lookat(vec3 O, vec3 T, float d) {\r\n\tmat3 M;\r\n\tvec3 OT = normalize(T-O);\r\n\tM[0] = OT;\r\n\tM[2] = normalize(vec3(0.,0.,1.)-OT.z*OT)/d;\r\n\tM[1] = cross(M[2],OT);\r\n\treturn M;\r\n}\r\n\r\n// --- ray -  ellipsoid intersection\r\n// if true, return P,N and thickness l\r\n\r\nbool intersect_ellipsoid(vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\r\n\tvec3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere \r\n\t\t// P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\r\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\r\n\tfloat d = OD*OD - (OO-1.)*DD;\r\n\t\r\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\r\n\t// ray intersects the ellipsoid (and not in our back)\r\n\t// note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\r\n\t\t\r\n\tfloat t = (-OD-sqrt(d))/DD;\r\n\t// return intersection point, normal and thickness\r\n\tP = O+t*D;\r\n\tN=normalize(P/(R*R));\r\n\tl = 2.*sqrt(d)/DD;\r\n\r\n\treturn true;\r\n}\r\n\r\n// --- Gardner textured ellipsoids (sort of)\r\n\r\n// 's' index corresponds to Garner faked silhouette\r\n// 'i' index corresponds to interior term faked by mid-surface\r\n\r\nfloat ks,ps, ki,pi;  // smoothness/thichness parameters\r\n\r\nfloat l;\r\nvoid draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {\r\n\tvec3 D = normalize(M*vec3(1.,pos));\t\t// ray\r\n\t\r\n\tvec3 P,N; \r\n\tif (! intersect_ellipsoid(O,D, P,N,l)) return;\r\n\t\r\n\tvec3 Pm = P+.5*l*D,                \t\t// .5: deepest point inside cloud. \r\n\t\t Nm = normalize(Pm/(R*R)),     \t\t// it's normal\r\n\t     Nn = normalize(P/R);\r\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t// ratio of light-facing (for lighting)\r\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t// ratio of camera-facing (for silhouette)\r\n\r\n\r\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\r\n\tfloat A, l0 = 3.;\r\n\t//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette\r\n\tl = clamp(l-6.*ni,0.,1e10);\r\n\tfloat As = pow(ks*nd, ps), \t\t\t \t // silhouette\r\n\t\t  Ai = 1.-pow(.7,pi*l);              // interior\r\n\r\n\r\n\tAs =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);\r\n\tif (mode==2) \r\n\t\tA = 1.- (1.-As)*(1.-Ai);  \t\t\t// mul Ti and Ts\r\n\telse\r\n\t\tA = (mode==0) ? Ai : As; \r\n\tA = clamp(A,0.,1.); \r\n\tnl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));\r\n\r\n\t#if 0 // noise bump\r\n\tN = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); \r\n\tnl = clamp( dot(N,L),0.,1.);\r\n#endif\r\n\t\r\n\tvec4 col = vec4(mix(nl,1.,AMBIENT));\r\n\tFragColor = mix(FragColor,col,A);\r\n}\r\n\r\n// === main =============================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.85,.5));\r\n\tvec2 mouse = 2.*(iMouse.xy / iResolution.xy - vec2(.85,.5));\r\n\tfloat z = .2;\r\n\tks = 1.+mouse.x, ps = mouse.y*8., ki, pi;\r\n\tks = 1.; ps = 3.;   ki = .9; pi = 3.;\r\n\t\r\n\tif (iMouse.z>0.) {\r\n\t\tt = -PI/2.*mouse.x;\r\n\t\tz = -PI/2.*mouse.y;\r\n\t}\r\n\tvec3 O = vec3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t// camera\r\n\tfloat compas = t-.2*uv.x; vec2 dir = vec2(cos(compas),sin(compas));\r\n\tFragColor = (keyToggle(64+19)) \r\n\t\t? vec4(0.) \r\n\t\t: clamp(vec4(.6,.7+.3*dir,1.)*(uv.y+1.6)/1.8,0.,1.); \t\t// sky\r\n\r\n\tmat3 M = lookat(O,vec3(0.),5.); \r\n\tvec2 dx = vec2(1.,0.);\r\n\t\r\n\tif (!keyToggle(32))\r\n\t\tdraw_obj(O,M, uv, 2);\t\r\n\telse {\r\n\t\tdraw_obj(O,M, 1.5*(uv+dx), 0);\t\r\n\t\tdraw_obj(O,M, 1.5*(uv-dx), 1);\t\r\n\t}\r\n    \r\n   fragColor = FragColor; \r\n}\r\n","inputs":[],"outputs":[],"code":"// Gardner textured ellipsoids - https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf + bib\r\n\r\nvec3 R = vec3(2.,4.,2.);              // ellipsoid radius\r\nvec3 L = normalize(vec3(-.4,0.,1.));  // light source\r\n#define AMBIENT .4\t\t\t\t\t  // ambient luminosity\r\n\r\n#define ANIM true\r\n#define PI 3.1415927\r\nvec4 FragColor;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )    // in [0,1]\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // in [0,1]\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )    // in [0,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\nfloat snoise( in vec3 x ) // in [-1,1]\r\n{ return 2.*noise(x)-1.; }\r\n\r\nfloat sfbm( vec3 p )      // in [-1,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\r\n    f += 0.2500*snoise( p ); p = m*p*2.03;\r\n    f += 0.1250*snoise( p ); p = m*p*2.01;\r\n    f += 0.0625*snoise( p );\r\n    return f;\r\n}\r\n\r\n\r\n\r\n// --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\r\n\r\n\r\nmat3 lookat(vec3 O, vec3 T, float d) {\r\n\tmat3 M;\r\n\tvec3 OT = normalize(T-O);\r\n\tM[0] = OT;\r\n\tM[2] = normalize(vec3(0.,0.,1.)-OT.z*OT)/d;\r\n\tM[1] = cross(M[2],OT);\r\n\treturn M;\r\n}\r\n\r\n// --- ray -  ellipsoid intersection\r\n// if true, return P,N and thickness l\r\n\r\nbool intersect_ellipsoid(vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\r\n\tvec3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere \r\n\t\t// P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\r\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\r\n\tfloat d = OD*OD - (OO-1.)*DD;\r\n\t\r\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\r\n\t// ray intersects the ellipsoid (and not in our back)\r\n\t// note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\r\n\t\t\r\n\tfloat t = (-OD-sqrt(d))/DD;\r\n\t// return intersection point, normal and thickness\r\n\tP = O+t*D;\r\n\tN=normalize(P/(R*R));\r\n\tl = 2.*sqrt(d)/DD;\r\n\r\n\treturn true;\r\n}\r\n\r\n// --- Gardner textured ellipsoids (sort of)\r\n\r\n// 's' index corresponds to Garner faked silhouette\r\n// 'i' index corresponds to interior term faked by mid-surface\r\n\r\nfloat ks,ps, ki,pi;  // smoothness/thichness parameters\r\n\r\nfloat l;\r\nvoid draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {\r\n\tvec3 D = normalize(M*vec3(1.,pos));\t\t// ray\r\n\t\r\n\tvec3 P,N; \r\n\tif (! intersect_ellipsoid(O,D, P,N,l)) return;\r\n\t\r\n\tvec3 Pm = P+.5*l*D,                \t\t// .5: deepest point inside cloud. \r\n\t\t Nm = normalize(Pm/(R*R)),     \t\t// it's normal\r\n\t     Nn = normalize(P/R);\r\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t// ratio of light-facing (for lighting)\r\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t// ratio of camera-facing (for silhouette)\r\n\r\n\r\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\r\n\tfloat A, l0 = 3.;\r\n\t//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette\r\n\tl = clamp(l-6.*ni,0.,1e10);\r\n\tfloat As = pow(ks*nd, ps), \t\t\t \t // silhouette\r\n\t\t  Ai = 1.-pow(.7,pi*l);              // interior\r\n\r\n\r\n\tAs =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);\r\n\tif (mode==2) \r\n\t\tA = 1.- (1.-As)*(1.-Ai);  \t\t\t// mul Ti and Ts\r\n\telse\r\n\t\tA = (mode==0) ? Ai : As; \r\n\tA = clamp(A,0.,1.); \r\n\tnl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));\r\n\r\n\t#if 0 // noise bump\r\n\tN = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); \r\n\tnl = clamp( dot(N,L),0.,1.);\r\n#endif\r\n\t\r\n\tvec4 col = vec4(mix(nl,1.,AMBIENT));\r\n\tFragColor = mix(FragColor,col,A);\r\n}\r\n\r\n// === main =============================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.85,.5));\r\n\tvec2 mouse = 2.*(iMouse.xy / iResolution.xy - vec2(.85,.5));\r\n\tfloat z = .2;\r\n\tks = 1.+mouse.x, ps = mouse.y*8., ki, pi;\r\n\tks = 1.; ps = 3.;   ki = .9; pi = 3.;\r\n\t\r\n\tif (iMouse.z>0.) {\r\n\t\tt = -PI/2.*mouse.x;\r\n\t\tz = -PI/2.*mouse.y;\r\n\t}\r\n\tvec3 O = vec3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t// camera\r\n\tfloat compas = t-.2*uv.x; vec2 dir = vec2(cos(compas),sin(compas));\r\n\tFragColor = (keyToggle(64+19)) \r\n\t\t? vec4(0.) \r\n\t\t: clamp(vec4(.6,.7+.3*dir,1.)*(uv.y+1.6)/1.8,0.,1.); \t\t// sky\r\n\r\n\tmat3 M = lookat(O,vec3(0.),5.); \r\n\tvec2 dx = vec2(1.,0.);\r\n\t\r\n\tif (!keyToggle(32))\r\n\t\tdraw_obj(O,M, uv, 2);\t\r\n\telse {\r\n\t\tdraw_obj(O,M, 1.5*(uv+dx), 0);\t\r\n\t\tdraw_obj(O,M, 1.5*(uv-dx), 1);\t\r\n\t}\r\n    \r\n   fragColor = FragColor; \r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"textured ellipsoids","id":"f68887fe97e4464198de45525837f846","date":null,"viewed":0,"name":"textured ellipsoids","description":"S: toggles sky  SPACE: decompos\n \nIn Siggraph'85, Gardner proposed a smart way to fake hypertextures with simple ellipsoids.\nThe secret is to have transparency (or the density noise) vanishing at silhouettes, i.e., view-dep (e.g. based on dot(N,Eye) ).\nhttps://www.shadertoy.com/view/XsfXW8","likes":0,"published":null,"tags":["procedural"," noise"," cloud"]},"ver":null,"info":{"Name":"textured ellipsoids","id":"f68887fe97e4464198de45525837f846","date":null,"viewed":0,"name":"textured ellipsoids","description":"S: toggles sky  SPACE: decompos\n \nIn Siggraph'85, Gardner proposed a smart way to fake hypertextures with simple ellipsoids.\nThe secret is to have transparency (or the density noise) vanishing at silhouettes, i.e., view-dep (e.g. based on dot(N,Eye) ).\nhttps://www.shadertoy.com/view/XsfXW8","likes":0,"published":null,"tags":["procedural"," noise"," cloud"]},"renderpass":[{"Code":"// Gardner textured ellipsoids - https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf + bib\r\n\r\nvec3 R = vec3(2.,4.,2.);              // ellipsoid radius\r\nvec3 L = normalize(vec3(-.4,0.,1.));  // light source\r\n#define AMBIENT .4\t\t\t\t\t  // ambient luminosity\r\n\r\n#define ANIM true\r\n#define PI 3.1415927\r\nvec4 FragColor;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )    // in [0,1]\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // in [0,1]\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )    // in [0,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\nfloat snoise( in vec3 x ) // in [-1,1]\r\n{ return 2.*noise(x)-1.; }\r\n\r\nfloat sfbm( vec3 p )      // in [-1,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\r\n    f += 0.2500*snoise( p ); p = m*p*2.03;\r\n    f += 0.1250*snoise( p ); p = m*p*2.01;\r\n    f += 0.0625*snoise( p );\r\n    return f;\r\n}\r\n\r\n\r\n\r\n// --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\r\n\r\n\r\nmat3 lookat(vec3 O, vec3 T, float d) {\r\n\tmat3 M;\r\n\tvec3 OT = normalize(T-O);\r\n\tM[0] = OT;\r\n\tM[2] = normalize(vec3(0.,0.,1.)-OT.z*OT)/d;\r\n\tM[1] = cross(M[2],OT);\r\n\treturn M;\r\n}\r\n\r\n// --- ray -  ellipsoid intersection\r\n// if true, return P,N and thickness l\r\n\r\nbool intersect_ellipsoid(vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\r\n\tvec3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere \r\n\t\t// P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\r\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\r\n\tfloat d = OD*OD - (OO-1.)*DD;\r\n\t\r\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\r\n\t// ray intersects the ellipsoid (and not in our back)\r\n\t// note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\r\n\t\t\r\n\tfloat t = (-OD-sqrt(d))/DD;\r\n\t// return intersection point, normal and thickness\r\n\tP = O+t*D;\r\n\tN=normalize(P/(R*R));\r\n\tl = 2.*sqrt(d)/DD;\r\n\r\n\treturn true;\r\n}\r\n\r\n// --- Gardner textured ellipsoids (sort of)\r\n\r\n// 's' index corresponds to Garner faked silhouette\r\n// 'i' index corresponds to interior term faked by mid-surface\r\n\r\nfloat ks,ps, ki,pi;  // smoothness/thichness parameters\r\n\r\nfloat l;\r\nvoid draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {\r\n\tvec3 D = normalize(M*vec3(1.,pos));\t\t// ray\r\n\t\r\n\tvec3 P,N; \r\n\tif (! intersect_ellipsoid(O,D, P,N,l)) return;\r\n\t\r\n\tvec3 Pm = P+.5*l*D,                \t\t// .5: deepest point inside cloud. \r\n\t\t Nm = normalize(Pm/(R*R)),     \t\t// it's normal\r\n\t     Nn = normalize(P/R);\r\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t// ratio of light-facing (for lighting)\r\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t// ratio of camera-facing (for silhouette)\r\n\r\n\r\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\r\n\tfloat A, l0 = 3.;\r\n\t//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette\r\n\tl = clamp(l-6.*ni,0.,1e10);\r\n\tfloat As = pow(ks*nd, ps), \t\t\t \t // silhouette\r\n\t\t  Ai = 1.-pow(.7,pi*l);              // interior\r\n\r\n\r\n\tAs =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);\r\n\tif (mode==2) \r\n\t\tA = 1.- (1.-As)*(1.-Ai);  \t\t\t// mul Ti and Ts\r\n\telse\r\n\t\tA = (mode==0) ? Ai : As; \r\n\tA = clamp(A,0.,1.); \r\n\tnl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));\r\n\r\n\t#if 0 // noise bump\r\n\tN = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); \r\n\tnl = clamp( dot(N,L),0.,1.);\r\n#endif\r\n\t\r\n\tvec4 col = vec4(mix(nl,1.,AMBIENT));\r\n\tFragColor = mix(FragColor,col,A);\r\n}\r\n\r\n// === main =============================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.85,.5));\r\n\tvec2 mouse = 2.*(iMouse.xy / iResolution.xy - vec2(.85,.5));\r\n\tfloat z = .2;\r\n\tks = 1.+mouse.x, ps = mouse.y*8., ki, pi;\r\n\tks = 1.; ps = 3.;   ki = .9; pi = 3.;\r\n\t\r\n\tif (iMouse.z>0.) {\r\n\t\tt = -PI/2.*mouse.x;\r\n\t\tz = -PI/2.*mouse.y;\r\n\t}\r\n\tvec3 O = vec3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t// camera\r\n\tfloat compas = t-.2*uv.x; vec2 dir = vec2(cos(compas),sin(compas));\r\n\tFragColor = (keyToggle(64+19)) \r\n\t\t? vec4(0.) \r\n\t\t: clamp(vec4(.6,.7+.3*dir,1.)*(uv.y+1.6)/1.8,0.,1.); \t\t// sky\r\n\r\n\tmat3 M = lookat(O,vec3(0.),5.); \r\n\tvec2 dx = vec2(1.,0.);\r\n\t\r\n\tif (!keyToggle(32))\r\n\t\tdraw_obj(O,M, uv, 2);\t\r\n\telse {\r\n\t\tdraw_obj(O,M, 1.5*(uv+dx), 0);\t\r\n\t\tdraw_obj(O,M, 1.5*(uv-dx), 1);\t\r\n\t}\r\n    \r\n   fragColor = FragColor; \r\n}\r\n","inputs":[],"outputs":[],"code":"// Gardner textured ellipsoids - https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf + bib\r\n\r\nvec3 R = vec3(2.,4.,2.);              // ellipsoid radius\r\nvec3 L = normalize(vec3(-.4,0.,1.));  // light source\r\n#define AMBIENT .4\t\t\t\t\t  // ambient luminosity\r\n\r\n#define ANIM true\r\n#define PI 3.1415927\r\nvec4 FragColor;\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )    // in [0,1]\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x ) // in [0,1]\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )    // in [0,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\nfloat snoise( in vec3 x ) // in [-1,1]\r\n{ return 2.*noise(x)-1.; }\r\n\r\nfloat sfbm( vec3 p )      // in [-1,1]\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float f;\r\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\r\n    f += 0.2500*snoise( p ); p = m*p*2.03;\r\n    f += 0.1250*snoise( p ); p = m*p*2.01;\r\n    f += 0.0625*snoise( p );\r\n    return f;\r\n}\r\n\r\n\r\n\r\n// --- view matrix when looking T from O with [-1,1]x[-1,1] screen at dist d\r\n\r\n\r\nmat3 lookat(vec3 O, vec3 T, float d) {\r\n\tmat3 M;\r\n\tvec3 OT = normalize(T-O);\r\n\tM[0] = OT;\r\n\tM[2] = normalize(vec3(0.,0.,1.)-OT.z*OT)/d;\r\n\tM[1] = cross(M[2],OT);\r\n\treturn M;\r\n}\r\n\r\n// --- ray -  ellipsoid intersection\r\n// if true, return P,N and thickness l\r\n\r\nbool intersect_ellipsoid(vec3 O, vec3 D, out vec3 P, out vec3 N, out float l) {\r\n\tvec3 OR = O/R, DR = D/R; // to space where ellipsoid is a sphere \r\n\t\t// P=O+tD & |P|=1 -> solve t in O^2 +2(O.D)t + D^2.t^2 = 1\r\n\tfloat OD = dot(OR,DR), OO=dot(OR,OR), DD=dot(DR,DR);\r\n\tfloat d = OD*OD - (OO-1.)*DD;\r\n\t\r\n\tif (!((d >=0.)&&(OD<0.)&&(OO>1.))) return false;\r\n\t// ray intersects the ellipsoid (and not in our back)\r\n\t// note that t>0 <=> -OD>0 &  OD^2 > OD^ -(OO-1.)*DD -> |O|>1\r\n\t\t\r\n\tfloat t = (-OD-sqrt(d))/DD;\r\n\t// return intersection point, normal and thickness\r\n\tP = O+t*D;\r\n\tN=normalize(P/(R*R));\r\n\tl = 2.*sqrt(d)/DD;\r\n\r\n\treturn true;\r\n}\r\n\r\n// --- Gardner textured ellipsoids (sort of)\r\n\r\n// 's' index corresponds to Garner faked silhouette\r\n// 'i' index corresponds to interior term faked by mid-surface\r\n\r\nfloat ks,ps, ki,pi;  // smoothness/thichness parameters\r\n\r\nfloat l;\r\nvoid draw_obj(vec3 O, mat3 M, vec2 pos, int mode) {\r\n\tvec3 D = normalize(M*vec3(1.,pos));\t\t// ray\r\n\t\r\n\tvec3 P,N; \r\n\tif (! intersect_ellipsoid(O,D, P,N,l)) return;\r\n\t\r\n\tvec3 Pm = P+.5*l*D,                \t\t// .5: deepest point inside cloud. \r\n\t\t Nm = normalize(Pm/(R*R)),     \t\t// it's normal\r\n\t     Nn = normalize(P/R);\r\n\tfloat nl = clamp( dot(N,L),0.,1.), \t\t// ratio of light-facing (for lighting)\r\n\t\t  nd = clamp(-dot(Nn,D),0.,1.); \t// ratio of camera-facing (for silhouette)\r\n\r\n\r\n\tfloat ns = fbm(P), ni = fbm(Pm+10.);\r\n\tfloat A, l0 = 3.;\r\n\t//l += l*(l/l0-1.)/(1.+l*l/(l0*l0));     // optical depth modified at silhouette\r\n\tl = clamp(l-6.*ni,0.,1e10);\r\n\tfloat As = pow(ks*nd, ps), \t\t\t \t // silhouette\r\n\t\t  Ai = 1.-pow(.7,pi*l);              // interior\r\n\r\n\r\n\tAs =clamp(As-ns,0.,1.)*2.; // As = 2.*pow(As ,.6);\r\n\tif (mode==2) \r\n\t\tA = 1.- (1.-As)*(1.-Ai);  \t\t\t// mul Ti and Ts\r\n\telse\r\n\t\tA = (mode==0) ? Ai : As; \r\n\tA = clamp(A,0.,1.); \r\n\tnl = .8*( nl + ((mode==0) ? fbm(Pm-10.) : fbm(P+10.) ));\r\n\r\n\t#if 0 // noise bump\r\n\tN = normalize(N -.1*(dFdx(A)*M[1]+dFdy(A)*M[2])*iResolution.y); \r\n\tnl = clamp( dot(N,L),0.,1.);\r\n#endif\r\n\t\r\n\tvec4 col = vec4(mix(nl,1.,AMBIENT));\r\n\tFragColor = mix(FragColor,col,A);\r\n}\r\n\r\n// === main =============================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tfloat t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y-vec2(.85,.5));\r\n\tvec2 mouse = 2.*(iMouse.xy / iResolution.xy - vec2(.85,.5));\r\n\tfloat z = .2;\r\n\tks = 1.+mouse.x, ps = mouse.y*8., ki, pi;\r\n\tks = 1.; ps = 3.;   ki = .9; pi = 3.;\r\n\t\r\n\tif (iMouse.z>0.) {\r\n\t\tt = -PI/2.*mouse.x;\r\n\t\tz = -PI/2.*mouse.y;\r\n\t}\r\n\tvec3 O = vec3(-15.*cos(t)*cos(z),15.*sin(t)*cos(z),15.*sin(z));\t// camera\r\n\tfloat compas = t-.2*uv.x; vec2 dir = vec2(cos(compas),sin(compas));\r\n\tFragColor = (keyToggle(64+19)) \r\n\t\t? vec4(0.) \r\n\t\t: clamp(vec4(.6,.7+.3*dir,1.)*(uv.y+1.6)/1.8,0.,1.); \t\t// sky\r\n\r\n\tmat3 M = lookat(O,vec3(0.),5.); \r\n\tvec2 dx = vec2(1.,0.);\r\n\t\r\n\tif (!keyToggle(32))\r\n\t\tdraw_obj(O,M, uv, 2);\t\r\n\telse {\r\n\t\tdraw_obj(O,M, 1.5*(uv+dx), 0);\t\r\n\t\tdraw_obj(O,M, 1.5*(uv-dx), 1);\t\r\n\t}\r\n    \r\n   fragColor = FragColor; \r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// variations on noise \r\n\r\n#define SCALE_LACUNARITY 8. // when exponent is active\r\n#define NOctaves 20.    \t// max scales\r\n#define LimitDetails 2. \t// Anti aliasing\r\n#define ANIM 0\t\t\t\t// Manual / Auto\r\n#define ClampLevel 1.\t\t// Colormap\r\n\r\n\r\n// widgets from https://www.shadertoy.com/view/lsXXzN\r\n\r\nvec2 FragCoord;\r\nvec4 FragColor;\r\n\r\n// --- key toggles -----------------------------------------------------\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- Digit display ----------------------------------------------------\r\n\r\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\r\n\r\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\r\n\r\nfloat segment(vec2 uv, bool On) {\r\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\r\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\r\n\t\t        : 0.;\r\n}\r\n\r\nfloat sevenSegment(vec2 uv,int num) {\r\n\tfloat seg= 0.;\r\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\r\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\r\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\r\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\r\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\r\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\r\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\r\n\treturn seg;\r\n}\r\n\r\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\r\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\r\n\r\n\tif (nr<0) {\r\n\t\tnr = -nr;\r\n\t\tif (uv.x>1.5) {\r\n\t\t\tuv.x -= 2.;\r\n\t\t\treturn segment(uv.yx,true); // <<<< signe. bug\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (uv.x>0.) {\r\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\r\n\t\tuv -= vec2(.75,0.);\r\n\t} else {\r\n\t\tuv += vec2(.75,0.); \r\n\t\tnr = int(mod(float(nr),10.));\r\n\t}\r\n\r\n\treturn sevenSegment(uv,nr);\r\n}\r\n\r\nfloat dots(vec2 uv, int dot) {\r\n\tfloat point0 = float(dot/2),\r\n\t\t  point1 = float(dot)-2.*point0; \r\n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\r\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\r\n\treturn 0.;\r\n}\r\n//    ... end of digits adapted from Andre\r\n\r\n#define STEPX .875\r\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\r\n\r\n// 2digit int + sign\r\nbool display(vec2 pos, float scale, float offset, int number, int dot) { // dot: draw separator\r\n\tvec2 uv = FragCoord.xy/iResolution.y;\r\n\tuv = (uv-pos)/scale*2.; \r\n    uv.x = .5-uv.x + STEPX*offset;\r\n\tuv.y -= 1.;\r\n\t\r\n\tfloat seg = showNum(uv,number,false);\r\n\toffset += 2.;\r\n\t\r\n\tif (dot>0) {\r\n\t\tuv.x += STEPX*offset; \r\n\t\tseg += dots(uv,dot);\r\n\t\toffset += 2.;\r\n\t}\r\n\r\n\tFragColor += seg*vec4(0.,.5,1.,1.);  // change color here\r\n\t_offset = offset;\r\n\treturn (seg>0.);\r\n}\r\n\r\n// 2.2 float + sign\r\nbool display(vec2 pos, float scale, float offset, float val) { // dot: draw separator\r\n\tif (display( pos, scale, 0., int(val), 1)) return true;\r\n    if (display( pos, scale, _offset, int(fract(val)*100.), 0)) return true;\r\n\treturn false;\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {                     // noise in [-1,1]\r\n    // p+= iTime;\r\n    vec2 i = floor(p), f = fract(p);\r\n\tvec2 u = f*f*(3.-2.*f);\r\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \r\n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\r\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \r\n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\r\n}\r\n\r\n\r\nvec3 colormap(float value) {\r\n\tfloat maxv = ClampLevel;\r\n\tvec3 c1,c2;\r\n\tfloat t;\r\n\tif (value < maxv / 3.) {\r\n\t\tc1 = vec3(0.);   \t c2 = vec3(1.,0.,0.); \tt =  1./3.;\r\n\t} else if (value < maxv * 2. / 3.) {\r\n\t\tc1 = vec3(1.,0.,0.); c2 = vec3(1.,1.,.5);\tt =  2./3. ;\r\n\t} else {\r\n\t\tc1 = vec3(1.,1.,.5); c2 = vec3(1.);      \tt =  1.;\r\n\t}\r\n\tt = (t*maxv-value)/(maxv/3.);\r\n\treturn t*c1 + (1.-t)*c2;\r\n}\r\n\r\n// ===============================================================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \r\n    float t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy/ iResolution.y- vec2(.5*iResolution.x/iResolution.y,.5));\r\n\tvec4 mouse = iMouse / iResolution.xyxy;\r\n\tFragCoord=fragCoord;\r\n    FragColor=fragColor=vec4(0);\r\n    \r\n\t// --- tunings ------------------------------\r\n\r\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\r\n\t\r\n #if ANIM\r\n\tfloat cycle = cos(mod(-t,100.)/100.*2.*3.14);\r\n\tfloat zoom = exp(cycle*cycle*20.);\r\n#else\r\n\tfloat zoom = 0.;\r\n\tzoom = (keyToggle(83)) ? abs(mouse.z) : mouse.x ;\r\n\tzoom = exp(-6. + zoom*9.);\r\n#endif\r\n\t\r\n\tif (!keyToggle(68)) { // 'D' : switch on/off display mouse.xy\r\n\t\tvec2 pos ; float scale = 0.1;\r\n        pos = vec2(.2,.8); if (display( pos, scale, 0., mouse.x*100.)) { fragColor=FragColor; return; }\r\n        pos.y -= .15;\t   if (display( pos, scale, 0., mouse.y*100.)) { fragColor=FragColor; return; }\r\n\t}\r\n\t\r\n\tint TYPE = (keyToggle(84)) ? 0 : 1;\t// 0: additive perlin  1: multiplicative perlin\r\n\r\n\r\n\tif (keyToggle(71)) { // 'G' : map on galaxy\r\n\t\tfloat r = length(uv), a = atan(uv.y,uv.x);  // to polar\r\n\t\tif (!keyToggle(64+25)) { // 'Y'\r\n\t\t\tr = 1.*log(r/.1); \t\t\t\t\t\t    // restore aspect ratio\r\n\t\t\ta -= r;           \t\t\t\t\t\t\t// slight slant\r\n\t\t\tuv = vec2(a,2.*r-1.);\r\n\t\t} \r\n\t\telse {\r\n\t\t\ta -= r;\r\n\t\t\tuv = vec2(r*cos(a),r*sin(a));\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (keyToggle(64+23)) { // 'W' : gravity waves ( = galaxy spirals)\r\n#define AMP .1\r\n\t\tfloat phi = 3.*(uv.x-.5*iTime);\r\n\t\tuv.x -= AMP*sin(phi);\r\n\t\tmouse.y = 6.*AMP*(1.+cos(phi))/2.;\r\n\t}\r\n\t\r\n\t// zoom and centering\r\n\tuv *= zoom; \r\n\t\r\n\tif (keyToggle(64+26)) { // 'Z'  mapping reference\r\n\t\tuv *= 8.;\r\n\t\tfloat n = 20.*2.*sign(mod(uv.x,1.)-.5)*sign(mod(uv.y,1.)-.5)-1.;\r\n\t\tfragColor=vec4(n); return;\r\n\t}\r\n\t\r\n\tfloat theta = 4. + float(ANIM)*.01*t; // some rotations, not compulsory\r\n    mat2 m = 2.*mat2( cos(theta),sin(theta), \r\n\t\t\t\t\t -sin(theta),cos(theta) );\r\n\t\t\r\n\t// noise type:   0: smooth  1: abs  2: 1-abs  3: 1/(1+x)\r\n\tint NOISE = ((keyToggle(78))?1:0) + ((keyToggle(66))?2:0);\r\n\t\r\n\t\r\n\t// --- computation of the noise cascade ----------------------------\r\n\t\r\n\tfloat d = (TYPE==0) ? 0.:.5; // density\r\n\tfloat q = zoom;\r\n\t\r\n\tfor (float i = 0.; i < NOctaves; i++) { // cumulates scales from large to small\r\n\t\t\r\n\t\tif (TYPE==1) if(d < 1e-2) continue;\r\n\t\tfloat crit = iResolution.x/(q*LimitDetails)-1.;\r\n\t\tif (crit < 0.) continue; // otherwise, smaller than pixel\r\n\t\r\n\t\t// --- base noise     normalization should ensure constant average\r\n\t\t\r\n\t\tfloat n = noise(uv + 10.*i*i); // base noise [-1,1]\r\n#define GAIN 1. // 5.*mouse.y // 5.\r\n\t\t// n = clamp(GAIN*n,-1.,1.); // to cancel poor stddev\r\n\t\tif (NOISE == 0)\r\n\t\t\tn = (1.+n)*.95; // [0.,1.]\r\n\t\telse if (NOISE == 1)\r\n\t\t\tn = abs(n)*8.5;\r\n\t\telse if (NOISE == 3)\r\n\t\t\tn = (1.-abs(n)) * 1.1;\r\n\t\telse if (NOISE == 2)\r\n\t\t\tn = 1./(1.+n)*.9;\r\n\r\n\t\t\t\r\n\t\t// --- lacunarity ( = vicinity at largest scale )\r\n\t\t\t\r\n\t\tif (keyToggle(69)) // 'E' : mouse.y tune exponent\r\n\t\t{ \r\n\t\t\tfloat P = mouse.y*10.; //  power to control high-scale lacunarity\r\n\t\t\t// lacunarity fall-off with scale.   'S' : mouse.x tune scales of lacunarity\r\n\t\t\tfloat lac = SCALE_LACUNARITY * ( (keyToggle(83)) ? 2.*mouse.x : 1.);\r\n\t\t\tP = 1. + P*exp(-i/lac);\r\n#define FACTOR 1.5\r\n\t\t\tn = clamp(n,0.,FACTOR); \r\n\t\t\tn = pow(n,P); \r\n\t\t}\r\n\t\t\r\n\r\n\t\t// --- fading zone to avoid aliasing\r\n\t\tif (crit<1.)   \r\n\t\t\tn = n*crit + (1.-crit); \r\n\r\n\t\t// --- cumulates cascade bands\r\n\t\tif (TYPE==1)\r\n\t\t\td *= n; \t\t\t// cumulates multiplicatively\r\n\t\telse\r\n\t\t\td += .4*n*zoom/q;   // cumulates additively\r\n\t\t\r\n\t\tuv = m*uv; q*= 2.; // go to the next octave\r\n\t}\r\n\r\n    if (keyToggle(64+9)) // 'I' : reverse\r\n        d = 1.-d;\r\n\tfragColor.xyz = (keyToggle(67)) ?  vec3(d) : colormap(d) ;\r\n    //if (d<0.) fragColor = vec4(0,0,1,0);\r\n    //if (d>1.) fragColor = vec4(1,0,0,0);\r\n}","inputs":[],"outputs":[],"code":"// variations on noise \r\n\r\n#define SCALE_LACUNARITY 8. // when exponent is active\r\n#define NOctaves 20.    \t// max scales\r\n#define LimitDetails 2. \t// Anti aliasing\r\n#define ANIM 0\t\t\t\t// Manual / Auto\r\n#define ClampLevel 1.\t\t// Colormap\r\n\r\n\r\n// widgets from https://www.shadertoy.com/view/lsXXzN\r\n\r\nvec2 FragCoord;\r\nvec4 FragColor;\r\n\r\n// --- key toggles -----------------------------------------------------\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- Digit display ----------------------------------------------------\r\n\r\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\r\n\r\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\r\n\r\nfloat segment(vec2 uv, bool On) {\r\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\r\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\r\n\t\t        : 0.;\r\n}\r\n\r\nfloat sevenSegment(vec2 uv,int num) {\r\n\tfloat seg= 0.;\r\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\r\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\r\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\r\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\r\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\r\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\r\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\r\n\treturn seg;\r\n}\r\n\r\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\r\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\r\n\r\n\tif (nr<0) {\r\n\t\tnr = -nr;\r\n\t\tif (uv.x>1.5) {\r\n\t\t\tuv.x -= 2.;\r\n\t\t\treturn segment(uv.yx,true); // <<<< signe. bug\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (uv.x>0.) {\r\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\r\n\t\tuv -= vec2(.75,0.);\r\n\t} else {\r\n\t\tuv += vec2(.75,0.); \r\n\t\tnr = int(mod(float(nr),10.));\r\n\t}\r\n\r\n\treturn sevenSegment(uv,nr);\r\n}\r\n\r\nfloat dots(vec2 uv, int dot) {\r\n\tfloat point0 = float(dot/2),\r\n\t\t  point1 = float(dot)-2.*point0; \r\n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\r\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\r\n\treturn 0.;\r\n}\r\n//    ... end of digits adapted from Andre\r\n\r\n#define STEPX .875\r\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\r\n\r\n// 2digit int + sign\r\nbool display(vec2 pos, float scale, float offset, int number, int dot) { // dot: draw separator\r\n\tvec2 uv = FragCoord.xy/iResolution.y;\r\n\tuv = (uv-pos)/scale*2.; \r\n    uv.x = .5-uv.x + STEPX*offset;\r\n\tuv.y -= 1.;\r\n\t\r\n\tfloat seg = showNum(uv,number,false);\r\n\toffset += 2.;\r\n\t\r\n\tif (dot>0) {\r\n\t\tuv.x += STEPX*offset; \r\n\t\tseg += dots(uv,dot);\r\n\t\toffset += 2.;\r\n\t}\r\n\r\n\tFragColor += seg*vec4(0.,.5,1.,1.);  // change color here\r\n\t_offset = offset;\r\n\treturn (seg>0.);\r\n}\r\n\r\n// 2.2 float + sign\r\nbool display(vec2 pos, float scale, float offset, float val) { // dot: draw separator\r\n\tif (display( pos, scale, 0., int(val), 1)) return true;\r\n    if (display( pos, scale, _offset, int(fract(val)*100.), 0)) return true;\r\n\treturn false;\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {                     // noise in [-1,1]\r\n    // p+= iTime;\r\n    vec2 i = floor(p), f = fract(p);\r\n\tvec2 u = f*f*(3.-2.*f);\r\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \r\n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\r\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \r\n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\r\n}\r\n\r\n\r\nvec3 colormap(float value) {\r\n\tfloat maxv = ClampLevel;\r\n\tvec3 c1,c2;\r\n\tfloat t;\r\n\tif (value < maxv / 3.) {\r\n\t\tc1 = vec3(0.);   \t c2 = vec3(1.,0.,0.); \tt =  1./3.;\r\n\t} else if (value < maxv * 2. / 3.) {\r\n\t\tc1 = vec3(1.,0.,0.); c2 = vec3(1.,1.,.5);\tt =  2./3. ;\r\n\t} else {\r\n\t\tc1 = vec3(1.,1.,.5); c2 = vec3(1.);      \tt =  1.;\r\n\t}\r\n\tt = (t*maxv-value)/(maxv/3.);\r\n\treturn t*c1 + (1.-t)*c2;\r\n}\r\n\r\n// ===============================================================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \r\n    float t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy/ iResolution.y- vec2(.5*iResolution.x/iResolution.y,.5));\r\n\tvec4 mouse = iMouse / iResolution.xyxy;\r\n\tFragCoord=fragCoord;\r\n    FragColor=fragColor=vec4(0);\r\n    \r\n\t// --- tunings ------------------------------\r\n\r\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\r\n\t\r\n #if ANIM\r\n\tfloat cycle = cos(mod(-t,100.)/100.*2.*3.14);\r\n\tfloat zoom = exp(cycle*cycle*20.);\r\n#else\r\n\tfloat zoom = 0.;\r\n\tzoom = (keyToggle(83)) ? abs(mouse.z) : mouse.x ;\r\n\tzoom = exp(-6. + zoom*9.);\r\n#endif\r\n\t\r\n\tif (!keyToggle(68)) { // 'D' : switch on/off display mouse.xy\r\n\t\tvec2 pos ; float scale = 0.1;\r\n        pos = vec2(.2,.8); if (display( pos, scale, 0., mouse.x*100.)) { fragColor=FragColor; return; }\r\n        pos.y -= .15;\t   if (display( pos, scale, 0., mouse.y*100.)) { fragColor=FragColor; return; }\r\n\t}\r\n\t\r\n\tint TYPE = (keyToggle(84)) ? 0 : 1;\t// 0: additive perlin  1: multiplicative perlin\r\n\r\n\r\n\tif (keyToggle(71)) { // 'G' : map on galaxy\r\n\t\tfloat r = length(uv), a = atan(uv.y,uv.x);  // to polar\r\n\t\tif (!keyToggle(64+25)) { // 'Y'\r\n\t\t\tr = 1.*log(r/.1); \t\t\t\t\t\t    // restore aspect ratio\r\n\t\t\ta -= r;           \t\t\t\t\t\t\t// slight slant\r\n\t\t\tuv = vec2(a,2.*r-1.);\r\n\t\t} \r\n\t\telse {\r\n\t\t\ta -= r;\r\n\t\t\tuv = vec2(r*cos(a),r*sin(a));\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (keyToggle(64+23)) { // 'W' : gravity waves ( = galaxy spirals)\r\n#define AMP .1\r\n\t\tfloat phi = 3.*(uv.x-.5*iTime);\r\n\t\tuv.x -= AMP*sin(phi);\r\n\t\tmouse.y = 6.*AMP*(1.+cos(phi))/2.;\r\n\t}\r\n\t\r\n\t// zoom and centering\r\n\tuv *= zoom; \r\n\t\r\n\tif (keyToggle(64+26)) { // 'Z'  mapping reference\r\n\t\tuv *= 8.;\r\n\t\tfloat n = 20.*2.*sign(mod(uv.x,1.)-.5)*sign(mod(uv.y,1.)-.5)-1.;\r\n\t\tfragColor=vec4(n); return;\r\n\t}\r\n\t\r\n\tfloat theta = 4. + float(ANIM)*.01*t; // some rotations, not compulsory\r\n    mat2 m = 2.*mat2( cos(theta),sin(theta), \r\n\t\t\t\t\t -sin(theta),cos(theta) );\r\n\t\t\r\n\t// noise type:   0: smooth  1: abs  2: 1-abs  3: 1/(1+x)\r\n\tint NOISE = ((keyToggle(78))?1:0) + ((keyToggle(66))?2:0);\r\n\t\r\n\t\r\n\t// --- computation of the noise cascade ----------------------------\r\n\t\r\n\tfloat d = (TYPE==0) ? 0.:.5; // density\r\n\tfloat q = zoom;\r\n\t\r\n\tfor (float i = 0.; i < NOctaves; i++) { // cumulates scales from large to small\r\n\t\t\r\n\t\tif (TYPE==1) if(d < 1e-2) continue;\r\n\t\tfloat crit = iResolution.x/(q*LimitDetails)-1.;\r\n\t\tif (crit < 0.) continue; // otherwise, smaller than pixel\r\n\t\r\n\t\t// --- base noise     normalization should ensure constant average\r\n\t\t\r\n\t\tfloat n = noise(uv + 10.*i*i); // base noise [-1,1]\r\n#define GAIN 1. // 5.*mouse.y // 5.\r\n\t\t// n = clamp(GAIN*n,-1.,1.); // to cancel poor stddev\r\n\t\tif (NOISE == 0)\r\n\t\t\tn = (1.+n)*.95; // [0.,1.]\r\n\t\telse if (NOISE == 1)\r\n\t\t\tn = abs(n)*8.5;\r\n\t\telse if (NOISE == 3)\r\n\t\t\tn = (1.-abs(n)) * 1.1;\r\n\t\telse if (NOISE == 2)\r\n\t\t\tn = 1./(1.+n)*.9;\r\n\r\n\t\t\t\r\n\t\t// --- lacunarity ( = vicinity at largest scale )\r\n\t\t\t\r\n\t\tif (keyToggle(69)) // 'E' : mouse.y tune exponent\r\n\t\t{ \r\n\t\t\tfloat P = mouse.y*10.; //  power to control high-scale lacunarity\r\n\t\t\t// lacunarity fall-off with scale.   'S' : mouse.x tune scales of lacunarity\r\n\t\t\tfloat lac = SCALE_LACUNARITY * ( (keyToggle(83)) ? 2.*mouse.x : 1.);\r\n\t\t\tP = 1. + P*exp(-i/lac);\r\n#define FACTOR 1.5\r\n\t\t\tn = clamp(n,0.,FACTOR); \r\n\t\t\tn = pow(n,P); \r\n\t\t}\r\n\t\t\r\n\r\n\t\t// --- fading zone to avoid aliasing\r\n\t\tif (crit<1.)   \r\n\t\t\tn = n*crit + (1.-crit); \r\n\r\n\t\t// --- cumulates cascade bands\r\n\t\tif (TYPE==1)\r\n\t\t\td *= n; \t\t\t// cumulates multiplicatively\r\n\t\telse\r\n\t\t\td += .4*n*zoom/q;   // cumulates additively\r\n\t\t\r\n\t\tuv = m*uv; q*= 2.; // go to the next octave\r\n\t}\r\n\r\n    if (keyToggle(64+9)) // 'I' : reverse\r\n        d = 1.-d;\r\n\tfragColor.xyz = (keyToggle(67)) ?  vec3(d) : colormap(d) ;\r\n    //if (d<0.) fragColor = vec4(0,0,1,0);\r\n    //if (d>1.) fragColor = vec4(1,0,0,0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Variations on Noise ","id":"4a1b0c6a08954e17b6c3c097a7220090","date":null,"viewed":0,"name":"Variations on Noise ","description":"variation on https://www.shadertoy.com/view/Xs23D3\nmouse.x: zoom   S: mouse.x controls lacunarity instead \nE:   mouse.y = exponent (=vicinity)\nN+B: noise type:   00: smooth 10: abs 11: 1-abs 10:1/n\nT: add or mul \nC: toggles colors   G: toggles galaxy\nhttps://www.shadertoy.com/view/ldjGWc","likes":0,"published":null,"tags":[" fractal"," noise"," perlin"," filtering"," multiscale"]},"ver":null,"info":{"Name":"Variations on Noise ","id":"4a1b0c6a08954e17b6c3c097a7220090","date":null,"viewed":0,"name":"Variations on Noise ","description":"variation on https://www.shadertoy.com/view/Xs23D3\nmouse.x: zoom   S: mouse.x controls lacunarity instead \nE:   mouse.y = exponent (=vicinity)\nN+B: noise type:   00: smooth 10: abs 11: 1-abs 10:1/n\nT: add or mul \nC: toggles colors   G: toggles galaxy\nhttps://www.shadertoy.com/view/ldjGWc","likes":0,"published":null,"tags":[" fractal"," noise"," perlin"," filtering"," multiscale"]},"renderpass":[{"Code":"// variations on noise \r\n\r\n#define SCALE_LACUNARITY 8. // when exponent is active\r\n#define NOctaves 20.    \t// max scales\r\n#define LimitDetails 2. \t// Anti aliasing\r\n#define ANIM 0\t\t\t\t// Manual / Auto\r\n#define ClampLevel 1.\t\t// Colormap\r\n\r\n\r\n// widgets from https://www.shadertoy.com/view/lsXXzN\r\n\r\nvec2 FragCoord;\r\nvec4 FragColor;\r\n\r\n// --- key toggles -----------------------------------------------------\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- Digit display ----------------------------------------------------\r\n\r\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\r\n\r\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\r\n\r\nfloat segment(vec2 uv, bool On) {\r\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\r\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\r\n\t\t        : 0.;\r\n}\r\n\r\nfloat sevenSegment(vec2 uv,int num) {\r\n\tfloat seg= 0.;\r\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\r\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\r\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\r\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\r\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\r\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\r\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\r\n\treturn seg;\r\n}\r\n\r\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\r\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\r\n\r\n\tif (nr<0) {\r\n\t\tnr = -nr;\r\n\t\tif (uv.x>1.5) {\r\n\t\t\tuv.x -= 2.;\r\n\t\t\treturn segment(uv.yx,true); // <<<< signe. bug\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (uv.x>0.) {\r\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\r\n\t\tuv -= vec2(.75,0.);\r\n\t} else {\r\n\t\tuv += vec2(.75,0.); \r\n\t\tnr = int(mod(float(nr),10.));\r\n\t}\r\n\r\n\treturn sevenSegment(uv,nr);\r\n}\r\n\r\nfloat dots(vec2 uv, int dot) {\r\n\tfloat point0 = float(dot/2),\r\n\t\t  point1 = float(dot)-2.*point0; \r\n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\r\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\r\n\treturn 0.;\r\n}\r\n//    ... end of digits adapted from Andre\r\n\r\n#define STEPX .875\r\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\r\n\r\n// 2digit int + sign\r\nbool display(vec2 pos, float scale, float offset, int number, int dot) { // dot: draw separator\r\n\tvec2 uv = FragCoord.xy/iResolution.y;\r\n\tuv = (uv-pos)/scale*2.; \r\n    uv.x = .5-uv.x + STEPX*offset;\r\n\tuv.y -= 1.;\r\n\t\r\n\tfloat seg = showNum(uv,number,false);\r\n\toffset += 2.;\r\n\t\r\n\tif (dot>0) {\r\n\t\tuv.x += STEPX*offset; \r\n\t\tseg += dots(uv,dot);\r\n\t\toffset += 2.;\r\n\t}\r\n\r\n\tFragColor += seg*vec4(0.,.5,1.,1.);  // change color here\r\n\t_offset = offset;\r\n\treturn (seg>0.);\r\n}\r\n\r\n// 2.2 float + sign\r\nbool display(vec2 pos, float scale, float offset, float val) { // dot: draw separator\r\n\tif (display( pos, scale, 0., int(val), 1)) return true;\r\n    if (display( pos, scale, _offset, int(fract(val)*100.), 0)) return true;\r\n\treturn false;\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {                     // noise in [-1,1]\r\n    // p+= iTime;\r\n    vec2 i = floor(p), f = fract(p);\r\n\tvec2 u = f*f*(3.-2.*f);\r\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \r\n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\r\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \r\n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\r\n}\r\n\r\n\r\nvec3 colormap(float value) {\r\n\tfloat maxv = ClampLevel;\r\n\tvec3 c1,c2;\r\n\tfloat t;\r\n\tif (value < maxv / 3.) {\r\n\t\tc1 = vec3(0.);   \t c2 = vec3(1.,0.,0.); \tt =  1./3.;\r\n\t} else if (value < maxv * 2. / 3.) {\r\n\t\tc1 = vec3(1.,0.,0.); c2 = vec3(1.,1.,.5);\tt =  2./3. ;\r\n\t} else {\r\n\t\tc1 = vec3(1.,1.,.5); c2 = vec3(1.);      \tt =  1.;\r\n\t}\r\n\tt = (t*maxv-value)/(maxv/3.);\r\n\treturn t*c1 + (1.-t)*c2;\r\n}\r\n\r\n// ===============================================================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \r\n    float t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy/ iResolution.y- vec2(.5*iResolution.x/iResolution.y,.5));\r\n\tvec4 mouse = iMouse / iResolution.xyxy;\r\n\tFragCoord=fragCoord;\r\n    FragColor=fragColor=vec4(0);\r\n    \r\n\t// --- tunings ------------------------------\r\n\r\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\r\n\t\r\n #if ANIM\r\n\tfloat cycle = cos(mod(-t,100.)/100.*2.*3.14);\r\n\tfloat zoom = exp(cycle*cycle*20.);\r\n#else\r\n\tfloat zoom = 0.;\r\n\tzoom = (keyToggle(83)) ? abs(mouse.z) : mouse.x ;\r\n\tzoom = exp(-6. + zoom*9.);\r\n#endif\r\n\t\r\n\tif (!keyToggle(68)) { // 'D' : switch on/off display mouse.xy\r\n\t\tvec2 pos ; float scale = 0.1;\r\n        pos = vec2(.2,.8); if (display( pos, scale, 0., mouse.x*100.)) { fragColor=FragColor; return; }\r\n        pos.y -= .15;\t   if (display( pos, scale, 0., mouse.y*100.)) { fragColor=FragColor; return; }\r\n\t}\r\n\t\r\n\tint TYPE = (keyToggle(84)) ? 0 : 1;\t// 0: additive perlin  1: multiplicative perlin\r\n\r\n\r\n\tif (keyToggle(71)) { // 'G' : map on galaxy\r\n\t\tfloat r = length(uv), a = atan(uv.y,uv.x);  // to polar\r\n\t\tif (!keyToggle(64+25)) { // 'Y'\r\n\t\t\tr = 1.*log(r/.1); \t\t\t\t\t\t    // restore aspect ratio\r\n\t\t\ta -= r;           \t\t\t\t\t\t\t// slight slant\r\n\t\t\tuv = vec2(a,2.*r-1.);\r\n\t\t} \r\n\t\telse {\r\n\t\t\ta -= r;\r\n\t\t\tuv = vec2(r*cos(a),r*sin(a));\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (keyToggle(64+23)) { // 'W' : gravity waves ( = galaxy spirals)\r\n#define AMP .1\r\n\t\tfloat phi = 3.*(uv.x-.5*iTime);\r\n\t\tuv.x -= AMP*sin(phi);\r\n\t\tmouse.y = 6.*AMP*(1.+cos(phi))/2.;\r\n\t}\r\n\t\r\n\t// zoom and centering\r\n\tuv *= zoom; \r\n\t\r\n\tif (keyToggle(64+26)) { // 'Z'  mapping reference\r\n\t\tuv *= 8.;\r\n\t\tfloat n = 20.*2.*sign(mod(uv.x,1.)-.5)*sign(mod(uv.y,1.)-.5)-1.;\r\n\t\tfragColor=vec4(n); return;\r\n\t}\r\n\t\r\n\tfloat theta = 4. + float(ANIM)*.01*t; // some rotations, not compulsory\r\n    mat2 m = 2.*mat2( cos(theta),sin(theta), \r\n\t\t\t\t\t -sin(theta),cos(theta) );\r\n\t\t\r\n\t// noise type:   0: smooth  1: abs  2: 1-abs  3: 1/(1+x)\r\n\tint NOISE = ((keyToggle(78))?1:0) + ((keyToggle(66))?2:0);\r\n\t\r\n\t\r\n\t// --- computation of the noise cascade ----------------------------\r\n\t\r\n\tfloat d = (TYPE==0) ? 0.:.5; // density\r\n\tfloat q = zoom;\r\n\t\r\n\tfor (float i = 0.; i < NOctaves; i++) { // cumulates scales from large to small\r\n\t\t\r\n\t\tif (TYPE==1) if(d < 1e-2) continue;\r\n\t\tfloat crit = iResolution.x/(q*LimitDetails)-1.;\r\n\t\tif (crit < 0.) continue; // otherwise, smaller than pixel\r\n\t\r\n\t\t// --- base noise     normalization should ensure constant average\r\n\t\t\r\n\t\tfloat n = noise(uv + 10.*i*i); // base noise [-1,1]\r\n#define GAIN 1. // 5.*mouse.y // 5.\r\n\t\t// n = clamp(GAIN*n,-1.,1.); // to cancel poor stddev\r\n\t\tif (NOISE == 0)\r\n\t\t\tn = (1.+n)*.95; // [0.,1.]\r\n\t\telse if (NOISE == 1)\r\n\t\t\tn = abs(n)*8.5;\r\n\t\telse if (NOISE == 3)\r\n\t\t\tn = (1.-abs(n)) * 1.1;\r\n\t\telse if (NOISE == 2)\r\n\t\t\tn = 1./(1.+n)*.9;\r\n\r\n\t\t\t\r\n\t\t// --- lacunarity ( = vicinity at largest scale )\r\n\t\t\t\r\n\t\tif (keyToggle(69)) // 'E' : mouse.y tune exponent\r\n\t\t{ \r\n\t\t\tfloat P = mouse.y*10.; //  power to control high-scale lacunarity\r\n\t\t\t// lacunarity fall-off with scale.   'S' : mouse.x tune scales of lacunarity\r\n\t\t\tfloat lac = SCALE_LACUNARITY * ( (keyToggle(83)) ? 2.*mouse.x : 1.);\r\n\t\t\tP = 1. + P*exp(-i/lac);\r\n#define FACTOR 1.5\r\n\t\t\tn = clamp(n,0.,FACTOR); \r\n\t\t\tn = pow(n,P); \r\n\t\t}\r\n\t\t\r\n\r\n\t\t// --- fading zone to avoid aliasing\r\n\t\tif (crit<1.)   \r\n\t\t\tn = n*crit + (1.-crit); \r\n\r\n\t\t// --- cumulates cascade bands\r\n\t\tif (TYPE==1)\r\n\t\t\td *= n; \t\t\t// cumulates multiplicatively\r\n\t\telse\r\n\t\t\td += .4*n*zoom/q;   // cumulates additively\r\n\t\t\r\n\t\tuv = m*uv; q*= 2.; // go to the next octave\r\n\t}\r\n\r\n    if (keyToggle(64+9)) // 'I' : reverse\r\n        d = 1.-d;\r\n\tfragColor.xyz = (keyToggle(67)) ?  vec3(d) : colormap(d) ;\r\n    //if (d<0.) fragColor = vec4(0,0,1,0);\r\n    //if (d>1.) fragColor = vec4(1,0,0,0);\r\n}","inputs":[],"outputs":[],"code":"// variations on noise \r\n\r\n#define SCALE_LACUNARITY 8. // when exponent is active\r\n#define NOctaves 20.    \t// max scales\r\n#define LimitDetails 2. \t// Anti aliasing\r\n#define ANIM 0\t\t\t\t// Manual / Auto\r\n#define ClampLevel 1.\t\t// Colormap\r\n\r\n\r\n// widgets from https://www.shadertoy.com/view/lsXXzN\r\n\r\nvec2 FragCoord;\r\nvec4 FragColor;\r\n\r\n// --- key toggles -----------------------------------------------------\r\n\r\nbool keyToggle(int ascii) {\r\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\r\n}\r\n\r\n// --- Digit display ----------------------------------------------------\r\n\r\n// all functions return true or seg number if something was drawn -> caller can then exit the shader.\r\n\r\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\r\n\r\nfloat segment(vec2 uv, bool On) {\r\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\r\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\r\n\t\t        : 0.;\r\n}\r\n\r\nfloat sevenSegment(vec2 uv,int num) {\r\n\tfloat seg= 0.;\r\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\r\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\r\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\r\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\r\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\r\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\r\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\r\n\treturn seg;\r\n}\r\n\r\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\r\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\r\n\r\n\tif (nr<0) {\r\n\t\tnr = -nr;\r\n\t\tif (uv.x>1.5) {\r\n\t\t\tuv.x -= 2.;\r\n\t\t\treturn segment(uv.yx,true); // <<<< signe. bug\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (uv.x>0.) {\r\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\r\n\t\tuv -= vec2(.75,0.);\r\n\t} else {\r\n\t\tuv += vec2(.75,0.); \r\n\t\tnr = int(mod(float(nr),10.));\r\n\t}\r\n\r\n\treturn sevenSegment(uv,nr);\r\n}\r\n\r\nfloat dots(vec2 uv, int dot) {\r\n\tfloat point0 = float(dot/2),\r\n\t\t  point1 = float(dot)-2.*point0; \r\n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\r\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\r\n\treturn 0.;\r\n}\r\n//    ... end of digits adapted from Andre\r\n\r\n#define STEPX .875\r\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\r\n\r\n// 2digit int + sign\r\nbool display(vec2 pos, float scale, float offset, int number, int dot) { // dot: draw separator\r\n\tvec2 uv = FragCoord.xy/iResolution.y;\r\n\tuv = (uv-pos)/scale*2.; \r\n    uv.x = .5-uv.x + STEPX*offset;\r\n\tuv.y -= 1.;\r\n\t\r\n\tfloat seg = showNum(uv,number,false);\r\n\toffset += 2.;\r\n\t\r\n\tif (dot>0) {\r\n\t\tuv.x += STEPX*offset; \r\n\t\tseg += dots(uv,dot);\r\n\t\toffset += 2.;\r\n\t}\r\n\r\n\tFragColor += seg*vec4(0.,.5,1.,1.);  // change color here\r\n\t_offset = offset;\r\n\treturn (seg>0.);\r\n}\r\n\r\n// 2.2 float + sign\r\nbool display(vec2 pos, float scale, float offset, float val) { // dot: draw separator\r\n\tif (display( pos, scale, 0., int(val), 1)) return true;\r\n    if (display( pos, scale, _offset, int(fract(val)*100.), 0)) return true;\r\n\treturn false;\r\n}\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\r\n\tp = vec2( dot(p,vec2(127.1,311.7)),\r\n\t\t\t  dot(p,vec2(269.5,183.3)) );\r\n\treturn -1. + 2.*fract(sin(p)*43758.5453123);\r\n}\r\n\r\nfloat noise( in vec2 p ) {                     // noise in [-1,1]\r\n    // p+= iTime;\r\n    vec2 i = floor(p), f = fract(p);\r\n\tvec2 u = f*f*(3.-2.*f);\r\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \r\n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\r\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \r\n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\r\n}\r\n\r\n\r\nvec3 colormap(float value) {\r\n\tfloat maxv = ClampLevel;\r\n\tvec3 c1,c2;\r\n\tfloat t;\r\n\tif (value < maxv / 3.) {\r\n\t\tc1 = vec3(0.);   \t c2 = vec3(1.,0.,0.); \tt =  1./3.;\r\n\t} else if (value < maxv * 2. / 3.) {\r\n\t\tc1 = vec3(1.,0.,0.); c2 = vec3(1.,1.,.5);\tt =  2./3. ;\r\n\t} else {\r\n\t\tc1 = vec3(1.,1.,.5); c2 = vec3(1.);      \tt =  1.;\r\n\t}\r\n\tt = (t*maxv-value)/(maxv/3.);\r\n\treturn t*c1 + (1.-t)*c2;\r\n}\r\n\r\n// ===============================================================================\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \r\n    float t = iTime;\r\n    vec2 uv = 2.*(fragCoord.xy/ iResolution.y- vec2(.5*iResolution.x/iResolution.y,.5));\r\n\tvec4 mouse = iMouse / iResolution.xyxy;\r\n\tFragCoord=fragCoord;\r\n    FragColor=fragColor=vec4(0);\r\n    \r\n\t// --- tunings ------------------------------\r\n\r\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\r\n\t\r\n #if ANIM\r\n\tfloat cycle = cos(mod(-t,100.)/100.*2.*3.14);\r\n\tfloat zoom = exp(cycle*cycle*20.);\r\n#else\r\n\tfloat zoom = 0.;\r\n\tzoom = (keyToggle(83)) ? abs(mouse.z) : mouse.x ;\r\n\tzoom = exp(-6. + zoom*9.);\r\n#endif\r\n\t\r\n\tif (!keyToggle(68)) { // 'D' : switch on/off display mouse.xy\r\n\t\tvec2 pos ; float scale = 0.1;\r\n        pos = vec2(.2,.8); if (display( pos, scale, 0., mouse.x*100.)) { fragColor=FragColor; return; }\r\n        pos.y -= .15;\t   if (display( pos, scale, 0., mouse.y*100.)) { fragColor=FragColor; return; }\r\n\t}\r\n\t\r\n\tint TYPE = (keyToggle(84)) ? 0 : 1;\t// 0: additive perlin  1: multiplicative perlin\r\n\r\n\r\n\tif (keyToggle(71)) { // 'G' : map on galaxy\r\n\t\tfloat r = length(uv), a = atan(uv.y,uv.x);  // to polar\r\n\t\tif (!keyToggle(64+25)) { // 'Y'\r\n\t\t\tr = 1.*log(r/.1); \t\t\t\t\t\t    // restore aspect ratio\r\n\t\t\ta -= r;           \t\t\t\t\t\t\t// slight slant\r\n\t\t\tuv = vec2(a,2.*r-1.);\r\n\t\t} \r\n\t\telse {\r\n\t\t\ta -= r;\r\n\t\t\tuv = vec2(r*cos(a),r*sin(a));\r\n\t\t}\r\n\t}\r\n\t\r\n\tif (keyToggle(64+23)) { // 'W' : gravity waves ( = galaxy spirals)\r\n#define AMP .1\r\n\t\tfloat phi = 3.*(uv.x-.5*iTime);\r\n\t\tuv.x -= AMP*sin(phi);\r\n\t\tmouse.y = 6.*AMP*(1.+cos(phi))/2.;\r\n\t}\r\n\t\r\n\t// zoom and centering\r\n\tuv *= zoom; \r\n\t\r\n\tif (keyToggle(64+26)) { // 'Z'  mapping reference\r\n\t\tuv *= 8.;\r\n\t\tfloat n = 20.*2.*sign(mod(uv.x,1.)-.5)*sign(mod(uv.y,1.)-.5)-1.;\r\n\t\tfragColor=vec4(n); return;\r\n\t}\r\n\t\r\n\tfloat theta = 4. + float(ANIM)*.01*t; // some rotations, not compulsory\r\n    mat2 m = 2.*mat2( cos(theta),sin(theta), \r\n\t\t\t\t\t -sin(theta),cos(theta) );\r\n\t\t\r\n\t// noise type:   0: smooth  1: abs  2: 1-abs  3: 1/(1+x)\r\n\tint NOISE = ((keyToggle(78))?1:0) + ((keyToggle(66))?2:0);\r\n\t\r\n\t\r\n\t// --- computation of the noise cascade ----------------------------\r\n\t\r\n\tfloat d = (TYPE==0) ? 0.:.5; // density\r\n\tfloat q = zoom;\r\n\t\r\n\tfor (float i = 0.; i < NOctaves; i++) { // cumulates scales from large to small\r\n\t\t\r\n\t\tif (TYPE==1) if(d < 1e-2) continue;\r\n\t\tfloat crit = iResolution.x/(q*LimitDetails)-1.;\r\n\t\tif (crit < 0.) continue; // otherwise, smaller than pixel\r\n\t\r\n\t\t// --- base noise     normalization should ensure constant average\r\n\t\t\r\n\t\tfloat n = noise(uv + 10.*i*i); // base noise [-1,1]\r\n#define GAIN 1. // 5.*mouse.y // 5.\r\n\t\t// n = clamp(GAIN*n,-1.,1.); // to cancel poor stddev\r\n\t\tif (NOISE == 0)\r\n\t\t\tn = (1.+n)*.95; // [0.,1.]\r\n\t\telse if (NOISE == 1)\r\n\t\t\tn = abs(n)*8.5;\r\n\t\telse if (NOISE == 3)\r\n\t\t\tn = (1.-abs(n)) * 1.1;\r\n\t\telse if (NOISE == 2)\r\n\t\t\tn = 1./(1.+n)*.9;\r\n\r\n\t\t\t\r\n\t\t// --- lacunarity ( = vicinity at largest scale )\r\n\t\t\t\r\n\t\tif (keyToggle(69)) // 'E' : mouse.y tune exponent\r\n\t\t{ \r\n\t\t\tfloat P = mouse.y*10.; //  power to control high-scale lacunarity\r\n\t\t\t// lacunarity fall-off with scale.   'S' : mouse.x tune scales of lacunarity\r\n\t\t\tfloat lac = SCALE_LACUNARITY * ( (keyToggle(83)) ? 2.*mouse.x : 1.);\r\n\t\t\tP = 1. + P*exp(-i/lac);\r\n#define FACTOR 1.5\r\n\t\t\tn = clamp(n,0.,FACTOR); \r\n\t\t\tn = pow(n,P); \r\n\t\t}\r\n\t\t\r\n\r\n\t\t// --- fading zone to avoid aliasing\r\n\t\tif (crit<1.)   \r\n\t\t\tn = n*crit + (1.-crit); \r\n\r\n\t\t// --- cumulates cascade bands\r\n\t\tif (TYPE==1)\r\n\t\t\td *= n; \t\t\t// cumulates multiplicatively\r\n\t\telse\r\n\t\t\td += .4*n*zoom/q;   // cumulates additively\r\n\t\t\r\n\t\tuv = m*uv; q*= 2.; // go to the next octave\r\n\t}\r\n\r\n    if (keyToggle(64+9)) // 'I' : reverse\r\n        d = 1.-d;\r\n\tfragColor.xyz = (keyToggle(67)) ?  vec3(d) : colormap(d) ;\r\n    //if (d<0.) fragColor = vec4(0,0,1,0);\r\n    //if (d>1.) fragColor = vec4(1,0,0,0);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"//Font liberated from http://paulbourke.net/dataformats/hershey/\r\n\r\nfloat res=0.;\r\nvec2 cpos=vec2(0.);\r\n\r\nfloat antiAlias(float x,vec2 iResolution) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.);}\r\n\r\n#define PI 3.14159265359\r\n\r\n//float opU( float d1, float d2 )\r\n//{\r\n//    return max(d1,d2);\r\n//}\r\n#define opU(a,b) max(a,b)\r\n\r\nfloat width;\r\n\r\nfloat line( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p - a;\r\n    vec2 ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    float d = length( pa - ba*h );\r\n\r\n    return  1.00 + width - d;\r\n}\r\n// CHAR: 32 : \r\nvoid char_32(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 33 :!\r\nvoid char_33(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 34 :\"\r\nvoid char_34(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 35 :#\r\nvoid char_35(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(18.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(17.0,6.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 36 :$\r\nvoid char_36(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,25.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,25.0)*s,vec2(12.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 37 :%\r\nvoid char_37(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(21.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,19.0)*s,vec2(10.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(6.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,20.0)*s,vec2(13.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,19.0)*s,vec2(16.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,19.0)*s,vec2(19.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,20.0)*s,vec2(21.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(15.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,2.0)*s,vec2(16.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,0.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,0.0)*s,vec2(20.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,1.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,3.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(19.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,7.0)*s,vec2(17.0,7.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 38 :&\r\nvoid char_38(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(23.0,12.0)*s,vec2(23.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,13.0)*s,vec2(22.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,14.0)*s,vec2(21.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,14.0)*s,vec2(20.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,13.0)*s,vec2(19.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,11.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,9.0)*s,vec2(12.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,13.0)*s,vec2(13.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,14.0)*s,vec2(14.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,16.0)*s,vec2(14.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,18.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(8.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,16.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(11.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,10.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,0.0)*s,vec2(22.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,0.0)*s,vec2(23.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,1.0)*s,vec2(23.0,2.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 39 :'\r\nvoid char_39(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(6.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,18.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,15.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 40 :(\r\nvoid char_40(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(9.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(9.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-5.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 41 :)\r\nvoid char_41(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(5.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(9.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,16.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(10.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,7.0)*s,vec2(9.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(5.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-5.0)*s,vec2(3.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 42 :*\r\nvoid char_42(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(3.0,12.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 43 :+\r\nvoid char_43(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 44 :,\r\nvoid char_44(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 45 :-\r\nvoid char_45(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 46 :.\r\nvoid char_46(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 47 :/\r\nvoid char_47(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,25.0)*s,vec2(2.0,-7.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 48 :0\r\nvoid char_0(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,4.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 49 :1\r\nvoid char_1(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(11.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 50 :2\r\nvoid char_2(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(15.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,19.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(16.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,15.0)*s,vec2(15.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,13.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 51 :3\r\nvoid char_3(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(16.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,21.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 52 :4\r\nvoid char_4(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(13.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 53 :5\r\nvoid char_5(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 54 :6\r\nvoid char_6(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(11.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,13.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(5.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,10.0)*s,vec2(4.0,7.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 55 :7\r\nvoid char_7(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 56 :8\r\nvoid char_8(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(11.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,12.0)*s,vec2(14.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(17.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,4.0)*s,vec2(16.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,2.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(9.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(16.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,16.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 57 :9\r\nvoid char_9(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,9.0)*s,vec2(10.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,8.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(6.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,9.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(3.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,15.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(15.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,18.0)*s,vec2(16.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,4.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 58 ::\r\nvoid char_58(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 59 :;\r\nvoid char_59(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 60 :<\r\nvoid char_60(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,18.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 61 :=\r\nvoid char_61(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(22.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(22.0,6.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 62 :>\r\nvoid char_62(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(20.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,9.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 63 :?\r\nvoid char_63(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,17.0)*s,vec2(4.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,19.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(14.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,19.0)*s,vec2(15.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,17.0)*s,vec2(15.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,15.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,12.0)*s,vec2(9.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,10.0)*s,vec2(9.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(9.0,2.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 64 :@\r\nvoid char_64(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(17.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,15.0)*s,vec2(15.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,16.0)*s,vec2(12.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,15.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(8.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(9.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,5.0)*s,vec2(14.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,5.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(10.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,5.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(23.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,7.0)*s,vec2(24.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,10.0)*s,vec2(24.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,12.0)*s,vec2(23.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,15.0)*s,vec2(22.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,17.0)*s,vec2(20.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,19.0)*s,vec2(18.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,20.0)*s,vec2(15.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(7.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,19.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,15.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(9.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,0.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,2.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,16.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    cpos.x+=27.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 65 :A\r\nvoid char_A(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(1.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(14.0,7.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 66 :B\r\nvoid char_B(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(18.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,4.0)*s,vec2(17.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,2.0)*s,vec2(16.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,1.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 67 :C\r\nvoid char_C(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 68 :D\r\nvoid char_D(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(17.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,16.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(17.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,5.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 69 :E\r\nvoid char_E(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 70 :F\r\nvoid char_F(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 71 :G\r\nvoid char_G(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,8.0)*s,vec2(18.0,8.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 72 :H\r\nvoid char_H(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(18.0,11.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 73 :I\r\nvoid char_I(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 74 :J\r\nvoid char_J(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,5.0)*s,vec2(11.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,2.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,2.0)*s,vec2(2.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,5.0)*s,vec2(2.0,7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 75 :K\r\nvoid char_K(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 76 :L\r\nvoid char_L(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(16.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 77 :M\r\nvoid char_M(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 78 :N\r\nvoid char_N(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 79 :O\r\nvoid char_O(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 80 :P\r\nvoid char_P(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,14.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(4.0,10.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 81 :Q\r\nvoid char_Q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,4.0)*s,vec2(18.0,-2.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 82 :R\r\nvoid char_R(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,11.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 83 :S\r\nvoid char_S(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 84 :T\r\nvoid char_T(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(15.0,21.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 85 :U\r\nvoid char_U(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(18.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 86 :V\r\nvoid char_V(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 87 :W\r\nvoid char_W(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 88 :X\r\nvoid char_X(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 89 :Y\r\nvoid char_Y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 90 :Z\r\nvoid char_Z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 91 :[\r\nvoid char_91(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(5.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(11.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-7.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 92 :\\;\r\nvoid char_92(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,21.0)*s,vec2(14.0,-3.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 93 :]\r\nvoid char_93(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(9.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(10.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(10.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 94 :^\r\nvoid char_94(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,15.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 95 :_\r\nvoid char_95(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,-2.0)*s,vec2(16.0,-2.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 96 :`\r\nvoid char_96(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(6.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,16.0)*s,vec2(5.0,17.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 97 :a\r\nvoid char_a(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 98 :b\r\nvoid char_b(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 99 :c\r\nvoid char_c(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 100 :d\r\nvoid char_d(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 101 :e\r\nvoid char_e(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(15.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,8.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 102 :f\r\nvoid char_f(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 103 :g\r\nvoid char_g(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,-2.0)*s,vec2(14.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,-5.0)*s,vec2(13.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,-6.0)*s,vec2(11.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,-7.0)*s,vec2(8.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-7.0)*s,vec2(6.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 104 :h\r\nvoid char_h(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 105 :i\r\nvoid char_i(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,22.0)*s,vec2(3.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 106 :j\r\nvoid char_j(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-3.0)*s,vec2(5.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-6.0)*s,vec2(3.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 107 :k\r\nvoid char_k(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 108 :l\r\nvoid char_l(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 109 :m\r\nvoid char_m(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(20.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,14.0)*s,vec2(23.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,14.0)*s,vec2(25.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(25.0,13.0)*s,vec2(26.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(26.0,10.0)*s,vec2(26.0,0.0)*s));\r\n    cpos.x+=30.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 110 :n\r\nvoid char_n(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 111 :o\r\nvoid char_o(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 112 :p\r\nvoid char_p(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 113 :q\r\nvoid char_q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 114 :r\r\nvoid char_r(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,11.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=13.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 115 :s\r\nvoid char_s(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(3.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(11.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,7.0)*s,vec2(13.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 116 :t\r\nvoid char_t(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 117 :u\r\nvoid char_u(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,1.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 118 :v\r\nvoid char_v(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 119 :w\r\nvoid char_w(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 120 :x\r\nvoid char_x(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 121 :y\r\nvoid char_y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(4.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-6.0)*s,vec2(2.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 122 :z\r\nvoid char_z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(14.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 123 :{\r\nvoid char_123(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,23.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(6.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(8.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,7.0)*s,vec2(9.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,5.0)*s,vec2(9.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,3.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(6.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-2.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(8.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,6.0)*s,vec2(8.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(6.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(9.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n// CHAR: 124 :|\r\nvoid char_124(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n// CHAR: 125 :}\r\nvoid char_125(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,23.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(9.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,19.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(6.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,22.0)*s,vec2(8.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(10.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,9.0)*s,vec2(6.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,7.0)*s,vec2(5.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(8.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-2.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(6.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,6.0)*s,vec2(6.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-1.0)*s,vec2(9.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-3.0)*s,vec2(8.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(5.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 126 :~\r\nvoid char_126(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(14.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,8.0)*s,vec2(16.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(20.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,8.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(10.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,10.0)*s,vec2(14.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,7.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(20.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,7.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,10.0)*s,vec2(21.0,12.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n vec3 abc(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n    \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_A(uv,s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_B(uv,s);\r\n    \r\n\tchar_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_C(uv-vec2(-0.01,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    char_D(uv-vec2(-0.02,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    \r\n    \r\n    char_E(uv-vec2(-0.03,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_F(uv-vec2(-0.04,0.0),s);\r\n    \r\n    char_G(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_H(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_I(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_J(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_K(uv-vec2(-1.1,-0.12),s);\r\n\t\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_L(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_M(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n\tchar_N(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n\tchar_O(uv-vec2(-2.15,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n  \r\n\tchar_P(uv-vec2(-2.13,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\tchar_Q(uv-vec2(-2.1,-0.223),s);\r\n     \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n\tchar_R(uv-vec2(-2.08,-0.223),s);\r\n    \r\n    char_S(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n    char_T(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_U(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n    char_V(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_X(uv-vec2(-3.17,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_W(uv-vec2(-3.18,-0.34),s);\r\n    \r\n    char_Y(uv-vec2(-4.23,-0.45),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_z(uv-vec2(-4.23,-0.44),s);\r\n\r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\nvec3 help(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n     \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_H(uv,s);\r\n    char_E(uv,s);\r\n    char_L(uv,s);\r\n    char_P(uv,s);\r\n\r\n    \r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\n#define AA 1\r\nmat2 Rot(float a) {\r\n    float s = sin(a);\r\n    float c = cos(a);\r\n    return mat2(vec2(c, -s),vec2( s, c));\r\n}\r\nfloat sdBox( in vec2 p, in vec2 b )\r\n{\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nvec3 scene(vec2 p,vec2 iResolution,vec2 mouse){\r\n    vec3 col;\r\n   \r\n   p/=vec2(0.5);\r\n   mouse/=vec2(0.5);\r\n   mouse.y+=0.9;\r\n   p.y+=0.9;\r\n    \r\n  \r\n   float linha[15];\r\n   linha[0]=sdBox(p,vec2(1.8,0.01));\r\n   linha[1]=sdBox(p+vec2(0.0,0.33),vec2(1.8,0.01));\r\n   linha[2]=sdBox(p+vec2(0.0,0.66),vec2(1.8,0.01));\r\n   linha[3]=sdBox(p+vec2(0.0,-0.33),vec2(1.8,0.01));\r\n   linha[4]=sdBox(p+vec2(0.0,-0.66),vec2(1.8,0.01));\r\n   \r\n   \r\n   linha[5]=sdBox(p,vec2(0.01,1.0));\r\n   linha[6]=sdBox(p+vec2(0.60,0.0),vec2(0.01,1.0));\r\n   linha[7]=sdBox(p+vec2(1.2,0.0),vec2(0.01,1.0));\r\n   linha[8]=sdBox(p+vec2(-0.60,0.0),vec2(0.01,1.0));\r\n   linha[9]=sdBox(p+vec2(-1.20,0.0),vec2(0.01,1.0));\r\n    \r\n   linha[10]=sdBox(p+vec2(0.0,-1.0),vec2(1.8,0.01));\r\n   linha[11]=sdBox(p+vec2(0.0,1.0),vec2(1.8,0.01));\r\n   linha[12]=sdBox(p+vec2(-1.8,0.0),vec2(0.01,1.0));\r\n   linha[14]=sdBox(p+vec2(1.8,0.0),vec2(0.01,1.0));\r\n    \r\n    \r\n   float painel[26];\r\n   painel[0]=sdBox(p+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   painel[1]=sdBox(p+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   painel[2]=sdBox(p+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   painel[3]=sdBox(p+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   painel[4]=sdBox(p+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   painel[5]=sdBox(p+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   painel[6]=sdBox(p+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   painel[7]=sdBox(p+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[8]=sdBox(p+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[9]=sdBox(p+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[10]=sdBox(p+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[11]=sdBox(p+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   painel[12]=sdBox(p+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   painel[13]=sdBox(p+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[14]=sdBox(p+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[15]=sdBox(p+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[16]=sdBox(p+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[17]=sdBox(p+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   painel[18]=sdBox(p+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   painel[19]=sdBox(p+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   painel[20]=sdBox(p+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   painel[21]=sdBox(p+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   painel[22]=sdBox(p+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   painel[23]=sdBox(p+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   painel[24]=sdBox(p+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   painel[25]=sdBox(p+vec2(0.9,0.5),vec2(0.28,0.17)); \r\n    \r\n   float regiao[26];\r\n    \r\n   col=abc(p,iResolution,  vec3(0.82));\r\n   regiao[0]=sdBox(mouse+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   regiao[1]=sdBox(mouse+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[2]=sdBox(mouse+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[3]=sdBox(mouse+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[4]=sdBox(mouse+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[5]=sdBox(mouse+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   regiao[6]=sdBox(mouse+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   regiao[7]=sdBox(mouse+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[8]=sdBox(mouse+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[9]=sdBox(mouse+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[10]=sdBox(mouse+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[11]=sdBox(mouse+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   regiao[12]=sdBox(mouse+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   regiao[13]=sdBox(mouse+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[14]=sdBox(mouse+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[15]=sdBox(mouse+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[16]=sdBox(mouse+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[17]=sdBox(mouse+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   regiao[18]=sdBox(mouse+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   regiao[19]=sdBox(mouse+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[20]=sdBox(mouse+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   regiao[21]=sdBox(mouse+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   regiao[22]=sdBox(mouse+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[23]=sdBox(mouse+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   regiao[24]=sdBox(mouse+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   regiao[25]=sdBox(mouse+vec2(0.9,0.5),vec2(0.28,0.17));  \r\n    vec3 t=vec3(0.0);\r\n    float Output=sdBox(p-vec2(0.0,2.0),vec2(3.0,0.5));\r\n   \r\n   if(Output < 0.0) col=vec3(1.0);\r\n   \r\n    float caractere[24];\r\n    \r\n    caractere[0]=sdBox(p+vec2(0.0,-2.0),vec2(0.5,.5));\r\n\r\n    for(int i=0;i<painel.length();i++){\r\n   \t if(regiao[i]<=0.0 ){\r\n\r\n      \t  if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.1));\r\n         t=vec3(0.0,1.0,0.0);\r\n\r\n  \t  }else{ \r\n    \t    if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.82));\r\n   \t }\r\n\r\n    }\r\n    for(int i=0;i<linha.length();i++){\r\n  \r\n  \t\tif(linha[i] < 0.0) col=vec3(0.0);\r\n  \r\n    }\r\n   if(caractere[0] < 0.0) col=help(p+vec2(-1.2,-1.0),iResolution,  vec3(0.82));\r\n   return col;\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec3 tot = vec3(0.0);\r\n  \r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n     // pixel coordinates\r\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n     vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;   \r\n     vec2 mouse = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;   \r\n \t vec3 col=vec3(0.0);\r\n  \r\n  \t  col *= 1.5 - 0.2*length(p);\r\n      col = col*vec3(1.11,0.89,0.79);\r\n    \r\n      col=scene(p,iResolution.xy,mouse);\r\n        \r\n         tot += col;\r\n    }\r\n    \r\n    tot /= float(AA*AA);\r\n    \r\n  fragColor = vec4(tot,1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"//Font liberated from http://paulbourke.net/dataformats/hershey/\r\n\r\nfloat res=0.;\r\nvec2 cpos=vec2(0.);\r\n\r\nfloat antiAlias(float x,vec2 iResolution) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.);}\r\n\r\n#define PI 3.14159265359\r\n\r\n//float opU( float d1, float d2 )\r\n//{\r\n//    return max(d1,d2);\r\n//}\r\n#define opU(a,b) max(a,b)\r\n\r\nfloat width;\r\n\r\nfloat line( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p - a;\r\n    vec2 ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    float d = length( pa - ba*h );\r\n\r\n    return  1.00 + width - d;\r\n}\r\n// CHAR: 32 : \r\nvoid char_32(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 33 :!\r\nvoid char_33(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 34 :\"\r\nvoid char_34(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 35 :#\r\nvoid char_35(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(18.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(17.0,6.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 36 :$\r\nvoid char_36(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,25.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,25.0)*s,vec2(12.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 37 :%\r\nvoid char_37(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(21.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,19.0)*s,vec2(10.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(6.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,20.0)*s,vec2(13.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,19.0)*s,vec2(16.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,19.0)*s,vec2(19.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,20.0)*s,vec2(21.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(15.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,2.0)*s,vec2(16.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,0.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,0.0)*s,vec2(20.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,1.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,3.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(19.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,7.0)*s,vec2(17.0,7.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 38 :&\r\nvoid char_38(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(23.0,12.0)*s,vec2(23.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,13.0)*s,vec2(22.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,14.0)*s,vec2(21.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,14.0)*s,vec2(20.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,13.0)*s,vec2(19.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,11.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,9.0)*s,vec2(12.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,13.0)*s,vec2(13.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,14.0)*s,vec2(14.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,16.0)*s,vec2(14.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,18.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(8.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,16.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(11.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,10.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,0.0)*s,vec2(22.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,0.0)*s,vec2(23.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,1.0)*s,vec2(23.0,2.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 39 :'\r\nvoid char_39(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(6.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,18.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,15.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 40 :(\r\nvoid char_40(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(9.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(9.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-5.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 41 :)\r\nvoid char_41(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(5.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(9.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,16.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(10.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,7.0)*s,vec2(9.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(5.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-5.0)*s,vec2(3.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 42 :*\r\nvoid char_42(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(3.0,12.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 43 :+\r\nvoid char_43(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 44 :,\r\nvoid char_44(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 45 :-\r\nvoid char_45(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 46 :.\r\nvoid char_46(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 47 :/\r\nvoid char_47(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,25.0)*s,vec2(2.0,-7.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 48 :0\r\nvoid char_0(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,4.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 49 :1\r\nvoid char_1(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(11.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 50 :2\r\nvoid char_2(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(15.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,19.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(16.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,15.0)*s,vec2(15.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,13.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 51 :3\r\nvoid char_3(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(16.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,21.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 52 :4\r\nvoid char_4(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(13.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 53 :5\r\nvoid char_5(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 54 :6\r\nvoid char_6(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(11.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,13.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(5.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,10.0)*s,vec2(4.0,7.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 55 :7\r\nvoid char_7(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 56 :8\r\nvoid char_8(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(11.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,12.0)*s,vec2(14.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(17.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,4.0)*s,vec2(16.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,2.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(9.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(16.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,16.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 57 :9\r\nvoid char_9(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,9.0)*s,vec2(10.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,8.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(6.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,9.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(3.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,15.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(15.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,18.0)*s,vec2(16.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,4.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 58 ::\r\nvoid char_58(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 59 :;\r\nvoid char_59(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 60 :<\r\nvoid char_60(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,18.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 61 :=\r\nvoid char_61(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(22.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(22.0,6.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 62 :>\r\nvoid char_62(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(20.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,9.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 63 :?\r\nvoid char_63(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,17.0)*s,vec2(4.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,19.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(14.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,19.0)*s,vec2(15.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,17.0)*s,vec2(15.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,15.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,12.0)*s,vec2(9.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,10.0)*s,vec2(9.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(9.0,2.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 64 :@\r\nvoid char_64(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(17.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,15.0)*s,vec2(15.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,16.0)*s,vec2(12.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,15.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(8.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(9.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,5.0)*s,vec2(14.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,5.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(10.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,5.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(23.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,7.0)*s,vec2(24.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,10.0)*s,vec2(24.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,12.0)*s,vec2(23.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,15.0)*s,vec2(22.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,17.0)*s,vec2(20.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,19.0)*s,vec2(18.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,20.0)*s,vec2(15.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(7.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,19.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,15.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(9.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,0.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,2.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,16.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    cpos.x+=27.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 65 :A\r\nvoid char_A(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(1.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(14.0,7.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 66 :B\r\nvoid char_B(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(18.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,4.0)*s,vec2(17.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,2.0)*s,vec2(16.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,1.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 67 :C\r\nvoid char_C(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 68 :D\r\nvoid char_D(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(17.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,16.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(17.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,5.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 69 :E\r\nvoid char_E(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 70 :F\r\nvoid char_F(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 71 :G\r\nvoid char_G(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,8.0)*s,vec2(18.0,8.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 72 :H\r\nvoid char_H(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(18.0,11.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 73 :I\r\nvoid char_I(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 74 :J\r\nvoid char_J(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,5.0)*s,vec2(11.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,2.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,2.0)*s,vec2(2.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,5.0)*s,vec2(2.0,7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 75 :K\r\nvoid char_K(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 76 :L\r\nvoid char_L(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(16.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 77 :M\r\nvoid char_M(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 78 :N\r\nvoid char_N(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 79 :O\r\nvoid char_O(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 80 :P\r\nvoid char_P(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,14.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(4.0,10.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 81 :Q\r\nvoid char_Q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,4.0)*s,vec2(18.0,-2.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 82 :R\r\nvoid char_R(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,11.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 83 :S\r\nvoid char_S(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 84 :T\r\nvoid char_T(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(15.0,21.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 85 :U\r\nvoid char_U(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(18.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 86 :V\r\nvoid char_V(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 87 :W\r\nvoid char_W(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 88 :X\r\nvoid char_X(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 89 :Y\r\nvoid char_Y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 90 :Z\r\nvoid char_Z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 91 :[\r\nvoid char_91(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(5.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(11.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-7.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 92 :\\;\r\nvoid char_92(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,21.0)*s,vec2(14.0,-3.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 93 :]\r\nvoid char_93(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(9.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(10.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(10.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 94 :^\r\nvoid char_94(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,15.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 95 :_\r\nvoid char_95(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,-2.0)*s,vec2(16.0,-2.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 96 :`\r\nvoid char_96(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(6.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,16.0)*s,vec2(5.0,17.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 97 :a\r\nvoid char_a(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 98 :b\r\nvoid char_b(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 99 :c\r\nvoid char_c(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 100 :d\r\nvoid char_d(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 101 :e\r\nvoid char_e(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(15.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,8.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 102 :f\r\nvoid char_f(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 103 :g\r\nvoid char_g(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,-2.0)*s,vec2(14.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,-5.0)*s,vec2(13.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,-6.0)*s,vec2(11.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,-7.0)*s,vec2(8.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-7.0)*s,vec2(6.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 104 :h\r\nvoid char_h(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 105 :i\r\nvoid char_i(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,22.0)*s,vec2(3.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 106 :j\r\nvoid char_j(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-3.0)*s,vec2(5.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-6.0)*s,vec2(3.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 107 :k\r\nvoid char_k(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 108 :l\r\nvoid char_l(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 109 :m\r\nvoid char_m(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(20.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,14.0)*s,vec2(23.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,14.0)*s,vec2(25.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(25.0,13.0)*s,vec2(26.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(26.0,10.0)*s,vec2(26.0,0.0)*s));\r\n    cpos.x+=30.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 110 :n\r\nvoid char_n(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 111 :o\r\nvoid char_o(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 112 :p\r\nvoid char_p(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 113 :q\r\nvoid char_q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 114 :r\r\nvoid char_r(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,11.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=13.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 115 :s\r\nvoid char_s(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(3.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(11.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,7.0)*s,vec2(13.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 116 :t\r\nvoid char_t(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 117 :u\r\nvoid char_u(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,1.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 118 :v\r\nvoid char_v(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 119 :w\r\nvoid char_w(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 120 :x\r\nvoid char_x(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 121 :y\r\nvoid char_y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(4.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-6.0)*s,vec2(2.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 122 :z\r\nvoid char_z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(14.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 123 :{\r\nvoid char_123(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,23.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(6.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(8.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,7.0)*s,vec2(9.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,5.0)*s,vec2(9.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,3.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(6.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-2.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(8.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,6.0)*s,vec2(8.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(6.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(9.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n// CHAR: 124 :|\r\nvoid char_124(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n// CHAR: 125 :}\r\nvoid char_125(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,23.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(9.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,19.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(6.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,22.0)*s,vec2(8.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(10.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,9.0)*s,vec2(6.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,7.0)*s,vec2(5.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(8.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-2.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(6.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,6.0)*s,vec2(6.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-1.0)*s,vec2(9.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-3.0)*s,vec2(8.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(5.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 126 :~\r\nvoid char_126(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(14.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,8.0)*s,vec2(16.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(20.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,8.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(10.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,10.0)*s,vec2(14.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,7.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(20.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,7.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,10.0)*s,vec2(21.0,12.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n vec3 abc(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n    \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_A(uv,s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_B(uv,s);\r\n    \r\n\tchar_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_C(uv-vec2(-0.01,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    char_D(uv-vec2(-0.02,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    \r\n    \r\n    char_E(uv-vec2(-0.03,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_F(uv-vec2(-0.04,0.0),s);\r\n    \r\n    char_G(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_H(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_I(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_J(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_K(uv-vec2(-1.1,-0.12),s);\r\n\t\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_L(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_M(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n\tchar_N(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n\tchar_O(uv-vec2(-2.15,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n  \r\n\tchar_P(uv-vec2(-2.13,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\tchar_Q(uv-vec2(-2.1,-0.223),s);\r\n     \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n\tchar_R(uv-vec2(-2.08,-0.223),s);\r\n    \r\n    char_S(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n    char_T(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_U(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n    char_V(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_X(uv-vec2(-3.17,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_W(uv-vec2(-3.18,-0.34),s);\r\n    \r\n    char_Y(uv-vec2(-4.23,-0.45),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_z(uv-vec2(-4.23,-0.44),s);\r\n\r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\nvec3 help(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n     \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_H(uv,s);\r\n    char_E(uv,s);\r\n    char_L(uv,s);\r\n    char_P(uv,s);\r\n\r\n    \r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\n#define AA 1\r\nmat2 Rot(float a) {\r\n    float s = sin(a);\r\n    float c = cos(a);\r\n    return mat2(vec2(c, -s),vec2( s, c));\r\n}\r\nfloat sdBox( in vec2 p, in vec2 b )\r\n{\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nvec3 scene(vec2 p,vec2 iResolution,vec2 mouse){\r\n    vec3 col;\r\n   \r\n   p/=vec2(0.5);\r\n   mouse/=vec2(0.5);\r\n   mouse.y+=0.9;\r\n   p.y+=0.9;\r\n    \r\n  \r\n   float linha[15];\r\n   linha[0]=sdBox(p,vec2(1.8,0.01));\r\n   linha[1]=sdBox(p+vec2(0.0,0.33),vec2(1.8,0.01));\r\n   linha[2]=sdBox(p+vec2(0.0,0.66),vec2(1.8,0.01));\r\n   linha[3]=sdBox(p+vec2(0.0,-0.33),vec2(1.8,0.01));\r\n   linha[4]=sdBox(p+vec2(0.0,-0.66),vec2(1.8,0.01));\r\n   \r\n   \r\n   linha[5]=sdBox(p,vec2(0.01,1.0));\r\n   linha[6]=sdBox(p+vec2(0.60,0.0),vec2(0.01,1.0));\r\n   linha[7]=sdBox(p+vec2(1.2,0.0),vec2(0.01,1.0));\r\n   linha[8]=sdBox(p+vec2(-0.60,0.0),vec2(0.01,1.0));\r\n   linha[9]=sdBox(p+vec2(-1.20,0.0),vec2(0.01,1.0));\r\n    \r\n   linha[10]=sdBox(p+vec2(0.0,-1.0),vec2(1.8,0.01));\r\n   linha[11]=sdBox(p+vec2(0.0,1.0),vec2(1.8,0.01));\r\n   linha[12]=sdBox(p+vec2(-1.8,0.0),vec2(0.01,1.0));\r\n   linha[14]=sdBox(p+vec2(1.8,0.0),vec2(0.01,1.0));\r\n    \r\n    \r\n   float painel[26];\r\n   painel[0]=sdBox(p+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   painel[1]=sdBox(p+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   painel[2]=sdBox(p+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   painel[3]=sdBox(p+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   painel[4]=sdBox(p+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   painel[5]=sdBox(p+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   painel[6]=sdBox(p+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   painel[7]=sdBox(p+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[8]=sdBox(p+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[9]=sdBox(p+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[10]=sdBox(p+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[11]=sdBox(p+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   painel[12]=sdBox(p+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   painel[13]=sdBox(p+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[14]=sdBox(p+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[15]=sdBox(p+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[16]=sdBox(p+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[17]=sdBox(p+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   painel[18]=sdBox(p+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   painel[19]=sdBox(p+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   painel[20]=sdBox(p+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   painel[21]=sdBox(p+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   painel[22]=sdBox(p+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   painel[23]=sdBox(p+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   painel[24]=sdBox(p+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   painel[25]=sdBox(p+vec2(0.9,0.5),vec2(0.28,0.17)); \r\n    \r\n   float regiao[26];\r\n    \r\n   col=abc(p,iResolution,  vec3(0.82));\r\n   regiao[0]=sdBox(mouse+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   regiao[1]=sdBox(mouse+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[2]=sdBox(mouse+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[3]=sdBox(mouse+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[4]=sdBox(mouse+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[5]=sdBox(mouse+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   regiao[6]=sdBox(mouse+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   regiao[7]=sdBox(mouse+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[8]=sdBox(mouse+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[9]=sdBox(mouse+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[10]=sdBox(mouse+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[11]=sdBox(mouse+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   regiao[12]=sdBox(mouse+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   regiao[13]=sdBox(mouse+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[14]=sdBox(mouse+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[15]=sdBox(mouse+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[16]=sdBox(mouse+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[17]=sdBox(mouse+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   regiao[18]=sdBox(mouse+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   regiao[19]=sdBox(mouse+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[20]=sdBox(mouse+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   regiao[21]=sdBox(mouse+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   regiao[22]=sdBox(mouse+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[23]=sdBox(mouse+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   regiao[24]=sdBox(mouse+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   regiao[25]=sdBox(mouse+vec2(0.9,0.5),vec2(0.28,0.17));  \r\n    vec3 t=vec3(0.0);\r\n    float Output=sdBox(p-vec2(0.0,2.0),vec2(3.0,0.5));\r\n   \r\n   if(Output < 0.0) col=vec3(1.0);\r\n   \r\n    float caractere[24];\r\n    \r\n    caractere[0]=sdBox(p+vec2(0.0,-2.0),vec2(0.5,.5));\r\n\r\n    for(int i=0;i<painel.length();i++){\r\n   \t if(regiao[i]<=0.0 ){\r\n\r\n      \t  if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.1));\r\n         t=vec3(0.0,1.0,0.0);\r\n\r\n  \t  }else{ \r\n    \t    if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.82));\r\n   \t }\r\n\r\n    }\r\n    for(int i=0;i<linha.length();i++){\r\n  \r\n  \t\tif(linha[i] < 0.0) col=vec3(0.0);\r\n  \r\n    }\r\n   if(caractere[0] < 0.0) col=help(p+vec2(-1.2,-1.0),iResolution,  vec3(0.82));\r\n   return col;\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec3 tot = vec3(0.0);\r\n  \r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n     // pixel coordinates\r\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n     vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;   \r\n     vec2 mouse = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;   \r\n \t vec3 col=vec3(0.0);\r\n  \r\n  \t  col *= 1.5 - 0.2*length(p);\r\n      col = col*vec3(1.11,0.89,0.79);\r\n    \r\n      col=scene(p,iResolution.xy,mouse);\r\n        \r\n         tot += col;\r\n    }\r\n    \r\n    tot /= float(AA*AA);\r\n    \r\n  fragColor = vec4(tot,1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"virtual keyboard","id":"45a5dadf907b4dca8e5ae5beeac82b46","date":null,"viewed":0,"name":"virtual keyboard","description":"virtual keyboard\r\nhttps://www.shadertoy.com/view/3d3fD4","likes":0,"published":null,"tags":["keyboard"," virtual"]},"ver":null,"info":{"Name":"virtual keyboard","id":"45a5dadf907b4dca8e5ae5beeac82b46","date":null,"viewed":0,"name":"virtual keyboard","description":"virtual keyboard\r\nhttps://www.shadertoy.com/view/3d3fD4","likes":0,"published":null,"tags":["keyboard"," virtual"]},"renderpass":[{"Code":"//Font liberated from http://paulbourke.net/dataformats/hershey/\r\n\r\nfloat res=0.;\r\nvec2 cpos=vec2(0.);\r\n\r\nfloat antiAlias(float x,vec2 iResolution) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.);}\r\n\r\n#define PI 3.14159265359\r\n\r\n//float opU( float d1, float d2 )\r\n//{\r\n//    return max(d1,d2);\r\n//}\r\n#define opU(a,b) max(a,b)\r\n\r\nfloat width;\r\n\r\nfloat line( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p - a;\r\n    vec2 ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    float d = length( pa - ba*h );\r\n\r\n    return  1.00 + width - d;\r\n}\r\n// CHAR: 32 : \r\nvoid char_32(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 33 :!\r\nvoid char_33(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 34 :\"\r\nvoid char_34(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 35 :#\r\nvoid char_35(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(18.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(17.0,6.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 36 :$\r\nvoid char_36(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,25.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,25.0)*s,vec2(12.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 37 :%\r\nvoid char_37(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(21.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,19.0)*s,vec2(10.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(6.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,20.0)*s,vec2(13.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,19.0)*s,vec2(16.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,19.0)*s,vec2(19.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,20.0)*s,vec2(21.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(15.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,2.0)*s,vec2(16.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,0.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,0.0)*s,vec2(20.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,1.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,3.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(19.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,7.0)*s,vec2(17.0,7.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 38 :&\r\nvoid char_38(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(23.0,12.0)*s,vec2(23.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,13.0)*s,vec2(22.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,14.0)*s,vec2(21.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,14.0)*s,vec2(20.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,13.0)*s,vec2(19.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,11.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,9.0)*s,vec2(12.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,13.0)*s,vec2(13.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,14.0)*s,vec2(14.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,16.0)*s,vec2(14.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,18.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(8.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,16.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(11.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,10.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,0.0)*s,vec2(22.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,0.0)*s,vec2(23.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,1.0)*s,vec2(23.0,2.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 39 :'\r\nvoid char_39(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(6.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,18.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,15.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 40 :(\r\nvoid char_40(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(9.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(9.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-5.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 41 :)\r\nvoid char_41(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(5.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(9.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,16.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(10.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,7.0)*s,vec2(9.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(5.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-5.0)*s,vec2(3.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 42 :*\r\nvoid char_42(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(3.0,12.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 43 :+\r\nvoid char_43(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 44 :,\r\nvoid char_44(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 45 :-\r\nvoid char_45(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 46 :.\r\nvoid char_46(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 47 :/\r\nvoid char_47(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,25.0)*s,vec2(2.0,-7.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 48 :0\r\nvoid char_0(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,4.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 49 :1\r\nvoid char_1(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(11.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 50 :2\r\nvoid char_2(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(15.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,19.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(16.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,15.0)*s,vec2(15.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,13.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 51 :3\r\nvoid char_3(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(16.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,21.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 52 :4\r\nvoid char_4(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(13.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 53 :5\r\nvoid char_5(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 54 :6\r\nvoid char_6(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(11.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,13.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(5.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,10.0)*s,vec2(4.0,7.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 55 :7\r\nvoid char_7(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 56 :8\r\nvoid char_8(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(11.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,12.0)*s,vec2(14.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(17.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,4.0)*s,vec2(16.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,2.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(9.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(16.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,16.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 57 :9\r\nvoid char_9(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,9.0)*s,vec2(10.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,8.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(6.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,9.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(3.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,15.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(15.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,18.0)*s,vec2(16.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,4.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 58 ::\r\nvoid char_58(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 59 :;\r\nvoid char_59(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 60 :<\r\nvoid char_60(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,18.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 61 :=\r\nvoid char_61(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(22.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(22.0,6.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 62 :>\r\nvoid char_62(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(20.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,9.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 63 :?\r\nvoid char_63(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,17.0)*s,vec2(4.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,19.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(14.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,19.0)*s,vec2(15.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,17.0)*s,vec2(15.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,15.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,12.0)*s,vec2(9.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,10.0)*s,vec2(9.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(9.0,2.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 64 :@\r\nvoid char_64(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(17.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,15.0)*s,vec2(15.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,16.0)*s,vec2(12.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,15.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(8.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(9.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,5.0)*s,vec2(14.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,5.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(10.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,5.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(23.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,7.0)*s,vec2(24.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,10.0)*s,vec2(24.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,12.0)*s,vec2(23.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,15.0)*s,vec2(22.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,17.0)*s,vec2(20.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,19.0)*s,vec2(18.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,20.0)*s,vec2(15.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(7.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,19.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,15.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(9.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,0.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,2.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,16.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    cpos.x+=27.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 65 :A\r\nvoid char_A(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(1.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(14.0,7.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 66 :B\r\nvoid char_B(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(18.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,4.0)*s,vec2(17.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,2.0)*s,vec2(16.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,1.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 67 :C\r\nvoid char_C(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 68 :D\r\nvoid char_D(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(17.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,16.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(17.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,5.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 69 :E\r\nvoid char_E(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 70 :F\r\nvoid char_F(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 71 :G\r\nvoid char_G(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,8.0)*s,vec2(18.0,8.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 72 :H\r\nvoid char_H(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(18.0,11.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 73 :I\r\nvoid char_I(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 74 :J\r\nvoid char_J(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,5.0)*s,vec2(11.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,2.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,2.0)*s,vec2(2.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,5.0)*s,vec2(2.0,7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 75 :K\r\nvoid char_K(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 76 :L\r\nvoid char_L(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(16.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 77 :M\r\nvoid char_M(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 78 :N\r\nvoid char_N(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 79 :O\r\nvoid char_O(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 80 :P\r\nvoid char_P(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,14.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(4.0,10.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 81 :Q\r\nvoid char_Q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,4.0)*s,vec2(18.0,-2.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 82 :R\r\nvoid char_R(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,11.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 83 :S\r\nvoid char_S(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 84 :T\r\nvoid char_T(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(15.0,21.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 85 :U\r\nvoid char_U(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(18.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 86 :V\r\nvoid char_V(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 87 :W\r\nvoid char_W(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 88 :X\r\nvoid char_X(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 89 :Y\r\nvoid char_Y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 90 :Z\r\nvoid char_Z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 91 :[\r\nvoid char_91(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(5.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(11.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-7.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 92 :\\;\r\nvoid char_92(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,21.0)*s,vec2(14.0,-3.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 93 :]\r\nvoid char_93(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(9.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(10.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(10.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 94 :^\r\nvoid char_94(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,15.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 95 :_\r\nvoid char_95(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,-2.0)*s,vec2(16.0,-2.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 96 :`\r\nvoid char_96(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(6.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,16.0)*s,vec2(5.0,17.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 97 :a\r\nvoid char_a(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 98 :b\r\nvoid char_b(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 99 :c\r\nvoid char_c(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 100 :d\r\nvoid char_d(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 101 :e\r\nvoid char_e(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(15.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,8.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 102 :f\r\nvoid char_f(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 103 :g\r\nvoid char_g(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,-2.0)*s,vec2(14.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,-5.0)*s,vec2(13.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,-6.0)*s,vec2(11.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,-7.0)*s,vec2(8.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-7.0)*s,vec2(6.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 104 :h\r\nvoid char_h(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 105 :i\r\nvoid char_i(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,22.0)*s,vec2(3.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 106 :j\r\nvoid char_j(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-3.0)*s,vec2(5.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-6.0)*s,vec2(3.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 107 :k\r\nvoid char_k(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 108 :l\r\nvoid char_l(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 109 :m\r\nvoid char_m(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(20.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,14.0)*s,vec2(23.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,14.0)*s,vec2(25.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(25.0,13.0)*s,vec2(26.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(26.0,10.0)*s,vec2(26.0,0.0)*s));\r\n    cpos.x+=30.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 110 :n\r\nvoid char_n(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 111 :o\r\nvoid char_o(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 112 :p\r\nvoid char_p(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 113 :q\r\nvoid char_q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 114 :r\r\nvoid char_r(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,11.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=13.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 115 :s\r\nvoid char_s(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(3.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(11.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,7.0)*s,vec2(13.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 116 :t\r\nvoid char_t(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 117 :u\r\nvoid char_u(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,1.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 118 :v\r\nvoid char_v(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 119 :w\r\nvoid char_w(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 120 :x\r\nvoid char_x(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 121 :y\r\nvoid char_y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(4.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-6.0)*s,vec2(2.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 122 :z\r\nvoid char_z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(14.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 123 :{\r\nvoid char_123(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,23.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(6.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(8.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,7.0)*s,vec2(9.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,5.0)*s,vec2(9.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,3.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(6.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-2.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(8.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,6.0)*s,vec2(8.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(6.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(9.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n// CHAR: 124 :|\r\nvoid char_124(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n// CHAR: 125 :}\r\nvoid char_125(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,23.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(9.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,19.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(6.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,22.0)*s,vec2(8.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(10.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,9.0)*s,vec2(6.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,7.0)*s,vec2(5.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(8.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-2.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(6.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,6.0)*s,vec2(6.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-1.0)*s,vec2(9.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-3.0)*s,vec2(8.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(5.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 126 :~\r\nvoid char_126(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(14.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,8.0)*s,vec2(16.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(20.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,8.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(10.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,10.0)*s,vec2(14.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,7.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(20.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,7.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,10.0)*s,vec2(21.0,12.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n vec3 abc(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n    \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_A(uv,s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_B(uv,s);\r\n    \r\n\tchar_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_C(uv-vec2(-0.01,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    char_D(uv-vec2(-0.02,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    \r\n    \r\n    char_E(uv-vec2(-0.03,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_F(uv-vec2(-0.04,0.0),s);\r\n    \r\n    char_G(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_H(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_I(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_J(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_K(uv-vec2(-1.1,-0.12),s);\r\n\t\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_L(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_M(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n\tchar_N(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n\tchar_O(uv-vec2(-2.15,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n  \r\n\tchar_P(uv-vec2(-2.13,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\tchar_Q(uv-vec2(-2.1,-0.223),s);\r\n     \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n\tchar_R(uv-vec2(-2.08,-0.223),s);\r\n    \r\n    char_S(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n    char_T(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_U(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n    char_V(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_X(uv-vec2(-3.17,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_W(uv-vec2(-3.18,-0.34),s);\r\n    \r\n    char_Y(uv-vec2(-4.23,-0.45),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_z(uv-vec2(-4.23,-0.44),s);\r\n\r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\nvec3 help(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n     \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_H(uv,s);\r\n    char_E(uv,s);\r\n    char_L(uv,s);\r\n    char_P(uv,s);\r\n\r\n    \r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\n#define AA 1\r\nmat2 Rot(float a) {\r\n    float s = sin(a);\r\n    float c = cos(a);\r\n    return mat2(vec2(c, -s),vec2( s, c));\r\n}\r\nfloat sdBox( in vec2 p, in vec2 b )\r\n{\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nvec3 scene(vec2 p,vec2 iResolution,vec2 mouse){\r\n    vec3 col;\r\n   \r\n   p/=vec2(0.5);\r\n   mouse/=vec2(0.5);\r\n   mouse.y+=0.9;\r\n   p.y+=0.9;\r\n    \r\n  \r\n   float linha[15];\r\n   linha[0]=sdBox(p,vec2(1.8,0.01));\r\n   linha[1]=sdBox(p+vec2(0.0,0.33),vec2(1.8,0.01));\r\n   linha[2]=sdBox(p+vec2(0.0,0.66),vec2(1.8,0.01));\r\n   linha[3]=sdBox(p+vec2(0.0,-0.33),vec2(1.8,0.01));\r\n   linha[4]=sdBox(p+vec2(0.0,-0.66),vec2(1.8,0.01));\r\n   \r\n   \r\n   linha[5]=sdBox(p,vec2(0.01,1.0));\r\n   linha[6]=sdBox(p+vec2(0.60,0.0),vec2(0.01,1.0));\r\n   linha[7]=sdBox(p+vec2(1.2,0.0),vec2(0.01,1.0));\r\n   linha[8]=sdBox(p+vec2(-0.60,0.0),vec2(0.01,1.0));\r\n   linha[9]=sdBox(p+vec2(-1.20,0.0),vec2(0.01,1.0));\r\n    \r\n   linha[10]=sdBox(p+vec2(0.0,-1.0),vec2(1.8,0.01));\r\n   linha[11]=sdBox(p+vec2(0.0,1.0),vec2(1.8,0.01));\r\n   linha[12]=sdBox(p+vec2(-1.8,0.0),vec2(0.01,1.0));\r\n   linha[14]=sdBox(p+vec2(1.8,0.0),vec2(0.01,1.0));\r\n    \r\n    \r\n   float painel[26];\r\n   painel[0]=sdBox(p+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   painel[1]=sdBox(p+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   painel[2]=sdBox(p+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   painel[3]=sdBox(p+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   painel[4]=sdBox(p+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   painel[5]=sdBox(p+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   painel[6]=sdBox(p+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   painel[7]=sdBox(p+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[8]=sdBox(p+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[9]=sdBox(p+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[10]=sdBox(p+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[11]=sdBox(p+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   painel[12]=sdBox(p+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   painel[13]=sdBox(p+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[14]=sdBox(p+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[15]=sdBox(p+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[16]=sdBox(p+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[17]=sdBox(p+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   painel[18]=sdBox(p+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   painel[19]=sdBox(p+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   painel[20]=sdBox(p+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   painel[21]=sdBox(p+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   painel[22]=sdBox(p+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   painel[23]=sdBox(p+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   painel[24]=sdBox(p+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   painel[25]=sdBox(p+vec2(0.9,0.5),vec2(0.28,0.17)); \r\n    \r\n   float regiao[26];\r\n    \r\n   col=abc(p,iResolution,  vec3(0.82));\r\n   regiao[0]=sdBox(mouse+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   regiao[1]=sdBox(mouse+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[2]=sdBox(mouse+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[3]=sdBox(mouse+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[4]=sdBox(mouse+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[5]=sdBox(mouse+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   regiao[6]=sdBox(mouse+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   regiao[7]=sdBox(mouse+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[8]=sdBox(mouse+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[9]=sdBox(mouse+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[10]=sdBox(mouse+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[11]=sdBox(mouse+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   regiao[12]=sdBox(mouse+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   regiao[13]=sdBox(mouse+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[14]=sdBox(mouse+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[15]=sdBox(mouse+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[16]=sdBox(mouse+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[17]=sdBox(mouse+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   regiao[18]=sdBox(mouse+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   regiao[19]=sdBox(mouse+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[20]=sdBox(mouse+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   regiao[21]=sdBox(mouse+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   regiao[22]=sdBox(mouse+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[23]=sdBox(mouse+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   regiao[24]=sdBox(mouse+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   regiao[25]=sdBox(mouse+vec2(0.9,0.5),vec2(0.28,0.17));  \r\n    vec3 t=vec3(0.0);\r\n    float Output=sdBox(p-vec2(0.0,2.0),vec2(3.0,0.5));\r\n   \r\n   if(Output < 0.0) col=vec3(1.0);\r\n   \r\n    float caractere[24];\r\n    \r\n    caractere[0]=sdBox(p+vec2(0.0,-2.0),vec2(0.5,.5));\r\n\r\n    for(int i=0;i<painel.length();i++){\r\n   \t if(regiao[i]<=0.0 ){\r\n\r\n      \t  if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.1));\r\n         t=vec3(0.0,1.0,0.0);\r\n\r\n  \t  }else{ \r\n    \t    if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.82));\r\n   \t }\r\n\r\n    }\r\n    for(int i=0;i<linha.length();i++){\r\n  \r\n  \t\tif(linha[i] < 0.0) col=vec3(0.0);\r\n  \r\n    }\r\n   if(caractere[0] < 0.0) col=help(p+vec2(-1.2,-1.0),iResolution,  vec3(0.82));\r\n   return col;\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec3 tot = vec3(0.0);\r\n  \r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n     // pixel coordinates\r\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n     vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;   \r\n     vec2 mouse = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;   \r\n \t vec3 col=vec3(0.0);\r\n  \r\n  \t  col *= 1.5 - 0.2*length(p);\r\n      col = col*vec3(1.11,0.89,0.79);\r\n    \r\n      col=scene(p,iResolution.xy,mouse);\r\n        \r\n         tot += col;\r\n    }\r\n    \r\n    tot /= float(AA*AA);\r\n    \r\n  fragColor = vec4(tot,1.0);\r\n}\r\n","inputs":[],"outputs":[],"code":"//Font liberated from http://paulbourke.net/dataformats/hershey/\r\n\r\nfloat res=0.;\r\nvec2 cpos=vec2(0.);\r\n\r\nfloat antiAlias(float x,vec2 iResolution) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.);}\r\n\r\n#define PI 3.14159265359\r\n\r\n//float opU( float d1, float d2 )\r\n//{\r\n//    return max(d1,d2);\r\n//}\r\n#define opU(a,b) max(a,b)\r\n\r\nfloat width;\r\n\r\nfloat line( in vec2 p, in vec2 a, in vec2 b )\r\n{\r\n    vec2 pa = p - a;\r\n    vec2 ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    float d = length( pa - ba*h );\r\n\r\n    return  1.00 + width - d;\r\n}\r\n// CHAR: 32 : \r\nvoid char_32(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 33 :!\r\nvoid char_33(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 34 :\"\r\nvoid char_34(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 35 :#\r\nvoid char_35(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(18.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(17.0,6.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 36 :$\r\nvoid char_36(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,25.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,25.0)*s,vec2(12.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 37 :%\r\nvoid char_37(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(21.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,19.0)*s,vec2(10.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(6.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(10.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,20.0)*s,vec2(13.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,19.0)*s,vec2(16.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,19.0)*s,vec2(19.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,20.0)*s,vec2(21.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(15.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,2.0)*s,vec2(16.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,0.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,0.0)*s,vec2(20.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,1.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,3.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(19.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,7.0)*s,vec2(17.0,7.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 38 :&\r\nvoid char_38(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(23.0,12.0)*s,vec2(23.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,13.0)*s,vec2(22.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,14.0)*s,vec2(21.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,14.0)*s,vec2(20.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,13.0)*s,vec2(19.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,11.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,9.0)*s,vec2(12.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,13.0)*s,vec2(13.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,14.0)*s,vec2(14.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,16.0)*s,vec2(14.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,18.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(8.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,16.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(11.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,10.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,0.0)*s,vec2(22.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,0.0)*s,vec2(23.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,1.0)*s,vec2(23.0,2.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 39 :'\r\nvoid char_39(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(6.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,18.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,15.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 40 :(\r\nvoid char_40(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(11.0,25.0)*s,vec2(9.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,16.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(9.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-5.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 41 :)\r\nvoid char_41(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(5.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,23.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(9.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,16.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(10.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,7.0)*s,vec2(9.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(7.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-2.0)*s,vec2(5.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-5.0)*s,vec2(3.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 42 :*\r\nvoid char_42(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(3.0,12.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 43 :+\r\nvoid char_43(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,18.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 44 :,\r\nvoid char_44(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 45 :-\r\nvoid char_45(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(22.0,9.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 46 :.\r\nvoid char_46(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 47 :/\r\nvoid char_47(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,25.0)*s,vec2(2.0,-7.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 48 :0\r\nvoid char_0(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,4.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 49 :1\r\nvoid char_1(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(11.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 50 :2\r\nvoid char_2(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(4.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,17.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(15.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,19.0)*s,vec2(16.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,17.0)*s,vec2(16.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,15.0)*s,vec2(15.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,13.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 51 :3\r\nvoid char_3(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(16.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,21.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 52 :4\r\nvoid char_4(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(13.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 53 :5\r\nvoid char_5(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 54 :6\r\nvoid char_6(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(11.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,13.0)*s,vec2(10.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(5.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,10.0)*s,vec2(4.0,7.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 55 :7\r\nvoid char_7(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 56 :8\r\nvoid char_8(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(11.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,12.0)*s,vec2(14.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(17.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,7.0)*s,vec2(17.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,4.0)*s,vec2(16.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,2.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,2.0)*s,vec2(3.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,4.0)*s,vec2(3.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,7.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(9.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(16.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,16.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 57 :9\r\nvoid char_9(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,9.0)*s,vec2(10.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,8.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(6.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,9.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(3.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,15.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(10.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(15.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,18.0)*s,vec2(16.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,14.0)*s,vec2(16.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,9.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,4.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 58 ::\r\nvoid char_58(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 59 :;\r\nvoid char_59(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(5.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,12.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(5.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(5.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(6.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(4.0,-4.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 60 :<\r\nvoid char_60(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(20.0,18.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 61 :=\r\nvoid char_61(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,12.0)*s,vec2(22.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(22.0,6.0)*s));\r\n    cpos.x+=26.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 62 :>\r\nvoid char_62(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(20.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,9.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 63 :?\r\nvoid char_63(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(3.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,17.0)*s,vec2(4.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,19.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(13.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,20.0)*s,vec2(14.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,19.0)*s,vec2(15.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,17.0)*s,vec2(15.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,15.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,12.0)*s,vec2(9.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,10.0)*s,vec2(9.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(9.0,2.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 64 :@\r\nvoid char_64(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(17.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,15.0)*s,vec2(15.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,16.0)*s,vec2(12.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,15.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(8.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(9.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,5.0)*s,vec2(14.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,5.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,16.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,8.0)*s,vec2(10.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,6.0)*s,vec2(11.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,5.0)*s,vec2(21.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,5.0)*s,vec2(23.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,7.0)*s,vec2(24.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,10.0)*s,vec2(24.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(24.0,12.0)*s,vec2(23.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,15.0)*s,vec2(22.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,17.0)*s,vec2(20.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,19.0)*s,vec2(18.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,20.0)*s,vec2(15.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(9.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,20.0)*s,vec2(7.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,19.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(4.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,15.0)*s,vec2(3.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(3.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,9.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(9.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,0.0)*s,vec2(18.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,1.0)*s,vec2(20.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,2.0)*s,vec2(21.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,16.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(19.0,5.0)*s));\r\n    cpos.x+=27.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 65 :A\r\nvoid char_A(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(1.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,7.0)*s,vec2(14.0,7.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 66 :B\r\nvoid char_B(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(16.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,10.0)*s,vec2(17.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,9.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(18.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,4.0)*s,vec2(17.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,2.0)*s,vec2(16.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,1.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 67 :C\r\nvoid char_C(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 68 :D\r\nvoid char_D(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(11.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,21.0)*s,vec2(14.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,20.0)*s,vec2(16.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,18.0)*s,vec2(17.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,16.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,8.0)*s,vec2(17.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,5.0)*s,vec2(16.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,3.0)*s,vec2(14.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 69 :E\r\nvoid char_E(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 70 :F\r\nvoid char_F(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(12.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 71 :G\r\nvoid char_G(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(18.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,8.0)*s,vec2(18.0,8.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 72 :H\r\nvoid char_H(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(18.0,11.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 73 :I\r\nvoid char_I(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 74 :J\r\nvoid char_J(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(12.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,5.0)*s,vec2(11.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,2.0)*s,vec2(10.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,2.0)*s,vec2(2.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,5.0)*s,vec2(2.0,7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 75 :K\r\nvoid char_K(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(4.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,12.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 76 :L\r\nvoid char_L(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,0.0)*s,vec2(16.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 77 :M\r\nvoid char_M(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,21.0)*s,vec2(20.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 78 :N\r\nvoid char_N(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,21.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 79 :O\r\nvoid char_O(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 80 :P\r\nvoid char_P(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,14.0)*s,vec2(17.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,12.0)*s,vec2(16.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,11.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(4.0,10.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 81 :Q\r\nvoid char_Q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(7.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,20.0)*s,vec2(5.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(3.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,13.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,0.0)*s,vec2(13.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,5.0)*s,vec2(19.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,8.0)*s,vec2(19.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,13.0)*s,vec2(18.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,16.0)*s,vec2(17.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,4.0)*s,vec2(18.0,-2.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 82 :R\r\nvoid char_R(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(13.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,21.0)*s,vec2(16.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,20.0)*s,vec2(17.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,19.0)*s,vec2(18.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,17.0)*s,vec2(18.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,15.0)*s,vec2(17.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,13.0)*s,vec2(16.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,12.0)*s,vec2(13.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,11.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,11.0)*s,vec2(18.0,0.0)*s));\r\n    cpos.x+=21.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 83 :S\r\nvoid char_S(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,18.0)*s,vec2(15.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,20.0)*s,vec2(12.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(3.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,18.0)*s,vec2(3.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,16.0)*s,vec2(4.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(7.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,12.0)*s,vec2(13.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,10.0)*s,vec2(15.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,9.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(17.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,6.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 84 :T\r\nvoid char_T(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(15.0,21.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 85 :U\r\nvoid char_U(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,6.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(7.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,0.0)*s,vec2(15.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,1.0)*s,vec2(17.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,3.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(18.0,21.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 86 :V\r\nvoid char_V(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,0.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 87 :W\r\nvoid char_W(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(22.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 88 :X\r\nvoid char_X(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 89 :Y\r\nvoid char_Y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(1.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,11.0)*s,vec2(9.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(9.0,11.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 90 :Z\r\nvoid char_Z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(17.0,21.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(17.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(17.0,0.0)*s));\r\n    cpos.x+=20.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 91 :[\r\nvoid char_91(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(5.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(11.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-7.0)*s,vec2(11.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 92 :\\;\r\nvoid char_92(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,21.0)*s,vec2(14.0,-3.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 93 :]\r\nvoid char_93(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(9.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,25.0)*s,vec2(10.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,25.0)*s,vec2(10.0,25.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(10.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 94 :^\r\nvoid char_94(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,15.0)*s,vec2(8.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,18.0)*s,vec2(10.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,12.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(13.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 95 :_\r\nvoid char_95(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(0.0,-2.0)*s,vec2(16.0,-2.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 96 :`\r\nvoid char_96(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(6.0,21.0)*s,vec2(5.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,20.0)*s,vec2(4.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,18.0)*s,vec2(4.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,16.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(6.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,16.0)*s,vec2(5.0,17.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 97 :a\r\nvoid char_a(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 98 :b\r\nvoid char_b(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 99 :c\r\nvoid char_c(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 100 :d\r\nvoid char_d(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,21.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 101 :e\r\nvoid char_e(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(15.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,8.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(14.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,12.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=18.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 102 :f\r\nvoid char_f(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(10.0,21.0)*s,vec2(8.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(5.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,17.0)*s,vec2(5.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 103 :g\r\nvoid char_g(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,-2.0)*s,vec2(14.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,-5.0)*s,vec2(13.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,-6.0)*s,vec2(11.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,-7.0)*s,vec2(8.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-7.0)*s,vec2(6.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 104 :h\r\nvoid char_h(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 105 :i\r\nvoid char_i(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,21.0)*s,vec2(4.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,20.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(4.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,22.0)*s,vec2(3.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 106 :j\r\nvoid char_j(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,21.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-3.0)*s,vec2(5.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-6.0)*s,vec2(3.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=10.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 107 :k\r\nvoid char_k(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 108 :l\r\nvoid char_l(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,21.0)*s,vec2(4.0,0.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 109 :m\r\nvoid char_m(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(18.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,13.0)*s,vec2(20.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,14.0)*s,vec2(23.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(23.0,14.0)*s,vec2(25.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(25.0,13.0)*s,vec2(26.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(26.0,10.0)*s,vec2(26.0,0.0)*s));\r\n    cpos.x+=30.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 110 :n\r\nvoid char_n(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,14.0)*s,vec2(14.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,13.0)*s,vec2(15.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,10.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 111 :o\r\nvoid char_o(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 112 :p\r\nvoid char_p(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(15.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(16.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,8.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(15.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(4.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 113 :q\r\nvoid char_q(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(11.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(6.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,13.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(3.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(4.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(11.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,0.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(15.0,3.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 114 :r\r\nvoid char_r(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,8.0)*s,vec2(5.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,11.0)*s,vec2(7.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,13.0)*s,vec2(9.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,14.0)*s,vec2(12.0,14.0)*s));\r\n    cpos.x+=13.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 115 :s\r\nvoid char_s(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,11.0)*s,vec2(13.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,13.0)*s,vec2(10.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,14.0)*s,vec2(7.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,14.0)*s,vec2(4.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,13.0)*s,vec2(3.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(6.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(11.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,7.0)*s,vec2(13.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,6.0)*s,vec2(14.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,4.0)*s,vec2(14.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,3.0)*s,vec2(13.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(13.0,1.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(4.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,1.0)*s,vec2(3.0,3.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 116 :t\r\nvoid char_t(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,4.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(9.0,14.0)*s));\r\n    cpos.x+=12.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 117 :u\r\nvoid char_u(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,14.0)*s,vec2(4.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,4.0)*s,vec2(5.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(10.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,0.0)*s,vec2(12.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(12.0,1.0)*s,vec2(15.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(15.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=19.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 118 :v\r\nvoid char_v(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 119 :w\r\nvoid char_w(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(11.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(19.0,14.0)*s,vec2(15.0,0.0)*s));\r\n    cpos.x+=22.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 120 :x\r\nvoid char_x(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 121 :y\r\nvoid char_y(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(2.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(8.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,0.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(4.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,-6.0)*s,vec2(2.0,-7.0)*s));\r\n    res=opU(res,line(p,vec2(2.0,-7.0)*s,vec2(1.0,-7.0)*s));\r\n    cpos.x+=16.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 122 :z\r\nvoid char_z(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(14.0,14.0)*s,vec2(3.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,14.0)*s,vec2(14.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,0.0)*s,vec2(14.0,0.0)*s));\r\n    cpos.x+=17.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 123 :{\r\nvoid char_123(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(9.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,23.0)*s,vec2(5.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,21.0)*s,vec2(5.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,19.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(8.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,14.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(6.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(6.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,22.0)*s,vec2(6.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(9.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,15.0)*s,vec2(9.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,13.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(4.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,9.0)*s,vec2(8.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,7.0)*s,vec2(9.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,5.0)*s,vec2(9.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,3.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(6.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-2.0)*s,vec2(6.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,8.0)*s,vec2(8.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,6.0)*s,vec2(8.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(5.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-1.0)*s,vec2(5.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,-3.0)*s,vec2(6.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(9.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n// CHAR: 124 :|\r\nvoid char_124(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(4.0,25.0)*s,vec2(4.0,-7.0)*s));\r\n    cpos.x+=8.0*s.x;\r\n}\r\n\r\n// CHAR: 125 :}\r\nvoid char_125(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(5.0,25.0)*s,vec2(7.0,24.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,23.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,23.0)*s,vec2(9.0,21.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,21.0)*s,vec2(9.0,19.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,19.0)*s,vec2(8.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,17.0)*s,vec2(7.0,16.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,16.0)*s,vec2(6.0,14.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,14.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,24.0)*s,vec2(8.0,22.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,22.0)*s,vec2(8.0,20.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,20.0)*s,vec2(7.0,18.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,18.0)*s,vec2(6.0,17.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,17.0)*s,vec2(5.0,15.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,15.0)*s,vec2(5.0,13.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,13.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(10.0,9.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,9.0)*s,vec2(6.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,7.0)*s,vec2(5.0,5.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,5.0)*s,vec2(5.0,3.0)*s));\r\n    res=opU(res,line(p,vec2(5.0,3.0)*s,vec2(6.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,1.0)*s,vec2(7.0,0.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,0.0)*s,vec2(8.0,-2.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-2.0)*s,vec2(8.0,-4.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-4.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,8.0)*s,vec2(6.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,6.0)*s,vec2(6.0,4.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,4.0)*s,vec2(7.0,2.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,2.0)*s,vec2(8.0,1.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,1.0)*s,vec2(9.0,-1.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-1.0)*s,vec2(9.0,-3.0)*s));\r\n    res=opU(res,line(p,vec2(9.0,-3.0)*s,vec2(8.0,-5.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,-5.0)*s,vec2(7.0,-6.0)*s));\r\n    res=opU(res,line(p,vec2(7.0,-6.0)*s,vec2(5.0,-7.0)*s));\r\n    cpos.x+=14.0*s.x;\r\n}\r\n\r\n\r\n// CHAR: 126 :~\r\nvoid char_126(vec2 uv,vec2 s){\r\n    vec2 p=uv-cpos;\r\n    res=opU(res,line(p,vec2(3.0,6.0)*s,vec2(3.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,11.0)*s,vec2(6.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,12.0)*s,vec2(8.0,12.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,12.0)*s,vec2(10.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,11.0)*s,vec2(14.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,8.0)*s,vec2(16.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,7.0)*s,vec2(18.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,7.0)*s,vec2(20.0,8.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,8.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(3.0,8.0)*s,vec2(4.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(4.0,10.0)*s,vec2(6.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(6.0,11.0)*s,vec2(8.0,11.0)*s));\r\n    res=opU(res,line(p,vec2(8.0,11.0)*s,vec2(10.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(10.0,10.0)*s,vec2(14.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(14.0,7.0)*s,vec2(16.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(16.0,6.0)*s,vec2(18.0,6.0)*s));\r\n    res=opU(res,line(p,vec2(18.0,6.0)*s,vec2(20.0,7.0)*s));\r\n    res=opU(res,line(p,vec2(20.0,7.0)*s,vec2(21.0,10.0)*s));\r\n    res=opU(res,line(p,vec2(21.0,10.0)*s,vec2(21.0,12.0)*s));\r\n    cpos.x+=24.0*s.x;\r\n}\r\n vec3 abc(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n    \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_A(uv,s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_B(uv,s);\r\n    \r\n\tchar_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_C(uv-vec2(-0.01,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    char_D(uv-vec2(-0.02,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n    \r\n    \r\n    char_E(uv-vec2(-0.03,0.0),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_F(uv-vec2(-0.04,0.0),s);\r\n    \r\n    char_G(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_H(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_I(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_J(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_K(uv-vec2(-1.1,-0.12),s);\r\n\t\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_L(uv-vec2(-1.1,-0.12),s);\r\n    \r\n    char_M(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    \r\n\tchar_N(uv-vec2(-2.17,-0.223),s);\r\n    \r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n\tchar_O(uv-vec2(-2.15,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n  \r\n\tchar_P(uv-vec2(-2.13,-0.223),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\tchar_Q(uv-vec2(-2.1,-0.223),s);\r\n     \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n\tchar_R(uv-vec2(-2.08,-0.223),s);\r\n    \r\n    char_S(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n\r\n    char_T(uv-vec2(-3.13,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_U(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n     \r\n    char_V(uv-vec2(-3.15,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_X(uv-vec2(-3.17,-0.34),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    \r\n    char_W(uv-vec2(-3.18,-0.34),s);\r\n    \r\n    char_Y(uv-vec2(-4.23,-0.45),s);\r\n    \r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_32(uv,s);\r\n    char_z(uv-vec2(-4.23,-0.44),s);\r\n\r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\nvec3 help(vec2 uv,vec2 iResolution, vec3 background)\r\n{\r\n     \r\n   uv/=vec2(3.0);\r\n\r\n    res=0.;\r\n\r\n    vec2 s=vec2(0.0025);    \r\n    vec3 outline=vec3(1.,1.,1.);\r\n    vec3 col=vec3(1.,0.3,0.03);\r\n    \r\n\twidth=0.003;\r\n    cpos=vec2(-0.53 ,0.26);\r\n    char_H(uv,s);\r\n    char_E(uv,s);\r\n    char_L(uv,s);\r\n    char_P(uv,s);\r\n\r\n    \r\n    //antialias & outline\r\n    float aares=clamp(antiAlias(res,iResolution), 0.0, 1.);\r\n    \r\n\toutline*=smoothstep(1.,0.6,aares)*smoothstep(0.,0.2,aares);\r\n\r\n    return mix(background,vec3((col)+outline),aares);\r\n}\r\n\r\n#define AA 1\r\nmat2 Rot(float a) {\r\n    float s = sin(a);\r\n    float c = cos(a);\r\n    return mat2(vec2(c, -s),vec2( s, c));\r\n}\r\nfloat sdBox( in vec2 p, in vec2 b )\r\n{\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nvec3 scene(vec2 p,vec2 iResolution,vec2 mouse){\r\n    vec3 col;\r\n   \r\n   p/=vec2(0.5);\r\n   mouse/=vec2(0.5);\r\n   mouse.y+=0.9;\r\n   p.y+=0.9;\r\n    \r\n  \r\n   float linha[15];\r\n   linha[0]=sdBox(p,vec2(1.8,0.01));\r\n   linha[1]=sdBox(p+vec2(0.0,0.33),vec2(1.8,0.01));\r\n   linha[2]=sdBox(p+vec2(0.0,0.66),vec2(1.8,0.01));\r\n   linha[3]=sdBox(p+vec2(0.0,-0.33),vec2(1.8,0.01));\r\n   linha[4]=sdBox(p+vec2(0.0,-0.66),vec2(1.8,0.01));\r\n   \r\n   \r\n   linha[5]=sdBox(p,vec2(0.01,1.0));\r\n   linha[6]=sdBox(p+vec2(0.60,0.0),vec2(0.01,1.0));\r\n   linha[7]=sdBox(p+vec2(1.2,0.0),vec2(0.01,1.0));\r\n   linha[8]=sdBox(p+vec2(-0.60,0.0),vec2(0.01,1.0));\r\n   linha[9]=sdBox(p+vec2(-1.20,0.0),vec2(0.01,1.0));\r\n    \r\n   linha[10]=sdBox(p+vec2(0.0,-1.0),vec2(1.8,0.01));\r\n   linha[11]=sdBox(p+vec2(0.0,1.0),vec2(1.8,0.01));\r\n   linha[12]=sdBox(p+vec2(-1.8,0.0),vec2(0.01,1.0));\r\n   linha[14]=sdBox(p+vec2(1.8,0.0),vec2(0.01,1.0));\r\n    \r\n    \r\n   float painel[26];\r\n   painel[0]=sdBox(p+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   painel[1]=sdBox(p+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   painel[2]=sdBox(p+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   painel[3]=sdBox(p+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   painel[4]=sdBox(p+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   painel[5]=sdBox(p+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   painel[6]=sdBox(p+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   painel[7]=sdBox(p+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[8]=sdBox(p+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[9]=sdBox(p+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   painel[10]=sdBox(p+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   painel[11]=sdBox(p+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   painel[12]=sdBox(p+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   painel[13]=sdBox(p+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[14]=sdBox(p+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[15]=sdBox(p+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   painel[16]=sdBox(p+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   painel[17]=sdBox(p+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   painel[18]=sdBox(p+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   painel[19]=sdBox(p+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   painel[20]=sdBox(p+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   painel[21]=sdBox(p+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   painel[22]=sdBox(p+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   painel[23]=sdBox(p+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   painel[24]=sdBox(p+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   painel[25]=sdBox(p+vec2(0.9,0.5),vec2(0.28,0.17)); \r\n    \r\n   float regiao[26];\r\n    \r\n   col=abc(p,iResolution,  vec3(0.82));\r\n   regiao[0]=sdBox(mouse+vec2(1.495,-0.83),vec2(0.28,0.17));\r\n   regiao[1]=sdBox(mouse+vec2(0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[2]=sdBox(mouse+vec2(0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[3]=sdBox(mouse+vec2(-0.3,-0.83),vec2(0.28,0.17));\r\n   regiao[4]=sdBox(mouse+vec2(-0.9,-0.83),vec2(0.28,0.17));\r\n   regiao[5]=sdBox(mouse+vec2(-1.5,-0.83),vec2(0.28,0.17));\r\n   regiao[6]=sdBox(mouse+vec2(1.495,-0.5),vec2(0.28,0.17));\r\n   regiao[7]=sdBox(mouse+vec2(0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[8]=sdBox(mouse+vec2(0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[9]=sdBox(mouse+vec2(-0.3,-0.5),vec2(0.28,0.17)); \r\n   regiao[10]=sdBox(mouse+vec2(-0.9,-0.5),vec2(0.28,0.17)); \r\n   regiao[11]=sdBox(mouse+vec2(-1.5,-0.5),vec2(0.28,0.17)); \r\n   regiao[12]=sdBox(mouse+vec2(1.495,-0.15),vec2(0.28,0.17)); \r\n   regiao[13]=sdBox(mouse+vec2(0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[14]=sdBox(mouse+vec2(0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[15]=sdBox(mouse+vec2(-0.3,-0.15),vec2(0.28,0.17)); \r\n   regiao[16]=sdBox(mouse+vec2(-0.9,-0.15),vec2(0.28,0.17)); \r\n   regiao[17]=sdBox(mouse+vec2(-1.5,-0.15),vec2(0.28,0.17)); \r\n   regiao[18]=sdBox(mouse+vec2(1.495,0.15),vec2(0.28,0.17)); \r\n   regiao[19]=sdBox(mouse+vec2(0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[20]=sdBox(mouse+vec2(0.3,0.15),vec2(0.28,0.17)); \r\n   regiao[21]=sdBox(mouse+vec2(-0.3,0.15),vec2(0.28,0.17));  \r\n   regiao[22]=sdBox(mouse+vec2(-0.9,0.15),vec2(0.28,0.17)); \r\n   regiao[23]=sdBox(mouse+vec2(-1.5,0.15),vec2(0.28,0.17)); \r\n   regiao[24]=sdBox(mouse+vec2(1.495,0.5),vec2(0.28,0.17)); \r\n   regiao[25]=sdBox(mouse+vec2(0.9,0.5),vec2(0.28,0.17));  \r\n    vec3 t=vec3(0.0);\r\n    float Output=sdBox(p-vec2(0.0,2.0),vec2(3.0,0.5));\r\n   \r\n   if(Output < 0.0) col=vec3(1.0);\r\n   \r\n    float caractere[24];\r\n    \r\n    caractere[0]=sdBox(p+vec2(0.0,-2.0),vec2(0.5,.5));\r\n\r\n    for(int i=0;i<painel.length();i++){\r\n   \t if(regiao[i]<=0.0 ){\r\n\r\n      \t  if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.1));\r\n         t=vec3(0.0,1.0,0.0);\r\n\r\n  \t  }else{ \r\n    \t    if(painel[i] < 0.0) col=abc(p,iResolution,  vec3(0.82));\r\n   \t }\r\n\r\n    }\r\n    for(int i=0;i<linha.length();i++){\r\n  \r\n  \t\tif(linha[i] < 0.0) col=vec3(0.0);\r\n  \r\n    }\r\n   if(caractere[0] < 0.0) col=help(p+vec2(-1.2,-1.0),iResolution,  vec3(0.82));\r\n   return col;\r\n}\r\n\r\n#define ZERO (min(iFrame,0))\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec3 tot = vec3(0.0);\r\n  \r\n    for( int m=ZERO; m<AA; m++ )\r\n    for( int n=ZERO; n<AA; n++ )\r\n    {\r\n     // pixel coordinates\r\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\r\n     vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;   \r\n     vec2 mouse = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;   \r\n \t vec3 col=vec3(0.0);\r\n  \r\n  \t  col *= 1.5 - 0.2*length(p);\r\n      col = col*vec3(1.11,0.89,0.79);\r\n    \r\n      col=scene(p,iResolution.xy,mouse);\r\n        \r\n         tot += col;\r\n    }\r\n    \r\n    tot /= float(AA*AA);\r\n    \r\n  fragColor = vec4(tot,1.0);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// based on SebH's https://www.shadertoy.com/view/MdKSzc\r\n//          h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor,  vec2 uv )\r\n{\r\n\tuv /= iResolution.xy;\r\n    \r\n    // Draw XYZ curves at the bottom\r\n\r\n    float wavelength = float(SPECTRUM_START) + uv.x * float(SPECTRUM_BIN*SPECTRUM_STEP);\r\n    \r\n    \r\n    // Display XYZ spectrum curve\r\n\r\n\tvec3 outColor = step( uv.y*4., xyzFit_1931(wavelength) );\r\n   \r\n\r\n    // Spectrum -> xyz -> rgb absorption gradient\r\n\r\n    float spectrum[SPECTRUM_BIN];\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n      #if 1\r\n        spectrum[i] = 0.014;// uniform band distribution\r\n      #else\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n    \t      X = xFit_1931(w),\r\n    \t      Y = yFit_1931(w),\r\n    \t      Z = zFit_1931(w);\r\n        spectrum[i] = (X+Y+Z) * 0.014;// follow xyz distribution\r\n      #endif\r\n    }\r\n    \r\n\r\n \r\n#define sqr(x) ((x)*(x))\r\n#define gauss(x,s) 1.14* exp(-.5*sqr((x)/(s))) / (s)\r\n#define S 1.\r\n//#define S ((2.*uv.y-1.)*10.)\r\n    \r\n    if (uv.y >.9) uv.x = 5./uv.x / float(SPECTRUM_BIN); // org by freqs instead of wavelengths\r\n        \r\n    // Compute spectrum perception along wavelengthes  ( was: Compute spectrum after absorption )\r\n    float spectrum2[SPECTRUM_BIN],\r\n        depth = uv.x * 1000.;\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n        // spectrum2[i] = spectrum[i]  * exp(-depth * getAbsorption(w));\r\n        // spectrum2[i] = spectrum[i]*float(int(uv.x*float(SPECTRUM_BIN))==i);\r\n        spectrum2[i] = spectrum[i] * gauss( uv.x*float(SPECTRUM_BIN)-float(i), S);\r\n    }\r\n    \r\n    vec3 colorXYZ = vec3(0),\r\n        color2XYZ = vec3(0);\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i),  \r\n             dw = float(SPECTRUM_STEP);\r\n\r\n        vec3 xyzFit = dw * xyzFit_1931(w);        \r\n        colorXYZ  += spectrum [i] * xyzFit;\r\n        color2XYZ += spectrum2[i] * xyzFit;\r\n\t}\r\n    \r\n    vec3 color = xyzToRgb(colorXYZ),\r\n        color2 = xyzToRgb(constrainXYZToSRGBGamut(color2XYZ));\r\n    \r\n\r\n    // perceived colors at the top\r\n\r\n    if(uv.y > .5) {\r\n\t\toutColor =  uv.y > .75 && uv.y < .9\r\n           ? color2                                  // without gamma transform\r\n           : pow(max(vec3(0),color2), vec3(1./2.2)); // with gamma\r\n        if ( uv.y < .55 || uv.y > .97 )           \r\n             outColor = vec3(pow((color2.r+color2.g+color2.b)/3., 1./2.2));\r\n    }\r\n\r\n    \r\n\tfragColor = vec4(outColor,1.);\r\n}","inputs":[],"outputs":[],"code":"// based on SebH's https://www.shadertoy.com/view/MdKSzc\r\n//          h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor,  vec2 uv )\r\n{\r\n\tuv /= iResolution.xy;\r\n    \r\n    // Draw XYZ curves at the bottom\r\n\r\n    float wavelength = float(SPECTRUM_START) + uv.x * float(SPECTRUM_BIN*SPECTRUM_STEP);\r\n    \r\n    \r\n    // Display XYZ spectrum curve\r\n\r\n\tvec3 outColor = step( uv.y*4., xyzFit_1931(wavelength) );\r\n   \r\n\r\n    // Spectrum -> xyz -> rgb absorption gradient\r\n\r\n    float spectrum[SPECTRUM_BIN];\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n      #if 1\r\n        spectrum[i] = 0.014;// uniform band distribution\r\n      #else\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n    \t      X = xFit_1931(w),\r\n    \t      Y = yFit_1931(w),\r\n    \t      Z = zFit_1931(w);\r\n        spectrum[i] = (X+Y+Z) * 0.014;// follow xyz distribution\r\n      #endif\r\n    }\r\n    \r\n\r\n \r\n#define sqr(x) ((x)*(x))\r\n#define gauss(x,s) 1.14* exp(-.5*sqr((x)/(s))) / (s)\r\n#define S 1.\r\n//#define S ((2.*uv.y-1.)*10.)\r\n    \r\n    if (uv.y >.9) uv.x = 5./uv.x / float(SPECTRUM_BIN); // org by freqs instead of wavelengths\r\n        \r\n    // Compute spectrum perception along wavelengthes  ( was: Compute spectrum after absorption )\r\n    float spectrum2[SPECTRUM_BIN],\r\n        depth = uv.x * 1000.;\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n        // spectrum2[i] = spectrum[i]  * exp(-depth * getAbsorption(w));\r\n        // spectrum2[i] = spectrum[i]*float(int(uv.x*float(SPECTRUM_BIN))==i);\r\n        spectrum2[i] = spectrum[i] * gauss( uv.x*float(SPECTRUM_BIN)-float(i), S);\r\n    }\r\n    \r\n    vec3 colorXYZ = vec3(0),\r\n        color2XYZ = vec3(0);\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i),  \r\n             dw = float(SPECTRUM_STEP);\r\n\r\n        vec3 xyzFit = dw * xyzFit_1931(w);        \r\n        colorXYZ  += spectrum [i] * xyzFit;\r\n        color2XYZ += spectrum2[i] * xyzFit;\r\n\t}\r\n    \r\n    vec3 color = xyzToRgb(colorXYZ),\r\n        color2 = xyzToRgb(constrainXYZToSRGBGamut(color2XYZ));\r\n    \r\n\r\n    // perceived colors at the top\r\n\r\n    if(uv.y > .5) {\r\n\t\toutColor =  uv.y > .75 && uv.y < .9\r\n           ? color2                                  // without gamma transform\r\n           : pow(max(vec3(0),color2), vec3(1./2.2)); // with gamma\r\n        if ( uv.y < .55 || uv.y > .97 )           \r\n             outColor = vec3(pow((color2.r+color2.g+color2.b)/3., 1./2.2));\r\n    }\r\n\r\n    \r\n\tfragColor = vec4(outColor,1.);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"visible spectrum ","id":"170c58da0ae340b49b091a6e25035add","date":null,"viewed":0,"name":"visible spectrum ","description":"mid-height: perceived color associated to each wavelength from 360 to 790 nm\nabove: without the gamma conversion.\nvery top: perceived color associated to each frequency\n( based on h3r2tic's https://www.shadertoy.com/view/4dVSDy )\nhttps://www.shadertoy.com/view/llKSDz","likes":0,"published":null,"tags":["spectrum"," rainbow"," hue"," perception"," wavelength"," cie"," xyzcolorspace"]},"ver":null,"info":{"Name":"visible spectrum ","id":"170c58da0ae340b49b091a6e25035add","date":null,"viewed":0,"name":"visible spectrum ","description":"mid-height: perceived color associated to each wavelength from 360 to 790 nm\nabove: without the gamma conversion.\nvery top: perceived color associated to each frequency\n( based on h3r2tic's https://www.shadertoy.com/view/4dVSDy )\nhttps://www.shadertoy.com/view/llKSDz","likes":0,"published":null,"tags":["spectrum"," rainbow"," hue"," perception"," wavelength"," cie"," xyzcolorspace"]},"renderpass":[{"Code":"// based on SebH's https://www.shadertoy.com/view/MdKSzc\r\n//          h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor,  vec2 uv )\r\n{\r\n\tuv /= iResolution.xy;\r\n    \r\n    // Draw XYZ curves at the bottom\r\n\r\n    float wavelength = float(SPECTRUM_START) + uv.x * float(SPECTRUM_BIN*SPECTRUM_STEP);\r\n    \r\n    \r\n    // Display XYZ spectrum curve\r\n\r\n\tvec3 outColor = step( uv.y*4., xyzFit_1931(wavelength) );\r\n   \r\n\r\n    // Spectrum -> xyz -> rgb absorption gradient\r\n\r\n    float spectrum[SPECTRUM_BIN];\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n      #if 1\r\n        spectrum[i] = 0.014;// uniform band distribution\r\n      #else\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n    \t      X = xFit_1931(w),\r\n    \t      Y = yFit_1931(w),\r\n    \t      Z = zFit_1931(w);\r\n        spectrum[i] = (X+Y+Z) * 0.014;// follow xyz distribution\r\n      #endif\r\n    }\r\n    \r\n\r\n \r\n#define sqr(x) ((x)*(x))\r\n#define gauss(x,s) 1.14* exp(-.5*sqr((x)/(s))) / (s)\r\n#define S 1.\r\n//#define S ((2.*uv.y-1.)*10.)\r\n    \r\n    if (uv.y >.9) uv.x = 5./uv.x / float(SPECTRUM_BIN); // org by freqs instead of wavelengths\r\n        \r\n    // Compute spectrum perception along wavelengthes  ( was: Compute spectrum after absorption )\r\n    float spectrum2[SPECTRUM_BIN],\r\n        depth = uv.x * 1000.;\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n        // spectrum2[i] = spectrum[i]  * exp(-depth * getAbsorption(w));\r\n        // spectrum2[i] = spectrum[i]*float(int(uv.x*float(SPECTRUM_BIN))==i);\r\n        spectrum2[i] = spectrum[i] * gauss( uv.x*float(SPECTRUM_BIN)-float(i), S);\r\n    }\r\n    \r\n    vec3 colorXYZ = vec3(0),\r\n        color2XYZ = vec3(0);\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i),  \r\n             dw = float(SPECTRUM_STEP);\r\n\r\n        vec3 xyzFit = dw * xyzFit_1931(w);        \r\n        colorXYZ  += spectrum [i] * xyzFit;\r\n        color2XYZ += spectrum2[i] * xyzFit;\r\n\t}\r\n    \r\n    vec3 color = xyzToRgb(colorXYZ),\r\n        color2 = xyzToRgb(constrainXYZToSRGBGamut(color2XYZ));\r\n    \r\n\r\n    // perceived colors at the top\r\n\r\n    if(uv.y > .5) {\r\n\t\toutColor =  uv.y > .75 && uv.y < .9\r\n           ? color2                                  // without gamma transform\r\n           : pow(max(vec3(0),color2), vec3(1./2.2)); // with gamma\r\n        if ( uv.y < .55 || uv.y > .97 )           \r\n             outColor = vec3(pow((color2.r+color2.g+color2.b)/3., 1./2.2));\r\n    }\r\n\r\n    \r\n\tfragColor = vec4(outColor,1.);\r\n}","inputs":[],"outputs":[],"code":"// based on SebH's https://www.shadertoy.com/view/MdKSzc\r\n//          h3r2tic's https://www.shadertoy.com/view/4dVSDy\r\n\r\n// Spectrum to xyz approx function from Sloan http://jcgt.org/published/0002/02/01/paper.pdf\r\n// Inputs:  Wavelength in nanometers\r\nfloat xFit_1931( float wave )\r\n{\r\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\r\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\r\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\r\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\r\n}\r\nfloat yFit_1931( float wave )\r\n{\r\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\r\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\r\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\r\n}\r\nfloat zFit_1931( float wave )\r\n{\r\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\r\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\r\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\r\n}\r\n\r\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \r\n    \r\nvec3 xyzToRgb(vec3 XYZ)\r\n{\r\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\r\n\t                  -0.969256 , 1.875991,  0.041556,\r\n\t                   0.055648, -0.204043,  1.057311 );\r\n}\r\n\r\n#define SPECTRUM_START 360\r\n#define SPECTRUM_BIN   43\r\n#define SPECTRUM_STEP  10\r\n\r\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; } \r\n\r\n// Returns 1 if the lines intersect, otherwise 0. In addition, if the lines \r\n// intersect the intersection point may be stored in the floats i_x and i_y.\r\n\r\nvec2 intersectSegment(vec2 p0, vec2 p1, vec2 p2, vec2 p3)\r\n{\r\n    vec2 s1 = p1-p0, s2 = p3-p2;\r\n\r\n    float d = cross2(s1,s2),\r\n          s = cross2(s1, p0-p2) / d,\r\n          t = cross2(s2, p0-p2) / d;\r\n\r\n    return s >= 0. && s <= 1. && t >= 0. && t <= 1.\r\n         ? p0 + t*s1    // Collision detected\r\n         : p0;\r\n}\r\n\r\nvec3 constrainXYZToSRGBGamut(vec3 col)\r\n{\r\n    vec2 xy = col.xy / (col.x + col.y + col.z);\r\n    \r\n    vec2 red   = vec2(0.64,   0.33  ),\r\n         green = vec2(0.3,    0.6   ),\r\n         blue  = vec2(0.15,   0.06  ),\r\n         white = vec2(0.3127, 0.3290);\r\n    \r\n    const float desaturationAmount = 0.1;\r\n    xy = mix(xy, white, desaturationAmount);\r\n    \r\n    xy = intersectSegment(xy, white, red,   green);\r\n    xy = intersectSegment(xy, white, green, blue );\r\n    xy = intersectSegment(xy, white, blue,  red  );\r\n    \r\n    return col.y * vec3( xy, 1. - xy.x - xy.y ) / xy.y;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor,  vec2 uv )\r\n{\r\n\tuv /= iResolution.xy;\r\n    \r\n    // Draw XYZ curves at the bottom\r\n\r\n    float wavelength = float(SPECTRUM_START) + uv.x * float(SPECTRUM_BIN*SPECTRUM_STEP);\r\n    \r\n    \r\n    // Display XYZ spectrum curve\r\n\r\n\tvec3 outColor = step( uv.y*4., xyzFit_1931(wavelength) );\r\n   \r\n\r\n    // Spectrum -> xyz -> rgb absorption gradient\r\n\r\n    float spectrum[SPECTRUM_BIN];\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n      #if 1\r\n        spectrum[i] = 0.014;// uniform band distribution\r\n      #else\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n    \t      X = xFit_1931(w),\r\n    \t      Y = yFit_1931(w),\r\n    \t      Z = zFit_1931(w);\r\n        spectrum[i] = (X+Y+Z) * 0.014;// follow xyz distribution\r\n      #endif\r\n    }\r\n    \r\n\r\n \r\n#define sqr(x) ((x)*(x))\r\n#define gauss(x,s) 1.14* exp(-.5*sqr((x)/(s))) / (s)\r\n#define S 1.\r\n//#define S ((2.*uv.y-1.)*10.)\r\n    \r\n    if (uv.y >.9) uv.x = 5./uv.x / float(SPECTRUM_BIN); // org by freqs instead of wavelengths\r\n        \r\n    // Compute spectrum perception along wavelengthes  ( was: Compute spectrum after absorption )\r\n    float spectrum2[SPECTRUM_BIN],\r\n        depth = uv.x * 1000.;\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i);\r\n        // spectrum2[i] = spectrum[i]  * exp(-depth * getAbsorption(w));\r\n        // spectrum2[i] = spectrum[i]*float(int(uv.x*float(SPECTRUM_BIN))==i);\r\n        spectrum2[i] = spectrum[i] * gauss( uv.x*float(SPECTRUM_BIN)-float(i), S);\r\n    }\r\n    \r\n    vec3 colorXYZ = vec3(0),\r\n        color2XYZ = vec3(0);\r\n    for(int i=0; i<SPECTRUM_BIN; ++i)\r\n    {\r\n        float w = float(SPECTRUM_START + SPECTRUM_STEP*i),  \r\n             dw = float(SPECTRUM_STEP);\r\n\r\n        vec3 xyzFit = dw * xyzFit_1931(w);        \r\n        colorXYZ  += spectrum [i] * xyzFit;\r\n        color2XYZ += spectrum2[i] * xyzFit;\r\n\t}\r\n    \r\n    vec3 color = xyzToRgb(colorXYZ),\r\n        color2 = xyzToRgb(constrainXYZToSRGBGamut(color2XYZ));\r\n    \r\n\r\n    // perceived colors at the top\r\n\r\n    if(uv.y > .5) {\r\n\t\toutColor =  uv.y > .75 && uv.y < .9\r\n           ? color2                                  // without gamma transform\r\n           : pow(max(vec3(0),color2), vec3(1./2.2)); // with gamma\r\n        if ( uv.y < .55 || uv.y > .97 )           \r\n             outColor = vec3(pow((color2.r+color2.g+color2.b)/3., 1./2.2));\r\n    }\r\n\r\n    \r\n\tfragColor = vec4(outColor,1.);\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":" #define SHQ\t\r\n //#define MEDQ\t\r\n //#define YUCKQ\t\r\n\r\nconst float tmax = 20.0;\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCappedCylinder( vec3 p, float h, float r )\r\n{\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nvec2 opU( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nvec2 sdScene(vec3 p)\r\n{\r\n    vec2 res = vec2(999.0);\r\n    float r = 7.4;\r\n    //res = opU(res, vec2(sdSphere(p-vec3(0.,0.,0.), r), r));\r\n    res = opU(res, vec2(sdCappedCylinder(p-vec3(0.,.0,0.), r,4.0), r));\r\n    return res;\r\n}\r\n\r\n/*\r\n//iq's LUT 3D noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 f = fract(x);\r\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\r\n    f = f*f*(3.0-2.0*f);\r\n     \r\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n    return mix( rg.x, rg.y, f.z );\r\n}\r\n*/\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// assign colour to the media\r\nvec3 computeColour( float density)\r\n{\r\n\tvec3 result = mix(vec3(.9,0.9,0.9), vec3(0.25,0.25,0.25), density );\r\n\t\r\n\treturn result;\r\n}\r\n\r\nfloat Turbulence(vec3 p)\r\n{\t\r\n\tfloat t = 0.;\r\n\tfloat oof = 1.;\r\n\tfor (int i=0; i<7; i++)\r\n\t{\r\n\t\tt += abs(noise(p))*oof;\r\n\t\toof *= 0.5;\r\n\t\tp *= 2.7;\t//bigger number, more detail\r\n\t}\r\n\t\r\n\treturn t-1.;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    //start of params\r\n    float rotateS = 2.6;\r\n    float riseS = 3.55;\r\n    float rmax = 4.2;\r\n    float rmin = 1.2;\r\n    //end of parms\r\n    \r\n    vec3 bottom = vec3(0.0,-4.4,0.0);\r\n    float den = 0.0;\r\n    float maxH = 8.8;  \r\n    vec3 lp = p;\r\n    float height = lp.y - bottom.y + noise(lp)*rmin*0.33;\r\n    float tease = height/maxH;\r\n    \r\n    float theta_s = iTime*rotateS;\r\n    float down = riseS*iTime;\r\n    float c = cos(-theta_s - p.y);\r\n    float s = sin(-theta_s - p.y);\r\n    float c1 = cos(-theta_s - p.y);\r\n    float s1 = sin(-theta_s - p.y);\r\n    \r\n    float noi = noise(p);\r\n    float scale = 1.0;\r\n    scale *= noi*0.01 + 0.77+0.23*abs(sin((p.y+sin(iTime*3.3)*0.1+noi*0.08)*1.9));\r\n    scale *= (0.56 + 0.44*abs(sin((tease+0.5)*3.14159)))*(1.0);\r\n    scale *= 0.6+tease*0.3;\r\n    \r\n    vec3 lp1 = lp;\r\n    lp.x *= scale;\r\n    lp.z *= scale;\r\n    lp1.x = lp.x*c-lp.z*s;\r\n    lp1.z = lp.x*s+lp.z*c;\r\n    lp1.y -= down;\r\n    float turb = Turbulence(lp1);    \r\n    \r\n    float r = rmax*scale + turb*0.3*rotateS;\r\n    float r_sq = r*r;\r\n    float roffset = r*0.2;\r\n    vec3 center = vec3(roffset*c1,p.y,roffset*s1);\r\n    center.x += turb*0.1;\r\n    center.y += turb*0.2;\r\n    center.z += turb*0.1;\r\n    vec3 diff = p - center;\r\n    float dist_sq = diff.x*diff.x + diff.y*diff.y + diff.z*diff.z;\r\n    den = (1.0-dist_sq/r_sq + turb*0.45)*1.11;\r\n    float rn_seq = (p.x*p.x + p.z*p.z)/r;\r\n    rn_seq = clamp(rn_seq,0.0,1.0);\r\n    den *= (0.22 + 0.78*abs(sin((rn_seq)*3.14159)));\r\n    den *= pow(rmax/r,2.0);\r\n    \r\n    den = clamp(den,0.0,1.0);\r\n    den = pow(den, 0.4);\r\n    \r\n    //make color\r\n    vec3 color = mix(vec3(.9,0.9,0.9), vec3(0.45,0.45,0.45), den );\r\n\treturn vec4(color,den);\r\n}\r\n\r\n\r\nvec4 raytraceVolumetric(in vec3 rayo, in vec3 rayd,in float t)\r\n{\r\n    vec3 pos = rayo+rayd*t;\r\n    float d = sdScene(pos).x;\r\n    vec4 sum = vec4( 0.0 );\r\n    \t\r\n    float last_t = t;\r\n    \r\n    #ifdef SHQ\r\n\t#define STEPS  128\r\n    float dt = 0.062;\r\n    #endif\t\r\n    #ifdef MEDQ\r\n\t#define STEPS\t64\r\n    float dt = 0.124;\r\n    #endif\t\r\n    #ifdef YUCKQ\t\r\n\t#define STEPS\t32\r\n    float dt = 0.248;\r\n    #endif\r\n    \r\n    for( int i = 0; i < STEPS && t < tmax && d<t*0.001; i++ )\r\n    {\r\n        if( sum.a > 0.99 ) continue;\r\n\t\t\t\t\r\n\t\tvec4 col = map(pos);\r\n\t\tcol.a*= (t-last_t)*1.5;\r\n        \r\n\t\t// colour by alpha\r\n\t\tcol.rgb *= col.a;\r\n\t\t\r\n\t\t// alpha blend in contribution\r\n\t\tsum = sum + col*(1.0 - sum.a);  \r\n\t\t\r\n\t\t// step along ray\r\n        last_t = t;\r\n\t\t//t += max(0.062, t*0.0096);\r\n        t += dt;\r\n\t\tpos = rayo + rayd * t;\r\n        d = sdScene(pos).x;\r\n    }\r\n\tvec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n\tsum = sum + bg*(1.0 - sum.a);  \r\n        \r\n    return clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\nvec4 raymarch( in vec3 rayo, in vec3 rayd)\r\n{\r\n    vec3 pos = rayo;\r\n    float t = 0.0;\r\n\t\r\n\tfor(int i = 0; i < 15 && t < tmax; i++)\r\n    {\r\n        vec2 h = sdScene(pos);\r\n        if( h.x < 0.0001*t)\r\n        { \r\n            return raytraceVolumetric(rayo,rayd,t); \r\n        }\r\n        t += h.x;\r\n        pos = rayo + rayd * t;\r\n    }\r\n    vec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n    return bg; \r\n}\r\n\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t\r\n    float camRadius = 9.8;\r\n\t// use mouse x coord\r\n\tfloat a = 0.0;// iTime * 20.;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\ta = iMouse.x;\r\n        camRadius = iMouse.y/iResolution.y*camRadius;\r\n    }\r\n\tfloat theta = (-a/iResolution.x)*3.1415926*2.+3.1415926*0.5;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,0.,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.,0.,0.);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get aspect corrected normalized pixel coordinate\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, cameraPos;\r\n    rayDir = computePixelRay( p, cameraPos );\r\n\t\r\n\tvec4 col = vec4(0.);\r\n\tcol = raymarch( cameraPos, rayDir);\r\n    // smoothstep final color to add contrast\r\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\r\n}\r\n","inputs":[],"outputs":[],"code":" #define SHQ\t\r\n //#define MEDQ\t\r\n //#define YUCKQ\t\r\n\r\nconst float tmax = 20.0;\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCappedCylinder( vec3 p, float h, float r )\r\n{\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nvec2 opU( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nvec2 sdScene(vec3 p)\r\n{\r\n    vec2 res = vec2(999.0);\r\n    float r = 7.4;\r\n    //res = opU(res, vec2(sdSphere(p-vec3(0.,0.,0.), r), r));\r\n    res = opU(res, vec2(sdCappedCylinder(p-vec3(0.,.0,0.), r,4.0), r));\r\n    return res;\r\n}\r\n\r\n/*\r\n//iq's LUT 3D noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 f = fract(x);\r\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\r\n    f = f*f*(3.0-2.0*f);\r\n     \r\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n    return mix( rg.x, rg.y, f.z );\r\n}\r\n*/\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// assign colour to the media\r\nvec3 computeColour( float density)\r\n{\r\n\tvec3 result = mix(vec3(.9,0.9,0.9), vec3(0.25,0.25,0.25), density );\r\n\t\r\n\treturn result;\r\n}\r\n\r\nfloat Turbulence(vec3 p)\r\n{\t\r\n\tfloat t = 0.;\r\n\tfloat oof = 1.;\r\n\tfor (int i=0; i<7; i++)\r\n\t{\r\n\t\tt += abs(noise(p))*oof;\r\n\t\toof *= 0.5;\r\n\t\tp *= 2.7;\t//bigger number, more detail\r\n\t}\r\n\t\r\n\treturn t-1.;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    //start of params\r\n    float rotateS = 2.6;\r\n    float riseS = 3.55;\r\n    float rmax = 4.2;\r\n    float rmin = 1.2;\r\n    //end of parms\r\n    \r\n    vec3 bottom = vec3(0.0,-4.4,0.0);\r\n    float den = 0.0;\r\n    float maxH = 8.8;  \r\n    vec3 lp = p;\r\n    float height = lp.y - bottom.y + noise(lp)*rmin*0.33;\r\n    float tease = height/maxH;\r\n    \r\n    float theta_s = iTime*rotateS;\r\n    float down = riseS*iTime;\r\n    float c = cos(-theta_s - p.y);\r\n    float s = sin(-theta_s - p.y);\r\n    float c1 = cos(-theta_s - p.y);\r\n    float s1 = sin(-theta_s - p.y);\r\n    \r\n    float noi = noise(p);\r\n    float scale = 1.0;\r\n    scale *= noi*0.01 + 0.77+0.23*abs(sin((p.y+sin(iTime*3.3)*0.1+noi*0.08)*1.9));\r\n    scale *= (0.56 + 0.44*abs(sin((tease+0.5)*3.14159)))*(1.0);\r\n    scale *= 0.6+tease*0.3;\r\n    \r\n    vec3 lp1 = lp;\r\n    lp.x *= scale;\r\n    lp.z *= scale;\r\n    lp1.x = lp.x*c-lp.z*s;\r\n    lp1.z = lp.x*s+lp.z*c;\r\n    lp1.y -= down;\r\n    float turb = Turbulence(lp1);    \r\n    \r\n    float r = rmax*scale + turb*0.3*rotateS;\r\n    float r_sq = r*r;\r\n    float roffset = r*0.2;\r\n    vec3 center = vec3(roffset*c1,p.y,roffset*s1);\r\n    center.x += turb*0.1;\r\n    center.y += turb*0.2;\r\n    center.z += turb*0.1;\r\n    vec3 diff = p - center;\r\n    float dist_sq = diff.x*diff.x + diff.y*diff.y + diff.z*diff.z;\r\n    den = (1.0-dist_sq/r_sq + turb*0.45)*1.11;\r\n    float rn_seq = (p.x*p.x + p.z*p.z)/r;\r\n    rn_seq = clamp(rn_seq,0.0,1.0);\r\n    den *= (0.22 + 0.78*abs(sin((rn_seq)*3.14159)));\r\n    den *= pow(rmax/r,2.0);\r\n    \r\n    den = clamp(den,0.0,1.0);\r\n    den = pow(den, 0.4);\r\n    \r\n    //make color\r\n    vec3 color = mix(vec3(.9,0.9,0.9), vec3(0.45,0.45,0.45), den );\r\n\treturn vec4(color,den);\r\n}\r\n\r\n\r\nvec4 raytraceVolumetric(in vec3 rayo, in vec3 rayd,in float t)\r\n{\r\n    vec3 pos = rayo+rayd*t;\r\n    float d = sdScene(pos).x;\r\n    vec4 sum = vec4( 0.0 );\r\n    \t\r\n    float last_t = t;\r\n    \r\n    #ifdef SHQ\r\n\t#define STEPS  128\r\n    float dt = 0.062;\r\n    #endif\t\r\n    #ifdef MEDQ\r\n\t#define STEPS\t64\r\n    float dt = 0.124;\r\n    #endif\t\r\n    #ifdef YUCKQ\t\r\n\t#define STEPS\t32\r\n    float dt = 0.248;\r\n    #endif\r\n    \r\n    for( int i = 0; i < STEPS && t < tmax && d<t*0.001; i++ )\r\n    {\r\n        if( sum.a > 0.99 ) continue;\r\n\t\t\t\t\r\n\t\tvec4 col = map(pos);\r\n\t\tcol.a*= (t-last_t)*1.5;\r\n        \r\n\t\t// colour by alpha\r\n\t\tcol.rgb *= col.a;\r\n\t\t\r\n\t\t// alpha blend in contribution\r\n\t\tsum = sum + col*(1.0 - sum.a);  \r\n\t\t\r\n\t\t// step along ray\r\n        last_t = t;\r\n\t\t//t += max(0.062, t*0.0096);\r\n        t += dt;\r\n\t\tpos = rayo + rayd * t;\r\n        d = sdScene(pos).x;\r\n    }\r\n\tvec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n\tsum = sum + bg*(1.0 - sum.a);  \r\n        \r\n    return clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\nvec4 raymarch( in vec3 rayo, in vec3 rayd)\r\n{\r\n    vec3 pos = rayo;\r\n    float t = 0.0;\r\n\t\r\n\tfor(int i = 0; i < 15 && t < tmax; i++)\r\n    {\r\n        vec2 h = sdScene(pos);\r\n        if( h.x < 0.0001*t)\r\n        { \r\n            return raytraceVolumetric(rayo,rayd,t); \r\n        }\r\n        t += h.x;\r\n        pos = rayo + rayd * t;\r\n    }\r\n    vec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n    return bg; \r\n}\r\n\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t\r\n    float camRadius = 9.8;\r\n\t// use mouse x coord\r\n\tfloat a = 0.0;// iTime * 20.;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\ta = iMouse.x;\r\n        camRadius = iMouse.y/iResolution.y*camRadius;\r\n    }\r\n\tfloat theta = (-a/iResolution.x)*3.1415926*2.+3.1415926*0.5;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,0.,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.,0.,0.);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get aspect corrected normalized pixel coordinate\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, cameraPos;\r\n    rayDir = computePixelRay( p, cameraPos );\r\n\t\r\n\tvec4 col = vec4(0.);\r\n\tcol = raymarch( cameraPos, rayDir);\r\n    // smoothstep final color to add contrast\r\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"volumetric tornado","id":"ad42ce50f9d1488d87d44be0403e79b8","date":null,"viewed":0,"name":"volumetric tornado","description":"volumetric tornado","likes":0,"published":null,"tags":["sdf"," volumetric"," tornade"]},"ver":null,"info":{"Name":"volumetric tornado","id":"ad42ce50f9d1488d87d44be0403e79b8","date":null,"viewed":0,"name":"volumetric tornado","description":"volumetric tornado","likes":0,"published":null,"tags":["sdf"," volumetric"," tornade"]},"renderpass":[{"Code":" #define SHQ\t\r\n //#define MEDQ\t\r\n //#define YUCKQ\t\r\n\r\nconst float tmax = 20.0;\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCappedCylinder( vec3 p, float h, float r )\r\n{\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nvec2 opU( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nvec2 sdScene(vec3 p)\r\n{\r\n    vec2 res = vec2(999.0);\r\n    float r = 7.4;\r\n    //res = opU(res, vec2(sdSphere(p-vec3(0.,0.,0.), r), r));\r\n    res = opU(res, vec2(sdCappedCylinder(p-vec3(0.,.0,0.), r,4.0), r));\r\n    return res;\r\n}\r\n\r\n/*\r\n//iq's LUT 3D noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 f = fract(x);\r\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\r\n    f = f*f*(3.0-2.0*f);\r\n     \r\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n    return mix( rg.x, rg.y, f.z );\r\n}\r\n*/\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// assign colour to the media\r\nvec3 computeColour( float density)\r\n{\r\n\tvec3 result = mix(vec3(.9,0.9,0.9), vec3(0.25,0.25,0.25), density );\r\n\t\r\n\treturn result;\r\n}\r\n\r\nfloat Turbulence(vec3 p)\r\n{\t\r\n\tfloat t = 0.;\r\n\tfloat oof = 1.;\r\n\tfor (int i=0; i<7; i++)\r\n\t{\r\n\t\tt += abs(noise(p))*oof;\r\n\t\toof *= 0.5;\r\n\t\tp *= 2.7;\t//bigger number, more detail\r\n\t}\r\n\t\r\n\treturn t-1.;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    //start of params\r\n    float rotateS = 2.6;\r\n    float riseS = 3.55;\r\n    float rmax = 4.2;\r\n    float rmin = 1.2;\r\n    //end of parms\r\n    \r\n    vec3 bottom = vec3(0.0,-4.4,0.0);\r\n    float den = 0.0;\r\n    float maxH = 8.8;  \r\n    vec3 lp = p;\r\n    float height = lp.y - bottom.y + noise(lp)*rmin*0.33;\r\n    float tease = height/maxH;\r\n    \r\n    float theta_s = iTime*rotateS;\r\n    float down = riseS*iTime;\r\n    float c = cos(-theta_s - p.y);\r\n    float s = sin(-theta_s - p.y);\r\n    float c1 = cos(-theta_s - p.y);\r\n    float s1 = sin(-theta_s - p.y);\r\n    \r\n    float noi = noise(p);\r\n    float scale = 1.0;\r\n    scale *= noi*0.01 + 0.77+0.23*abs(sin((p.y+sin(iTime*3.3)*0.1+noi*0.08)*1.9));\r\n    scale *= (0.56 + 0.44*abs(sin((tease+0.5)*3.14159)))*(1.0);\r\n    scale *= 0.6+tease*0.3;\r\n    \r\n    vec3 lp1 = lp;\r\n    lp.x *= scale;\r\n    lp.z *= scale;\r\n    lp1.x = lp.x*c-lp.z*s;\r\n    lp1.z = lp.x*s+lp.z*c;\r\n    lp1.y -= down;\r\n    float turb = Turbulence(lp1);    \r\n    \r\n    float r = rmax*scale + turb*0.3*rotateS;\r\n    float r_sq = r*r;\r\n    float roffset = r*0.2;\r\n    vec3 center = vec3(roffset*c1,p.y,roffset*s1);\r\n    center.x += turb*0.1;\r\n    center.y += turb*0.2;\r\n    center.z += turb*0.1;\r\n    vec3 diff = p - center;\r\n    float dist_sq = diff.x*diff.x + diff.y*diff.y + diff.z*diff.z;\r\n    den = (1.0-dist_sq/r_sq + turb*0.45)*1.11;\r\n    float rn_seq = (p.x*p.x + p.z*p.z)/r;\r\n    rn_seq = clamp(rn_seq,0.0,1.0);\r\n    den *= (0.22 + 0.78*abs(sin((rn_seq)*3.14159)));\r\n    den *= pow(rmax/r,2.0);\r\n    \r\n    den = clamp(den,0.0,1.0);\r\n    den = pow(den, 0.4);\r\n    \r\n    //make color\r\n    vec3 color = mix(vec3(.9,0.9,0.9), vec3(0.45,0.45,0.45), den );\r\n\treturn vec4(color,den);\r\n}\r\n\r\n\r\nvec4 raytraceVolumetric(in vec3 rayo, in vec3 rayd,in float t)\r\n{\r\n    vec3 pos = rayo+rayd*t;\r\n    float d = sdScene(pos).x;\r\n    vec4 sum = vec4( 0.0 );\r\n    \t\r\n    float last_t = t;\r\n    \r\n    #ifdef SHQ\r\n\t#define STEPS  128\r\n    float dt = 0.062;\r\n    #endif\t\r\n    #ifdef MEDQ\r\n\t#define STEPS\t64\r\n    float dt = 0.124;\r\n    #endif\t\r\n    #ifdef YUCKQ\t\r\n\t#define STEPS\t32\r\n    float dt = 0.248;\r\n    #endif\r\n    \r\n    for( int i = 0; i < STEPS && t < tmax && d<t*0.001; i++ )\r\n    {\r\n        if( sum.a > 0.99 ) continue;\r\n\t\t\t\t\r\n\t\tvec4 col = map(pos);\r\n\t\tcol.a*= (t-last_t)*1.5;\r\n        \r\n\t\t// colour by alpha\r\n\t\tcol.rgb *= col.a;\r\n\t\t\r\n\t\t// alpha blend in contribution\r\n\t\tsum = sum + col*(1.0 - sum.a);  \r\n\t\t\r\n\t\t// step along ray\r\n        last_t = t;\r\n\t\t//t += max(0.062, t*0.0096);\r\n        t += dt;\r\n\t\tpos = rayo + rayd * t;\r\n        d = sdScene(pos).x;\r\n    }\r\n\tvec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n\tsum = sum + bg*(1.0 - sum.a);  \r\n        \r\n    return clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\nvec4 raymarch( in vec3 rayo, in vec3 rayd)\r\n{\r\n    vec3 pos = rayo;\r\n    float t = 0.0;\r\n\t\r\n\tfor(int i = 0; i < 15 && t < tmax; i++)\r\n    {\r\n        vec2 h = sdScene(pos);\r\n        if( h.x < 0.0001*t)\r\n        { \r\n            return raytraceVolumetric(rayo,rayd,t); \r\n        }\r\n        t += h.x;\r\n        pos = rayo + rayd * t;\r\n    }\r\n    vec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n    return bg; \r\n}\r\n\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t\r\n    float camRadius = 9.8;\r\n\t// use mouse x coord\r\n\tfloat a = 0.0;// iTime * 20.;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\ta = iMouse.x;\r\n        camRadius = iMouse.y/iResolution.y*camRadius;\r\n    }\r\n\tfloat theta = (-a/iResolution.x)*3.1415926*2.+3.1415926*0.5;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,0.,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.,0.,0.);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get aspect corrected normalized pixel coordinate\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, cameraPos;\r\n    rayDir = computePixelRay( p, cameraPos );\r\n\t\r\n\tvec4 col = vec4(0.);\r\n\tcol = raymarch( cameraPos, rayDir);\r\n    // smoothstep final color to add contrast\r\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\r\n}\r\n","inputs":[],"outputs":[],"code":" #define SHQ\t\r\n //#define MEDQ\t\r\n //#define YUCKQ\t\r\n\r\nconst float tmax = 20.0;\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    return length(p)-s;\r\n}\r\n\r\nfloat sdCappedCylinder( vec3 p, float h, float r )\r\n{\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\n\r\nvec2 opU( vec2 d1, vec2 d2 )\r\n{\r\n\treturn (d1.x<d2.x) ? d1 : d2;\r\n}\r\n\r\nvec2 sdScene(vec3 p)\r\n{\r\n    vec2 res = vec2(999.0);\r\n    float r = 7.4;\r\n    //res = opU(res, vec2(sdSphere(p-vec3(0.,0.,0.), r), r));\r\n    res = opU(res, vec2(sdCappedCylinder(p-vec3(0.,.0,0.), r,4.0), r));\r\n    return res;\r\n}\r\n\r\n/*\r\n//iq's LUT 3D noise\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 f = fract(x);\r\n    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.\r\n    f = f*f*(3.0-2.0*f);\r\n     \r\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\r\n    return mix( rg.x, rg.y, f.z );\r\n}\r\n*/\r\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\r\n\r\n// assign colour to the media\r\nvec3 computeColour( float density)\r\n{\r\n\tvec3 result = mix(vec3(.9,0.9,0.9), vec3(0.25,0.25,0.25), density );\r\n\t\r\n\treturn result;\r\n}\r\n\r\nfloat Turbulence(vec3 p)\r\n{\t\r\n\tfloat t = 0.;\r\n\tfloat oof = 1.;\r\n\tfor (int i=0; i<7; i++)\r\n\t{\r\n\t\tt += abs(noise(p))*oof;\r\n\t\toof *= 0.5;\r\n\t\tp *= 2.7;\t//bigger number, more detail\r\n\t}\r\n\t\r\n\treturn t-1.;\r\n}\r\n\r\nvec4 map(in vec3 p)\r\n{\r\n    //start of params\r\n    float rotateS = 2.6;\r\n    float riseS = 3.55;\r\n    float rmax = 4.2;\r\n    float rmin = 1.2;\r\n    //end of parms\r\n    \r\n    vec3 bottom = vec3(0.0,-4.4,0.0);\r\n    float den = 0.0;\r\n    float maxH = 8.8;  \r\n    vec3 lp = p;\r\n    float height = lp.y - bottom.y + noise(lp)*rmin*0.33;\r\n    float tease = height/maxH;\r\n    \r\n    float theta_s = iTime*rotateS;\r\n    float down = riseS*iTime;\r\n    float c = cos(-theta_s - p.y);\r\n    float s = sin(-theta_s - p.y);\r\n    float c1 = cos(-theta_s - p.y);\r\n    float s1 = sin(-theta_s - p.y);\r\n    \r\n    float noi = noise(p);\r\n    float scale = 1.0;\r\n    scale *= noi*0.01 + 0.77+0.23*abs(sin((p.y+sin(iTime*3.3)*0.1+noi*0.08)*1.9));\r\n    scale *= (0.56 + 0.44*abs(sin((tease+0.5)*3.14159)))*(1.0);\r\n    scale *= 0.6+tease*0.3;\r\n    \r\n    vec3 lp1 = lp;\r\n    lp.x *= scale;\r\n    lp.z *= scale;\r\n    lp1.x = lp.x*c-lp.z*s;\r\n    lp1.z = lp.x*s+lp.z*c;\r\n    lp1.y -= down;\r\n    float turb = Turbulence(lp1);    \r\n    \r\n    float r = rmax*scale + turb*0.3*rotateS;\r\n    float r_sq = r*r;\r\n    float roffset = r*0.2;\r\n    vec3 center = vec3(roffset*c1,p.y,roffset*s1);\r\n    center.x += turb*0.1;\r\n    center.y += turb*0.2;\r\n    center.z += turb*0.1;\r\n    vec3 diff = p - center;\r\n    float dist_sq = diff.x*diff.x + diff.y*diff.y + diff.z*diff.z;\r\n    den = (1.0-dist_sq/r_sq + turb*0.45)*1.11;\r\n    float rn_seq = (p.x*p.x + p.z*p.z)/r;\r\n    rn_seq = clamp(rn_seq,0.0,1.0);\r\n    den *= (0.22 + 0.78*abs(sin((rn_seq)*3.14159)));\r\n    den *= pow(rmax/r,2.0);\r\n    \r\n    den = clamp(den,0.0,1.0);\r\n    den = pow(den, 0.4);\r\n    \r\n    //make color\r\n    vec3 color = mix(vec3(.9,0.9,0.9), vec3(0.45,0.45,0.45), den );\r\n\treturn vec4(color,den);\r\n}\r\n\r\n\r\nvec4 raytraceVolumetric(in vec3 rayo, in vec3 rayd,in float t)\r\n{\r\n    vec3 pos = rayo+rayd*t;\r\n    float d = sdScene(pos).x;\r\n    vec4 sum = vec4( 0.0 );\r\n    \t\r\n    float last_t = t;\r\n    \r\n    #ifdef SHQ\r\n\t#define STEPS  128\r\n    float dt = 0.062;\r\n    #endif\t\r\n    #ifdef MEDQ\r\n\t#define STEPS\t64\r\n    float dt = 0.124;\r\n    #endif\t\r\n    #ifdef YUCKQ\t\r\n\t#define STEPS\t32\r\n    float dt = 0.248;\r\n    #endif\r\n    \r\n    for( int i = 0; i < STEPS && t < tmax && d<t*0.001; i++ )\r\n    {\r\n        if( sum.a > 0.99 ) continue;\r\n\t\t\t\t\r\n\t\tvec4 col = map(pos);\r\n\t\tcol.a*= (t-last_t)*1.5;\r\n        \r\n\t\t// colour by alpha\r\n\t\tcol.rgb *= col.a;\r\n\t\t\r\n\t\t// alpha blend in contribution\r\n\t\tsum = sum + col*(1.0 - sum.a);  \r\n\t\t\r\n\t\t// step along ray\r\n        last_t = t;\r\n\t\t//t += max(0.062, t*0.0096);\r\n        t += dt;\r\n\t\tpos = rayo + rayd * t;\r\n        d = sdScene(pos).x;\r\n    }\r\n\tvec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n\tsum = sum + bg*(1.0 - sum.a);  \r\n        \r\n    return clamp( sum, 0.0, 1.0 );\r\n}\r\n\r\nvec4 raymarch( in vec3 rayo, in vec3 rayd)\r\n{\r\n    vec3 pos = rayo;\r\n    float t = 0.0;\r\n\t\r\n\tfor(int i = 0; i < 15 && t < tmax; i++)\r\n    {\r\n        vec2 h = sdScene(pos);\r\n        if( h.x < 0.0001*t)\r\n        { \r\n            return raytraceVolumetric(rayo,rayd,t); \r\n        }\r\n        t += h.x;\r\n        pos = rayo + rayd * t;\r\n    }\r\n    vec4 bg = vec4(0.0,0.0,0.0,1.0);//texture(iChannel1,rayd); \r\n    //bg.a *= 0.6;\r\n    bg.rgb *= bg.a;\t\r\n    return bg; \r\n}\r\n\r\n\r\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\r\n{\t\r\n    float camRadius = 9.8;\r\n\t// use mouse x coord\r\n\tfloat a = 0.0;// iTime * 20.;\r\n    if( iMouse.z > 0. )\r\n    {\r\n\t\ta = iMouse.x;\r\n        camRadius = iMouse.y/iResolution.y*camRadius;\r\n    }\r\n\tfloat theta = (-a/iResolution.x)*3.1415926*2.+3.1415926*0.5;\r\n    float xoff = camRadius * cos(theta);\r\n    float zoff = camRadius * sin(theta);\r\n    cameraPos = vec3(xoff,0.,zoff);\r\n     \r\n    // camera target\r\n    vec3 target = vec3(0.,0.,0.);\r\n     \r\n    // camera frame\r\n    vec3 fo = normalize(target-cameraPos);\r\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\r\n    vec3 up = normalize(cross(fo,ri));\r\n     \r\n    // multiplier to emulate a fov control\r\n    float fov = .5;\r\n\t\r\n    // ray direction\r\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\r\n\t\r\n\treturn rayDir;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// get aspect corrected normalized pixel coordinate\r\n    vec2 q = fragCoord.xy / iResolution.xy;\r\n    vec2 p = -1.0 + 2.0*q;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    \r\n\tvec3 rayDir, cameraPos;\r\n    rayDir = computePixelRay( p, cameraPos );\r\n\t\r\n\tvec4 col = vec4(0.);\r\n\tcol = raymarch( cameraPos, rayDir);\r\n    // smoothstep final color to add contrast\r\n    fragColor.xyz = col.xyz*col.xyz*(3.0-2.0*col.xyz);\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// See here for a tutorial on how to make this:\r\n//\r\n// http://www.iquilezles.org/www/articles/warp/warp.htm\r\n\r\n//====================================================================\r\n\r\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat noise( in vec2 p )\r\n{\r\n\treturn sin(p.x)*sin(p.y);\r\n}\r\n\r\nfloat fbm4( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm6( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\r\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\r\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\r\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.015625*(0.5+0.5*noise( p ));\r\n    return f/0.96875;\r\n}\r\n\r\nvec2 fbm4_2( vec2 p )\r\n{\r\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\r\n}\r\n\r\nvec2 fbm6_2( vec2 p )\r\n{\r\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\r\n}\r\n\r\n//====================================================================\r\n\r\nfloat func( vec2 q, out vec4 ron )\r\n{\r\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\r\n\r\n\tvec2 o = fbm4_2( 0.9*q );\r\n\r\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\r\n\r\n    vec2 n = fbm6_2( 3.0*o );\r\n\r\n\tron = vec4( o, n );\r\n\r\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\r\n\r\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    float e = 2.0/iResolution.y;\r\n\r\n    vec4 on = vec4(0.0);\r\n    float f = func(p, on);\r\n\r\n\tvec3 col = vec3(0.0);\r\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\r\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\r\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\r\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\r\n    col = clamp( col*f*2.0, 0.0, 1.0 );\r\n    \r\n#if 0\r\n    // gpu derivatives - bad quality, but fast\r\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\r\n#else    \r\n    // manual derivatives - better quality, but slower\r\n    vec4 kk;\r\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \r\n                                2.0*e,\r\n                                func(p+vec2(0.0,e),kk)-f ) );\r\n#endif    \r\n\r\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\r\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\r\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\r\n    col *= 1.2*lin;\r\n\tcol = 1.0 - col;\r\n\tcol = 1.1*col*col;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// See here for a tutorial on how to make this:\r\n//\r\n// http://www.iquilezles.org/www/articles/warp/warp.htm\r\n\r\n//====================================================================\r\n\r\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat noise( in vec2 p )\r\n{\r\n\treturn sin(p.x)*sin(p.y);\r\n}\r\n\r\nfloat fbm4( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm6( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\r\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\r\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\r\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.015625*(0.5+0.5*noise( p ));\r\n    return f/0.96875;\r\n}\r\n\r\nvec2 fbm4_2( vec2 p )\r\n{\r\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\r\n}\r\n\r\nvec2 fbm6_2( vec2 p )\r\n{\r\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\r\n}\r\n\r\n//====================================================================\r\n\r\nfloat func( vec2 q, out vec4 ron )\r\n{\r\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\r\n\r\n\tvec2 o = fbm4_2( 0.9*q );\r\n\r\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\r\n\r\n    vec2 n = fbm6_2( 3.0*o );\r\n\r\n\tron = vec4( o, n );\r\n\r\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\r\n\r\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    float e = 2.0/iResolution.y;\r\n\r\n    vec4 on = vec4(0.0);\r\n    float f = func(p, on);\r\n\r\n\tvec3 col = vec3(0.0);\r\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\r\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\r\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\r\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\r\n    col = clamp( col*f*2.0, 0.0, 1.0 );\r\n    \r\n#if 0\r\n    // gpu derivatives - bad quality, but fast\r\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\r\n#else    \r\n    // manual derivatives - better quality, but slower\r\n    vec4 kk;\r\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \r\n                                2.0*e,\r\n                                func(p+vec2(0.0,e),kk)-f ) );\r\n#endif    \r\n\r\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\r\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\r\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\r\n    col *= 1.2*lin;\r\n\tcol = 1.0 - col;\r\n\tcol = 1.1*col*col;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Warping - procedural 2 ","id":"563b6883cdf642908ce4f7f30ba4781a","date":null,"viewed":0,"name":"Warping - procedural 2 ","description":"Warp. Tutorial here: \nhttps://www.shadertoy.com/view/lsl3RH","likes":0,"published":null,"tags":["procedural"," 2d"," fbm"]},"ver":null,"info":{"Name":"Warping - procedural 2 ","id":"563b6883cdf642908ce4f7f30ba4781a","date":null,"viewed":0,"name":"Warping - procedural 2 ","description":"Warp. Tutorial here: \nhttps://www.shadertoy.com/view/lsl3RH","likes":0,"published":null,"tags":["procedural"," 2d"," fbm"]},"renderpass":[{"Code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// See here for a tutorial on how to make this:\r\n//\r\n// http://www.iquilezles.org/www/articles/warp/warp.htm\r\n\r\n//====================================================================\r\n\r\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat noise( in vec2 p )\r\n{\r\n\treturn sin(p.x)*sin(p.y);\r\n}\r\n\r\nfloat fbm4( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm6( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\r\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\r\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\r\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.015625*(0.5+0.5*noise( p ));\r\n    return f/0.96875;\r\n}\r\n\r\nvec2 fbm4_2( vec2 p )\r\n{\r\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\r\n}\r\n\r\nvec2 fbm6_2( vec2 p )\r\n{\r\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\r\n}\r\n\r\n//====================================================================\r\n\r\nfloat func( vec2 q, out vec4 ron )\r\n{\r\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\r\n\r\n\tvec2 o = fbm4_2( 0.9*q );\r\n\r\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\r\n\r\n    vec2 n = fbm6_2( 3.0*o );\r\n\r\n\tron = vec4( o, n );\r\n\r\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\r\n\r\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    float e = 2.0/iResolution.y;\r\n\r\n    vec4 on = vec4(0.0);\r\n    float f = func(p, on);\r\n\r\n\tvec3 col = vec3(0.0);\r\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\r\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\r\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\r\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\r\n    col = clamp( col*f*2.0, 0.0, 1.0 );\r\n    \r\n#if 0\r\n    // gpu derivatives - bad quality, but fast\r\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\r\n#else    \r\n    // manual derivatives - better quality, but slower\r\n    vec4 kk;\r\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \r\n                                2.0*e,\r\n                                func(p+vec2(0.0,e),kk)-f ) );\r\n#endif    \r\n\r\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\r\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\r\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\r\n    col *= 1.2*lin;\r\n\tcol = 1.0 - col;\r\n\tcol = 1.1*col*col;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n// See here for a tutorial on how to make this:\r\n//\r\n// http://www.iquilezles.org/www/articles/warp/warp.htm\r\n\r\n//====================================================================\r\n\r\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\r\n\r\nfloat noise( in vec2 p )\r\n{\r\n\treturn sin(p.x)*sin(p.y);\r\n}\r\n\r\nfloat fbm4( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm6( vec2 p )\r\n{\r\n    float f = 0.0;\r\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\r\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\r\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\r\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\r\n    f += 0.015625*(0.5+0.5*noise( p ));\r\n    return f/0.96875;\r\n}\r\n\r\nvec2 fbm4_2( vec2 p )\r\n{\r\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\r\n}\r\n\r\nvec2 fbm6_2( vec2 p )\r\n{\r\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\r\n}\r\n\r\n//====================================================================\r\n\r\nfloat func( vec2 q, out vec4 ron )\r\n{\r\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\r\n\r\n\tvec2 o = fbm4_2( 0.9*q );\r\n\r\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\r\n\r\n    vec2 n = fbm6_2( 3.0*o );\r\n\r\n\tron = vec4( o, n );\r\n\r\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\r\n\r\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n    float e = 2.0/iResolution.y;\r\n\r\n    vec4 on = vec4(0.0);\r\n    float f = func(p, on);\r\n\r\n\tvec3 col = vec3(0.0);\r\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\r\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\r\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\r\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\r\n    col = clamp( col*f*2.0, 0.0, 1.0 );\r\n    \r\n#if 0\r\n    // gpu derivatives - bad quality, but fast\r\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\r\n#else    \r\n    // manual derivatives - better quality, but slower\r\n    vec4 kk;\r\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \r\n                                2.0*e,\r\n                                func(p+vec2(0.0,e),kk)-f ) );\r\n#endif    \r\n\r\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\r\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\r\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\r\n    col *= 1.2*lin;\r\n\tcol = 1.0 - col;\r\n\tcol = 1.1*col*col;\r\n    \r\n    fragColor = vec4( col, 1.0 );\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// different wavelengths travels at different speed: this is dispersion\r\n// there are 2 main cases: gravity waves + capillary waves\r\n// (+ mix case + shallow water + mix case + soliton + ... ok, forget theses :-p )\r\n// Physics of dispersion here: https://en.wikipedia.org/wiki/Capillary_wave\r\n\r\n// in 2D, add 1/r modulation. Or better: use Bessels instead of sines.\r\n\r\n\r\n#define W(x,k,c) A*sin(k*(X=x-c*t))*exp(-X*X)\r\n\r\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-uv.y))\r\n// #define plot(Y) o +=exp(-max(0.,Y-uv.y))\r\n\r\nvoid mainImage( out vec4 o, vec2 uv )\r\n{\r\n    float A=.8,X,y,Y=0.,  t=mod(iTime,10.); \r\n    vec2 R = iResolution.xy;    o = vec4(0.0);\r\n    uv = 10.* (2.*uv-R)/R.y; \r\n    \r\n    for (float k=1.; k<10.; k++) {\r\n        Y += y = W(abs(uv.x), k, sqrt(k))/k;   // dispertion for capillary waves\r\n     // Y += y = W(abs(uv.x), k, 1./sqrt(k))/k;// dispertion for gravity waves\r\n\t    plot( y - 3.  ); \r\n    }\r\n\r\n    plot( Y + 3. );\r\n    \r\n    o.b += .2;\r\n}","inputs":[],"outputs":[],"code":"// different wavelengths travels at different speed: this is dispersion\r\n// there are 2 main cases: gravity waves + capillary waves\r\n// (+ mix case + shallow water + mix case + soliton + ... ok, forget theses :-p )\r\n// Physics of dispersion here: https://en.wikipedia.org/wiki/Capillary_wave\r\n\r\n// in 2D, add 1/r modulation. Or better: use Bessels instead of sines.\r\n\r\n\r\n#define W(x,k,c) A*sin(k*(X=x-c*t))*exp(-X*X)\r\n\r\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-uv.y))\r\n// #define plot(Y) o +=exp(-max(0.,Y-uv.y))\r\n\r\nvoid mainImage( out vec4 o, vec2 uv )\r\n{\r\n    float A=.8,X,y,Y=0.,  t=mod(iTime,10.); \r\n    vec2 R = iResolution.xy;    o = vec4(0.0);\r\n    uv = 10.* (2.*uv-R)/R.y; \r\n    \r\n    for (float k=1.; k<10.; k++) {\r\n        Y += y = W(abs(uv.x), k, sqrt(k))/k;   // dispertion for capillary waves\r\n     // Y += y = W(abs(uv.x), k, 1./sqrt(k))/k;// dispertion for gravity waves\r\n\t    plot( y - 3.  ); \r\n    }\r\n\r\n    plot( Y + 3. );\r\n    \r\n    o.b += .2;\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"waves dispersion","id":"c7ee26be7bb34748b1d8896cb42b5ec5","date":null,"viewed":0,"name":"waves dispersion","description":"Different wavelengths travels at different speed: this is dispersion.\r\nHere, a 1D ripple made of capillary waves (i.e. raindrop fall, not asteroid ;-) ).\r\nTop: sum.   Bottom: decomposition .\r\nhttps://www.shadertoy.com/view/MtBSDG","likes":0,"published":null,"tags":["wave"," dispersion"]},"ver":null,"info":{"Name":"waves dispersion","id":"c7ee26be7bb34748b1d8896cb42b5ec5","date":null,"viewed":0,"name":"waves dispersion","description":"Different wavelengths travels at different speed: this is dispersion.\r\nHere, a 1D ripple made of capillary waves (i.e. raindrop fall, not asteroid ;-) ).\r\nTop: sum.   Bottom: decomposition .\r\nhttps://www.shadertoy.com/view/MtBSDG","likes":0,"published":null,"tags":["wave"," dispersion"]},"renderpass":[{"Code":"// different wavelengths travels at different speed: this is dispersion\r\n// there are 2 main cases: gravity waves + capillary waves\r\n// (+ mix case + shallow water + mix case + soliton + ... ok, forget theses :-p )\r\n// Physics of dispersion here: https://en.wikipedia.org/wiki/Capillary_wave\r\n\r\n// in 2D, add 1/r modulation. Or better: use Bessels instead of sines.\r\n\r\n\r\n#define W(x,k,c) A*sin(k*(X=x-c*t))*exp(-X*X)\r\n\r\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-uv.y))\r\n// #define plot(Y) o +=exp(-max(0.,Y-uv.y))\r\n\r\nvoid mainImage( out vec4 o, vec2 uv )\r\n{\r\n    float A=.8,X,y,Y=0.,  t=mod(iTime,10.); \r\n    vec2 R = iResolution.xy;    o = vec4(0.0);\r\n    uv = 10.* (2.*uv-R)/R.y; \r\n    \r\n    for (float k=1.; k<10.; k++) {\r\n        Y += y = W(abs(uv.x), k, sqrt(k))/k;   // dispertion for capillary waves\r\n     // Y += y = W(abs(uv.x), k, 1./sqrt(k))/k;// dispertion for gravity waves\r\n\t    plot( y - 3.  ); \r\n    }\r\n\r\n    plot( Y + 3. );\r\n    \r\n    o.b += .2;\r\n}","inputs":[],"outputs":[],"code":"// different wavelengths travels at different speed: this is dispersion\r\n// there are 2 main cases: gravity waves + capillary waves\r\n// (+ mix case + shallow water + mix case + soliton + ... ok, forget theses :-p )\r\n// Physics of dispersion here: https://en.wikipedia.org/wiki/Capillary_wave\r\n\r\n// in 2D, add 1/r modulation. Or better: use Bessels instead of sines.\r\n\r\n\r\n#define W(x,k,c) A*sin(k*(X=x-c*t))*exp(-X*X)\r\n\r\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-uv.y))\r\n// #define plot(Y) o +=exp(-max(0.,Y-uv.y))\r\n\r\nvoid mainImage( out vec4 o, vec2 uv )\r\n{\r\n    float A=.8,X,y,Y=0.,  t=mod(iTime,10.); \r\n    vec2 R = iResolution.xy;    o = vec4(0.0);\r\n    uv = 10.* (2.*uv-R)/R.y; \r\n    \r\n    for (float k=1.; k<10.; k++) {\r\n        Y += y = W(abs(uv.x), k, sqrt(k))/k;   // dispertion for capillary waves\r\n     // Y += y = W(abs(uv.x), k, 1./sqrt(k))/k;// dispertion for gravity waves\r\n\t    plot( y - 3.  ); \r\n    }\r\n\r\n    plot( Y + 3. );\r\n    \r\n    o.b += .2;\r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"/*\r\n       _\r\n\\^/ILD|-LOWER\r\n\r\nby Hazel Quantock 2020\r\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\r\n*/\r\n\r\n// create a simple repetetive patch of grass,\r\n// then blend it with copies of itself randomly offset and rotated\r\n\r\n\r\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\r\n#define M1 1597334677U     //1719413*929\r\n#define M2 3812015801U     //140473*2467*11\r\n#define M3 3299493293U     //467549*7057\r\n\r\n#define F0 (1.0/float(0xffffffffU))\r\n\r\n#define hash(n) n*(n^(n>>15))\r\n\r\n#define coord1(p) (uint(p)*M1)\r\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\r\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\r\n\r\nfloat hash1(uint n){return float(hash(n))*F0;}\r\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\r\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\r\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\r\n\r\n\r\nfloat BladeOfGrass( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool stalk )\r\n{\r\n    // cone, curved from vertical to tip\r\n    // subtract a second cone, offset away from tip\r\n    // maybe curve more on shorter ones\r\n\r\n    float v = (pos.y-base.y) / (tip.y - base.y);\r\n    \r\n    // curve the blade\r\n    v = pow(v,1.5);\r\n\r\n    // apply the curved slope\r\n    pos.xz -= mix(base.xz,tip.xz,v);\r\n\r\n    // wrap space here, so it can follow the curve without needing duplicate blades\r\n    // even if blade curves enough to lean into next repeat!\r\n//    pos.xz = (abs(fract(pos.xz/(tile*2.)-.25)-.5)-.25)*tile*2.;    // this flips the crease inside out but makes the sdf continuous\r\n    pos.xz = (fract(pos.xz/tile+.5)-.5)*tile;\r\n    \r\n    float r = .03*tip.y;\r\n    vec2 cutBase = -normalize(tip.xz)*r*.3;\r\n    \r\n    if ( stalk )\r\n        r = .0005;\r\n    else\r\n        r *= (1.-v);\r\n    \r\n    float f = length(pos.xz) - r;\r\n\r\n    if ( !stalk )\r\n    {\r\n        f = max(f, -(length(pos.xz - cutBase*(1.-v)) - r*1.2) );\r\n    }\r\n        \r\n    return max(pos.y-tip.y-.0, // improve distance values above tip (with a fudge because this is too low!?)\r\n              f*.8); // HACK gradient too high because of tilt - todo: do this analytically (curve of v is a problem)\r\n    \t\t\t\t// this breaks looking top-down if pow(,2) or more\r\n    \t\t\t\t// better options: tilt plane of the circle, maybe sweep it along a circular curve\r\n}\r\n\r\n\r\nfloat Flower( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool grass )\r\n{\r\n    vec3 tpos = pos-tip-vec3(0,-.0004,0);\r\n    tpos.xz = (fract(tpos.xz/tile+.5)-.5)*tile;\r\n    \r\n//\tfloat f = length(tpos)-.003;\r\n    \r\n    // tilt, so the flower sits at a nice angle\r\n    tpos.yz = tpos.yz*sqrt(2./4.) + tpos.zy*sqrt(2./4.)*vec2(-1,1);\r\n    \r\n    // petals: mirror tpos in a circle around z\r\n    tpos.xy = abs(tpos.xy);\r\n\tif ( tpos.x > tpos.y ) tpos.xy = tpos.yx;\r\n\r\n// too thin at the edges\r\n// better to intersect a thin sphere with a sphere to cut the shape\r\n/*    float f = max(\r\n            length(tpos-vec3(.001,.002,.002)*1.1) - .002,\r\n            -(length(tpos-vec3(.001,.002,.003)) - .0028)\r\n        );*/\r\n    float f = max(\r\n            length(tpos-vec3(.001,.002,.0005)*1.1) - .002, // cut shape\r\n            abs( length(tpos-vec3(.001,.002,.003)) - .003)-.0001\r\n        );\r\n    f = min( f,\r\n            max(\r\n\t            length(tpos-vec3(0,0,.000)) -.001,\r\n\t            length(tpos-vec3(0,0,.001)) -.001\r\n            )\r\n            )*.9;\r\n\r\n\tif ( grass ) f = min(min( f,\r\n                             BladeOfGrass( base, tip, tile, pos, true )),\r\n                             BladeOfGrass( base, tip+vec3(.003,-.008,-.001), tile, pos, false )\r\n                            );\r\n    \r\n\treturn f;\r\n}\r\n\r\n\r\nfloat Tile( vec3 pos, float invWeight, vec4 rand, bool grass )\r\n{\r\n//    if ( rand.w > .2 ) invWeight = 1.; // isolate some of the blades\r\n    \r\n//    invWeight = invWeight*invWeight; // should be 0 until about .5\r\n//    invWeight = smoothstep(.5,1.,invWeight); // should be 0 until about .5\r\n\r\n    // vary the height a little to make it look less even\r\n    pos.y += sqrt(rand.w)*.07;\r\n    \r\n    pos.xz += rand.xy;\r\n    float a = rand.z*6.283;\r\n    pos.xz = pos.xz*cos(a) + sin(a)*vec2(-1,1)*pos.zx;\r\n    \r\n    float f = 1e20;\r\n    \r\n    if ( grass )\r\n    {\r\n        f = min(f,min(min(min(min(\r\n            BladeOfGrass(vec3(.01,0,0),vec3(.03,.15,.04),vec2(.06),pos,false),\r\n            BladeOfGrass(vec3(0),vec3(-.05,.17,.02),vec2(.06),pos,false)),\r\n            BladeOfGrass(vec3(0),vec3(-.01,.10,.02),vec2(.04),pos,false)),\r\n            BladeOfGrass(vec3(0,0,-.01),vec3(-.01,.12,-.03),vec2(.03),pos,false)),\r\n            BladeOfGrass(vec3(.005,0,0),vec3(.03,.16,-.05),vec2(.04),pos,false)\r\n        )) + (1.-invWeight)*.0;\r\n    }\r\n    \r\n    // flowers\r\n    f = min(f, Flower(vec3(.1,0,0),vec3(.1,.2,.05),vec2(.13),pos,grass) + (1.-invWeight)*.0 );\r\n    \r\n    return mix( max(.03,pos.y-.2), f, invWeight );\r\n//    return f;\r\n}\r\n\r\nfloat SDF( vec3 pos, bool grass )\r\n{\r\n    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations\r\n    \r\n    vec2 gridSize = vec2(.1);//.04);\r\n    vec2 uv = pos.xz/gridSize;\r\n    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);\r\n    uv -= floor(uv);\r\n    \r\n    uvec2 d = uvec2(0,1);\r\n    vec4 rand00 = hash4(coord2(idx00+d.xx));\r\n    vec4 rand01 = hash4(coord2(idx00+d.yx));\r\n    vec4 rand10 = hash4(coord2(idx00+d.xy));\r\n    vec4 rand11 = hash4(coord2(idx00+d.yy));\r\n\r\n//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it\r\n\r\n    vec2 uvlo = smoothstep(1.,.5,uv);\r\n    vec2 uvhi = smoothstep(0.,.5,uv);\r\n\r\n    return min( pos.y,\r\n                min(\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),\r\n                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )\r\n                    ),\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),\r\n                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )\r\n                    )\r\n                )\r\n\t\t\t) * 1.;\r\n/*    return mix(\r\n                    mix(\r\n                        Tile( pos, uv.x*uv.y, rand00, grass ),\r\n                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),\r\n                        uv.x\r\n                    ),\r\n                    mix(\r\n                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),\r\n                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),\r\n                        uv.x\r\n                    ),\r\n        \t\t\tuv.y\r\n                );*/\r\n}\r\n\r\n// adjust trace quality/performance\r\nconst float epsilon = .00005;\r\nconst int loopCount = 200;\r\n\r\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\r\n{\r\n\tfloat t = epsilon;\r\n    for ( int i=0; i < loopCount; i++ )\r\n    {\r\n        float h = SDF( rayDirection*t+rayStart, true );\r\n        t += h;\r\n        if ( t > far || h < epsilon ) // *t )\r\n            return t;\r\n    }\r\n    \r\n    return t;\r\n}\r\n\r\n\r\nvec3 Normal( vec3 pos )\r\n{\r\n    vec2 d = vec2(-1,1) * .000004;\r\n    return\r\n        normalize(\r\n            SDF( pos + d.xxx, true )*d.xxx +\r\n            SDF( pos + d.xyy, true )*d.xyy +\r\n            SDF( pos + d.yxy, true )*d.yxy +\r\n            SDF( pos + d.yyx, true )*d.yyx\r\n        );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\r\n{\r\n    vec2 camAngle = vec2(.5-.03*(iTime/8.-sin(iTime/8.))*8.,.15-cos(iTime/8.)*.08);\r\n\tif ( iMouse.z > 0. ) camAngle = pow(iMouse.xy/iResolution.xy,vec2(1.,.5))*vec2(6,-1.57) + vec2(0,1.57);\r\n    vec3 camPos = 1.*vec3(cos(camAngle.y)*sin(camAngle.x),sin(camAngle.y),cos(camAngle.y)*cos(camAngle.x));\r\n    vec3 camLook = vec3(0,.10,0)+camPos*vec3(1,0,1)*.3;\r\n    float camZoom = 2.;\r\n    \r\n    vec3 camK = normalize(camLook-camPos);\r\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\r\n    vec3 camJ = cross(camK,camI);\r\n\r\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,camZoom);\r\n    ray = normalize(ray);\r\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\r\n    \r\n    float t = Trace( camPos, ray, 1e20 );\r\n    \r\n    float far = 20.;\r\n    if ( t < far )\r\n    {\r\n        vec3 pos = camPos+ray*t;\r\n\r\n        float sdf = SDF(pos,true);\r\n        float sdfnograss = SDF(pos,false);\r\n\r\n        vec3 flowerColour = sin(pos/.03)*.1+.9;\r\n        vec3 grassColour = mix( vec3(.2,.6,.01), vec3(.5,.7,.2), .5+.5*sin(pos.yxz/.025+2.5) );\r\n\r\n        vec3 albedo = mix( grassColour, mix( vec3(.03,.0,.0), flowerColour, smoothstep(.0,.05,pos.y)), step(sdfnograss,sdf) );\r\n\r\n        vec3 n = Normal( camPos+ray*t );\r\n        vec3 ambient = mix( vec3(.06,.1,.02), vec3(.15,.2,.25), n.y*.5+.5 );\r\n        float nl = dot(n,normalize(vec3(1,3,2)));\r\n\r\n        fragColour.rgb = ambient;\r\n        fragColour.rgb += vec3(.9)*max(0.,nl); // direct light\r\n        fragColour.rgb += vec3(.3)*pow(albedo*.99,vec3(4))*smoothstep(-1.,.1,nl); // subsurface light\r\n        fragColour.rgb *= smoothstep(.0,.18,pos.y); // fake combined shadows & AO\r\n        fragColour.rgb *= albedo;\r\n    }\r\n    else\r\n    {\r\n        fragColour.rgb = vec3(1);\r\n        t = far; // so it gets fog applied\r\n    }\r\n    \r\n    fragColour.rgb = mix( vec3(.7,.8,1), fragColour.rgb, exp2(-t/5.)*1.08 );\r\n \r\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\r\n    fragColour.a = 1.;\r\n\r\n//float f = BladeOfGrass( vec3(.8,0,0), vec3(.9,.5,0), vec3(fragCoord/iResolution.y,0) );\r\n//float f = SDF(vec3(fragCoord/1000.,.1+.1*sin(iTime)).xzy,true);\r\n//fragColour.rgb = vec3( .5+.5*f/(abs(f)+.001) );\r\n}\r\n","inputs":[],"outputs":[],"code":"/*\r\n       _\r\n\\^/ILD|-LOWER\r\n\r\nby Hazel Quantock 2020\r\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\r\n*/\r\n\r\n// create a simple repetetive patch of grass,\r\n// then blend it with copies of itself randomly offset and rotated\r\n\r\n\r\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\r\n#define M1 1597334677U     //1719413*929\r\n#define M2 3812015801U     //140473*2467*11\r\n#define M3 3299493293U     //467549*7057\r\n\r\n#define F0 (1.0/float(0xffffffffU))\r\n\r\n#define hash(n) n*(n^(n>>15))\r\n\r\n#define coord1(p) (uint(p)*M1)\r\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\r\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\r\n\r\nfloat hash1(uint n){return float(hash(n))*F0;}\r\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\r\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\r\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\r\n\r\n\r\nfloat BladeOfGrass( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool stalk )\r\n{\r\n    // cone, curved from vertical to tip\r\n    // subtract a second cone, offset away from tip\r\n    // maybe curve more on shorter ones\r\n\r\n    float v = (pos.y-base.y) / (tip.y - base.y);\r\n    \r\n    // curve the blade\r\n    v = pow(v,1.5);\r\n\r\n    // apply the curved slope\r\n    pos.xz -= mix(base.xz,tip.xz,v);\r\n\r\n    // wrap space here, so it can follow the curve without needing duplicate blades\r\n    // even if blade curves enough to lean into next repeat!\r\n//    pos.xz = (abs(fract(pos.xz/(tile*2.)-.25)-.5)-.25)*tile*2.;    // this flips the crease inside out but makes the sdf continuous\r\n    pos.xz = (fract(pos.xz/tile+.5)-.5)*tile;\r\n    \r\n    float r = .03*tip.y;\r\n    vec2 cutBase = -normalize(tip.xz)*r*.3;\r\n    \r\n    if ( stalk )\r\n        r = .0005;\r\n    else\r\n        r *= (1.-v);\r\n    \r\n    float f = length(pos.xz) - r;\r\n\r\n    if ( !stalk )\r\n    {\r\n        f = max(f, -(length(pos.xz - cutBase*(1.-v)) - r*1.2) );\r\n    }\r\n        \r\n    return max(pos.y-tip.y-.0, // improve distance values above tip (with a fudge because this is too low!?)\r\n              f*.8); // HACK gradient too high because of tilt - todo: do this analytically (curve of v is a problem)\r\n    \t\t\t\t// this breaks looking top-down if pow(,2) or more\r\n    \t\t\t\t// better options: tilt plane of the circle, maybe sweep it along a circular curve\r\n}\r\n\r\n\r\nfloat Flower( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool grass )\r\n{\r\n    vec3 tpos = pos-tip-vec3(0,-.0004,0);\r\n    tpos.xz = (fract(tpos.xz/tile+.5)-.5)*tile;\r\n    \r\n//\tfloat f = length(tpos)-.003;\r\n    \r\n    // tilt, so the flower sits at a nice angle\r\n    tpos.yz = tpos.yz*sqrt(2./4.) + tpos.zy*sqrt(2./4.)*vec2(-1,1);\r\n    \r\n    // petals: mirror tpos in a circle around z\r\n    tpos.xy = abs(tpos.xy);\r\n\tif ( tpos.x > tpos.y ) tpos.xy = tpos.yx;\r\n\r\n// too thin at the edges\r\n// better to intersect a thin sphere with a sphere to cut the shape\r\n/*    float f = max(\r\n            length(tpos-vec3(.001,.002,.002)*1.1) - .002,\r\n            -(length(tpos-vec3(.001,.002,.003)) - .0028)\r\n        );*/\r\n    float f = max(\r\n            length(tpos-vec3(.001,.002,.0005)*1.1) - .002, // cut shape\r\n            abs( length(tpos-vec3(.001,.002,.003)) - .003)-.0001\r\n        );\r\n    f = min( f,\r\n            max(\r\n\t            length(tpos-vec3(0,0,.000)) -.001,\r\n\t            length(tpos-vec3(0,0,.001)) -.001\r\n            )\r\n            )*.9;\r\n\r\n\tif ( grass ) f = min(min( f,\r\n                             BladeOfGrass( base, tip, tile, pos, true )),\r\n                             BladeOfGrass( base, tip+vec3(.003,-.008,-.001), tile, pos, false )\r\n                            );\r\n    \r\n\treturn f;\r\n}\r\n\r\n\r\nfloat Tile( vec3 pos, float invWeight, vec4 rand, bool grass )\r\n{\r\n//    if ( rand.w > .2 ) invWeight = 1.; // isolate some of the blades\r\n    \r\n//    invWeight = invWeight*invWeight; // should be 0 until about .5\r\n//    invWeight = smoothstep(.5,1.,invWeight); // should be 0 until about .5\r\n\r\n    // vary the height a little to make it look less even\r\n    pos.y += sqrt(rand.w)*.07;\r\n    \r\n    pos.xz += rand.xy;\r\n    float a = rand.z*6.283;\r\n    pos.xz = pos.xz*cos(a) + sin(a)*vec2(-1,1)*pos.zx;\r\n    \r\n    float f = 1e20;\r\n    \r\n    if ( grass )\r\n    {\r\n        f = min(f,min(min(min(min(\r\n            BladeOfGrass(vec3(.01,0,0),vec3(.03,.15,.04),vec2(.06),pos,false),\r\n            BladeOfGrass(vec3(0),vec3(-.05,.17,.02),vec2(.06),pos,false)),\r\n            BladeOfGrass(vec3(0),vec3(-.01,.10,.02),vec2(.04),pos,false)),\r\n            BladeOfGrass(vec3(0,0,-.01),vec3(-.01,.12,-.03),vec2(.03),pos,false)),\r\n            BladeOfGrass(vec3(.005,0,0),vec3(.03,.16,-.05),vec2(.04),pos,false)\r\n        )) + (1.-invWeight)*.0;\r\n    }\r\n    \r\n    // flowers\r\n    f = min(f, Flower(vec3(.1,0,0),vec3(.1,.2,.05),vec2(.13),pos,grass) + (1.-invWeight)*.0 );\r\n    \r\n    return mix( max(.03,pos.y-.2), f, invWeight );\r\n//    return f;\r\n}\r\n\r\nfloat SDF( vec3 pos, bool grass )\r\n{\r\n    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations\r\n    \r\n    vec2 gridSize = vec2(.1);//.04);\r\n    vec2 uv = pos.xz/gridSize;\r\n    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);\r\n    uv -= floor(uv);\r\n    \r\n    uvec2 d = uvec2(0,1);\r\n    vec4 rand00 = hash4(coord2(idx00+d.xx));\r\n    vec4 rand01 = hash4(coord2(idx00+d.yx));\r\n    vec4 rand10 = hash4(coord2(idx00+d.xy));\r\n    vec4 rand11 = hash4(coord2(idx00+d.yy));\r\n\r\n//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it\r\n\r\n    vec2 uvlo = smoothstep(1.,.5,uv);\r\n    vec2 uvhi = smoothstep(0.,.5,uv);\r\n\r\n    return min( pos.y,\r\n                min(\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),\r\n                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )\r\n                    ),\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),\r\n                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )\r\n                    )\r\n                )\r\n\t\t\t) * 1.;\r\n/*    return mix(\r\n                    mix(\r\n                        Tile( pos, uv.x*uv.y, rand00, grass ),\r\n                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),\r\n                        uv.x\r\n                    ),\r\n                    mix(\r\n                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),\r\n                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),\r\n                        uv.x\r\n                    ),\r\n        \t\t\tuv.y\r\n                );*/\r\n}\r\n\r\n// adjust trace quality/performance\r\nconst float epsilon = .00005;\r\nconst int loopCount = 200;\r\n\r\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\r\n{\r\n\tfloat t = epsilon;\r\n    for ( int i=0; i < loopCount; i++ )\r\n    {\r\n        float h = SDF( rayDirection*t+rayStart, true );\r\n        t += h;\r\n        if ( t > far || h < epsilon ) // *t )\r\n            return t;\r\n    }\r\n    \r\n    return t;\r\n}\r\n\r\n\r\nvec3 Normal( vec3 pos )\r\n{\r\n    vec2 d = vec2(-1,1) * .000004;\r\n    return\r\n        normalize(\r\n            SDF( pos + d.xxx, true )*d.xxx +\r\n            SDF( pos + d.xyy, true )*d.xyy +\r\n            SDF( pos + d.yxy, true )*d.yxy +\r\n            SDF( pos + d.yyx, true )*d.yyx\r\n        );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\r\n{\r\n    vec2 camAngle = vec2(.5-.03*(iTime/8.-sin(iTime/8.))*8.,.15-cos(iTime/8.)*.08);\r\n\tif ( iMouse.z > 0. ) camAngle = pow(iMouse.xy/iResolution.xy,vec2(1.,.5))*vec2(6,-1.57) + vec2(0,1.57);\r\n    vec3 camPos = 1.*vec3(cos(camAngle.y)*sin(camAngle.x),sin(camAngle.y),cos(camAngle.y)*cos(camAngle.x));\r\n    vec3 camLook = vec3(0,.10,0)+camPos*vec3(1,0,1)*.3;\r\n    float camZoom = 2.;\r\n    \r\n    vec3 camK = normalize(camLook-camPos);\r\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\r\n    vec3 camJ = cross(camK,camI);\r\n\r\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,camZoom);\r\n    ray = normalize(ray);\r\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\r\n    \r\n    float t = Trace( camPos, ray, 1e20 );\r\n    \r\n    float far = 20.;\r\n    if ( t < far )\r\n    {\r\n        vec3 pos = camPos+ray*t;\r\n\r\n        float sdf = SDF(pos,true);\r\n        float sdfnograss = SDF(pos,false);\r\n\r\n        vec3 flowerColour = sin(pos/.03)*.1+.9;\r\n        vec3 grassColour = mix( vec3(.2,.6,.01), vec3(.5,.7,.2), .5+.5*sin(pos.yxz/.025+2.5) );\r\n\r\n        vec3 albedo = mix( grassColour, mix( vec3(.03,.0,.0), flowerColour, smoothstep(.0,.05,pos.y)), step(sdfnograss,sdf) );\r\n\r\n        vec3 n = Normal( camPos+ray*t );\r\n        vec3 ambient = mix( vec3(.06,.1,.02), vec3(.15,.2,.25), n.y*.5+.5 );\r\n        float nl = dot(n,normalize(vec3(1,3,2)));\r\n\r\n        fragColour.rgb = ambient;\r\n        fragColour.rgb += vec3(.9)*max(0.,nl); // direct light\r\n        fragColour.rgb += vec3(.3)*pow(albedo*.99,vec3(4))*smoothstep(-1.,.1,nl); // subsurface light\r\n        fragColour.rgb *= smoothstep(.0,.18,pos.y); // fake combined shadows & AO\r\n        fragColour.rgb *= albedo;\r\n    }\r\n    else\r\n    {\r\n        fragColour.rgb = vec3(1);\r\n        t = far; // so it gets fog applied\r\n    }\r\n    \r\n    fragColour.rgb = mix( vec3(.7,.8,1), fragColour.rgb, exp2(-t/5.)*1.08 );\r\n \r\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\r\n    fragColour.a = 1.;\r\n\r\n//float f = BladeOfGrass( vec3(.8,0,0), vec3(.9,.5,0), vec3(fragCoord/iResolution.y,0) );\r\n//float f = SDF(vec3(fragCoord/1000.,.1+.1*sin(iTime)).xzy,true);\r\n//fragColour.rgb = vec3( .5+.5*f/(abs(f)+.001) );\r\n}\r\n","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Wildflower","id":"2817b55017af4f769ca466b8dfcce7a0","date":null,"viewed":0,"name":"Wildflower","description":"An experiment in creating a dense detailed organic scene.\r\nhttps://www.shadertoy.com/view/tlVGz1","likes":0,"published":null,"tags":["raymarching"," flower"," grass"," organic"," natural"]},"ver":null,"info":{"Name":"Wildflower","id":"2817b55017af4f769ca466b8dfcce7a0","date":null,"viewed":0,"name":"Wildflower","description":"An experiment in creating a dense detailed organic scene.\r\nhttps://www.shadertoy.com/view/tlVGz1","likes":0,"published":null,"tags":["raymarching"," flower"," grass"," organic"," natural"]},"renderpass":[{"Code":"/*\r\n       _\r\n\\^/ILD|-LOWER\r\n\r\nby Hazel Quantock 2020\r\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\r\n*/\r\n\r\n// create a simple repetetive patch of grass,\r\n// then blend it with copies of itself randomly offset and rotated\r\n\r\n\r\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\r\n#define M1 1597334677U     //1719413*929\r\n#define M2 3812015801U     //140473*2467*11\r\n#define M3 3299493293U     //467549*7057\r\n\r\n#define F0 (1.0/float(0xffffffffU))\r\n\r\n#define hash(n) n*(n^(n>>15))\r\n\r\n#define coord1(p) (uint(p)*M1)\r\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\r\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\r\n\r\nfloat hash1(uint n){return float(hash(n))*F0;}\r\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\r\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\r\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\r\n\r\n\r\nfloat BladeOfGrass( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool stalk )\r\n{\r\n    // cone, curved from vertical to tip\r\n    // subtract a second cone, offset away from tip\r\n    // maybe curve more on shorter ones\r\n\r\n    float v = (pos.y-base.y) / (tip.y - base.y);\r\n    \r\n    // curve the blade\r\n    v = pow(v,1.5);\r\n\r\n    // apply the curved slope\r\n    pos.xz -= mix(base.xz,tip.xz,v);\r\n\r\n    // wrap space here, so it can follow the curve without needing duplicate blades\r\n    // even if blade curves enough to lean into next repeat!\r\n//    pos.xz = (abs(fract(pos.xz/(tile*2.)-.25)-.5)-.25)*tile*2.;    // this flips the crease inside out but makes the sdf continuous\r\n    pos.xz = (fract(pos.xz/tile+.5)-.5)*tile;\r\n    \r\n    float r = .03*tip.y;\r\n    vec2 cutBase = -normalize(tip.xz)*r*.3;\r\n    \r\n    if ( stalk )\r\n        r = .0005;\r\n    else\r\n        r *= (1.-v);\r\n    \r\n    float f = length(pos.xz) - r;\r\n\r\n    if ( !stalk )\r\n    {\r\n        f = max(f, -(length(pos.xz - cutBase*(1.-v)) - r*1.2) );\r\n    }\r\n        \r\n    return max(pos.y-tip.y-.0, // improve distance values above tip (with a fudge because this is too low!?)\r\n              f*.8); // HACK gradient too high because of tilt - todo: do this analytically (curve of v is a problem)\r\n    \t\t\t\t// this breaks looking top-down if pow(,2) or more\r\n    \t\t\t\t// better options: tilt plane of the circle, maybe sweep it along a circular curve\r\n}\r\n\r\n\r\nfloat Flower( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool grass )\r\n{\r\n    vec3 tpos = pos-tip-vec3(0,-.0004,0);\r\n    tpos.xz = (fract(tpos.xz/tile+.5)-.5)*tile;\r\n    \r\n//\tfloat f = length(tpos)-.003;\r\n    \r\n    // tilt, so the flower sits at a nice angle\r\n    tpos.yz = tpos.yz*sqrt(2./4.) + tpos.zy*sqrt(2./4.)*vec2(-1,1);\r\n    \r\n    // petals: mirror tpos in a circle around z\r\n    tpos.xy = abs(tpos.xy);\r\n\tif ( tpos.x > tpos.y ) tpos.xy = tpos.yx;\r\n\r\n// too thin at the edges\r\n// better to intersect a thin sphere with a sphere to cut the shape\r\n/*    float f = max(\r\n            length(tpos-vec3(.001,.002,.002)*1.1) - .002,\r\n            -(length(tpos-vec3(.001,.002,.003)) - .0028)\r\n        );*/\r\n    float f = max(\r\n            length(tpos-vec3(.001,.002,.0005)*1.1) - .002, // cut shape\r\n            abs( length(tpos-vec3(.001,.002,.003)) - .003)-.0001\r\n        );\r\n    f = min( f,\r\n            max(\r\n\t            length(tpos-vec3(0,0,.000)) -.001,\r\n\t            length(tpos-vec3(0,0,.001)) -.001\r\n            )\r\n            )*.9;\r\n\r\n\tif ( grass ) f = min(min( f,\r\n                             BladeOfGrass( base, tip, tile, pos, true )),\r\n                             BladeOfGrass( base, tip+vec3(.003,-.008,-.001), tile, pos, false )\r\n                            );\r\n    \r\n\treturn f;\r\n}\r\n\r\n\r\nfloat Tile( vec3 pos, float invWeight, vec4 rand, bool grass )\r\n{\r\n//    if ( rand.w > .2 ) invWeight = 1.; // isolate some of the blades\r\n    \r\n//    invWeight = invWeight*invWeight; // should be 0 until about .5\r\n//    invWeight = smoothstep(.5,1.,invWeight); // should be 0 until about .5\r\n\r\n    // vary the height a little to make it look less even\r\n    pos.y += sqrt(rand.w)*.07;\r\n    \r\n    pos.xz += rand.xy;\r\n    float a = rand.z*6.283;\r\n    pos.xz = pos.xz*cos(a) + sin(a)*vec2(-1,1)*pos.zx;\r\n    \r\n    float f = 1e20;\r\n    \r\n    if ( grass )\r\n    {\r\n        f = min(f,min(min(min(min(\r\n            BladeOfGrass(vec3(.01,0,0),vec3(.03,.15,.04),vec2(.06),pos,false),\r\n            BladeOfGrass(vec3(0),vec3(-.05,.17,.02),vec2(.06),pos,false)),\r\n            BladeOfGrass(vec3(0),vec3(-.01,.10,.02),vec2(.04),pos,false)),\r\n            BladeOfGrass(vec3(0,0,-.01),vec3(-.01,.12,-.03),vec2(.03),pos,false)),\r\n            BladeOfGrass(vec3(.005,0,0),vec3(.03,.16,-.05),vec2(.04),pos,false)\r\n        )) + (1.-invWeight)*.0;\r\n    }\r\n    \r\n    // flowers\r\n    f = min(f, Flower(vec3(.1,0,0),vec3(.1,.2,.05),vec2(.13),pos,grass) + (1.-invWeight)*.0 );\r\n    \r\n    return mix( max(.03,pos.y-.2), f, invWeight );\r\n//    return f;\r\n}\r\n\r\nfloat SDF( vec3 pos, bool grass )\r\n{\r\n    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations\r\n    \r\n    vec2 gridSize = vec2(.1);//.04);\r\n    vec2 uv = pos.xz/gridSize;\r\n    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);\r\n    uv -= floor(uv);\r\n    \r\n    uvec2 d = uvec2(0,1);\r\n    vec4 rand00 = hash4(coord2(idx00+d.xx));\r\n    vec4 rand01 = hash4(coord2(idx00+d.yx));\r\n    vec4 rand10 = hash4(coord2(idx00+d.xy));\r\n    vec4 rand11 = hash4(coord2(idx00+d.yy));\r\n\r\n//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it\r\n\r\n    vec2 uvlo = smoothstep(1.,.5,uv);\r\n    vec2 uvhi = smoothstep(0.,.5,uv);\r\n\r\n    return min( pos.y,\r\n                min(\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),\r\n                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )\r\n                    ),\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),\r\n                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )\r\n                    )\r\n                )\r\n\t\t\t) * 1.;\r\n/*    return mix(\r\n                    mix(\r\n                        Tile( pos, uv.x*uv.y, rand00, grass ),\r\n                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),\r\n                        uv.x\r\n                    ),\r\n                    mix(\r\n                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),\r\n                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),\r\n                        uv.x\r\n                    ),\r\n        \t\t\tuv.y\r\n                );*/\r\n}\r\n\r\n// adjust trace quality/performance\r\nconst float epsilon = .00005;\r\nconst int loopCount = 200;\r\n\r\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\r\n{\r\n\tfloat t = epsilon;\r\n    for ( int i=0; i < loopCount; i++ )\r\n    {\r\n        float h = SDF( rayDirection*t+rayStart, true );\r\n        t += h;\r\n        if ( t > far || h < epsilon ) // *t )\r\n            return t;\r\n    }\r\n    \r\n    return t;\r\n}\r\n\r\n\r\nvec3 Normal( vec3 pos )\r\n{\r\n    vec2 d = vec2(-1,1) * .000004;\r\n    return\r\n        normalize(\r\n            SDF( pos + d.xxx, true )*d.xxx +\r\n            SDF( pos + d.xyy, true )*d.xyy +\r\n            SDF( pos + d.yxy, true )*d.yxy +\r\n            SDF( pos + d.yyx, true )*d.yyx\r\n        );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\r\n{\r\n    vec2 camAngle = vec2(.5-.03*(iTime/8.-sin(iTime/8.))*8.,.15-cos(iTime/8.)*.08);\r\n\tif ( iMouse.z > 0. ) camAngle = pow(iMouse.xy/iResolution.xy,vec2(1.,.5))*vec2(6,-1.57) + vec2(0,1.57);\r\n    vec3 camPos = 1.*vec3(cos(camAngle.y)*sin(camAngle.x),sin(camAngle.y),cos(camAngle.y)*cos(camAngle.x));\r\n    vec3 camLook = vec3(0,.10,0)+camPos*vec3(1,0,1)*.3;\r\n    float camZoom = 2.;\r\n    \r\n    vec3 camK = normalize(camLook-camPos);\r\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\r\n    vec3 camJ = cross(camK,camI);\r\n\r\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,camZoom);\r\n    ray = normalize(ray);\r\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\r\n    \r\n    float t = Trace( camPos, ray, 1e20 );\r\n    \r\n    float far = 20.;\r\n    if ( t < far )\r\n    {\r\n        vec3 pos = camPos+ray*t;\r\n\r\n        float sdf = SDF(pos,true);\r\n        float sdfnograss = SDF(pos,false);\r\n\r\n        vec3 flowerColour = sin(pos/.03)*.1+.9;\r\n        vec3 grassColour = mix( vec3(.2,.6,.01), vec3(.5,.7,.2), .5+.5*sin(pos.yxz/.025+2.5) );\r\n\r\n        vec3 albedo = mix( grassColour, mix( vec3(.03,.0,.0), flowerColour, smoothstep(.0,.05,pos.y)), step(sdfnograss,sdf) );\r\n\r\n        vec3 n = Normal( camPos+ray*t );\r\n        vec3 ambient = mix( vec3(.06,.1,.02), vec3(.15,.2,.25), n.y*.5+.5 );\r\n        float nl = dot(n,normalize(vec3(1,3,2)));\r\n\r\n        fragColour.rgb = ambient;\r\n        fragColour.rgb += vec3(.9)*max(0.,nl); // direct light\r\n        fragColour.rgb += vec3(.3)*pow(albedo*.99,vec3(4))*smoothstep(-1.,.1,nl); // subsurface light\r\n        fragColour.rgb *= smoothstep(.0,.18,pos.y); // fake combined shadows & AO\r\n        fragColour.rgb *= albedo;\r\n    }\r\n    else\r\n    {\r\n        fragColour.rgb = vec3(1);\r\n        t = far; // so it gets fog applied\r\n    }\r\n    \r\n    fragColour.rgb = mix( vec3(.7,.8,1), fragColour.rgb, exp2(-t/5.)*1.08 );\r\n \r\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\r\n    fragColour.a = 1.;\r\n\r\n//float f = BladeOfGrass( vec3(.8,0,0), vec3(.9,.5,0), vec3(fragCoord/iResolution.y,0) );\r\n//float f = SDF(vec3(fragCoord/1000.,.1+.1*sin(iTime)).xzy,true);\r\n//fragColour.rgb = vec3( .5+.5*f/(abs(f)+.001) );\r\n}\r\n","inputs":[],"outputs":[],"code":"/*\r\n       _\r\n\\^/ILD|-LOWER\r\n\r\nby Hazel Quantock 2020\r\nThis work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\r\n*/\r\n\r\n// create a simple repetetive patch of grass,\r\n// then blend it with copies of itself randomly offset and rotated\r\n\r\n\r\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\r\n#define M1 1597334677U     //1719413*929\r\n#define M2 3812015801U     //140473*2467*11\r\n#define M3 3299493293U     //467549*7057\r\n\r\n#define F0 (1.0/float(0xffffffffU))\r\n\r\n#define hash(n) n*(n^(n>>15))\r\n\r\n#define coord1(p) (uint(p)*M1)\r\n#define coord2(p) (uvec2(p).x*M1^uvec2(p).y*M2)\r\n#define coord3(p) (uvec3(p).x*M1^uvec3(p).y*M2^uvec3(p).z*M3)\r\n\r\nfloat hash1(uint n){return float(hash(n))*F0;}\r\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\r\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\r\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\r\n\r\n\r\nfloat BladeOfGrass( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool stalk )\r\n{\r\n    // cone, curved from vertical to tip\r\n    // subtract a second cone, offset away from tip\r\n    // maybe curve more on shorter ones\r\n\r\n    float v = (pos.y-base.y) / (tip.y - base.y);\r\n    \r\n    // curve the blade\r\n    v = pow(v,1.5);\r\n\r\n    // apply the curved slope\r\n    pos.xz -= mix(base.xz,tip.xz,v);\r\n\r\n    // wrap space here, so it can follow the curve without needing duplicate blades\r\n    // even if blade curves enough to lean into next repeat!\r\n//    pos.xz = (abs(fract(pos.xz/(tile*2.)-.25)-.5)-.25)*tile*2.;    // this flips the crease inside out but makes the sdf continuous\r\n    pos.xz = (fract(pos.xz/tile+.5)-.5)*tile;\r\n    \r\n    float r = .03*tip.y;\r\n    vec2 cutBase = -normalize(tip.xz)*r*.3;\r\n    \r\n    if ( stalk )\r\n        r = .0005;\r\n    else\r\n        r *= (1.-v);\r\n    \r\n    float f = length(pos.xz) - r;\r\n\r\n    if ( !stalk )\r\n    {\r\n        f = max(f, -(length(pos.xz - cutBase*(1.-v)) - r*1.2) );\r\n    }\r\n        \r\n    return max(pos.y-tip.y-.0, // improve distance values above tip (with a fudge because this is too low!?)\r\n              f*.8); // HACK gradient too high because of tilt - todo: do this analytically (curve of v is a problem)\r\n    \t\t\t\t// this breaks looking top-down if pow(,2) or more\r\n    \t\t\t\t// better options: tilt plane of the circle, maybe sweep it along a circular curve\r\n}\r\n\r\n\r\nfloat Flower( vec3 base, vec3 tip, vec2 tile, vec3 pos, bool grass )\r\n{\r\n    vec3 tpos = pos-tip-vec3(0,-.0004,0);\r\n    tpos.xz = (fract(tpos.xz/tile+.5)-.5)*tile;\r\n    \r\n//\tfloat f = length(tpos)-.003;\r\n    \r\n    // tilt, so the flower sits at a nice angle\r\n    tpos.yz = tpos.yz*sqrt(2./4.) + tpos.zy*sqrt(2./4.)*vec2(-1,1);\r\n    \r\n    // petals: mirror tpos in a circle around z\r\n    tpos.xy = abs(tpos.xy);\r\n\tif ( tpos.x > tpos.y ) tpos.xy = tpos.yx;\r\n\r\n// too thin at the edges\r\n// better to intersect a thin sphere with a sphere to cut the shape\r\n/*    float f = max(\r\n            length(tpos-vec3(.001,.002,.002)*1.1) - .002,\r\n            -(length(tpos-vec3(.001,.002,.003)) - .0028)\r\n        );*/\r\n    float f = max(\r\n            length(tpos-vec3(.001,.002,.0005)*1.1) - .002, // cut shape\r\n            abs( length(tpos-vec3(.001,.002,.003)) - .003)-.0001\r\n        );\r\n    f = min( f,\r\n            max(\r\n\t            length(tpos-vec3(0,0,.000)) -.001,\r\n\t            length(tpos-vec3(0,0,.001)) -.001\r\n            )\r\n            )*.9;\r\n\r\n\tif ( grass ) f = min(min( f,\r\n                             BladeOfGrass( base, tip, tile, pos, true )),\r\n                             BladeOfGrass( base, tip+vec3(.003,-.008,-.001), tile, pos, false )\r\n                            );\r\n    \r\n\treturn f;\r\n}\r\n\r\n\r\nfloat Tile( vec3 pos, float invWeight, vec4 rand, bool grass )\r\n{\r\n//    if ( rand.w > .2 ) invWeight = 1.; // isolate some of the blades\r\n    \r\n//    invWeight = invWeight*invWeight; // should be 0 until about .5\r\n//    invWeight = smoothstep(.5,1.,invWeight); // should be 0 until about .5\r\n\r\n    // vary the height a little to make it look less even\r\n    pos.y += sqrt(rand.w)*.07;\r\n    \r\n    pos.xz += rand.xy;\r\n    float a = rand.z*6.283;\r\n    pos.xz = pos.xz*cos(a) + sin(a)*vec2(-1,1)*pos.zx;\r\n    \r\n    float f = 1e20;\r\n    \r\n    if ( grass )\r\n    {\r\n        f = min(f,min(min(min(min(\r\n            BladeOfGrass(vec3(.01,0,0),vec3(.03,.15,.04),vec2(.06),pos,false),\r\n            BladeOfGrass(vec3(0),vec3(-.05,.17,.02),vec2(.06),pos,false)),\r\n            BladeOfGrass(vec3(0),vec3(-.01,.10,.02),vec2(.04),pos,false)),\r\n            BladeOfGrass(vec3(0,0,-.01),vec3(-.01,.12,-.03),vec2(.03),pos,false)),\r\n            BladeOfGrass(vec3(.005,0,0),vec3(.03,.16,-.05),vec2(.04),pos,false)\r\n        )) + (1.-invWeight)*.0;\r\n    }\r\n    \r\n    // flowers\r\n    f = min(f, Flower(vec3(.1,0,0),vec3(.1,.2,.05),vec2(.13),pos,grass) + (1.-invWeight)*.0 );\r\n    \r\n    return mix( max(.03,pos.y-.2), f, invWeight );\r\n//    return f;\r\n}\r\n\r\nfloat SDF( vec3 pos, bool grass )\r\n{\r\n    // bilinearly filter 4 instances of the Tile pattern with random offsets and rotations\r\n    \r\n    vec2 gridSize = vec2(.1);//.04);\r\n    vec2 uv = pos.xz/gridSize;\r\n    uvec2 idx00 = uvec2(ivec2(floor(uv))+0x10000);\r\n    uv -= floor(uv);\r\n    \r\n    uvec2 d = uvec2(0,1);\r\n    vec4 rand00 = hash4(coord2(idx00+d.xx));\r\n    vec4 rand01 = hash4(coord2(idx00+d.yx));\r\n    vec4 rand10 = hash4(coord2(idx00+d.xy));\r\n    vec4 rand11 = hash4(coord2(idx00+d.yy));\r\n\r\n//    uv = smoothstep(.0,1.,uv); // this causes a steeper gradient in the middle, so get fewer errors without it\r\n\r\n    vec2 uvlo = smoothstep(1.,.5,uv);\r\n    vec2 uvhi = smoothstep(0.,.5,uv);\r\n\r\n    return min( pos.y,\r\n                min(\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvlo.y, rand00, grass ),\r\n                        Tile( pos, uvhi.x*uvlo.y, rand01, grass )\r\n                    ),\r\n                    min(\r\n                        Tile( pos, uvlo.x*uvhi.y, rand10, grass ),\r\n                        Tile( pos, uvhi.x*uvhi.y, rand11, grass )\r\n                    )\r\n                )\r\n\t\t\t) * 1.;\r\n/*    return mix(\r\n                    mix(\r\n                        Tile( pos, uv.x*uv.y, rand00, grass ),\r\n                        Tile( pos, (1.-uv.x)*uv.y, rand01, grass ),\r\n                        uv.x\r\n                    ),\r\n                    mix(\r\n                        Tile( pos, uv.x*(1.-uv.y), rand10, grass ),\r\n                        Tile( pos, (1.-uv.x)*(1.-uv.y), rand11, grass ),\r\n                        uv.x\r\n                    ),\r\n        \t\t\tuv.y\r\n                );*/\r\n}\r\n\r\n// adjust trace quality/performance\r\nconst float epsilon = .00005;\r\nconst int loopCount = 200;\r\n\r\nfloat Trace( vec3 rayStart, vec3 rayDirection, float far )\r\n{\r\n\tfloat t = epsilon;\r\n    for ( int i=0; i < loopCount; i++ )\r\n    {\r\n        float h = SDF( rayDirection*t+rayStart, true );\r\n        t += h;\r\n        if ( t > far || h < epsilon ) // *t )\r\n            return t;\r\n    }\r\n    \r\n    return t;\r\n}\r\n\r\n\r\nvec3 Normal( vec3 pos )\r\n{\r\n    vec2 d = vec2(-1,1) * .000004;\r\n    return\r\n        normalize(\r\n            SDF( pos + d.xxx, true )*d.xxx +\r\n            SDF( pos + d.xyy, true )*d.xyy +\r\n            SDF( pos + d.yxy, true )*d.yxy +\r\n            SDF( pos + d.yyx, true )*d.yyx\r\n        );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\r\n{\r\n    vec2 camAngle = vec2(.5-.03*(iTime/8.-sin(iTime/8.))*8.,.15-cos(iTime/8.)*.08);\r\n\tif ( iMouse.z > 0. ) camAngle = pow(iMouse.xy/iResolution.xy,vec2(1.,.5))*vec2(6,-1.57) + vec2(0,1.57);\r\n    vec3 camPos = 1.*vec3(cos(camAngle.y)*sin(camAngle.x),sin(camAngle.y),cos(camAngle.y)*cos(camAngle.x));\r\n    vec3 camLook = vec3(0,.10,0)+camPos*vec3(1,0,1)*.3;\r\n    float camZoom = 2.;\r\n    \r\n    vec3 camK = normalize(camLook-camPos);\r\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\r\n    vec3 camJ = cross(camK,camI);\r\n\r\n    vec3 ray = vec3((fragCoord-iResolution.xy*.5)/iResolution.y,camZoom);\r\n    ray = normalize(ray);\r\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\r\n    \r\n    float t = Trace( camPos, ray, 1e20 );\r\n    \r\n    float far = 20.;\r\n    if ( t < far )\r\n    {\r\n        vec3 pos = camPos+ray*t;\r\n\r\n        float sdf = SDF(pos,true);\r\n        float sdfnograss = SDF(pos,false);\r\n\r\n        vec3 flowerColour = sin(pos/.03)*.1+.9;\r\n        vec3 grassColour = mix( vec3(.2,.6,.01), vec3(.5,.7,.2), .5+.5*sin(pos.yxz/.025+2.5) );\r\n\r\n        vec3 albedo = mix( grassColour, mix( vec3(.03,.0,.0), flowerColour, smoothstep(.0,.05,pos.y)), step(sdfnograss,sdf) );\r\n\r\n        vec3 n = Normal( camPos+ray*t );\r\n        vec3 ambient = mix( vec3(.06,.1,.02), vec3(.15,.2,.25), n.y*.5+.5 );\r\n        float nl = dot(n,normalize(vec3(1,3,2)));\r\n\r\n        fragColour.rgb = ambient;\r\n        fragColour.rgb += vec3(.9)*max(0.,nl); // direct light\r\n        fragColour.rgb += vec3(.3)*pow(albedo*.99,vec3(4))*smoothstep(-1.,.1,nl); // subsurface light\r\n        fragColour.rgb *= smoothstep(.0,.18,pos.y); // fake combined shadows & AO\r\n        fragColour.rgb *= albedo;\r\n    }\r\n    else\r\n    {\r\n        fragColour.rgb = vec3(1);\r\n        t = far; // so it gets fog applied\r\n    }\r\n    \r\n    fragColour.rgb = mix( vec3(.7,.8,1), fragColour.rgb, exp2(-t/5.)*1.08 );\r\n \r\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\r\n    fragColour.a = 1.;\r\n\r\n//float f = BladeOfGrass( vec3(.8,0,0), vec3(.9,.5,0), vec3(fragCoord/iResolution.y,0) );\r\n//float f = SDF(vec3(fragCoord/1000.,.1+.1*sin(iTime)).xzy,true);\r\n//fragColour.rgb = vec3( .5+.5*f/(abs(f)+.001) );\r\n}\r\n","name":"Image","description":null,"type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Worley Cellular Noise 2D","id":"tt3GRj","date":"1577105511","viewed":35,"name":"Worley Cellular Noise 2D","description":"Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["2d","noise","worley","cellular"]},"ver":"0.1","info":{"Name":"Worley Cellular Noise 2D","id":"tt3GRj","date":"1577105511","viewed":35,"name":"Worley Cellular Noise 2D","description":"Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["2d","noise","worley","cellular"]},"renderpass":[{"Code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec2 noise22(in vec2 x){\n    vec3 p = vec3(x,0.5);\n    p.z += anim;\n    p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    return vec2(fx,fy);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, vec2 at, vec4 oldFs, inout vec4 ids){\n    vec2 p = vec2(float(cellX),float(cellY));\n    vec2 seed = vec2(p.x*1.234+1234.0, p.y*5.678+5678.0);\n    float id = seed.x + seed.y;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec2 diff = noise22(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        \n        vec2 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz;oldFs.x = d;\n            ids.yzw = ids.yzw;ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz;oldFs.y = d;\n            ids.zw = ids.yz;ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z;oldFs.z = d;\n            ids.w = ids.z;ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n2d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise2D(vec2 at, inout vec4 ids){\n    vec2 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    if(dx1<fs[max_order-1])//\u5DE6\n        fs = AddSamples(int_at_x-1,int_at_y,at,fs,ids);\n    if(dy1 < fs[max_order-1])//\u4E0B\n        fs = AddSamples(int_at_x,int_at_y-1,at,fs,ids);\n    if(dx1+dy1 < fs[max_order-1])//\u5DE6\u4E0B\n        fs = AddSamples(int_at_x-1,int_at_y-1,at,fs,ids);\n    if(dx2 < fs[max_order-1])//\u53F3\n        fs = AddSamples(int_at_x+1,int_at_y,at,fs,ids);\n    if(dy2 < fs[max_order-1])//\u4E0A\n        fs = AddSamples(int_at_x,int_at_y+1,at,fs,ids);\n    if(dx2+dy2 < fs[max_order-1])//\u53F3\u4E0A\n        fs = AddSamples(int_at_x+1,int_at_y+1,at,fs,ids);\n    if(dx1+dy2 < fs[max_order-1])//\u5DE6\u4E0A\n        fs = AddSamples(int_at_x-1,int_at_y+1,at,fs,ids);\n    if(dx2+dy1 < fs[max_order-1])//\u53F3\u4E0B\n        fs = AddSamples(int_at_x+1,int_at_y-1,at,fs,ids);\n    return fs;\n}\n\n\nvec4 fractalCellularNoise2D(vec2 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n        vec4 ids;\n\t\tm += cellularNoise2D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n\n    vec2 p = fragCoord/iResolution.y;\n    vec2 at = p*4.0;\n    float anim2 = iTime*0.2;\n    float scanLineX = fract(anim2);\n    int demo = int(floor(mod(anim2,4.0)));//linear combination\n    float x = fragCoord.x/iResolution.x;\n    if(x > scanLineX){\n        demo = demo - 1;\n        if(demo<0)\n            demo = 3;\n    }\n    vec3 col = vec3(0.0,0.0,0.0);\n    vec4 ids;\n    vec4 fs = cellularNoise2D(at,ids); fs = sqrt(fs);\n   \n    vec4 fs2 = fractalCellularNoise2D(at); fs2 = sqrt(fs2);\n    if(demo == 0){\n        col = vec3(fs[0]);\n    }else if(demo == 1){\n        float c=fs.x*(0.95*fs.y-fs.x); \n        col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n    }else if(demo == 2){\n        col = vec3(-fs[0]+fs[1]);\n    }else if(demo == 3){\n        col = vec3(fs2.x);\n    }\n    col *= smoothstep(0.0,0.01,abs(x-scanLineX));\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"Ver":"0.1","ImageRenderpass":{"Code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"},"Inputs":[],"Info":{"Name":"Worley Cellular Noise 3D","id":"3ldGRl","date":"1577259203","viewed":50,"name":"Worley Cellular Noise 3D","description":"3d Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["3d","noise","worley","cellular"]},"ver":"0.1","info":{"Name":"Worley Cellular Noise 3D","id":"3ldGRl","date":"1577259203","viewed":50,"name":"Worley Cellular Noise 3D","description":"3d Cellular\u566A\u58F0","likes":1,"published":"Public","tags":["3d","noise","worley","cellular"]},"renderpass":[{"Code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nfloat anim = 0.0;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n//\u5728\u6570\u7EC4\u4E2D\u968F\u673A\u53D6\u4E00\u4E2A\u503C\uFF0C\u6EE1\u8DB3\u6CCA\u677E\u5206\u5E03\uFF0C\u5747\u503C\u4E3A2.5\nconst int Poisson_count[256]= int[](\n4,3,1,1,1,2,4,2,2,2,5,1,0,2,1,2,2,0,4,3,2,1,2,1,3,2,2,4,2,2,5,1,2,3,\n2,2,2,2,2,3,2,4,2,5,3,2,2,2,5,3,3,5,2,1,3,3,4,4,2,3,0,4,2,2,2,1,3,2,\n2,2,3,3,3,1,2,0,2,1,1,2,2,2,2,5,3,2,3,2,3,2,2,1,0,2,1,1,2,1,2,2,1,3,\n4,2,2,2,5,4,2,4,2,2,5,4,3,2,2,5,4,3,3,3,5,2,2,2,2,2,3,1,1,4,2,1,3,3,\n4,3,2,4,3,3,3,4,5,1,4,2,4,3,1,2,3,5,3,2,1,3,1,3,3,3,2,3,1,5,5,4,2,2,\n4,1,3,4,1,5,3,3,5,3,4,3,2,2,1,1,1,1,1,2,4,5,4,5,4,2,1,5,1,1,2,3,3,3,\n2,5,2,3,3,2,0,2,1,1,4,2,1,3,2,1,2,2,3,2,5,5,3,4,5,5,2,4,4,5,3,2,2,2,\n1,4,2,3,3,4,2,5,4,2,4,2,2,2,4,5,3,2);\n    \nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 noise33(in vec3 x){\n    vec3 p = x;\n    //p.z += anim;\n    //p *= m;\n    float fx = noise(p);\n    float fy = noise(p+vec3(1.23,4.56,7.89));\n    float fz = noise(p+vec3(1.23,4.56,7.89)*7.6543);\n    return vec3(fx,fy,fz);\n}\n\n/*\n\u5728cellX,cellY\u6307\u5B9A\u7684\u6676\u683C\u4E2D\u91C7\u6837\uFF0C\u5F97\u5230\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\n*/\nvec4 AddSamples(int cellX, int cellY, int cellZ, vec3 at, vec4 oldFs,inout vec4 ids){\n    vec3 p = vec3(float(cellX),float(cellY),float(cellZ));\n    vec3 seed = vec3(p.x*1.234+1234.0, p.y*5.678+5678.0, p.z*4.57+0.752);\n    float id = seed.x+seed.y+seed.z;\n    //\u5728\u6676\u683C\u4E2D\u4EA7\u751F\u82E5\u5E72\u4E2A\u7279\u5F81\u70B9\uFF0C\u4E2A\u6570\u5728\u6CCA\u677E\u5206\u5E03\u8868\u4E2D\u968F\u673A\u5F97\u5230\n    int count = Poisson_count[int(fract(seed.x+seed.y+seed.z)*256.0)];\n    for(int i = 0; i < count; i++){\n        vec3 diff = noise33(seed);\n        //\u504F\u79FB\u79CD\u5B50\uFF0C\u7528\u4EE5\u4EA7\u751F\u4E0B\u4E00\u4E2A\u4E0D\u540C\u7684\u504F\u79FB\n        seed.x = seed.x*1.366+0.123;\n        seed.y = seed.y*2.4745687+7.73246;\n        seed.z = seed.z*475.90235+87.7578;\n        \n        vec3 featurePoint = p + diff;\n        \n        float d = length(featurePoint - at);\n        d*=d;\n        if(d<oldFs.x){\n            oldFs.yzw = oldFs.xyz; oldFs.x = d;\n            ids.yzw = ids.xyz; ids.x = id;\n        }else if(d<oldFs.y){\n            oldFs.zw = oldFs.yz; oldFs.y = d;\n            ids.zw = ids.yz; ids.y = id;\n        }else if(d<oldFs.z){\n            oldFs.w = oldFs.z; oldFs.z = d;\n            ids.w = ids.z; ids.z = id;\n        }else if(d<oldFs.w){\n            oldFs.w = d;\n            ids.w = id;\n        }\n        \n    }\n    return oldFs;\n}\n\n/*\n3d Worley\u7EC6\u80DE\u566A\u58F0\n\u8F93\u5165\uFF1A\u4F4D\u7F6E\n\u8F93\u51FA\uFF1A\u4ECE\u5C0F\u5230\u5927\u6392\u5E8F\u7684\u8DDD\u79BB\u6700\u8FD1\u7684\u56DB\u4E2A\u7279\u5F81\u70B9\u7684\u8DDD\u79BB\n*/\nvec4 cellularNoise3D(vec3 at, inout vec4 ids){\n    vec3 int_at = floor(at);\n    int int_at_x = int(int_at.x);\n    int int_at_y = int(int_at.y);\n    int int_at_z = int(int_at.z);\n    vec4 fs = vec4(9999999.0,9999999.0,9999999.0,9999999.0);\n    fs = AddSamples(int_at_x,int_at_y,int_at_z,at,fs,ids);\n    float dx1 = at.x - int_at.x;\n    float dy1 = at.y - int_at.y;\n    float dz1 = at.z - int_at.z;\n    float dx2 = (1.0-dx1)*(1.0-dx1);\n    float dy2 = (1.0-dy1)*(1.0-dy1);\n    float dz2 = (1.0-dz1)*(1.0-dz1);\n    dx1 *= dx1;\n    dy1 *= dy1;\n    dz1 *= dz1;\n    int max_order = 4;\n    //\u5224\u65AD\u662F\u5426\u5F97\u5230\u4E86\u6700\u8FD1\u7684\u56DB\u4E2A\u8DDD\u79BB\uFF0C\u5982\u679C\u662F\u7684\u8BDD\uFF0C\u4E0D\u5FC5\u5728\u76F8\u90BB\u6676\u683C\u8FDB\u884C\u91C7\u6837\n    //z = +1\n    if(dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dx2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z+1,at,fs,ids);\n    if(dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx1+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dx2+dy1+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z+1,at,fs,ids);\n    if(dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx1+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z+1,at,fs,ids);\n    if(dx2+dy2+dz2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z+1,at,fs,ids);\n    //z = -1\n    if(dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dx2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z-1,at,fs,ids);\n    if(dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx1+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dx2+dy1+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z-1,at,fs,ids);\n    if(dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx1+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z-1,at,fs,ids);\n    if(dx2+dy2+dz1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z-1,at,fs,ids);\n    //z = 0\n    if(dx1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y,  int_at_z,at,fs,ids);\n    if(dx2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y,  int_at_z,at,fs,ids);\n    if(dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y-1,int_at_z,at,fs,ids);\n    if(dx1+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dx2+dy1<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y-1,int_at_z,at,fs,ids);\n    if(dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x,  int_at_y+1,int_at_z,at,fs,ids);\n    if(dx1+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x-1,int_at_y+1,int_at_z,at,fs,ids);\n    if(dx2+dy2<fs[max_order-1])\n        fs = AddSamples(int_at_x+1,int_at_y+1,int_at_z,at,fs,ids);\n    return fs;\n}\n\nvec4 fractalCellularNoise3D(vec3 at) {\n\tvec4 m = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < 4; i++) {\n        vec4 ids;\n\t\tm += cellularNoise3D(at*f,ids) / f;\n\t\tf *= 2.17;\n\t}\n\treturn m;\n}\n\nvec3 cellId2Color(float id)\n{\r\n    vec2 p = vec2(mod(id,64.))/64.;\r\n    float lod = mod(floor(id/64.),64.)/64.;\r\n    return vec3(p,lod);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2(1e10, 0.0);\n   \n    res = opU(res, vec2(sdSphere(pos + vec3(0,0,0), 2.0),1));\n    \n    //res = opU(res, vec2(sdBox(pos+vec3(-1.5,0,0),vec3(1.0,0.3,1.0)),1));\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i = 0; i < 70 && t < tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y; \n    vec3 pos = ro + t * rd;\n    vec3 col = vec3(0,0,0); \n    if(m <= -1.0)//skyBox\n    {\n        col = vec3(0.8,0.8,1.0);\n    } else{\n        vec4 ids;\n         vec4 fs = cellularNoise3D(pos*4.0, ids);// fractalCellularNoise3D(pos*4.0);\n         fs = sqrt(fs);\n         float c = fs.x*(0.95*fs.y-fs.x); \n\t\t col = (c<0.0)? vec3(-c) : (1.0 - c)*cellId2Color(ids.x);\n         //col = vec3(fs.y);\n    }\n    return col;\n}\n\nmat3 getViewMatrix(in vec3 cameraPos, in vec3 targetPos)\n{\n    vec3 w = normalize(targetPos - cameraPos);\n    vec3 up = vec3(0,1,0);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    anim = 0.5*(2.*iTime + .5*sin(1.*iTime+10.0));\n    \n    vec2 mousePos = iMouse.xy / iResolution.xy - vec2(0.5,0.5);\n    float time = iTime * 0.1;\n    vec3 cameraPos = vec3(3.0 * cos(time + 6.0*mousePos.x), 2.0 + 2.0*mousePos.y, 3.0 * sin(time + + 6.0*mousePos.x));\n    vec3 lookAtPos = vec3(0,0.0,0);\n    mat3 viewMatrix = getViewMatrix(cameraPos, lookAtPos);\n    \n    \n    vec3 sum = vec3(0.0);\n    for(int i = 0;i<AA;i++){\n        for(int j = 0;j<AA;j++){\n             vec2 diff = vec2(float(i),float(j))/float(AA)-0.5;\n             vec2 p = (-iResolution.xy + 2.0*(fragCoord+diff))/iResolution.y;\n             vec3 rayDir = viewMatrix * normalize(vec3(p, 1.0));\n             vec3 col = render(cameraPos, rayDir);\n             col = pow( col, vec3(0.4545) );\n             sum += col;\n        }\n    }\n    \n    sum /= float(AA*AA);\n\n    fragColor = vec4(sum, 1);\n    \n}","name":"Image","description":"","type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"// --- Workey noise ---    Fabrice Neyret, July 2013\r\n\r\n#define TYPE -1    // shader tunings: 1,11,12,  2,21,22,  3,31,32,33,34, 4,41\r\n                   //                 -1 = autodemo\r\n\r\n#define MODULATE 1\r\n#define ANIM true\r\nfloat time;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\n// gives a random 1..N integer for index i\r\n//#define rnd(i,N) int(1.+float(N)*hash(float(i)))\r\nint rnd(float i,int N) { return int(1.+float(N)*hash(i)); }\r\n\r\n// gives a random 1..N integer every T seconds, starting at i.\r\n//#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(iTime/(T))))\r\nint rndT(float i,int N,float T) { return int(1.+float(N)*hash(i+floor(iTime/(T)))); }\r\n\r\nvec2 noise2_2( vec2 p )     // 2 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_2( vec2 p )     // 3 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    float fz = noise(pos+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec2 noise2_3( vec3 p )     // 2 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_3( vec3 p )     // 3 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\n\r\nvec2 fbm2( vec2 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(vec3(p,.5));\r\n    float fy = fbm(vec3(p,.5)+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec2 perturb2(vec2 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm2(p/scaleX); // usually, to be added to p\r\n}\r\n\r\n// --- Worley -------------------------------------------------\r\n\r\n#define id(i,j,k)   (float(128+i)+256.*float(128+j)+65536.*float(k))  \r\n#define id2cell(id) vec3(mod(id,256.)-128.,mod(floor(id/256.),256.)-128.,id/65536.)\r\n\r\n// d2 and id are vectors or 4 sorted distances + corresponding cell id\r\n// id is relative to current position (add floor(p) to get absolute cell id).\r\nvoid sort(float tmp_d2, int i, int j, int k, inout vec4 d2, inout vec4 id)\r\n{\r\n\tif (tmp_d2 < d2.x)\r\n\t{                                         // nearest point\r\n\t\td2.yzw = d2.xyz; d2.x = tmp_d2;\r\n\t\tid.yzw = id.xyz; id.x = id(i,j,k);\r\n\t}\r\n\telse if (tmp_d2 < d2.y)\r\n\t{                                         // 2nd nearest point\r\n\t\td2.zw = d2.yz; d2.y = tmp_d2;\r\n\t\tid.zw = id.yz; id.y = id(i,j,k);\r\n\t}\t\r\n\telse if (tmp_d2 < d2.z)\r\n\t{                                         // 3rd nearest point\r\n\t\td2.w = d2.z; d2.z = tmp_d2;\r\n\t\tid.w = id.z; id.z = id(i,j,k);\r\n\t}\r\n\telse \r\n\t{                                         // 4th nearest point\r\n\t\td2.w = tmp_d2;\r\n\t\tid.w = id(i,j,k);\r\n\t}\r\n}\r\n\r\nvec4 worley2( in vec2 p, out vec4 id ) // 2D procedural texture\r\n{\r\n\tvec2 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int j=-2; j<=2; j++)          // browse points in neighborhood cells\r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec2 tmp_p   = ip+vec2(float(i),float(j)); // one cell\r\n\t\t\tvec2 tmp_pos = tmp_p+noise2_2(tmp_p)-p;    // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);       // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,0, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec4 worley3( in vec3 p, out vec4 id ) // 3D procedural texture\r\n{\r\n\tvec3 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int k=-2; k<=2; k++)          // browse points in neighborhood cells\r\n\t  for (int j=-2; j<=2; j++)       \r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec3 tmp_p   = ip+vec3(float(i),float(j),float(k));  // one cell\r\n\t\t\tvec3 tmp_pos = tmp_p+noise3_3(tmp_p)-p;   // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);      // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,k, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y+65536.*ip.z); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec3 cellId2Color(float id)\r\n{\r\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\ttime = iTime;\r\n    vec2 uv  = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy / iResolution.y;\r\n\tuv  = (uv  - mouse)/(1.+mouse.y);\r\n\tvec3 col;\r\n\tfloat c;\r\n\r\n\t\r\n#if TYPE == -1 // demo mode \r\n\tfloat duv = -.3*sin(4.*uv.y+uv.x+time) - .1*sin(10.*uv.y+6.*uv.x+10.*time);\r\n\tfloat k = floor(.7*(uv.x+duv)+time/5.); \r\n    int demo = rnd(k,13);\r\n#else\r\n\tconst int demo=0;\r\n#endif\r\n\t\r\n#if MODULATE\r\n\ttime = 1.*(2.*time + .5*sin(1.*time+10.*length(uv)));\r\n#endif\r\n\t\r\n\tvec4 id; vec4 D = worley2(10.*uv, id);\r\n\r\n    if((TYPE == 1)||(demo==1))\r\n\t{\r\n\t\tcol = vec3(D.x);\r\n\t}\r\n    else if ((TYPE == 11)||(demo==2))\r\n\t{\r\n\t\tc = D.x + .5*worley2(20.*uv, id).x + .25*worley2(40.*uv, id).x;\r\n\t\tc = 1.-c;\r\n\t\tcol = vec3(c);\r\n\t}\r\n\telse if ((TYPE == 12)||(demo==3))\r\n\t{\r\n\t\tcol = vec3(D.x, worley2(20.*uv, id).x, worley2(40.*uv, id).x);\r\n\t}\r\n\t\r\n\t\r\n\telse if ((TYPE == 2)||(demo==4))\r\n\t{\r\n\t\tcol = vec3(D.y-D.x);\r\n\t}\r\n\telse if ((TYPE == 21)||(demo==5))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = .75*vec3(c);\r\n\t}\r\n\telse if ((TYPE == 22)||(demo==6))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c -= (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = vec3(c);\r\n\t}\r\n\t\r\n\tif ((TYPE == 3)||(demo==7))\r\n\t{\r\n\t\tc =.7*D.y-D.x; \r\n\t\tcol = (c<0.)? -c*vec3(2.,.5,0.) : 2.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 31)||(demo==8))\r\n\t{\r\n\t\t//c = (.7*D.y-D.x); \r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 32)||(demo==9))\r\n\t{\r\n\t\tc=pow(D.x,.5)*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : 9.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 33)||(demo==10))\t\r\n\t{\r\n\t\tc=.7*D.y-D.x; \r\n\t\tD = worley2(40.*uv, id); c -= .5*D.x;\r\n\t\tcol = (c<0.)? vec3(0.) : 4.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 34)||(demo==11))\r\n\t{\r\n\t\tfloat id0=id.x;\r\n\t\tc= (.7*D.y-D.x); \r\n\t\tD = worley2(60.*uv, id); c -= .2*D.x;\r\n\t\tc = mix(-.1,1.,c);\r\n\t\tcol = (c<0.)? -c*vec3(1.,.5,0.) : 3.*(1.-sqrt(c))*cellId2Color(id0);\r\n\t}\r\n\t\r\n\telse if ((TYPE == 4)||(demo==12))\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc = pow(D.y-D.x,.1);\r\n\t\t// c += pow(1.-D.x,5.);\r\n\t\tcol = c*texture(iChannel1,uv).rgb;\r\n\t}\r\n\telse if ((TYPE == 41)||(demo==13))\t\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x)*2.*texture(iChannel1,uv).rgb;\r\n\t}\r\n\t\t\t   \r\n    fragColor = vec4(col, 0.); \r\n}","inputs":[],"outputs":[],"code":"// --- Workey noise ---    Fabrice Neyret, July 2013\r\n\r\n#define TYPE -1    // shader tunings: 1,11,12,  2,21,22,  3,31,32,33,34, 4,41\r\n                   //                 -1 = autodemo\r\n\r\n#define MODULATE 1\r\n#define ANIM true\r\nfloat time;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\n// gives a random 1..N integer for index i\r\n//#define rnd(i,N) int(1.+float(N)*hash(float(i)))\r\nint rnd(float i,int N) { return int(1.+float(N)*hash(i)); }\r\n\r\n// gives a random 1..N integer every T seconds, starting at i.\r\n//#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(iTime/(T))))\r\nint rndT(float i,int N,float T) { return int(1.+float(N)*hash(i+floor(iTime/(T)))); }\r\n\r\nvec2 noise2_2( vec2 p )     // 2 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_2( vec2 p )     // 3 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    float fz = noise(pos+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec2 noise2_3( vec3 p )     // 2 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_3( vec3 p )     // 3 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\n\r\nvec2 fbm2( vec2 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(vec3(p,.5));\r\n    float fy = fbm(vec3(p,.5)+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec2 perturb2(vec2 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm2(p/scaleX); // usually, to be added to p\r\n}\r\n\r\n// --- Worley -------------------------------------------------\r\n\r\n#define id(i,j,k)   (float(128+i)+256.*float(128+j)+65536.*float(k))  \r\n#define id2cell(id) vec3(mod(id,256.)-128.,mod(floor(id/256.),256.)-128.,id/65536.)\r\n\r\n// d2 and id are vectors or 4 sorted distances + corresponding cell id\r\n// id is relative to current position (add floor(p) to get absolute cell id).\r\nvoid sort(float tmp_d2, int i, int j, int k, inout vec4 d2, inout vec4 id)\r\n{\r\n\tif (tmp_d2 < d2.x)\r\n\t{                                         // nearest point\r\n\t\td2.yzw = d2.xyz; d2.x = tmp_d2;\r\n\t\tid.yzw = id.xyz; id.x = id(i,j,k);\r\n\t}\r\n\telse if (tmp_d2 < d2.y)\r\n\t{                                         // 2nd nearest point\r\n\t\td2.zw = d2.yz; d2.y = tmp_d2;\r\n\t\tid.zw = id.yz; id.y = id(i,j,k);\r\n\t}\t\r\n\telse if (tmp_d2 < d2.z)\r\n\t{                                         // 3rd nearest point\r\n\t\td2.w = d2.z; d2.z = tmp_d2;\r\n\t\tid.w = id.z; id.z = id(i,j,k);\r\n\t}\r\n\telse \r\n\t{                                         // 4th nearest point\r\n\t\td2.w = tmp_d2;\r\n\t\tid.w = id(i,j,k);\r\n\t}\r\n}\r\n\r\nvec4 worley2( in vec2 p, out vec4 id ) // 2D procedural texture\r\n{\r\n\tvec2 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int j=-2; j<=2; j++)          // browse points in neighborhood cells\r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec2 tmp_p   = ip+vec2(float(i),float(j)); // one cell\r\n\t\t\tvec2 tmp_pos = tmp_p+noise2_2(tmp_p)-p;    // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);       // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,0, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec4 worley3( in vec3 p, out vec4 id ) // 3D procedural texture\r\n{\r\n\tvec3 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int k=-2; k<=2; k++)          // browse points in neighborhood cells\r\n\t  for (int j=-2; j<=2; j++)       \r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec3 tmp_p   = ip+vec3(float(i),float(j),float(k));  // one cell\r\n\t\t\tvec3 tmp_pos = tmp_p+noise3_3(tmp_p)-p;   // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);      // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,k, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y+65536.*ip.z); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec3 cellId2Color(float id)\r\n{\r\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\ttime = iTime;\r\n    vec2 uv  = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy / iResolution.y;\r\n\tuv  = (uv  - mouse)/(1.+mouse.y);\r\n\tvec3 col;\r\n\tfloat c;\r\n\r\n\t\r\n#if TYPE == -1 // demo mode \r\n\tfloat duv = -.3*sin(4.*uv.y+uv.x+time) - .1*sin(10.*uv.y+6.*uv.x+10.*time);\r\n\tfloat k = floor(.7*(uv.x+duv)+time/5.); \r\n    int demo = rnd(k,13);\r\n#else\r\n\tconst int demo=0;\r\n#endif\r\n\t\r\n#if MODULATE\r\n\ttime = 1.*(2.*time + .5*sin(1.*time+10.*length(uv)));\r\n#endif\r\n\t\r\n\tvec4 id; vec4 D = worley2(10.*uv, id);\r\n\r\n    if((TYPE == 1)||(demo==1))\r\n\t{\r\n\t\tcol = vec3(D.x);\r\n\t}\r\n    else if ((TYPE == 11)||(demo==2))\r\n\t{\r\n\t\tc = D.x + .5*worley2(20.*uv, id).x + .25*worley2(40.*uv, id).x;\r\n\t\tc = 1.-c;\r\n\t\tcol = vec3(c);\r\n\t}\r\n\telse if ((TYPE == 12)||(demo==3))\r\n\t{\r\n\t\tcol = vec3(D.x, worley2(20.*uv, id).x, worley2(40.*uv, id).x);\r\n\t}\r\n\t\r\n\t\r\n\telse if ((TYPE == 2)||(demo==4))\r\n\t{\r\n\t\tcol = vec3(D.y-D.x);\r\n\t}\r\n\telse if ((TYPE == 21)||(demo==5))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = .75*vec3(c);\r\n\t}\r\n\telse if ((TYPE == 22)||(demo==6))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c -= (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = vec3(c);\r\n\t}\r\n\t\r\n\tif ((TYPE == 3)||(demo==7))\r\n\t{\r\n\t\tc =.7*D.y-D.x; \r\n\t\tcol = (c<0.)? -c*vec3(2.,.5,0.) : 2.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 31)||(demo==8))\r\n\t{\r\n\t\t//c = (.7*D.y-D.x); \r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 32)||(demo==9))\r\n\t{\r\n\t\tc=pow(D.x,.5)*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : 9.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 33)||(demo==10))\t\r\n\t{\r\n\t\tc=.7*D.y-D.x; \r\n\t\tD = worley2(40.*uv, id); c -= .5*D.x;\r\n\t\tcol = (c<0.)? vec3(0.) : 4.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 34)||(demo==11))\r\n\t{\r\n\t\tfloat id0=id.x;\r\n\t\tc= (.7*D.y-D.x); \r\n\t\tD = worley2(60.*uv, id); c -= .2*D.x;\r\n\t\tc = mix(-.1,1.,c);\r\n\t\tcol = (c<0.)? -c*vec3(1.,.5,0.) : 3.*(1.-sqrt(c))*cellId2Color(id0);\r\n\t}\r\n\t\r\n\telse if ((TYPE == 4)||(demo==12))\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc = pow(D.y-D.x,.1);\r\n\t\t// c += pow(1.-D.x,5.);\r\n\t\tcol = c*texture(iChannel1,uv).rgb;\r\n\t}\r\n\telse if ((TYPE == 41)||(demo==13))\t\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x)*2.*texture(iChannel1,uv).rgb;\r\n\t}\r\n\t\t\t   \r\n    fragColor = vec4(col, 0.); \r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Worley noise","id":"5d2ddb3072ba4fb3921f121fc70dc814","date":null,"viewed":0,"name":"Worley noise","description":"Worley cellular noise (same spirit than Perlin noise, but discontinuities-oriented).\nThe #define TYPE on line 3 set the tuning choice. -1 (auto-demo) explore them randomly.\nhttps://www.shadertoy.com/view/ldX3R2","likes":0,"published":null,"tags":["procedural"," noise"," worley"," cellular"]},"ver":null,"info":{"Name":"Worley noise","id":"5d2ddb3072ba4fb3921f121fc70dc814","date":null,"viewed":0,"name":"Worley noise","description":"Worley cellular noise (same spirit than Perlin noise, but discontinuities-oriented).\nThe #define TYPE on line 3 set the tuning choice. -1 (auto-demo) explore them randomly.\nhttps://www.shadertoy.com/view/ldX3R2","likes":0,"published":null,"tags":["procedural"," noise"," worley"," cellular"]},"renderpass":[{"Code":"// --- Workey noise ---    Fabrice Neyret, July 2013\r\n\r\n#define TYPE -1    // shader tunings: 1,11,12,  2,21,22,  3,31,32,33,34, 4,41\r\n                   //                 -1 = autodemo\r\n\r\n#define MODULATE 1\r\n#define ANIM true\r\nfloat time;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\n// gives a random 1..N integer for index i\r\n//#define rnd(i,N) int(1.+float(N)*hash(float(i)))\r\nint rnd(float i,int N) { return int(1.+float(N)*hash(i)); }\r\n\r\n// gives a random 1..N integer every T seconds, starting at i.\r\n//#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(iTime/(T))))\r\nint rndT(float i,int N,float T) { return int(1.+float(N)*hash(i+floor(iTime/(T)))); }\r\n\r\nvec2 noise2_2( vec2 p )     // 2 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_2( vec2 p )     // 3 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    float fz = noise(pos+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec2 noise2_3( vec3 p )     // 2 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_3( vec3 p )     // 3 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\n\r\nvec2 fbm2( vec2 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(vec3(p,.5));\r\n    float fy = fbm(vec3(p,.5)+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec2 perturb2(vec2 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm2(p/scaleX); // usually, to be added to p\r\n}\r\n\r\n// --- Worley -------------------------------------------------\r\n\r\n#define id(i,j,k)   (float(128+i)+256.*float(128+j)+65536.*float(k))  \r\n#define id2cell(id) vec3(mod(id,256.)-128.,mod(floor(id/256.),256.)-128.,id/65536.)\r\n\r\n// d2 and id are vectors or 4 sorted distances + corresponding cell id\r\n// id is relative to current position (add floor(p) to get absolute cell id).\r\nvoid sort(float tmp_d2, int i, int j, int k, inout vec4 d2, inout vec4 id)\r\n{\r\n\tif (tmp_d2 < d2.x)\r\n\t{                                         // nearest point\r\n\t\td2.yzw = d2.xyz; d2.x = tmp_d2;\r\n\t\tid.yzw = id.xyz; id.x = id(i,j,k);\r\n\t}\r\n\telse if (tmp_d2 < d2.y)\r\n\t{                                         // 2nd nearest point\r\n\t\td2.zw = d2.yz; d2.y = tmp_d2;\r\n\t\tid.zw = id.yz; id.y = id(i,j,k);\r\n\t}\t\r\n\telse if (tmp_d2 < d2.z)\r\n\t{                                         // 3rd nearest point\r\n\t\td2.w = d2.z; d2.z = tmp_d2;\r\n\t\tid.w = id.z; id.z = id(i,j,k);\r\n\t}\r\n\telse \r\n\t{                                         // 4th nearest point\r\n\t\td2.w = tmp_d2;\r\n\t\tid.w = id(i,j,k);\r\n\t}\r\n}\r\n\r\nvec4 worley2( in vec2 p, out vec4 id ) // 2D procedural texture\r\n{\r\n\tvec2 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int j=-2; j<=2; j++)          // browse points in neighborhood cells\r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec2 tmp_p   = ip+vec2(float(i),float(j)); // one cell\r\n\t\t\tvec2 tmp_pos = tmp_p+noise2_2(tmp_p)-p;    // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);       // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,0, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec4 worley3( in vec3 p, out vec4 id ) // 3D procedural texture\r\n{\r\n\tvec3 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int k=-2; k<=2; k++)          // browse points in neighborhood cells\r\n\t  for (int j=-2; j<=2; j++)       \r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec3 tmp_p   = ip+vec3(float(i),float(j),float(k));  // one cell\r\n\t\t\tvec3 tmp_pos = tmp_p+noise3_3(tmp_p)-p;   // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);      // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,k, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y+65536.*ip.z); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec3 cellId2Color(float id)\r\n{\r\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\ttime = iTime;\r\n    vec2 uv  = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy / iResolution.y;\r\n\tuv  = (uv  - mouse)/(1.+mouse.y);\r\n\tvec3 col;\r\n\tfloat c;\r\n\r\n\t\r\n#if TYPE == -1 // demo mode \r\n\tfloat duv = -.3*sin(4.*uv.y+uv.x+time) - .1*sin(10.*uv.y+6.*uv.x+10.*time);\r\n\tfloat k = floor(.7*(uv.x+duv)+time/5.); \r\n    int demo = rnd(k,13);\r\n#else\r\n\tconst int demo=0;\r\n#endif\r\n\t\r\n#if MODULATE\r\n\ttime = 1.*(2.*time + .5*sin(1.*time+10.*length(uv)));\r\n#endif\r\n\t\r\n\tvec4 id; vec4 D = worley2(10.*uv, id);\r\n\r\n    if((TYPE == 1)||(demo==1))\r\n\t{\r\n\t\tcol = vec3(D.x);\r\n\t}\r\n    else if ((TYPE == 11)||(demo==2))\r\n\t{\r\n\t\tc = D.x + .5*worley2(20.*uv, id).x + .25*worley2(40.*uv, id).x;\r\n\t\tc = 1.-c;\r\n\t\tcol = vec3(c);\r\n\t}\r\n\telse if ((TYPE == 12)||(demo==3))\r\n\t{\r\n\t\tcol = vec3(D.x, worley2(20.*uv, id).x, worley2(40.*uv, id).x);\r\n\t}\r\n\t\r\n\t\r\n\telse if ((TYPE == 2)||(demo==4))\r\n\t{\r\n\t\tcol = vec3(D.y-D.x);\r\n\t}\r\n\telse if ((TYPE == 21)||(demo==5))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = .75*vec3(c);\r\n\t}\r\n\telse if ((TYPE == 22)||(demo==6))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c -= (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = vec3(c);\r\n\t}\r\n\t\r\n\tif ((TYPE == 3)||(demo==7))\r\n\t{\r\n\t\tc =.7*D.y-D.x; \r\n\t\tcol = (c<0.)? -c*vec3(2.,.5,0.) : 2.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 31)||(demo==8))\r\n\t{\r\n\t\t//c = (.7*D.y-D.x); \r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 32)||(demo==9))\r\n\t{\r\n\t\tc=pow(D.x,.5)*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : 9.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 33)||(demo==10))\t\r\n\t{\r\n\t\tc=.7*D.y-D.x; \r\n\t\tD = worley2(40.*uv, id); c -= .5*D.x;\r\n\t\tcol = (c<0.)? vec3(0.) : 4.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 34)||(demo==11))\r\n\t{\r\n\t\tfloat id0=id.x;\r\n\t\tc= (.7*D.y-D.x); \r\n\t\tD = worley2(60.*uv, id); c -= .2*D.x;\r\n\t\tc = mix(-.1,1.,c);\r\n\t\tcol = (c<0.)? -c*vec3(1.,.5,0.) : 3.*(1.-sqrt(c))*cellId2Color(id0);\r\n\t}\r\n\t\r\n\telse if ((TYPE == 4)||(demo==12))\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc = pow(D.y-D.x,.1);\r\n\t\t// c += pow(1.-D.x,5.);\r\n\t\tcol = c*texture(iChannel1,uv).rgb;\r\n\t}\r\n\telse if ((TYPE == 41)||(demo==13))\t\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x)*2.*texture(iChannel1,uv).rgb;\r\n\t}\r\n\t\t\t   \r\n    fragColor = vec4(col, 0.); \r\n}","inputs":[],"outputs":[],"code":"// --- Workey noise ---    Fabrice Neyret, July 2013\r\n\r\n#define TYPE -1    // shader tunings: 1,11,12,  2,21,22,  3,31,32,33,34, 4,41\r\n                   //                 -1 = autodemo\r\n\r\n#define MODULATE 1\r\n#define ANIM true\r\nfloat time;\r\n\r\n// --- noise functions from https://www.shadertoy.com/view/XslGRr\r\n// Created by inigo quilez - iq/2013\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nmat3 m = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\nfloat hash( float n )\r\n{\r\n    return fract(sin(n)*43758.5453);\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\r\n    f = f*f*(3.0-2.0*f);\r\n\r\n    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\r\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n    return res;\r\n}\r\n\r\nfloat fbm( vec3 p )\r\n{\r\n    float f;\r\n    f  = 0.5000*noise( p ); p = m*p*2.02;\r\n    f += 0.2500*noise( p ); p = m*p*2.03;\r\n    f += 0.1250*noise( p ); p = m*p*2.01;\r\n    f += 0.0625*noise( p );\r\n    return f;\r\n}\r\n// --- End of Created by inigo quilez\r\n\r\n// gives a random 1..N integer for index i\r\n//#define rnd(i,N) int(1.+float(N)*hash(float(i)))\r\nint rnd(float i,int N) { return int(1.+float(N)*hash(i)); }\r\n\r\n// gives a random 1..N integer every T seconds, starting at i.\r\n//#define rndT(i,N,T) int(1.+float(N)*hash(float(i)+floor(iTime/(T))))\r\nint rndT(float i,int N,float T) { return int(1.+float(N)*hash(i+floor(iTime/(T)))); }\r\n\r\nvec2 noise2_2( vec2 p )     // 2 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_2( vec2 p )     // 3 noise channels from 2D position\r\n{\r\n\tvec3 pos = vec3(p,.5);\r\n\tif (ANIM) pos.z += time;\r\n\tpos *= m;\r\n    float fx = noise(pos);\r\n    float fy = noise(pos+vec3(1345.67,0,45.67));\r\n    float fz = noise(pos+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\nvec2 noise2_3( vec3 p )     // 2 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec3 noise3_3( vec3 p )     // 3 noise channels from 3D position\r\n{\r\n\tif (ANIM) p.z += time;\r\n\tp *= m;\r\n    float fx = noise(p);\r\n    float fy = noise(p+vec3(1345.67,0,45.67));\r\n    float fz = noise(p+vec3(0,134.67,3245.67));\r\n    return vec3(fx,fy,fz);\r\n}\r\n\r\nvec2 fbm2( vec2 p )\r\n{\r\n\tif (ANIM) p += iTime;\r\n    float fx = fbm(vec3(p,.5));\r\n    float fy = fbm(vec3(p,.5)+vec3(1345.67,0,45.67));\r\n    return vec2(fx,fy);\r\n}\r\nvec2 perturb2(vec2 p, float scaleX, float scaleI)\r\n{\r\n    scaleX *= 2.;\r\n\treturn scaleI*scaleX*fbm2(p/scaleX); // usually, to be added to p\r\n}\r\n\r\n// --- Worley -------------------------------------------------\r\n\r\n#define id(i,j,k)   (float(128+i)+256.*float(128+j)+65536.*float(k))  \r\n#define id2cell(id) vec3(mod(id,256.)-128.,mod(floor(id/256.),256.)-128.,id/65536.)\r\n\r\n// d2 and id are vectors or 4 sorted distances + corresponding cell id\r\n// id is relative to current position (add floor(p) to get absolute cell id).\r\nvoid sort(float tmp_d2, int i, int j, int k, inout vec4 d2, inout vec4 id)\r\n{\r\n\tif (tmp_d2 < d2.x)\r\n\t{                                         // nearest point\r\n\t\td2.yzw = d2.xyz; d2.x = tmp_d2;\r\n\t\tid.yzw = id.xyz; id.x = id(i,j,k);\r\n\t}\r\n\telse if (tmp_d2 < d2.y)\r\n\t{                                         // 2nd nearest point\r\n\t\td2.zw = d2.yz; d2.y = tmp_d2;\r\n\t\tid.zw = id.yz; id.y = id(i,j,k);\r\n\t}\t\r\n\telse if (tmp_d2 < d2.z)\r\n\t{                                         // 3rd nearest point\r\n\t\td2.w = d2.z; d2.z = tmp_d2;\r\n\t\tid.w = id.z; id.z = id(i,j,k);\r\n\t}\r\n\telse \r\n\t{                                         // 4th nearest point\r\n\t\td2.w = tmp_d2;\r\n\t\tid.w = id(i,j,k);\r\n\t}\r\n}\r\n\r\nvec4 worley2( in vec2 p, out vec4 id ) // 2D procedural texture\r\n{\r\n\tvec2 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int j=-2; j<=2; j++)          // browse points in neighborhood cells\r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec2 tmp_p   = ip+vec2(float(i),float(j)); // one cell\r\n\t\t\tvec2 tmp_pos = tmp_p+noise2_2(tmp_p)-p;    // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);       // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,0, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec4 worley3( in vec3 p, out vec4 id ) // 3D procedural texture\r\n{\r\n\tvec3 ip = floor(p);\r\n\tvec4 d2 = vec4(1.e30); // 4 nearests initialized to infinity\r\n\t\r\n\tfor (int k=-2; k<=2; k++)          // browse points in neighborhood cells\r\n\t  for (int j=-2; j<=2; j++)       \r\n\t\tfor (int i=-2; i<=2; i++)\r\n\t\t{\r\n\t\t\tvec3 tmp_p   = ip+vec3(float(i),float(j),float(k));  // one cell\r\n\t\t\tvec3 tmp_pos = tmp_p+noise3_3(tmp_p)-p;   // pixel pos to cell point\r\n\t\t\tfloat tmp_d2 = dot(tmp_pos,tmp_pos);      // square distance of it\r\n\t\t\tsort (tmp_d2, i,j,k, d2,id);\r\n\t\t}\r\n\tid += vec4(ip.x+256.*ip.y+65536.*ip.z); // id = vector of nearest cells\r\n\treturn sqrt(d2);      // return vector of nearest distances\r\n}\r\n\r\nvec3 cellId2Color(float id)\r\n{\r\n\treturn texture(iChannel0,vec2(mod(id,64.)/64., mod(floor(id/64.),64.)/64.)).rgb;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\ttime = iTime;\r\n    vec2 uv  = fragCoord.xy / iResolution.y;\r\n\tvec2 mouse = iMouse.xy / iResolution.y;\r\n\tuv  = (uv  - mouse)/(1.+mouse.y);\r\n\tvec3 col;\r\n\tfloat c;\r\n\r\n\t\r\n#if TYPE == -1 // demo mode \r\n\tfloat duv = -.3*sin(4.*uv.y+uv.x+time) - .1*sin(10.*uv.y+6.*uv.x+10.*time);\r\n\tfloat k = floor(.7*(uv.x+duv)+time/5.); \r\n    int demo = rnd(k,13);\r\n#else\r\n\tconst int demo=0;\r\n#endif\r\n\t\r\n#if MODULATE\r\n\ttime = 1.*(2.*time + .5*sin(1.*time+10.*length(uv)));\r\n#endif\r\n\t\r\n\tvec4 id; vec4 D = worley2(10.*uv, id);\r\n\r\n    if((TYPE == 1)||(demo==1))\r\n\t{\r\n\t\tcol = vec3(D.x);\r\n\t}\r\n    else if ((TYPE == 11)||(demo==2))\r\n\t{\r\n\t\tc = D.x + .5*worley2(20.*uv, id).x + .25*worley2(40.*uv, id).x;\r\n\t\tc = 1.-c;\r\n\t\tcol = vec3(c);\r\n\t}\r\n\telse if ((TYPE == 12)||(demo==3))\r\n\t{\r\n\t\tcol = vec3(D.x, worley2(20.*uv, id).x, worley2(40.*uv, id).x);\r\n\t}\r\n\t\r\n\t\r\n\telse if ((TYPE == 2)||(demo==4))\r\n\t{\r\n\t\tcol = vec3(D.y-D.x);\r\n\t}\r\n\telse if ((TYPE == 21)||(demo==5))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = .75*vec3(c);\r\n\t}\r\n\telse if ((TYPE == 22)||(demo==6))\r\n\t{\r\n\t\tfloat I=1.;\r\n\t\tc = (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c -= (D.y-D.x);\r\n\t\tI*=.5; uv*=2.; D = I*worley2(10.*uv, id); c += (D.y-D.x);\r\n\t\tcol = vec3(c);\r\n\t}\r\n\t\r\n\tif ((TYPE == 3)||(demo==7))\r\n\t{\r\n\t\tc =.7*D.y-D.x; \r\n\t\tcol = (c<0.)? -c*vec3(2.,.5,0.) : 2.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 31)||(demo==8))\r\n\t{\r\n\t\t//c = (.7*D.y-D.x); \r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 32)||(demo==9))\r\n\t{\r\n\t\tc=pow(D.x,.5)*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : 9.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 33)||(demo==10))\t\r\n\t{\r\n\t\tc=.7*D.y-D.x; \r\n\t\tD = worley2(40.*uv, id); c -= .5*D.x;\r\n\t\tcol = (c<0.)? vec3(0.) : 4.*c*cellId2Color(id.x);\r\n\t}\r\n\telse if ((TYPE == 34)||(demo==11))\r\n\t{\r\n\t\tfloat id0=id.x;\r\n\t\tc= (.7*D.y-D.x); \r\n\t\tD = worley2(60.*uv, id); c -= .2*D.x;\r\n\t\tc = mix(-.1,1.,c);\r\n\t\tcol = (c<0.)? -c*vec3(1.,.5,0.) : 3.*(1.-sqrt(c))*cellId2Color(id0);\r\n\t}\r\n\t\r\n\telse if ((TYPE == 4)||(demo==12))\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc = pow(D.y-D.x,.1);\r\n\t\t// c += pow(1.-D.x,5.);\r\n\t\tcol = c*texture(iChannel1,uv).rgb;\r\n\t}\r\n\telse if ((TYPE == 41)||(demo==13))\t\r\n\t{\r\n\t\tuv -= .1*noise2_2(id2cell(id.x).xy);\r\n    \tuv = mod( uv*vec2(iResolution.y/iResolution.x,1.), 1.);\r\n\t\tc=D.x*(.7*D.y-D.x); \r\n\t\tcol = (c<0.)? vec3(-c) : (1.-c)*cellId2Color(id.x)*2.*texture(iChannel1,uv).rgb;\r\n\t}\r\n\t\t\t   \r\n    fragColor = vec4(col, 0.); \r\n}","name":"Image","description":null,"type":"image"}]},{"Ver":null,"ImageRenderpass":{"Code":"float rnd(float x) { return fract(1000.*sin(234.56*x)); }\r\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\r\nfloat hash(float x,float y,float z) { return (x+432.432*y-1178.65*z); }\r\nfloat hash(vec3 v) { return dot(v,vec3(1., 32.432, -1178.65)); }\n\r\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 x)\r\n{\r\n    return vec3(value_noise(x),value_noise(x+1.11),value_noise(x+2.22));\r\n}\r\n\r\nvec4 Worley(vec3 uvw) {\r\n    \r\n   vec3 uvwi = floor(uvw);\t\t\t\t\t\t\t// cell coords\r\n   float dmin = 1e9, d2min=1e9, nmin=-1.;\r\n    \r\n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t// visit neighborhood\r\n      for (int j=-1; j<=1; j++)\t\t\t\t\t\t// to find the closest point\r\n          for (int k=-1; k<=1; k++) \r\n          {\r\n              vec3 c = uvwi + vec3(float(i),float(j),float(k)); // neighbor cells\r\n              float n = hash(c);\t \t\t\t\t\t\t\t// cell ID\r\n              vec3 p = c + rnd3(n+.1);\t\t\t\t\t\t\t// random point in cell\r\n              float d = length(p-uvw);\t\t\t\t\t\t\t// dist to point\r\n              if (d<dmin) { d2min=dmin; dmin=d; nmin=n; }\t\t// 2 closest dists\r\n              else if (d<d2min) { d2min=d; }\r\n          }\r\n\treturn vec4(dmin,d2min,d2min-dmin, nmin);\t\t\t// 2 closest dists + closest ID\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 uvw = vec3(2.*(fragCoord.xy / iResolution.y-vec2(.9,.5)), .2*iTime);\r\n    float a = .2*iTime,c=cos(a),s=sin(a); uvw.xy *= mat2(c,-s,s,c);\t// rotate\r\n    uvw *= 4.*(.7+.5*vec3(vec2(cos(.5*iTime)),0.));\t\t\t\t\t// zoom\r\n\r\n    vec3 uvw0=uvw; \r\n    //uvw += .2*texture(iChannel0,.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    uvw += .2*noise23(.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    vec4 wor = Worley(uvw);         \r\n    vec3 col = mix(vec3(1.), rnd3(wor.a+.4), .4);\r\n    float v = wor.z;\r\n    int mode = int(mod(.25*iTime,4.));\t\t\t\t\t\t\t\t// demo mode\r\n    if      (mode==0) v *= 2.;\r\n    else if (mode==1) v = pow(v,.025);\r\n    else if (mode==2) { v -= .3*sin(30.*uvw0.x)*sin(30.*uvw0.y); v = pow(v,.025); }\r\n    else              { v -= .02; v = pow(v,.025); }\r\n    //v = 1.-pow(1.-v,40.);    \r\n\r\n\tfragColor = vec4(v*col,1.0);\r\n}","inputs":[],"outputs":[],"code":"float rnd(float x) { return fract(1000.*sin(234.56*x)); }\r\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\r\nfloat hash(float x,float y,float z) { return (x+432.432*y-1178.65*z); }\r\nfloat hash(vec3 v) { return dot(v,vec3(1., 32.432, -1178.65)); }\n\r\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 x)\r\n{\r\n    return vec3(value_noise(x),value_noise(x+1.11),value_noise(x+2.22));\r\n}\r\n\r\nvec4 Worley(vec3 uvw) {\r\n    \r\n   vec3 uvwi = floor(uvw);\t\t\t\t\t\t\t// cell coords\r\n   float dmin = 1e9, d2min=1e9, nmin=-1.;\r\n    \r\n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t// visit neighborhood\r\n      for (int j=-1; j<=1; j++)\t\t\t\t\t\t// to find the closest point\r\n          for (int k=-1; k<=1; k++) \r\n          {\r\n              vec3 c = uvwi + vec3(float(i),float(j),float(k)); // neighbor cells\r\n              float n = hash(c);\t \t\t\t\t\t\t\t// cell ID\r\n              vec3 p = c + rnd3(n+.1);\t\t\t\t\t\t\t// random point in cell\r\n              float d = length(p-uvw);\t\t\t\t\t\t\t// dist to point\r\n              if (d<dmin) { d2min=dmin; dmin=d; nmin=n; }\t\t// 2 closest dists\r\n              else if (d<d2min) { d2min=d; }\r\n          }\r\n\treturn vec4(dmin,d2min,d2min-dmin, nmin);\t\t\t// 2 closest dists + closest ID\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 uvw = vec3(2.*(fragCoord.xy / iResolution.y-vec2(.9,.5)), .2*iTime);\r\n    float a = .2*iTime,c=cos(a),s=sin(a); uvw.xy *= mat2(c,-s,s,c);\t// rotate\r\n    uvw *= 4.*(.7+.5*vec3(vec2(cos(.5*iTime)),0.));\t\t\t\t\t// zoom\r\n\r\n    vec3 uvw0=uvw; \r\n    //uvw += .2*texture(iChannel0,.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    uvw += .2*noise23(.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    vec4 wor = Worley(uvw);         \r\n    vec3 col = mix(vec3(1.), rnd3(wor.a+.4), .4);\r\n    float v = wor.z;\r\n    int mode = int(mod(.25*iTime,4.));\t\t\t\t\t\t\t\t// demo mode\r\n    if      (mode==0) v *= 2.;\r\n    else if (mode==1) v = pow(v,.025);\r\n    else if (mode==2) { v -= .3*sin(30.*uvw0.x)*sin(30.*uvw0.y); v = pow(v,.025); }\r\n    else              { v -= .02; v = pow(v,.025); }\r\n    //v = 1.-pow(1.-v,40.);    \r\n\r\n\tfragColor = vec4(v*col,1.0);\r\n}","name":"Image","description":null,"type":"image"},"Inputs":[],"Info":{"Name":"Worley noise 3","id":"aabbd86ccf4c4a2cb7fb81dbb2442788","date":null,"viewed":0,"name":"Worley noise 3","description":"variant from https://www.shadertoy.com/view/Md2SDz\nhttps://www.shadertoy.com/view/XdSSW1","likes":0,"published":null,"tags":["voronoi"," worley"]},"ver":null,"info":{"Name":"Worley noise 3","id":"aabbd86ccf4c4a2cb7fb81dbb2442788","date":null,"viewed":0,"name":"Worley noise 3","description":"variant from https://www.shadertoy.com/view/Md2SDz\nhttps://www.shadertoy.com/view/XdSSW1","likes":0,"published":null,"tags":["voronoi"," worley"]},"renderpass":[{"Code":"float rnd(float x) { return fract(1000.*sin(234.56*x)); }\r\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\r\nfloat hash(float x,float y,float z) { return (x+432.432*y-1178.65*z); }\r\nfloat hash(vec3 v) { return dot(v,vec3(1., 32.432, -1178.65)); }\n\r\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 x)\r\n{\r\n    return vec3(value_noise(x),value_noise(x+1.11),value_noise(x+2.22));\r\n}\r\n\r\nvec4 Worley(vec3 uvw) {\r\n    \r\n   vec3 uvwi = floor(uvw);\t\t\t\t\t\t\t// cell coords\r\n   float dmin = 1e9, d2min=1e9, nmin=-1.;\r\n    \r\n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t// visit neighborhood\r\n      for (int j=-1; j<=1; j++)\t\t\t\t\t\t// to find the closest point\r\n          for (int k=-1; k<=1; k++) \r\n          {\r\n              vec3 c = uvwi + vec3(float(i),float(j),float(k)); // neighbor cells\r\n              float n = hash(c);\t \t\t\t\t\t\t\t// cell ID\r\n              vec3 p = c + rnd3(n+.1);\t\t\t\t\t\t\t// random point in cell\r\n              float d = length(p-uvw);\t\t\t\t\t\t\t// dist to point\r\n              if (d<dmin) { d2min=dmin; dmin=d; nmin=n; }\t\t// 2 closest dists\r\n              else if (d<d2min) { d2min=d; }\r\n          }\r\n\treturn vec4(dmin,d2min,d2min-dmin, nmin);\t\t\t// 2 closest dists + closest ID\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 uvw = vec3(2.*(fragCoord.xy / iResolution.y-vec2(.9,.5)), .2*iTime);\r\n    float a = .2*iTime,c=cos(a),s=sin(a); uvw.xy *= mat2(c,-s,s,c);\t// rotate\r\n    uvw *= 4.*(.7+.5*vec3(vec2(cos(.5*iTime)),0.));\t\t\t\t\t// zoom\r\n\r\n    vec3 uvw0=uvw; \r\n    //uvw += .2*texture(iChannel0,.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    uvw += .2*noise23(.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    vec4 wor = Worley(uvw);         \r\n    vec3 col = mix(vec3(1.), rnd3(wor.a+.4), .4);\r\n    float v = wor.z;\r\n    int mode = int(mod(.25*iTime,4.));\t\t\t\t\t\t\t\t// demo mode\r\n    if      (mode==0) v *= 2.;\r\n    else if (mode==1) v = pow(v,.025);\r\n    else if (mode==2) { v -= .3*sin(30.*uvw0.x)*sin(30.*uvw0.y); v = pow(v,.025); }\r\n    else              { v -= .02; v = pow(v,.025); }\r\n    //v = 1.-pow(1.-v,40.);    \r\n\r\n\tfragColor = vec4(v*col,1.0);\r\n}","inputs":[],"outputs":[],"code":"float rnd(float x) { return fract(1000.*sin(234.56*x)); }\r\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\r\nfloat hash(float x,float y,float z) { return (x+432.432*y-1178.65*z); }\r\nfloat hash(vec3 v) { return dot(v,vec3(1., 32.432, -1178.65)); }\n\r\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\r\n\nfloat value_noise(vec2 p){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve \u5E73\u6ED1\u66F2\u7EBF\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    \n    return mix(mix(hash21(i+vec2(0.0,0.0)),hash21(i+vec2(1.0,0.0)),u.x),\n               mix(hash21(i+vec2(0.0,1.0)),hash21(i+vec2(1.0,1.0)),u.x),\n               u.y);\n}\r\n\r\nvec3 noise23(in vec2 x)\r\n{\r\n    return vec3(value_noise(x),value_noise(x+1.11),value_noise(x+2.22));\r\n}\r\n\r\nvec4 Worley(vec3 uvw) {\r\n    \r\n   vec3 uvwi = floor(uvw);\t\t\t\t\t\t\t// cell coords\r\n   float dmin = 1e9, d2min=1e9, nmin=-1.;\r\n    \r\n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t// visit neighborhood\r\n      for (int j=-1; j<=1; j++)\t\t\t\t\t\t// to find the closest point\r\n          for (int k=-1; k<=1; k++) \r\n          {\r\n              vec3 c = uvwi + vec3(float(i),float(j),float(k)); // neighbor cells\r\n              float n = hash(c);\t \t\t\t\t\t\t\t// cell ID\r\n              vec3 p = c + rnd3(n+.1);\t\t\t\t\t\t\t// random point in cell\r\n              float d = length(p-uvw);\t\t\t\t\t\t\t// dist to point\r\n              if (d<dmin) { d2min=dmin; dmin=d; nmin=n; }\t\t// 2 closest dists\r\n              else if (d<d2min) { d2min=d; }\r\n          }\r\n\treturn vec4(dmin,d2min,d2min-dmin, nmin);\t\t\t// 2 closest dists + closest ID\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 uvw = vec3(2.*(fragCoord.xy / iResolution.y-vec2(.9,.5)), .2*iTime);\r\n    float a = .2*iTime,c=cos(a),s=sin(a); uvw.xy *= mat2(c,-s,s,c);\t// rotate\r\n    uvw *= 4.*(.7+.5*vec3(vec2(cos(.5*iTime)),0.));\t\t\t\t\t// zoom\r\n\r\n    vec3 uvw0=uvw; \r\n    //uvw += .2*texture(iChannel0,.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    uvw += .2*noise23(.1*uvw.xy).rgb;\t\t\t// jitter pos\r\n    vec4 wor = Worley(uvw);         \r\n    vec3 col = mix(vec3(1.), rnd3(wor.a+.4), .4);\r\n    float v = wor.z;\r\n    int mode = int(mod(.25*iTime,4.));\t\t\t\t\t\t\t\t// demo mode\r\n    if      (mode==0) v *= 2.;\r\n    else if (mode==1) v = pow(v,.025);\r\n    else if (mode==2) { v -= .3*sin(30.*uvw0.x)*sin(30.*uvw0.y); v = pow(v,.025); }\r\n    else              { v -= .02; v = pow(v,.025); }\r\n    //v = 1.-pow(1.-v,40.);    \r\n\r\n\tfragColor = vec4(v*col,1.0);\r\n}","name":"Image","description":null,"type":"image"}]}]}